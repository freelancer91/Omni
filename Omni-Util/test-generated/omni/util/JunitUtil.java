package omni.util;
import java.util.Random;
import java.util.Objects;
import java.util.stream.IntStream;
import org.junit.jupiter.api.Assertions;
import java.util.function.IntBinaryOperator;
import omni.function.BooleanComparator;
import omni.function.ByteComparator;
import omni.function.CharComparator;
import omni.function.ShortComparator;
import omni.function.LongComparator;
import omni.function.FloatComparator;
import omni.function.DoubleComparator;
import java.util.Comparator;
import java.util.Collection;
public interface JunitUtil
{
  static int randomIntBetween(int minIncl,int maxIncl,Random rand)
  {
    return minIncl+rand.nextInt(maxIncl-minIncl+1);
  }
  public static boolean convertToboolean(int val)
  {
    return (val&0b1)!=0;
  }
  public static byte convertTobyte(int val)
  {
    return (byte)val;
  }
  public static char convertTochar(int val)
  {
    return (char)val;
  }
  public static short convertToshort(int val)
  {
    return (short)val;
  }
  public static int convertToint(int val)
  {
    return (int)val;
  }
  public static long convertTolong(int val)
  {
    return (long)val;
  }
  public static float convertTofloat(int val)
  {
    return (float)val;
  }
  public static double convertTodouble(int val)
  {
    return (double)val;
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Boolean convertToBoolean(int val)
  {
    return new Boolean((val&0b1)!=0);
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Byte convertToByte(int val)
  {
    return new Byte((byte)val);
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Character convertToCharacter(int val)
  {
    return new Character((char)val);
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Short convertToShort(int val)
  {
    return new Short((short)val);
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Integer convertToInteger(int val)
  {
    return new Integer(val);
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Long convertToLong(int val)
  {
    return new Long(val);
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Float convertToFloat(int val)
  {
    return new Float(val);
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Double convertToDouble(int val)
  {
    return new Double(val);
  }
  public static String convertToString(int val)
  {
    return Integer.toString(val);
  }
  public static boolean getRandomboolean(Random rand)
  {
    return rand.nextBoolean();
  }
  public static byte getRandombyte(Random rand)
  {
    return convertTobyte(rand.nextInt());
  }
  public static char getRandomchar(Random rand)
  {
    return convertTochar(rand.nextInt());
  }
  public static short getRandomshort(Random rand)
  {
    return convertToshort(rand.nextInt());
  }
  public static int getRandomint(Random rand)
  {
    return convertToint(rand.nextInt());
  }
  public static long getRandomlong(Random rand)
  {
    return (long)rand.nextLong();
  }
  public static float getRandomfloat(Random rand)
  {
    return rand.nextFloat();
  }
  public static double getRandomdouble(Random rand)
  {
    return rand.nextDouble();
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Boolean getRandomBoolean(Random rand)
  {
    return new Boolean(rand.nextBoolean());
  }
  public static Byte getRandomByte(Random rand)
  {
    return convertToByte(rand.nextInt());
  }
  public static Character getRandomCharacter(Random rand)
  {
    return convertToCharacter(rand.nextInt());
  }
  public static Short getRandomShort(Random rand)
  {
    return convertToShort(rand.nextInt());
  }
  public static Integer getRandomInteger(Random rand)
  {
    return convertToInteger(rand.nextInt());
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Long getRandomLong(Random rand)
  {
    return new Long(rand.nextLong());
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Float getRandomFloat(Random rand)
  {
    return new Float(rand.nextFloat());
  }
  //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
  @SuppressWarnings("deprecation")
  public static Double getRandomDouble(Random rand)
  {
    return new Double(rand.nextDouble());
  }
  public static String getRandomString(Random rand)
  {
    return convertToString(rand.nextInt());
  }
  public static Comparator<String> getAscendingStringComparator()
  {
    return (val1,val2)->
    {
      return
        (
      Integer.compare(Integer.parseInt(val1),Integer.parseInt(val2))
        );
    };
  }
  public static Comparator<Integer> getAscendingIntegerComparator()
  {
    return (val1,val2)->
    {
      return
        (
      val1.compareTo(val2)
        );
    };
  }
  public static BooleanComparator getAscendingbooleanComparator()
  {
    return (val1,val2)->
    {
      return
        (
      Boolean.compare(val1,val2)
        );
    };
  }
  public static ByteComparator getAscendingbyteComparator()
  {
    return (val1,val2)->
    {
      return
        (
      Byte.compare(val1,val2)
        );
    };
  }
  public static CharComparator getAscendingcharComparator()
  {
    return (val1,val2)->
    {
      return
        (
      Character.compare(val1,val2)
        );
    };
  }
  public static ShortComparator getAscendingshortComparator()
  {
    return (val1,val2)->
    {
      return
        (
      Short.compare(val1,val2)
        );
    };
  }
  public static IntBinaryOperator getAscendingintComparator()
  {
    return (val1,val2)->
    {
      return
        (
      Integer.compare(val1,val2)
        );
    };
  }
  public static LongComparator getAscendinglongComparator()
  {
    return (val1,val2)->
    {
      return
        (
      Long.compare(val1,val2)
        );
    };
  }
  public static FloatComparator getAscendingfloatComparator()
  {
    return (val1,val2)->
    {
      return
        (
      Float.compare(val1,val2)
        );
    };
  }
  public static DoubleComparator getAscendingdoubleComparator()
  {
    return (val1,val2)->
    {
      return
        (
      Double.compare(val1,val2)
        );
    };
  }
  public static Comparator<String> getUnsortedStringComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static Comparator<Integer> getUnsortedIntegerComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static BooleanComparator getUnsortedbooleanComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static ByteComparator getUnsortedbyteComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static CharComparator getUnsortedcharComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static ShortComparator getUnsortedshortComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static IntBinaryOperator getUnsortedintComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static LongComparator getUnsortedlongComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static FloatComparator getUnsortedfloatComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static DoubleComparator getUnsorteddoubleComparator()
  {
    return (val1,val2)->
    {
      return
        (
        0
        );
    };
  }
  public static Comparator<String> getDescendingStringComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      Integer.compare(Integer.parseInt(val1),Integer.parseInt(val2))
        );
    };
  }
  public static Comparator<Integer> getDescendingIntegerComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      val1.compareTo(val2)
        );
    };
  }
  public static BooleanComparator getDescendingbooleanComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      Boolean.compare(val1,val2)
        );
    };
  }
  public static ByteComparator getDescendingbyteComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      Byte.compare(val1,val2)
        );
    };
  }
  public static CharComparator getDescendingcharComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      Character.compare(val1,val2)
        );
    };
  }
  public static ShortComparator getDescendingshortComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      Short.compare(val1,val2)
        );
    };
  }
  public static IntBinaryOperator getDescendingintComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      Integer.compare(val1,val2)
        );
    };
  }
  public static LongComparator getDescendinglongComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      Long.compare(val1,val2)
        );
    };
  }
  public static FloatComparator getDescendingfloatComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      Float.compare(val1,val2)
        );
    };
  }
  public static DoubleComparator getDescendingdoubleComparator()
  {
    return (val1,val2)->
    {
      return
        -
        (
      Double.compare(val1,val2)
        );
    };
  }
  public static enum booleanArrayBuilder
  {
    Randomized
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(boolean[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomboolean(rand);
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Boolean[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomBoolean(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public void buildUnchecked(boolean[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/2;i<middle;arr[(i++)+offset]=convertToboolean(0)){}
        do
        {
          arr[i+offset]=convertToboolean(1);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Boolean[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/2;i<middle;arr[(i++)+offset]=convertToBoolean(0)){}
        do
        {
          arr[i+offset]=convertToBoolean(1);
        }
        while(++i!=length);
      }
    }
    ,
    Descending
    {
      @Override
      public void buildUnchecked(boolean[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/2;i<middle;arr[(i++)+offset]=convertToboolean(1)){}
        do
        {
          arr[i+offset]=convertToboolean(0);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Boolean[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/2;i<middle;arr[(i++)+offset]=convertToBoolean(1)){}
        do
        {
          arr[i+offset]=convertToBoolean(0);
        }
        while(++i!=length);
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public void buildUnchecked(boolean[] arr,int offset,int length,Random rand,int m)
      {
        boolean val=convertToboolean(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Boolean[] arr,int offset,int length,Random rand,int m)
      {
        Boolean val=convertToBoolean(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(boolean[] arr,int offset,int length,Random rand,int m);
    public void build(boolean[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(boolean[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    public abstract void buildUnchecked(Boolean[] arr,int offset,int length,Random rand,int m);
    public void build(Boolean[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(Boolean[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "booleanArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<boolean[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          boolean[] arr=new boolean[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static enum byteArrayBuilder
  {
    Randomized
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandombyte(rand);
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomByte(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTobyte(m+i)){}
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToByte(m+i)){}
      }
    }
    ,
    Descending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTobyte(length-m-i)){}
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToByte(length-m-i)){}
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 0;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        byte val=convertTobyte(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        Byte val=convertToByte(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ,
    MergeAscending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTobyte(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTobyte(++v)){}
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToByte(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToByte(++v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToByte(0);
          }
        }
      }
    }
    ,
    MergeDescending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTobyte(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTobyte(--v)){}
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToByte(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToByte(--v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToByte(0);
          }
        }
      }
    }
    ,
    Saw
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTobyte(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTobyte(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToByte(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToByte(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    SortedRepeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertTobyte(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToByte(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
    }
    ,
    Repeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTobyte(i%m);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToByte(i%m);
        }
        while(++i!=length);
      }
    }
    ,
    Duplicated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTobyte(rand.nextInt(m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToByte(rand.nextInt(m));
        }
        while(++i!=length);
      }
    }
    ,
    SortedOrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertTobyte(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToByte(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    OrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertTobyte(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertTobyte(length-(i++)-1);
        }
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToByte(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToByte(length-(i++)-1);
        }
      }
    }
    ,
    Stagger
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTobyte((i*m+i)%length);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToByte((i*m+i)%length);
        }
        while(++i!=length);
      }
    }
    ,
    Plateau
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertTobyte(Math.min(i,m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToByte(Math.min(i,m));
        }
        while(++i!=length);
      }
    }
    ,
    Shuffle
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertTobyte(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
      @Override
      public void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToByte(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(byte[] arr,int offset,int length,Random rand,int m);
    public void build(byte[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(byte[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    public abstract void buildUnchecked(Byte[] arr,int offset,int length,Random rand,int m);
    public void build(Byte[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(Byte[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "byteArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<byte[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          byte[] arr=new byte[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static enum charArrayBuilder
  {
    Randomized
    {
    /*
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomchar(rand);
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomCharacter(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTochar(m+i)){}
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToCharacter(m+i)){}
      }
    }
    ,
    Descending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTochar(length-m-i)){}
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToCharacter(length-m-i)){}
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 0;
      }
    /*
    */
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        char val=convertTochar(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        Character val=convertToCharacter(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ,
    MergeAscending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
    /*
    */
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTochar(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTochar(++v)){}
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToCharacter(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToCharacter(++v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToCharacter(0);
          }
        }
      }
    }
    ,
    MergeDescending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
    /*
    */
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTochar(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTochar(--v)){}
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToCharacter(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToCharacter(--v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToCharacter(0);
          }
        }
      }
    }
    ,
    Saw
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTochar(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTochar(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToCharacter(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToCharacter(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    SortedRepeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
    /*
    */
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertTochar(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToCharacter(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
    }
    ,
    Repeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTochar(i%m);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToCharacter(i%m);
        }
        while(++i!=length);
      }
    }
    ,
    Duplicated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
      @Override
      public int getNumReps(int arrLength)
      {
        if(arrLength<=3201 && arrLength>=47)
        {
          return 9;
        }
        return 1;
      }
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTochar(rand.nextInt(m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToCharacter(rand.nextInt(m));
        }
        while(++i!=length);
      }
    }
    ,
    SortedOrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
    /*
    */
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertTochar(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToCharacter(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    OrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertTochar(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertTochar(length-(i++)-1);
        }
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToCharacter(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToCharacter(length-(i++)-1);
        }
      }
    }
    ,
    Stagger
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTochar((i*m+i)%length);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToCharacter((i*m+i)%length);
        }
        while(++i!=length);
      }
    }
    ,
    Plateau
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertTochar(Math.min(i,m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToCharacter(Math.min(i,m));
        }
        while(++i!=length);
      }
    }
    ,
    Shuffle
    {
    /*
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(char[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertTochar(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
      @Override
      public void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToCharacter(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(char[] arr,int offset,int length,Random rand,int m);
    public void build(char[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(char[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    public abstract void buildUnchecked(Character[] arr,int offset,int length,Random rand,int m);
    public void build(Character[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(Character[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "charArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<char[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          char[] arr=new char[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static enum shortArrayBuilder
  {
    Randomized
    {
    /*
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomshort(rand);
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomShort(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToshort(m+i)){}
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToShort(m+i)){}
      }
    }
    ,
    Descending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToshort(length-m-i)){}
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToShort(length-m-i)){}
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 0;
      }
    /*
    */
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        short val=convertToshort(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        Short val=convertToShort(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ,
    MergeAscending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
    /*
    */
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToshort(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToshort(++v)){}
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToShort(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToShort(++v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToShort(0);
          }
        }
      }
    }
    ,
    MergeDescending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
    /*
    */
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToshort(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToshort(--v)){}
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToShort(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToShort(--v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToShort(0);
          }
        }
      }
    }
    ,
    Saw
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToshort(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToshort(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToShort(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToShort(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    SortedRepeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
    /*
    */
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToshort(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToShort(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
    }
    ,
    Repeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToshort(i%m);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToShort(i%m);
        }
        while(++i!=length);
      }
    }
    ,
    Duplicated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
      @Override
      public int getNumReps(int arrLength)
      {
        if(arrLength<=3201 && arrLength>=47)
        {
          return 9;
        }
        return 1;
      }
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToshort(rand.nextInt(m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToShort(rand.nextInt(m));
        }
        while(++i!=length);
      }
    }
    ,
    SortedOrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
    /*
    */
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToshort(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToShort(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    OrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToshort(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToshort(length-(i++)-1);
        }
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToShort(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToShort(length-(i++)-1);
        }
      }
    }
    ,
    Stagger
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToshort((i*m+i)%length);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToShort((i*m+i)%length);
        }
        while(++i!=length);
      }
    }
    ,
    Plateau
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToshort(Math.min(i,m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToShort(Math.min(i,m));
        }
        while(++i!=length);
      }
    }
    ,
    Shuffle
    {
    /*
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(short[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToshort(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
      @Override
      public void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToShort(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(short[] arr,int offset,int length,Random rand,int m);
    public void build(short[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(short[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    public abstract void buildUnchecked(Short[] arr,int offset,int length,Random rand,int m);
    public void build(Short[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(Short[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "shortArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<short[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          short[] arr=new short[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static enum intArrayBuilder
  {
    Randomized
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomint(rand);
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomInteger(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToint(m+i)){}
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToInteger(m+i)){}
      }
    }
    ,
    Descending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToint(length-m-i)){}
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToInteger(length-m-i)){}
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 0;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        int val=convertToint(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        Integer val=convertToInteger(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ,
    MergeAscending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToint(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToint(++v)){}
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToInteger(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToInteger(++v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToInteger(0);
          }
        }
      }
    }
    ,
    MergeDescending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToint(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToint(--v)){}
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToInteger(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToInteger(--v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToInteger(0);
          }
        }
      }
    }
    ,
    Saw
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToint(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToint(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToInteger(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToInteger(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    SortedRepeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToint(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToInteger(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
    }
    ,
    Repeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToint(i%m);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToInteger(i%m);
        }
        while(++i!=length);
      }
    }
    ,
    Duplicated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToint(rand.nextInt(m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToInteger(rand.nextInt(m));
        }
        while(++i!=length);
      }
    }
    ,
    SortedOrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToint(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToInteger(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    OrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToint(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToint(length-(i++)-1);
        }
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToInteger(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToInteger(length-(i++)-1);
        }
      }
    }
    ,
    Stagger
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToint((i*m+i)%length);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToInteger((i*m+i)%length);
        }
        while(++i!=length);
      }
    }
    ,
    Plateau
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToint(Math.min(i,m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToInteger(Math.min(i,m));
        }
        while(++i!=length);
      }
    }
    ,
    Shuffle
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(int[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToint(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToInteger(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(int[] arr,int offset,int length,Random rand,int m);
    public void build(int[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(int[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    public abstract void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m);
    public void build(Integer[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(Integer[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "intArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<int[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          int[] arr=new int[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static enum longArrayBuilder
  {
    Randomized
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomlong(rand);
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomLong(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTolong(m+i)){}
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToLong(m+i)){}
      }
    }
    ,
    Descending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTolong(length-m-i)){}
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToLong(length-m-i)){}
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 0;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        long val=convertTolong(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        Long val=convertToLong(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ,
    MergeAscending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTolong(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTolong(++v)){}
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToLong(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToLong(++v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToLong(0);
          }
        }
      }
    }
    ,
    MergeDescending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTolong(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTolong(--v)){}
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToLong(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToLong(--v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToLong(0);
          }
        }
      }
    }
    ,
    Saw
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTolong(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTolong(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToLong(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToLong(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    SortedRepeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertTolong(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToLong(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
    }
    ,
    Repeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTolong(i%m);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToLong(i%m);
        }
        while(++i!=length);
      }
    }
    ,
    Duplicated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTolong(rand.nextInt(m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToLong(rand.nextInt(m));
        }
        while(++i!=length);
      }
    }
    ,
    SortedOrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertTolong(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToLong(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    OrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertTolong(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertTolong(length-(i++)-1);
        }
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToLong(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToLong(length-(i++)-1);
        }
      }
    }
    ,
    Stagger
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTolong((i*m+i)%length);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToLong((i*m+i)%length);
        }
        while(++i!=length);
      }
    }
    ,
    Plateau
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertTolong(Math.min(i,m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToLong(Math.min(i,m));
        }
        while(++i!=length);
      }
    }
    ,
    Shuffle
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(long[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertTolong(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
      @Override
      public void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToLong(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(long[] arr,int offset,int length,Random rand,int m);
    public void build(long[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(long[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    public abstract void buildUnchecked(Long[] arr,int offset,int length,Random rand,int m);
    public void build(Long[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(Long[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "longArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<long[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          long[] arr=new long[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static enum floatArrayBuilder
  {
    Randomized
    {
    /*
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomfloat(rand);
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomFloat(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTofloat(m+i)){}
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToFloat(m+i)){}
      }
    }
    ,
    Descending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTofloat(length-m-i)){}
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToFloat(length-m-i)){}
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 0;
      }
    /*
    */
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        float val=convertTofloat(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        Float val=convertToFloat(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ,
    MergeAscending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
    /*
    */
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTofloat(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTofloat(++v)){}
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToFloat(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToFloat(++v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToFloat(0);
          }
        }
      }
    }
    ,
    MergeDescending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
    /*
    */
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTofloat(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTofloat(--v)){}
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToFloat(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToFloat(--v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToFloat(0);
          }
        }
      }
    }
    ,
    Saw
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTofloat(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTofloat(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToFloat(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToFloat(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    SortedRepeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
    /*
    */
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertTofloat(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToFloat(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
    }
    ,
    Repeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTofloat(i%m);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToFloat(i%m);
        }
        while(++i!=length);
      }
    }
    ,
    Duplicated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTofloat(rand.nextInt(m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToFloat(rand.nextInt(m));
        }
        while(++i!=length);
      }
    }
    ,
    SortedOrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
    /*
    */
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertTofloat(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToFloat(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    OrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertTofloat(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertTofloat(length-(i++)-1);
        }
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToFloat(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToFloat(length-(i++)-1);
        }
      }
    }
    ,
    Stagger
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTofloat((i*m+i)%length);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToFloat((i*m+i)%length);
        }
        while(++i!=length);
      }
    }
    ,
    Plateau
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertTofloat(Math.min(i,m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToFloat(Math.min(i,m));
        }
        while(++i!=length);
      }
    }
    ,
    Shuffle
    {
    /*
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertTofloat(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToFloat(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
    }
    ,
    WithNaNsAndZeros
    {
    /*
      @Override
      public int getNumReps(int arrLength)
      {
        return 2;
      }
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(float[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;++i)
        {
          switch(rand.nextInt(4))
          {
          case 0:
            arr[i+offset]=(float)0.0;
            break;
          case 1:
            arr[i+offset]=(float)-0.0;
            break;
          case 2:
            arr[i+offset]=Float.NaN;
            break;
          default:
            arr[i+offset]=getRandomfloat(rand);
          }
        }
      }
      //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
      @SuppressWarnings("deprecation")
      @Override
      public void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;++i)
        {
          switch(rand.nextInt(4))
          {
          case 0:
            arr[i+offset]=new Float((float)0.0);
            break;
          case 1:
            arr[i+offset]=new Float((float)-0.0);
            break;
          case 2:
            arr[i+offset]=new Float(Float.NaN);
            break;
          default:
            arr[i+offset]=getRandomFloat(rand);
          }
        }
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(float[] arr,int offset,int length,Random rand,int m);
    public void build(float[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(float[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    public abstract void buildUnchecked(Float[] arr,int offset,int length,Random rand,int m);
    public void build(Float[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(Float[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "floatArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<float[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          float[] arr=new float[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static enum doubleArrayBuilder
  {
    Randomized
    {
    /*
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomdouble(rand);
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomDouble(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTodouble(m+i)){}
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToDouble(m+i)){}
      }
    }
    ,
    Descending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertTodouble(length-m-i)){}
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToDouble(length-m-i)){}
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 0;
      }
    /*
    */
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        double val=convertTodouble(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        Double val=convertToDouble(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ,
    MergeAscending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
    /*
    */
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTodouble(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTodouble(++v)){}
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToDouble(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToDouble(++v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToDouble(0);
          }
        }
      }
    }
    ,
    MergeDescending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
    /*
    */
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertTodouble(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertTodouble(--v)){}
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToDouble(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToDouble(--v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToDouble(0);
          }
        }
      }
    }
    ,
    Saw
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTodouble(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertTodouble(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToDouble(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToDouble(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    SortedRepeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
    /*
    */
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertTodouble(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToDouble(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
    }
    ,
    Repeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTodouble(i%m);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToDouble(i%m);
        }
        while(++i!=length);
      }
    }
    ,
    Duplicated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTodouble(rand.nextInt(m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToDouble(rand.nextInt(m));
        }
        while(++i!=length);
      }
    }
    ,
    SortedOrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
    /*
    */
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertTodouble(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToDouble(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    OrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertTodouble(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertTodouble(length-(i++)-1);
        }
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToDouble(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToDouble(length-(i++)-1);
        }
      }
    }
    ,
    Stagger
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertTodouble((i*m+i)%length);
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToDouble((i*m+i)%length);
        }
        while(++i!=length);
      }
    }
    ,
    Plateau
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
    /*
    */
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertTodouble(Math.min(i,m));
        }
        while(++i!=length);
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToDouble(Math.min(i,m));
        }
        while(++i!=length);
      }
    }
    ,
    Shuffle
    {
    /*
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertTodouble(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToDouble(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
    }
    ,
    WithNaNsAndZeros
    {
    /*
      @Override
      public int getNumReps(int arrLength)
      {
        return 2;
      }
    */
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(double[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;++i)
        {
          switch(rand.nextInt(4))
          {
          case 0:
            arr[i+offset]=(double)0.0;
            break;
          case 1:
            arr[i+offset]=(double)-0.0;
            break;
          case 2:
            arr[i+offset]=Double.NaN;
            break;
          default:
            arr[i+offset]=getRandomdouble(rand);
          }
        }
      }
      //Ignore deprecation because we need would like to be able to use identity equality on the newly created boxed types
      @SuppressWarnings("deprecation")
      @Override
      public void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;++i)
        {
          switch(rand.nextInt(4))
          {
          case 0:
            arr[i+offset]=new Double((double)0.0);
            break;
          case 1:
            arr[i+offset]=new Double((double)-0.0);
            break;
          case 2:
            arr[i+offset]=new Double(Double.NaN);
            break;
          default:
            arr[i+offset]=getRandomDouble(rand);
          }
        }
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(double[] arr,int offset,int length,Random rand,int m);
    public void build(double[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(double[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    public abstract void buildUnchecked(Double[] arr,int offset,int length,Random rand,int m);
    public void build(Double[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(Double[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "doubleArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<double[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          double[] arr=new double[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static enum StringArrayBuilder
  {
    Randomized
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomString(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToString(m+i)){}
      }
    }
    ,
    Descending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToString(length-m-i)){}
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 0;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        String val=convertToString(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ,
    MergeAscending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToString(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToString(++v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToString(0);
          }
        }
      }
    }
    ,
    MergeDescending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToString(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToString(--v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToString(0);
          }
        }
      }
    }
    ,
    Saw
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToString(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToString(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    SortedRepeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToString(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
    }
    ,
    Repeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToString(i%m);
        }
        while(++i!=length);
      }
    }
    ,
    Duplicated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToString(rand.nextInt(m));
        }
        while(++i!=length);
      }
    }
    ,
    SortedOrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToString(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    OrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToString(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToString(length-(i++)-1);
        }
      }
    }
    ,
    Stagger
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToString((i*m+i)%length);
        }
        while(++i!=length);
      }
    }
    ,
    Plateau
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToString(Math.min(i,m));
        }
        while(++i!=length);
      }
    }
    ,
    Shuffle
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(String[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToString(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(String[] arr,int offset,int length,Random rand,int m);
    public void build(String[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(String[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "StringArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<String[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          String[] arr=new String[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static enum IntegerArrayBuilder
  {
    Randomized
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        length+=offset;
        do
        {
          arr[offset]=getRandomInteger(rand);
        }
        while(++offset!=length);
      }
    }
    ,
    Ascending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToInteger(m+i)){}
      }
    }
    ,
    Descending
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;i<length;arr[(i++)+offset]=convertToInteger(length-m-i)){}
      }
    }
    ,
    AllEquals
    {
      @Override
      public int getMLo()
      {
        return 0;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 0;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        Integer val=convertToInteger(m);
        length+=offset;
        do
        {
          arr[offset]=val;
        }
        while(++offset!=length);
      }
    }
    ,
    MergeAscending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToInteger(++v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToInteger(++v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToInteger(0);
          }
        }
      }
    }
    ,
    MergeDescending
    {
      @Override
      public int getMLo()
      {
        return 65;
      }
      @Override
      public int getMHi(int arrLength)
      {
        return 69;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int v=0;
        for(int i=0, k=0,period=length/m;k<m;++k)
        {
          v=0;
          for(int p=0;p<period;arr[(i++)+offset]=convertToInteger(--v),++p){}
        }
        for(int j=1;j<length-1;arr[j++]=convertToInteger(--v)){}
        for(int i=offset,bound=offset+length;i<bound;++i)
        {
          if(arr[i]==null)
          {
            arr[i]=convertToInteger(0);
          }
        }
      }
    }
    ,
    Saw
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int incCount=1,decCount=length,i=0,period=m--;;period+=m)
        {
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToInteger(incCount++))
          {
            if(i>=length)
            {
              return;
            }
          }
          period+=m;
          for(int k=0;++k<=period;arr[(i++)+offset]=convertToInteger(decCount--))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    SortedRepeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int period=length/m,i=0,k=0;;++k)
        {
          for(int t=0;++t<=period;arr[(i++)+offset]=convertToInteger(k))
          {
            if(i>=length)
            {
              return;
            }
          }
          if(i>=length)
          {
            return;
          }
        }
      }
    }
    ,
    Repeated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToInteger(i%m);
        }
        while(++i!=length);
      }
    }
    ,
    Duplicated
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToInteger(rand.nextInt(m));
        }
        while(++i!=length);
      }
    }
    ,
    SortedOrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return Math.min(arrLength,7);
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        for(int i=0;;)
        {
          for(int t=0;++t<=m;arr[(i++)+offset]=convertToInteger(m))
          {
            if(i>=length)
            {
              return;
            }
          }
        }
      }
    }
    ,
    OrganPipes
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        for(int middle=length/(m+1);i<middle;arr[i+offset]=convertToInteger(i++)){}
        while(i<length)
        {
          arr[i+offset]=convertToInteger(length-(i++)-1);
        }
      }
    }
    ,
    Stagger
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[i+offset]=convertToInteger((i*m+i)%length);
        }
        while(++i!=length);
      }
    }
    ,
    Plateau
    {
      @Override
      public int getMHi(int arrLength)
      {
        return (arrLength<<1)-1;
      }
      public int incrementM(int m)
      {
        return m<<1;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int i=0;
        do
        {
          arr[offset+i]=convertToInteger(Math.min(i,m));
        }
        while(++i!=length);
      }
    }
    ,
    Shuffle
    {
      @Override
      public boolean isRandomized()
      {
        return true;
      }
      @Override
      public void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m)
      {
        int x=0,y=0;
        int bound=offset+length;
        do
        {
          arr[offset]=convertToInteger(rand.nextBoolean()?(x+2):(y+2));
        }
        while(++offset!=bound);
      }
    }
    ;
    public int getMLo()
    {
      return 1;
    }
    public int getMHi(int arrLength)
    {
      return 1;
    }
    public int getNumReps(int arrLength)
    {
      if(isRandomized())
      {
        return 10;
      }
      return 1;
    }
    public int incrementM(int m)
    {
      return m+1;
    }
    public boolean isRandomized()
    {
      //most sub-types are not randomized, so make that the default
      return false;
    }
    public abstract void buildUnchecked(Integer[] arr,int offset,int length,Random rand,int m);
    public void build(Integer[] arr,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      int length;
      if((length=arr.length)!=0)
      {
        buildUnchecked(arr,0,length,rand,m);
      }
    }  
    public void build(Integer[] arr,int offset,int length,Random rand,int m)
    {
      if(arr==null)
      {
        throw new NullPointerException("arr cannot be null");
      }
      if(offset<0 || length<0 || offset+length>arr.length)
      {
        throw new ArrayIndexOutOfBoundsException("offset = "+offset+"; length="+length+"; arr.length="+arr.length);
      }
      if(length!=0)
      {
        buildUnchecked(arr,offset,length,rand,m);
      }
    }
    @Override
    public String toString()
    {
      return "IntegerArrayBuilder."+this.name();
    }
    public void addArrays(long randSeed,int arrLength,Collection<Integer[]> arrays)
    {
      Random rand=new Random(randSeed);
      for(int m=getMLo(),mHi=getMHi(arrLength),numReps=getNumReps(arrLength);m<=mHi;m=incrementM(m))
      {
        for(int i=0;i<numReps;++i)
        {
          Integer[] arr=new Integer[arrLength];
          if(arrLength!=0)
          {
            buildUnchecked(arr,0,arrLength,rand,m);
          }
          synchronized(arrays)
          {
            arrays.add(arr);
          }
        }
      }
    }
  }
  public static boolean isEqual(boolean l,boolean r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,byte r)
  {
        return TypeUtil.castToByte(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,char r)
  {
        return TypeUtil.castToByte(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,short r)
  {
        return TypeUtil.castToByte(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,int r)
  {
        return TypeUtil.castToByte(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,long r)
  {
        return TypeUtil.castToLong(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,float r)
  {
        return TypeUtil.castToFloat(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,double r)
  {
        return TypeUtil.doubleEquals(r,TypeUtil.castToDouble(l));
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,boolean r)
  {
        return l==TypeUtil.castToByte(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,float r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,double r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,boolean r)
  {
        return l==TypeUtil.castToByte(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,float r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,double r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,boolean r)
  {
        return l==TypeUtil.castToByte(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,float r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,double r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,boolean r)
  {
        return l==TypeUtil.castToByte(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,float r)
  {
        return l==r;
        //return ((double)l)==((double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,double r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,boolean r)
  {
        return l==TypeUtil.castToLong(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,float r)
  {
          return l==r;
        //return TypeUtil.floatEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,double r)
  {
          return l==r;
        //return TypeUtil.doubleEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,boolean r)
  {
        return l==TypeUtil.castToFloat(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,int r)
  {
        return ((double)l)==((double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,long r)
  {
        return l==r;
        //return TypeUtil.floatEquals(l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,float r)
  {
          return TypeUtil.floatEquals(r,l);
        //return TypeUtil.floatEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,double r)
  {
          return TypeUtil.doubleEquals(r,l);
        //return TypeUtil.doubleEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,boolean r)
  {
        return l==TypeUtil.castToDouble(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,long r)
  {
        return l==r;
        //return TypeUtil.doubleEquals(l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,float r)
  {
        return TypeUtil.doubleEquals(l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,double r)
  {
          return TypeUtil.doubleEquals(r,l);
        //return TypeUtil.doubleEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
}
