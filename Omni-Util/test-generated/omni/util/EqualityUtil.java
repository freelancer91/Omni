package omni.util;
import java.util.Objects;
import java.util.stream.IntStream;
import org.junit.jupiter.api.Assertions;
public interface EqualityUtil
{
  public static void parallelAssertStringsAreEqual(String expected,char[] actualBuffer,int actualOffset,int actualLength)
  {
    Assertions.assertEquals(expected.length(),actualLength);
    IntStream.range(0,actualLength).parallel().forEach(i->
    {
      final var ec=expected.charAt(i);
      final var ac=actualBuffer[i+actualOffset];
      if(ec!=ac)
      {
        Assertions.fail("expected["+i+"] = "+ec+"; actual["+i+"] = "+ac);
      }
    });
  }
  public static void assertStringsAreEqual(String expected,char[] actualBuffer,int actualOffset,int actualLength)
  {
    Assertions.assertEquals(expected.length(),actualLength);
    for(int i=0;i<actualLength;++i)
    {
      final var ec=expected.charAt(i);
      final var ac=actualBuffer[i+actualOffset];
      if(ec!=ac)
      {
        Assertions.fail("expected["+i+"] = "+ec+"; actual["+i+"] = "+ac);
      }
    }
  }
  public static void parallelAssertStringsAreEqual(String expected,byte[] actualBuffer,int actualOffset,int actualLength)
  {
    Assertions.assertEquals(expected.length(),actualLength);
    IntStream.range(0,actualLength).parallel().forEach(i->
    {
      final var ec=expected.charAt(i);
      final var ac=actualBuffer[i+actualOffset];
      if(ec!=ac)
      {
        Assertions.fail("expected["+i+"] = "+ec+"; actual["+i+"] = "+((char)ac));
      }
    });
  }
  public static void assertStringsAreEqual(String expected,byte[] actualBuffer,int actualOffset,int actualLength)
  {
    Assertions.assertEquals(expected.length(),actualLength);
    for(int i=0;i<actualLength;++i)
    {
      final var ec=expected.charAt(i);
      final var ac=actualBuffer[i+actualOffset];
      if(ec!=ac)
      {
        Assertions.fail("expected["+i+"] = "+ec+"; actual["+i+"] = "+((char)ac));
      }
    }
  }
  public static void parallelAssertStringsAreEqual(String expected,String actual)  {
    var length=expected.length();
    Assertions.assertEquals(length,actual.length(),"string lengths not equal");
    IntStream.range(0,length).parallel().forEach(i->
    {
      final var ec=expected.charAt(i);
      final var ac=actual.charAt(i);
      if(ec!=ac)
      {
        Assertions.fail("expected["+i+"] = "+ec+"; actual["+i+"] = "+ac);
      }
    });
  }
  public static void assertStringsAreEqual(String expected,String actual)  {
    var length=expected.length();
    Assertions.assertEquals(length,actual.length(),"string lengths not equal");
    for(int i=0;i<length;++i)
    {
      final var ec=expected.charAt(i);
      final var ac=actual.charAt(i);
      if(ec!=ac)
      {
        Assertions.fail("expected["+i+"] = "+ec+"; actual["+i+"] = "+ac);
      }
    }
  }
  public static boolean isEqual(boolean l,boolean r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,byte r)
  {
        return TypeUtil.castToByte(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,char r)
  {
        return TypeUtil.castToByte(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,short r)
  {
        return TypeUtil.castToByte(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,int r)
  {
        return TypeUtil.castToByte(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,long r)
  {
        return TypeUtil.castToLong(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,float r)
  {
        return TypeUtil.castToFloat(l)==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,double r)
  {
        return TypeUtil.doubleEquals(r,TypeUtil.castToDouble(l));
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(boolean l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,boolean r)
  {
        return l==TypeUtil.castToByte(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,float r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,double r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(byte l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,boolean r)
  {
        return l==TypeUtil.castToByte(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,float r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,double r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(char l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(char[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,boolean r)
  {
        return l==TypeUtil.castToByte(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,float r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,double r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(short l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,boolean r)
  {
        return l==TypeUtil.castToByte(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,float r)
  {
        return l==r;
        //return ((double)l)==((double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,double r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(int l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(int[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,boolean r)
  {
        return l==TypeUtil.castToLong(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,long r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,float r)
  {
          return l==r;
        //return TypeUtil.floatEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,double r)
  {
          return l==r;
        //return TypeUtil.doubleEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(long l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,boolean r)
  {
        return l==TypeUtil.castToFloat(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,int r)
  {
        return ((double)l)==((double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,long r)
  {
        return l==r;
        //return TypeUtil.floatEquals(l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,float r)
  {
          return TypeUtil.floatEquals(r,l);
        //return TypeUtil.floatEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,double r)
  {
          return TypeUtil.doubleEquals(r,l);
        //return TypeUtil.doubleEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(float l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,boolean r)
  {
        return l==TypeUtil.castToDouble(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,byte r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,char r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,short r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,int r)
  {
        return l==r;
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,long r)
  {
        return l==r;
        //return TypeUtil.doubleEquals(l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,float r)
  {
        return TypeUtil.doubleEquals(l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,double r)
  {
          return TypeUtil.doubleEquals(r,l);
        //return TypeUtil.doubleEquals(r,l);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Boolean r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(boolean)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Byte r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(byte)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Character r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(char)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Short r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(short)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Integer r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(int)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Long r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(long)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Float r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(float)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Double r)
  {
    if(r==null)
    {
      return false;
    }
        return isEqual(l,(double)r);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(double l,Object r)
  {
    if(r==null)
    {
      return false;
    }
        return r.equals(l);
  }
  public static void uncheckedparallelassertarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Boolean l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((boolean)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Boolean[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Byte l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((byte)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Byte[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Character l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((char)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Character[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Short l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((short)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Short[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Integer l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((int)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Integer[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Long l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((long)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Long[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Float l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((float)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Float[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Double l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return isEqual((double)l,r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Double[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,boolean r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,byte r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,char r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,char[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,short r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,int r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,int[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,long r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,float r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,double r)
  {
    if(l==null)
    {
        return false;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Boolean r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Boolean[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Byte r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Byte[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Character r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Character[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Short r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Short[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Integer r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Integer[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Long r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Long[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Float r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Float[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Double r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Double[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static boolean isEqual(Object l,Object r)
  {
    if(l==null)
    {
        return r==null;
    }
      return l.equals(r);
  }
  public static void uncheckedparallelassertarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+index],rArr[rOffset+index]));
    });
  }
  public static void parallelassertarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;;++rOffset)
    {
      Assertions.assertTrue(isEqual(lArr[lOffset],rArr[rOffset]));
      if(++lOffset==length)
      {
        return;
      }
    }
  }
  public static void assertarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedarraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(length+=lOffset;isEqual(lArr[lOffset],rArr[rOffset]);++rOffset)
    {
      if(++lOffset==length)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean arraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedarraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
  public static void uncheckedparallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    IntStream.range(0,length).parallel().forEach(index->
    {
      Assertions.assertTrue(isEqual(lArr[lOffset+(length-index-1)],rArr[rOffset+index]));
    });
  }
  public static void parallelassertreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedparallelassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static void uncheckedassertreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    int i=lOffset+length;
    do
    {
      Assertions.assertTrue(isEqual(lArr[--i],rArr[rOffset++]));
    }
    while(i!=lOffset);
  }
  public static void assertreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    if(length!=0)
    {
      uncheckedassertreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
    }
  }
  public static boolean uncheckedreversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    for(int i=lOffset+length;isEqual(lArr[--i],rArr[rOffset]);++rOffset)
    {
      if(i==lOffset)
      {
        return true;
      }
    }
    return false;
  }
  public static boolean reversearraysAreEqual(Object[] lArr,int lOffset,Object[] rArr,int rOffset,int length)
  {
    Objects.requireNonNull(lArr);
    Objects.requireNonNull(rArr);
    if(length<0 || lOffset<0 || rOffset<0 || lOffset+length>lArr.length || rOffset+length>rArr.length)
    {
      throw new ArrayIndexOutOfBoundsException("lArr.length="+lArr.length+"; rArr.length="+rArr.length+"; lOffset="+lOffset+"; rOffset="+rOffset+"; length="+length);
    }
    return length==0 || uncheckedreversearraysAreEqual(lArr,lOffset,rArr,rOffset,length);
  }
}
