#TYPEDEF OfGeneric
package omni.util;
import org.junit.Assert;
import org.junit.Test;
import java.util.Random;
import java.util.Arrays;
import java.util.Objects;
//TODO uncomment when the module bug is fixed
//import java.util.Comparator;
import java.util.function.IntBinaryOperator;
import omni.function.BooleanComparator;
import omni.function.ByteComparator;
import omni.function.CharComparator;
import omni.function.ShortComparator;
import omni.function.LongComparator;
import omni.function.FloatComparator;
import omni.function.DoubleComparator;
import java.util.function.Supplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import omni.function.ByteSupplier;
import omni.function.CharSupplier;
import omni.function.ShortSupplier;
import omni.function.FloatSupplier;
public class SortUtilTest
{
  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO GetComparator<Ascending,String>(String,Comparator<String>)
  */
  #MACRO GetComparator<Ascending,boolean>(Boolean,BooleanComparator)
  #MACRO GetComparator<Ascending,byte>(Byte,ByteComparator)
  #MACRO GetComparator<Ascending,char>(Character,CharComparator)
  #MACRO GetComparator<Ascending,short>(Short,ShortComparator)
  #MACRO GetComparator<Ascending,int>(Integer,IntBinaryOperator)
  #MACRO GetComparator<Ascending,long>(Long,LongComparator)
  #MACRO GetComparator<Ascending,float>(Float,FloatComparator)
  #MACRO GetComparator<Ascending,double>(Double,DoubleComparator)
  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO GetComparator<Unsorted,String>(String,Comparator<String>)
  */
  #MACRO GetComparator<Unsorted,boolean>(Boolean,BooleanComparator)
  #MACRO GetComparator<Unsorted,byte>(Byte,ByteComparator)
  #MACRO GetComparator<Unsorted,char>(Character,CharComparator)
  #MACRO GetComparator<Unsorted,short>(Short,ShortComparator)
  #MACRO GetComparator<Unsorted,int>(Integer,IntBinaryOperator)
  #MACRO GetComparator<Unsorted,long>(Long,LongComparator)
  #MACRO GetComparator<Unsorted,float>(Float,FloatComparator)
  #MACRO GetComparator<Unsorted,double>(Double,DoubleComparator)
  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO GetComparator<Descending,String>(String,Comparator<String>)
  */
  #MACRO GetComparator<Descending,boolean>(Boolean,BooleanComparator)
  #MACRO GetComparator<Descending,byte>(Byte,ByteComparator)
  #MACRO GetComparator<Descending,char>(Character,CharComparator)
  #MACRO GetComparator<Descending,short>(Short,ShortComparator)
  #MACRO GetComparator<Descending,int>(Integer,IntBinaryOperator)
  #MACRO GetComparator<Descending,long>(Long,LongComparator)
  #MACRO GetComparator<Descending,float>(Float,FloatComparator)
  #MACRO GetComparator<Descending,double>(Double,DoubleComparator)
#MACRODEF GetComparator<SORTTYPE,ARRTYPE>(BOXEDTYPE,COMPARATORTYPE)
private static COMPARATORTYPE getSORTTYPEARRTYPEComparator()
{
  return (val1,val2)->
  {
    return
#IFSWITCH SORTTYPE==Descending
      -
#ENDIF
      (
#IFSWITCH SORTTYPE==Unsorted
      0
#ELSE
  #IFSWITCH ARRTYPE==String
    val1.compareTo(val2)
  #ELSE
    BOXEDTYPE.compare(val1,val2)
  #ENDIF
#ENDIF
      );
  };
}
#ENDDEF

  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO IsSorted<String,sort>(String,Ref)
  */
  #MACRO IsSorted<boolean,sort>(Boolean,Boolean)
  #MACRO IsSorted<byte,sort>(Byte,Byte)
  #MACRO IsSorted<char,sort>(Character,Char)
  #MACRO IsSorted<short,sort>(Short,Short)
  #MACRO IsSorted<int,sort>(Integer,Int)
  #MACRO IsSorted<long,sort>(Long,Long)
  #MACRO IsSorted<float,sort>(Float,Float)
  #MACRO IsSorted<double,sort>(Double,Double)
  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO IsSorted<String,reverseSort>(String,Ref)
  */
  #MACRO IsSorted<boolean,reverseSort>(Boolean,Boolean)
  #MACRO IsSorted<byte,reverseSort>(Byte,Byte)
  #MACRO IsSorted<char,reverseSort>(Character,Char)
  #MACRO IsSorted<short,reverseSort>(Short,Short)
  #MACRO IsSorted<int,reverseSort>(Integer,Int)
  #MACRO IsSorted<long,reverseSort>(Long,Long)
  #MACRO IsSorted<float,reverseSort>(Float,Float)
  #MACRO IsSorted<double,reverseSort>(Double,Double)
#MACRODEF IsSorted<ARRTYPE,SORTTYPE>(BOXEDTYPE,CLASSPREFIX)
private static void isSortedSORTTYPE(ARRTYPE[] arr,ARRTYPE[] copy)
{
#IFSWITCH ARRTYPE==boolean
  BOXEDTYPE[] boxedCopy=new BOXEDTYPE[copy.length];
  ArrCopy.uncheckedCopy(copy,0,boxedCopy,0,copy.length);
  Arrays.sort(boxedCopy,0,copy.length);
  ArrCopy.uncheckedCopy(boxedCopy,0,copy,0,copy.length);
#ELSE
  Arrays.sort(copy,0,copy.length);
#ENDIF
#IFSWITCH SORTTYPE==reverseSort
  OmniArray.OfCLASSPREFIX.reverseRange(copy,0,copy.length-1);
#ENDIF
  for(int i=0;i<copy.length;++i)
  {
#IFSWITCH ARRTYPE==boolean,byte,char,short,int long
    Assert.assertTrue(arr[i]==copy[i]);
#ELSEIFSWITCH ARRTYPE==float,double
    Assert.assertTrue(TypeUtil.ARRTYPEEquals(arr[i],copy[i]));
#ELSE
    Assert.assertTrue(Objects.equals(arr[i],copy[i]));
#ENDIF
  }
}
#ENDDEF
  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO IsSorted<String>(Comparator<? super String>,compare,String)
  */
  #MACRO IsSorted<boolean>(BooleanComparator,compare,Boolean)
  #MACRO IsSorted<byte>(ByteComparator,compare,Byte)
  #MACRO IsSorted<char>(CharComparator,compare,Character)
  #MACRO IsSorted<short>(ShortComparator,compare,Short)
  #MACRO IsSorted<int>(IntBinaryOperator,applyAsInt,Integer)
  #MACRO IsSorted<long>(LongComparator,compare,Long)
  #MACRO IsSorted<float>(FloatComparator,compare,Float)
  #MACRO IsSorted<double>(DoubleComparator,compare,Double)
#MACRODEF IsSorted<ARRTYPE>(COMPARATORTYPE,COMPARATORMETHOD,BOXEDTYPE)
private static void isSorted(ARRTYPE[] arr,ARRTYPE[] copy,COMPARATORTYPE sorter)
{
#IFSWITCH ARRTYPE==String
  Arrays.sort(copy,0,copy.length,sorter);
#ELSE
  BOXEDTYPE[] boxedCopy=new BOXEDTYPE[copy.length];
  ArrCopy.uncheckedCopy(copy,0,boxedCopy,0,copy.length);
  Arrays.sort(boxedCopy,0,copy.length,sorter::COMPARATORMETHOD);
  ArrCopy.uncheckedCopy(boxedCopy,0,copy,0,copy.length);
#ENDIF
  for(int i=0;i<copy.length;++i)
  {
  #IFSWITCH ARRTYPE==boolean,byte,char,short,int long
    Assert.assertTrue(arr[i]==copy[i]);
  #ELSEIFSWITCH ARRTYPE==float,double
    Assert.assertTrue(TypeUtil.ARRTYPEEquals(arr[i],copy[i]));
  #ELSE
    Assert.assertTrue(Objects.equals(arr[i],copy[i]));
  #ENDIF
  }
}
#ENDDEF

  #MACRO GetRandom<boolean>()
  #MACRO GetRandom<byte>()
  #MACRO GetRandom<char>()
  #MACRO GetRandom<short>()
  #MACRO GetRandom<int>()
  #MACRO GetRandom<long>()
  #MACRO GetRandom<float>()
  #MACRO GetRandom<double>()
  /*//TODO uncomment when the eclipse module bug is fixed
  #MACRO GetRandom<String>()
  */
#MACRODEF GetRandom<ARRTYPE>()
private static ARRTYPE getRandARRTYPE(Random rand)
{
#IFSWITCH ARRTYPE==String
  return Long.toString(rand.nextLong());
#ELSEIFSWITCH ARRTYPE==boolean
  return rand.nextBoolean();
#ELSEIFSWITCH ARRTYPE==byte,char,short,int,long
  return (ARRTYPE)rand.nextLong();
#ELSEIFSWITCH ARRTYPE==float
  return rand.nextFloat();
#ELSEIFSWITCH ARRTYPE==double
  return rand.nextDouble();
#ELSE
ERROR unknown array type ARRTYPE
#ENDIF
}
#ENDDEF

  #MACRO ConvertMethods<boolean>()
  #MACRO ConvertMethods<byte>()
  #MACRO ConvertMethods<char>()
  #MACRO ConvertMethods<short>()
  #MACRO ConvertMethods<int>()
  #MACRO ConvertMethods<long>()
  #MACRO ConvertMethods<float>()
  #MACRO ConvertMethods<double>()
  /*//TODO uncomment when the eclipse module bug is fixed
  #MACRO ConvertMethods<String>()
  */
#MACRODEF ConvertMethods<ARRTYPE>()
private static ARRTYPE convertToARRTYPE(int val)
{
#IFSWITCH ARRTYPE==String
  return Integer.toString(val);
#ELSEIFSWITCH ARRTYPE==double,float,long,int,short,char,byte
  return (ARRTYPE)val;
#ELSE
  return val!=0;
#ENDIF
}
#ENDDEF



  #MACRO ArrayBuilders<boolean>()
  #MACRO ArrayBuilders<byte>()
  #MACRO ArrayBuilders<char>()
  #MACRO ArrayBuilders<short>()
  #MACRO ArrayBuilders<int>()
  #MACRO ArrayBuilders<long>()
  #MACRO ArrayBuilders<float>()
  #MACRO ArrayBuilders<double>()
  /*//TODO uncomment when the eclipse module bug is fixed
  #MACRO ArrayBuilders<String>()
  */
  

#MACRODEF ArrayBuilders<ARRTYPE>()
private static enum ArrayBuilderARRTYPE
{
  RANDOM
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=getRandARRTYPE(rand);
      }
    }
    int getNumRepetitions()
    {
      return 1000;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return 1;
    }
    int incrementM(int m)
    {
      return m+1;
    }
  },
  ASCENDING
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
#IFSWITCH ARRTYPE==boolean
      int pivotPoint=(arr.length/4)+rand.nextInt(arr.length/2);
      for(int i=0;i<pivotPoint;++i)
      {
        arr[i]=false;
      }
      for(int i=pivotPoint;i<arr.length;++i)
      {
        arr[i]=true;
      }
#ELSE
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=convertToARRTYPE(m+i);
      }
#ENDIF
    }
    int getNumRepetitions()
    {
#IFSWITCH ARRTYPE==boolean
      return 100;
#ELSE
      return 1;
#ENDIF
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
#IFSWITCH ARRTYPE==boolean
      return 1;
#ELSE
      return (2*arrLength)-1;
#ENDIF
    }
    int incrementM(int m)
    {
#IFSWITCH ARRTYPE==boolean
      return m+1;
#ELSE
      return m*2;
#ENDIF
    }
  },
  Descending
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
#IFSWITCH ARRTYPE==boolean
      int pivotPoint=(arr.length/4)+rand.nextInt(arr.length/2);
      for(int i=0;i<pivotPoint;++i)
      {
        arr[i]=true;
      }
      for(int i=pivotPoint;i<arr.length;++i)
      {
        arr[i]=false;
      }
#ELSE
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=convertToARRTYPE(arr.length-m-i);
      }
#ENDIF
    }

    int getNumRepetitions()
    {
#IFSWITCH ARRTYPE==boolean
      return 100;
#ELSE
      return 1;
#ENDIF
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
#IFSWITCH ARRTYPE==boolean
      return 1;
#ELSE
      return (2*arrLength)-1;
#ENDIF
    }
    int incrementM(int m)
    {
#IFSWITCH ARRTYPE==boolean
      return m+1;
#ELSE
      return m*2;
#ENDIF
    }

  },
  ALL_EQUAL
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=convertToARRTYPE(m);
      }
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 0;
    }
    int getMHi(int arrLength)
    {
#IFSWITCH ARRTYPE==boolean
      return 1;
#ELSE
      return 0;
#ENDIF
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
#IFNOTSWITCH ARRTYPE==boolean,byte
 
  ,MERGE_ASCENDING
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int period=arr.length/m;
      int v=1;
      int i=0;
      for(int k=0;k<m;++k)
      {
        v=1;
        for(int p=0;p<period;++p)
        {
          arr[i++]=convertToARRTYPE(v++);
        }
      }
      for(int j=1;j<arr.length-1;j++)
      {
        arr[j]=convertToARRTYPE(v++);

      }
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 65;
    }
    int getMHi(int arrLength)
    {
      return 69;
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
  ,MERGE_DESCENDING
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int period=arr.length/m;
      int v=-1;
      int i=0;
      for(int k=0;k<m;++k)
      {
        v=-1;
        for(int p=0;p<period;++p)
        {
          arr[i++]=convertToARRTYPE(v--);
        }
      }
      for(int j=1;j<arr.length-1;j++)
      {
        arr[j]=convertToARRTYPE(v--);
      }
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 65;
    }
    int getMHi(int arrLength)
    {
      return 69;
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
  ,SAW
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int incCount=1;
      int decCount=arr.length;
      int i=0;
      int period=m--;
      for(;;)
      {
        for(int k=1;k<=period;k++)
        {
          if(i>=arr.length)
          {
            return;
          }
          arr[i++]=convertToARRTYPE(incCount++);
        }
        period+=m;
        for(int k=1;k<=period;k++)
        {
          if(i>=arr.length)
          {
            return;
          }
          arr[i++]=convertToARRTYPE(decCount--);
        }
        period+=m;
      }
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,SORTED_REPEATED
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int period=arr.length/m;
      int i=0;
      int k=0;
      for(;;)
      {
        for(int t=1;t<=period;++t)
        {
          if(i>=arr.length)
          {
            return;
          }
          arr[i++]=convertToARRTYPE(k);
        }
        if(i>=arr.length)
        {
          return;
        }
        ++k;
      }
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return Math.min(arrLength,7);
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
  //FIXME REPEATED and DUPLICATED cause an AIOB exception
  ,REPEATED
  {
    void build(ARRTYPE[] arr, int m, Random rand)
    {
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=convertToARRTYPE(i%m);
      }
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,DUPLICATED
  {
    void build(ARRTYPE[] arr, int m, Random rand)
    {
      for (int i = 0; i < arr.length; i++)
      {
        arr[i] = convertToARRTYPE(rand.nextInt(m));
      }
    }
    int getNumRepetitions()
    {
      return 1000;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,SORTED_ORGAN_PIPES
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int i=0;
      int k=m;
      for(;;)
      {
        for(int t=1;t<=m;++t)
        {
          if(i>=arr.length)
          {
            return;
          }
          arr[i++]=convertToARRTYPE(k);
        }
      }
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return Math.min(arrLength,7);
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
  ,ORGAN_PIPES
  {
    void build(ARRTYPE[] arr, int m, Random rand)
    {
      int middle = arr.length / (m + 1);
      for (int i = 0; i < middle; i++) {
          arr[i] = convertToARRTYPE(i);
      }
      for (int i = middle; i < arr.length; i++) {
          arr[i] = convertToARRTYPE(arr.length - i - 1);
      }
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,STAGGER
  {
    void build(ARRTYPE[] arr, int m, Random rand) {
      for (int i = 0; i < arr.length; i++) {
        arr[i] = convertToARRTYPE((i * m + i) % arr.length);
      }
      
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,PLATEAU
  {
    void build(ARRTYPE[] arr, int m, Random rand) {
      for (int i = 0; i < arr.length; i++) {
        arr[i] = convertToARRTYPE(Math.min(i, m));
      }
    }
    int getNumRepetitions()
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,SHUFFLE
  {
    void build(ARRTYPE[] arr, int m, Random rand) {
      int x = 0, y = 0;
      for (int i = 0; i < arr.length; i++) {
        arr[i] = convertToARRTYPE(rand.nextBoolean() ? (x += 2) : (y += 2));
      }
    }
    int getNumRepetitions()
    {
      return 1000;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return 1;
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
#ENDIF
  ;

  abstract void build(ARRTYPE[] arr,int m,Random rand); 
  abstract int getNumRepetitions();
  abstract int getMLo();
  abstract int getMHi(int arrLength);
  abstract int incrementM(int m);
}

#ENDDEF
 


  #MACRO TestNonComparatorSortHelper<sort,boolean>()
  #MACRO TestNonComparatorSortHelper<sort,byte>()
  #MACRO TestNonComparatorSortHelper<sort,char>()
  #MACRO TestNonComparatorSortHelper<sort,short>()
  #MACRO TestNonComparatorSortHelper<sort,int>()
  #MACRO TestNonComparatorSortHelper<sort,long>()
  #MACRO TestNonComparatorSortHelper<sort,float>()
  #MACRO TestNonComparatorSortHelper<sort,double>()
  /*/TODO uncomment when the eclipse module bug is fixed
  #MACRO TestNonComparatorSortHelper<sort,String>()
  */
  
  #MACRO TestNonComparatorSortHelper<reverseSort,boolean>()
  #MACRO TestNonComparatorSortHelper<reverseSort,byte>()
  #MACRO TestNonComparatorSortHelper<reverseSort,char>()
  #MACRO TestNonComparatorSortHelper<reverseSort,short>()
  #MACRO TestNonComparatorSortHelper<reverseSort,int>()
  #MACRO TestNonComparatorSortHelper<reverseSort,long>()
  #MACRO TestNonComparatorSortHelper<reverseSort,float>()
  #MACRO TestNonComparatorSortHelper<reverseSort,double>()
  /*/TODO uncomment when the eclipse module bug is fixed
  #MACRO TestNonComparatorSortHelper<reverseSort,String>()
  */

#MACRODEF TestNonComparatorSortHelper<SORTTYPE,ARRTYPE>()
private static void testuncheckedSORTTYPEHelperARRTYPE(int arrLength,Random rand)
{
  ARRTYPE[] golden=new ARRTYPE[arrLength];
  for(ArrayBuilderARRTYPE builder:ArrayBuilderARRTYPE.values())
  {
    
    for(int m=builder.getMLo(),mHi=builder.getMHi(arrLength);m<=mHi;m=builder.incrementM(m))
    {
      for(int i=0,numReps=builder.getNumRepetitions();i<numReps;++i)
      {
        builder.build(golden,m,rand);
        ARRTYPE[] test=golden.clone();
        SortUtil.uncheckedSORTTYPE(test,0,arrLength-1);
        isSortedSORTTYPE(test,golden);
      }
      
    }
  }
}
#ENDDEF

 




  @Test
  public void testUncheckedSortboolean()
  {
    
  
    var rand=new Random(0);
    testuncheckedsortHelperboolean(100,rand);
    
  }
  @Test
  public void testUncheckedReverseSortboolean()
  {
    var rand=new Random(0);
    testuncheckedreverseSortHelperboolean(100,rand);
    
  }
  /*//TODO uncomment when the module bug is fixed
  @Test
  public void testUncheckedComparatorSortboolean()
  {
    //TODO
  }
  */
  @Test
  public void testUncheckedSortbyte()
  {
    var rand=new Random(0);
    testuncheckedsortHelperbyte(29,rand);
    testuncheckedsortHelperbyte(1000,rand);
  }
  @Test
  public void testUncheckedReverseSortbyte()
  {
    var rand=new Random(0);
    testuncheckedreverseSortHelperbyte(29,rand);
    testuncheckedreverseSortHelperbyte(1000,rand);
  }
  @Test
  public void testUncheckedsortchar()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedsortHelperchar(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedReverseSortchar()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedreverseSortHelperchar(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedsortshort()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedsortHelpershort(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedReverseSortshort()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedreverseSortHelpershort(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedsortint()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedsortHelperint(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedReverseSortint()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedreverseSortHelperint(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedsortlong()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedsortHelperlong(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedReverseSortlong()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedreverseSortHelperlong(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedsortfloat()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedsortHelperfloat(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedReverseSortfloat()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedreverseSortHelperfloat(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedsortdouble()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedsortHelperdouble(lengths[i],rand);
    }
  }
  @Test
  public void testUncheckedReverseSortdouble()
  {
    var rand=new Random(0);
    int[] lengths=new int[]{286,3201,3202};
    for(int i=0;i<lengths.length;++i)
    {
      testuncheckedreverseSortHelperdouble(lengths[i],rand);
    }
  }
}









