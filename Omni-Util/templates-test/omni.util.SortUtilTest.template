#TYPEDEF OfGeneric
package omni.util;
import org.junit.Assert;
import org.junit.Test;
import org.junit.BeforeClass;
import java.util.Random;
import java.util.Arrays;
import java.util.Objects;
import java.util.stream.IntStream;
//TODO uncomment when the module bug is fixed
//import java.util.Comparator;
import java.util.function.IntBinaryOperator;
import omni.function.BooleanComparator;
import omni.function.ByteComparator;
import omni.function.CharComparator;
import omni.function.ShortComparator;
import omni.function.LongComparator;
import omni.function.FloatComparator;
import omni.function.DoubleComparator;
import java.util.function.Supplier;
import java.util.function.BooleanSupplier;
import java.util.function.IntSupplier;
import java.util.function.LongSupplier;
import java.util.function.DoubleSupplier;
import omni.function.ByteSupplier;
import omni.function.CharSupplier;
import omni.function.ShortSupplier;
import omni.function.FloatSupplier;
public class SortUtilTest
{
  
  #MACRO Fields<true>()

#MACRODEF Fields<LONGRUN>()
#IFSWITCH LONGRUN==true
private static final int[] lengths=new int[]{2, 3, 5, 8, 13, 21, 34, 55, 100, 1000, 10000, 100000, 1000000};
private static final long[] randSeeds=new long[]{666L,0xC0FFEEL,999L};
#ELSE
private static final int[] lengths=new int[]{2, 3, 21, 55, 1000, 10000};
private static final long[] randSeeds=new long[]{666};
#ENDIF


#ENDDEF

  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO GetComparator<Ascending,String>(String,Comparator<String>)
  #MACRO GetComparator<Ascending,boolean>(Boolean,BooleanComparator)
  #MACRO GetComparator<Ascending,byte>(Byte,ByteComparator)
  #MACRO GetComparator<Ascending,char>(Character,CharComparator)
  #MACRO GetComparator<Ascending,short>(Short,ShortComparator)
  #MACRO GetComparator<Ascending,int>(Integer,IntBinaryOperator)
  #MACRO GetComparator<Ascending,long>(Long,LongComparator)
  #MACRO GetComparator<Ascending,float>(Float,FloatComparator)
  #MACRO GetComparator<Ascending,double>(Double,DoubleComparator)
  #MACRO GetComparator<Unsorted,String>(String,Comparator<String>)
  #MACRO GetComparator<Unsorted,boolean>(Boolean,BooleanComparator)
  #MACRO GetComparator<Unsorted,byte>(Byte,ByteComparator)
  #MACRO GetComparator<Unsorted,char>(Character,CharComparator)
  #MACRO GetComparator<Unsorted,short>(Short,ShortComparator)
  #MACRO GetComparator<Unsorted,int>(Integer,IntBinaryOperator)
  #MACRO GetComparator<Unsorted,long>(Long,LongComparator)
  #MACRO GetComparator<Unsorted,float>(Float,FloatComparator)
  #MACRO GetComparator<Unsorted,double>(Double,DoubleComparator)
  #MACRO GetComparator<Descending,String>(String,Comparator<String>)
  #MACRO GetComparator<Descending,boolean>(Boolean,BooleanComparator)
  #MACRO GetComparator<Descending,byte>(Byte,ByteComparator)
  #MACRO GetComparator<Descending,char>(Character,CharComparator)
  #MACRO GetComparator<Descending,short>(Short,ShortComparator)
  #MACRO GetComparator<Descending,int>(Integer,IntBinaryOperator)
  #MACRO GetComparator<Descending,long>(Long,LongComparator)
  #MACRO GetComparator<Descending,float>(Float,FloatComparator)
  #MACRO GetComparator<Descending,double>(Double,DoubleComparator)
  */
#MACRODEF GetComparator<SORTTYPE,ARRTYPE>(BOXEDTYPE,COMPARATORTYPE)
private static COMPARATORTYPE getSORTTYPEARRTYPEComparator()
{
  return (val1,val2)->
  {
    return
#IFSWITCH SORTTYPE==Descending
      -
#ENDIF
      (
#IFSWITCH SORTTYPE==Unsorted
      0
#ELSE
  #IFSWITCH ARRTYPE==String
    val1.compareTo(val2)
  #ELSE
    BOXEDTYPE.compare(val1,val2)
  #ENDIF
#ENDIF
      );
  };
}
#ENDDEF

  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO IsSorted<String,sort>(String,Ref)
  */
  #MACRO IsSorted<boolean,sort>(Boolean,Boolean)
  #MACRO IsSorted<byte,sort>(Byte,Byte)
  #MACRO IsSorted<char,sort>(Character,Char)
  #MACRO IsSorted<short,sort>(Short,Short)
  #MACRO IsSorted<int,sort>(Integer,Int)
  #MACRO IsSorted<long,sort>(Long,Long)
  #MACRO IsSorted<float,sort>(Float,Float)
  #MACRO IsSorted<double,sort>(Double,Double)
  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO IsSorted<String,reverseSort>(String,Ref)
  */
  #MACRO IsSorted<boolean,reverseSort>(Boolean,Boolean)
  #MACRO IsSorted<byte,reverseSort>(Byte,Byte)
  #MACRO IsSorted<char,reverseSort>(Character,Char)
  #MACRO IsSorted<short,reverseSort>(Short,Short)
  #MACRO IsSorted<int,reverseSort>(Integer,Int)
  #MACRO IsSorted<long,reverseSort>(Long,Long)
  #MACRO IsSorted<float,reverseSort>(Float,Float)
  #MACRO IsSorted<double,reverseSort>(Double,Double)
#MACRODEF IsSorted<ARRTYPE,SORTTYPE>(BOXEDTYPE,CLASSPREFIX)
private static void isSortedSORTTYPE(ARRTYPE[] arr,ARRTYPE[] copy) throws InterruptedException
{
  Thread stockSorterThread=new Thread(()->
  {
#IFSWITCH ARRTYPE==boolean
  BOXEDTYPE[] boxedCopy=new BOXEDTYPE[copy.length];
  ArrCopy.uncheckedCopy(copy,0,boxedCopy,0,copy.length);
  Arrays.parallelSort(boxedCopy,0,copy.length);
  ArrCopy.uncheckedCopy(boxedCopy,0,copy,0,copy.length);
#ELSE
  Arrays.parallelSort(copy,0,copy.length);
#ENDIF
#IFSWITCH SORTTYPE==reverseSort
  OmniArray.OfCLASSPREFIX.reverseRange(copy,0,copy.length-1);
#ENDIF
  });
  stockSorterThread.start();
  SortUtil.uncheckedSORTTYPE(arr,0,arr.length-1);
  stockSorterThread.join();
  IntStream.range(0,copy.length).parallel().forEach(index->
  {
#IFSWITCH ARRTYPE==boolean,byte,char,short,int long
    Assert.assertTrue(arr[index]==copy[index]);
#ELSEIFSWITCH ARRTYPE==float,double
    Assert.assertTrue(TypeUtil.ARRTYPEEquals(arr[index],copy[index]));
#ELSE
    Assert.assertTrue(Objects.equals(arr[index],copy[index]));
#ENDIF
  });
}
#ENDDEF
  /*//TODO uncomment when they fix the module bug in eclipse
  #MACRO IsSorted<String>(Comparator<? super String>,compare,String)
  #MACRO IsSorted<boolean>(BooleanComparator,compare,Boolean)
  #MACRO IsSorted<byte>(ByteComparator,compare,Byte)
  #MACRO IsSorted<char>(CharComparator,compare,Character)
  #MACRO IsSorted<short>(ShortComparator,compare,Short)
  #MACRO IsSorted<int>(IntBinaryOperator,applyAsInt,Integer)
  #MACRO IsSorted<long>(LongComparator,compare,Long)
  #MACRO IsSorted<float>(FloatComparator,compare,Float)
  #MACRO IsSorted<double>(DoubleComparator,compare,Double)
  */
#MACRODEF IsSorted<ARRTYPE>(COMPARATORTYPE,COMPARATORMETHOD,BOXEDTYPE)
private static void isSorted(ARRTYPE[] arr,ARRTYPE[] copy,COMPARATORTYPE sorter) throws InterruptedException
{
  Thread stockSorterThread=new Thread(()->
  {
#IFSWITCH ARRTYPE==String
  Arrays.parallelSort(copy,0,copy.length,sorter);
#ELSE
  BOXEDTYPE[] boxedCopy=new BOXEDTYPE[copy.length];
  ArrCopy.uncheckedCopy(copy,0,boxedCopy,0,copy.length);
  Arrays.parallelSort(boxedCopy,0,copy.length,sorter::COMPARATORMETHOD);
  ArrCopy.uncheckedCopy(boxedCopy,0,copy,0,copy.length);
#ENDIF
  });
  stockSorterThread.start();
  SortUtil.uncheckedcomparatorSort(arr,0,arr.length-1,sorter);
  stockSorterThread.join();
  IntStream.range(0,copy.length).parallel().forEach(index->
  {
#IFSWITCH ARRTYPE==boolean,byte,char,short,int long
    Assert.assertTrue(arr[index]==copy[index]);
#ELSEIFSWITCH ARRTYPE==float,double
    Assert.assertTrue(TypeUtil.ARRTYPEEquals(arr[index],copy[index]));
#ELSE
    Assert.assertTrue(Objects.equals(arr[index],copy[index]));
#ENDIF
  });
}
#ENDDEF

  #MACRO GetRandom<boolean>()
  #MACRO GetRandom<byte>()
  #MACRO GetRandom<char>()
  #MACRO GetRandom<short>()
  #MACRO GetRandom<int>()
  #MACRO GetRandom<long>()
  #MACRO GetRandom<float>()
  #MACRO GetRandom<double>()
  /*//TODO uncomment when the eclipse module bug is fixed
  #MACRO GetRandom<String>()
  */
#MACRODEF GetRandom<ARRTYPE>()
private static ARRTYPE getRandARRTYPE(Random rand)
{
#IFSWITCH ARRTYPE==String
  return Long.toString(rand.nextLong());
#ELSEIFSWITCH ARRTYPE==boolean
  return rand.nextBoolean();
#ELSEIFSWITCH ARRTYPE==byte,char,short,int,long
  return (ARRTYPE)rand.nextLong();
#ELSEIFSWITCH ARRTYPE==float
  return rand.nextFloat();
#ELSEIFSWITCH ARRTYPE==double
  return rand.nextDouble();
#ELSE
ERROR unknown array type ARRTYPE
#ENDIF
}
#ENDDEF

  #MACRO ConvertMethods<boolean>()
  #MACRO ConvertMethods<byte>()
  #MACRO ConvertMethods<char>()
  #MACRO ConvertMethods<short>()
  #MACRO ConvertMethods<int>()
  #MACRO ConvertMethods<long>()
  #MACRO ConvertMethods<float>()
  #MACRO ConvertMethods<double>()
  /*//TODO uncomment when the eclipse module bug is fixed
  #MACRO ConvertMethods<String>()
  */
#MACRODEF ConvertMethods<ARRTYPE>()
private static ARRTYPE convertToARRTYPE(int val)
{
#IFSWITCH ARRTYPE==String
  return Integer.toString(val);
#ELSEIFSWITCH ARRTYPE==double,float,long,int,short,char,byte
  return (ARRTYPE)val;
#ELSE
  return val!=0;
#ENDIF
}
#ENDDEF



  #MACRO ArrayBuilders<boolean>()
  #MACRO ArrayBuilders<byte>()
  #MACRO ArrayBuilders<char>()
  #MACRO ArrayBuilders<short>()
  #MACRO ArrayBuilders<int>()
  #MACRO ArrayBuilders<long>()
  #MACRO ArrayBuilders<float>()
  #MACRO ArrayBuilders<double>()
  /*//TODO uncomment when the eclipse module bug is fixed
  #MACRO ArrayBuilders<String>()
  */
  
  #MACRO GetMaxReps<boolean>()
  #MACRO GetMaxReps<byte>()
  #MACRO GetMaxReps<char>()
  #MACRO GetMaxReps<short>()
  #MACRO GetMaxReps<int>()
  #MACRO GetMaxReps<long>()
  #MACRO GetMaxReps<float>()
  #MACRO GetMaxReps<double>()
  #MACRO GetMaxReps<String>()

#MACRODEF GetMaxReps<ARRTYPE>()
private static int getMaxRepsARRTYPE(int arrLength)
{
#IFSWITCH ARRTYPE==boolean
      return 1;
#ELSEIFSWITCH ARRTYPE==byte
      return 1;
#ELSEIFSWITCH ARRTYPE==char,short
      if(arrLength>3201)
      {
        return 1;
      }
      return 1000;
#ELSE
      return 1;
#ENDIF
}
#ENDDEF

#MACRODEF ArrayBuilders<ARRTYPE>()
private static enum ArrayBuilderARRTYPE
{
  RANDOM
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=getRandARRTYPE(rand);
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return getMaxRepsARRTYPE(arrLength);
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return 1;
    }
    int incrementM(int m)
    {
      return m+1;
    }
  },
  ASCENDING
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
#IFSWITCH ARRTYPE==boolean
      int pivotPoint=(arr.length/4)+rand.nextInt(arr.length/2);
      for(int i=0;i<pivotPoint;++i)
      {
        arr[i]=false;
      }
      for(int i=pivotPoint;i<arr.length;++i)
      {
        arr[i]=true;
      }
#ELSE
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=convertToARRTYPE(m+i);
      }
#ENDIF
    }
    int getNumRepetitions(int arrLength)
    {
#IFSWITCH ARRTYPE==boolean
      return getMaxRepsARRTYPE(arrLength);
#ELSE
      return 1;
#ENDIF
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
#IFSWITCH ARRTYPE==boolean
      return 1;
#ELSE
      return (2*arrLength)-1;
#ENDIF
    }
    int incrementM(int m)
    {
#IFSWITCH ARRTYPE==boolean
      return m+1;
#ELSE
      return m*2;
#ENDIF
    }
  },
  DESCENDING
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
#IFSWITCH ARRTYPE==boolean
      int pivotPoint=(arr.length/4)+rand.nextInt(arr.length/2);
      for(int i=0;i<pivotPoint;++i)
      {
        arr[i]=true;
      }
      for(int i=pivotPoint;i<arr.length;++i)
      {
        arr[i]=false;
      }
#ELSE
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=convertToARRTYPE(arr.length-m-i);
      }
#ENDIF
    }

    int getNumRepetitions(int arrLength)
    {
#IFSWITCH ARRTYPE==boolean
      return getMaxRepsARRTYPE(arrLength);
#ELSE
      return 1;
#ENDIF
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
#IFSWITCH ARRTYPE==boolean
      return 1;
#ELSE
      return (2*arrLength)-1;
#ENDIF
    }
    int incrementM(int m)
    {
#IFSWITCH ARRTYPE==boolean
      return m+1;
#ELSE
      return m*2;
#ENDIF
    }

  },
  ALL_EQUAL
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=convertToARRTYPE(m);
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 0;
    }
    int getMHi(int arrLength)
    {
#IFSWITCH ARRTYPE==boolean
      return 1;
#ELSE
      return 0;
#ENDIF
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
#IFNOTSWITCH ARRTYPE==boolean
 
  ,MERGE_ASCENDING
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int period=arr.length/m;
      int v=1;
      int i=0;
      for(int k=0;k<m;++k)
      {
        v=1;
        for(int p=0;p<period;++p)
        {
          arr[i++]=convertToARRTYPE(v++);
        }
      }
      for(int j=1;j<arr.length-1;j++)
      {
        arr[j]=convertToARRTYPE(v++);

      }
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 65;
    }
    int getMHi(int arrLength)
    {
      return 69;
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
  ,MERGE_DESCENDING
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int period=arr.length/m;
      int v=-1;
      int i=0;
      for(int k=0;k<m;++k)
      {
        v=-1;
        for(int p=0;p<period;++p)
        {
          arr[i++]=convertToARRTYPE(v--);
        }
      }
      for(int j=1;j<arr.length-1;j++)
      {
        arr[j]=convertToARRTYPE(v--);
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 65;
    }
    int getMHi(int arrLength)
    {
      return 69;
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
  ,SAW
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int incCount=1;
      int decCount=arr.length;
      int i=0;
      int period=m--;
      for(;;)
      {
        for(int k=1;k<=period;k++)
        {
          if(i>=arr.length)
          {
            return;
          }
          arr[i++]=convertToARRTYPE(incCount++);
        }
        period+=m;
        for(int k=1;k<=period;k++)
        {
          if(i>=arr.length)
          {
            return;
          }
          arr[i++]=convertToARRTYPE(decCount--);
        }
        period+=m;
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,SORTED_REPEATED
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int period=arr.length/m;
      int i=0;
      int k=0;
      for(;;)
      {
        for(int t=1;t<=period;++t)
        {
          if(i>=arr.length)
          {
            return;
          }
          arr[i++]=convertToARRTYPE(k);
        }
        if(i>=arr.length)
        {
          return;
        }
        ++k;
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return Math.min(arrLength,7);
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
  ,REPEATED
  {
    void build(ARRTYPE[] arr, int m, Random rand)
    {
      for(int i=0;i<arr.length;++i)
      {
        arr[i]=convertToARRTYPE(i%m);
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,DUPLICATED
  {
    void build(ARRTYPE[] arr, int m, Random rand)
    {
      for (int i = 0; i < arr.length; i++)
      {
        arr[i] = convertToARRTYPE(rand.nextInt(m));
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return getMaxRepsARRTYPE(arrLength);
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,SORTED_ORGAN_PIPES
  {
    void build(ARRTYPE[] arr,int m,Random rand)
    {
      int i=0;
      int k=m;
      for(;;)
      {
        for(int t=1;t<=m;++t)
        {
          if(i>=arr.length)
          {
            return;
          }
          arr[i++]=convertToARRTYPE(k);
        }
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return Math.min(arrLength,7);
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
  ,ORGAN_PIPES
  {
    void build(ARRTYPE[] arr, int m, Random rand)
    {
      int middle = arr.length / (m + 1);
      for (int i = 0; i < middle; i++) {
          arr[i] = convertToARRTYPE(i);
      }
      for (int i = middle; i < arr.length; i++) {
          arr[i] = convertToARRTYPE(arr.length - i - 1);
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,STAGGER
  {
    void build(ARRTYPE[] arr, int m, Random rand) {
      for (int i = 0; i < arr.length; i++) {
        arr[i] = convertToARRTYPE((i * m + i) % arr.length);
      }
      
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,PLATEAU
  {
    void build(ARRTYPE[] arr, int m, Random rand) {
      for (int i = 0; i < arr.length; i++) {
        arr[i] = convertToARRTYPE(Math.min(i, m));
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return 1;
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return (2*arrLength)-1;
    }
    int incrementM(int m)
    {
      return m*2;
    }
  }
  ,SHUFFLE
  {
    void build(ARRTYPE[] arr, int m, Random rand) {
      int x = 0, y = 0;
      for (int i = 0; i < arr.length; i++) {
        arr[i] = convertToARRTYPE(rand.nextBoolean() ? (x += 2) : (y += 2));
      }
    }
    int getNumRepetitions(int arrLength)
    {
      return getMaxRepsARRTYPE(arrLength);
    }
    int getMLo()
    {
      return 1;
    }
    int getMHi(int arrLength)
    {
      return 1;
    }
    int incrementM(int m)
    {
      return m+1;
    }
  }
#ENDIF
  ;

  abstract void build(ARRTYPE[] arr,int m,Random rand); 
  abstract int getNumRepetitions(int arrLength);
  abstract int getMLo();
  abstract int getMHi(int arrLength);
  abstract int incrementM(int m);
}

#ENDDEF

/*
  #MACRO BasicSortTest<boolean,sort>()
  #MACRO BasicSortTest<boolean,reverseSort>()
  
  #MACRO BasicSortTest<byte,sort>()
  #MACRO BasicSortTest<byte,reverseSort>()
  */
  
  #MACRO BasicSortTest<char,sort>()
  /*
  #MACRO BasicSortTest<char,reverseSort>()
  
  #MACRO BasicSortTest<short,sort>()
  #MACRO BasicSortTest<short,reverseSort>()
  
  #MACRO BasicSortTest<int,sort>()
  #MACRO BasicSortTest<int,reverseSort>()
  
  #MACRO BasicSortTest<long,sort>()
  #MACRO BasicSortTest<long,reverseSort>()

  #MACRO BasicSortTest<float,sort>()
  #MACRO BasicSortTest<float,reverseSort>()
  
  #MACRO BasicSortTest<double,sort>()
  #MACRO BasicSortTest<double,reverseSort>()
  */

#MACRODEF BasicSortTest<ARRTYPE,SORTTYPE>()
private static void testuncheckedSORTTYPEARRTYPEHelper(long randSeed,int arrLength) throws InterruptedException
{
  Random rand=new Random(randSeed);
  ARRTYPE[] golden=new ARRTYPE[arrLength];
  ARRTYPE[] test=new ARRTYPE[arrLength];
  for(ArrayBuilderARRTYPE builder:ArrayBuilderARRTYPE.values())
  {
    
    for(int m=builder.getMLo(),mHi=builder.getMHi(arrLength);m<=mHi;m=builder.incrementM(m))
    {
      System.out.println("sortType = SORTTYPE; arrType = ARRTYPE; randSeed= "+randSeed+"; length= "+arrLength+"; builder type "+builder.name()+"; m = "+m);
    
      for(int i=0,numReps=builder.getNumRepetitions(arrLength);i<numReps;++i)
      {
        builder.build(golden,m,rand);
        ArrCopy.uncheckedCopy(golden,0,test,0,arrLength);
        isSortedSORTTYPE(test,golden);
      }
    }
  }
}
@Test
public void testuncheckedSORTTYPEARRTYPE() throws InterruptedException
{
#IFSWITCH ARRTYPE==boolean,byte
  testuncheckedSORTTYPEARRTYPEHelper(0,30);
  #IFSWITCH ARRTYPE==byte
  testuncheckedSORTTYPEARRTYPEHelper(0,31);
  #ENDIF
#ELSE
  for(int i=0;i<lengths.length;++i)
  {
    int arrLength=lengths[i];
    for(int j=0;j<randSeeds.length;++j)
    {
      long randSeed=randSeeds[j];
      testuncheckedSORTTYPEARRTYPEHelper(randSeed,arrLength);
    }
  }
#ENDIF
}
#ENDDEF


}









