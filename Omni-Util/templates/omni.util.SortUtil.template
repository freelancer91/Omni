#TYPEDEF OfGeneric
package omni.util;

import java.util.Comparator;
import java.util.function.IntBinaryOperator;
import omni.function.BooleanComparator;
import omni.function.ByteComparator;
import omni.function.CharComparator;
import omni.function.ShortComparator;
import omni.function.LongComparator;
import omni.function.FloatComparator;
import omni.function.DoubleComparator;

public final class SortUtil
{
  private SortUtil()
  {
    super();
    //private constructor
  }

  #MACRO noncomparatorSortMethod<sort,boolean,BooleanComparator,boolean,Boolean,NULL>( )
  #MACRO noncomparatorSortMethod<reverseSort,boolean,BooleanComparator,boolean,Boolean,NULL>( )
  public static void uncheckedcomparatorSort(boolean[] arr,int begin,int end,BooleanComparator sorter)
  {
    final boolean firstVal;
    int i;
    if((firstVal=arr[begin])==arr[i=begin+1])
    {
      do
      {
        if(i==end)
        {
          return;
        }
      }
      while(arr[++i]==firstVal);
    }
    switch(Integer.signum(sorter.compare(firstVal,!firstVal)))
    {
    case -1:
      for(;i!=end;--end)
      {
        if(arr[end]==firstVal)
        {
          uncheckedSortHelper(arr,i,end,firstVal);
          return;
        }
      }
    case 0:
      return;
    default:
      int firstValCounter=1;
      while(i!=end)
      {
        if(arr[++i]^firstVal)
        {
          ++firstValCounter;
        }
      }
      final boolean lastVal;
      for(arr[begin]=(lastVal=!firstVal);--firstValCounter!=0;arr[++begin]=lastVal){}
      do
      {
        arr[++begin]=firstVal;
      }
      while(begin!=end);
    }
  }  
  private static void uncheckedSortHelper(boolean[] arr,int begin,int end,boolean firstVal)
  {
    assert arr!=null;
    assert begin>=0;
    assert end<arr.length;
    assert begin<end;
    assert firstVal!=arr[begin];
    assert firstVal==arr[end];
    int endValCounter=1;
    for(int curr=begin+1;curr!=end;++curr)
    {
      if(arr[curr]^firstVal)
      {
        ++endValCounter;
      }
    }
    for(final var endVal=!firstVal;;--end)
    {
      arr[end]=endVal;
      if(--endValCounter==0)
      {
        do
        {
          arr[--end]=firstVal;
        }
        while(end!=begin);
        return;
      }
    }
  }
  
  #MACRO noncomparatorSortMethod<sort,byte,ByteComparator,byte,Byte,NULL>( )
  #MACRO CountingSort<sort,byte>(Byte)
  #MACRO InsertSort<sort,byte,byte>()
  
  #MACRO noncomparatorSortMethod<reverseSort,byte,ByteComparator,byte,Byte,NULL>( )
  #MACRO CountingSort<reverseSort,byte>(Byte)
  #MACRO InsertSort<reverseSort,byte,byte>()
   
  #MACRO noncomparatorSortMethod<sort,char,CharComparator,char,Character,NULL>( )
  #MACRO CountingSort<sort,char>(Character)
  #MACRO DoSort<sort,char,char>(Char)
  #MACRO MergeMethod<sort,char,char>()
  #MACRO InsertSort<sort,char,char>()
  #MACRO SentinelInsertSort<sort,char,char>()
  #MACRO QuickSort<sort,char,char,true>()
  #MACRO QuickSort<sort,char,char,false>()
  #MACRO QuickSortSinglePivot<sort,char,char,true>()
  #MACRO QuickSortSinglePivot<sort,char,char,false>()
  #MACRO QuickSortDualPivot<sort,char,char,true>()
  #MACRO QuickSortDualPivot<sort,char,char,false>()

  #MACRO noncomparatorSortMethod<reverseSort,char,CharComparator,char,Character,NULL>( )
  #MACRO CountingSort<reverseSort,char>(Character)
  #MACRO DoSort<reverseSort,char,char>(Char)
  #MACRO MergeMethod<reverseSort,char,char>()
  #MACRO InsertSort<reverseSort,char,char>()
  #MACRO SentinelInsertSort<reverseSort,char,char>()
  #MACRO QuickSort<reverseSort,char,char,true>()
  #MACRO QuickSort<reverseSort,char,char,false>()
  #MACRO QuickSortSinglePivot<reverseSort,char,char,true>()
  #MACRO QuickSortSinglePivot<reverseSort,char,char,false>()
  #MACRO QuickSortDualPivot<reverseSort,char,char,true>()
  #MACRO QuickSortDualPivot<reverseSort,char,char,false>()
  
  #MACRO noncomparatorSortMethod<sort,short,ShortComparator,short,Short,NULL>( )
  #MACRO CountingSort<sort,short>(Short)
  #MACRO DoSort<sort,short,short>(Short)
  #MACRO MergeMethod<sort,short,short>()
  #MACRO InsertSort<sort,short,short>()
  #MACRO SentinelInsertSort<sort,short,short>()
  #MACRO QuickSort<sort,short,short,true>()
  #MACRO QuickSort<sort,short,short,false>()
  #MACRO QuickSortSinglePivot<sort,short,short,true>()
  #MACRO QuickSortSinglePivot<sort,short,short,false>()
  #MACRO QuickSortDualPivot<sort,short,short,true>()
  #MACRO QuickSortDualPivot<sort,short,short,false>()
 
  #MACRO noncomparatorSortMethod<reverseSort,short,ShortComparator,short,Short,NULL>( )
  #MACRO CountingSort<reverseSort,short>(Short)
  #MACRO DoSort<reverseSort,short,short>(Short)
  #MACRO MergeMethod<reverseSort,short,short>()
  #MACRO InsertSort<reverseSort,short,short>()
  #MACRO SentinelInsertSort<reverseSort,short,short>()
  #MACRO QuickSort<reverseSort,short,short,true>()
  #MACRO QuickSort<reverseSort,short,short,false>()
  #MACRO QuickSortSinglePivot<reverseSort,short,short,true>()
  #MACRO QuickSortSinglePivot<reverseSort,short,short,false>()
  #MACRO QuickSortDualPivot<reverseSort,short,short,true>()
  #MACRO QuickSortDualPivot<reverseSort,short,short,false>()
  
  #MACRO DoSort<sort,int,int>(Int)
  #MACRO MergeMethod<sort,int,int>()
  #MACRO InsertSort<sort,int,int>()
  #MACRO SentinelInsertSort<sort,int,int>()
  #MACRO QuickSort<sort,int,int,true>()
  #MACRO QuickSort<sort,int,int,false>()
  #MACRO QuickSortSinglePivot<sort,int,int,true>()
  #MACRO QuickSortSinglePivot<sort,int,int,false>()
  #MACRO QuickSortDualPivot<sort,int,int,true>()
  #MACRO QuickSortDualPivot<sort,int,int,false>()

  #MACRO DoSort<reverseSort,int,int>(Int)
  #MACRO MergeMethod<reverseSort,int,int>()
  #MACRO InsertSort<reverseSort,int,int>()
  #MACRO SentinelInsertSort<reverseSort,int,int>()
  #MACRO QuickSort<reverseSort,int,int,true>()
  #MACRO QuickSort<reverseSort,int,int,false>()
  #MACRO QuickSortSinglePivot<reverseSort,int,int,true>()
  #MACRO QuickSortSinglePivot<reverseSort,int,int,false>()
  #MACRO QuickSortDualPivot<reverseSort,int,int,true>()
  #MACRO QuickSortDualPivot<reverseSort,int,int,false>()
  
  #MACRO DoSort<sort,long,long>(Long)
  #MACRO MergeMethod<sort,long,long>()
  #MACRO InsertSort<sort,long,long>()
  #MACRO SentinelInsertSort<sort,long,long>()
  #MACRO QuickSort<sort,long,long,true>()
  #MACRO QuickSort<sort,long,long,false>()
  #MACRO QuickSortSinglePivot<sort,long,long,true>()
  #MACRO QuickSortSinglePivot<sort,long,long,false>()
  #MACRO QuickSortDualPivot<sort,long,long,true>()
  #MACRO QuickSortDualPivot<sort,long,long,false>()

  #MACRO DoSort<reverseSort,long,long>(Long)
  #MACRO MergeMethod<reverseSort,long,long>()
  #MACRO InsertSort<reverseSort,long,long>()
  #MACRO SentinelInsertSort<reverseSort,long,long>()
  #MACRO QuickSort<reverseSort,long,long,true>()
  #MACRO QuickSort<reverseSort,long,long,false>()
  #MACRO QuickSortSinglePivot<reverseSort,long,long,true>()
  #MACRO QuickSortSinglePivot<reverseSort,long,long,false>()
  #MACRO QuickSortDualPivot<reverseSort,long,long,true>()
  #MACRO QuickSortDualPivot<reverseSort,long,long,false>()
  
  #MACRO noncomparatorSortMethod<sort,float,FloatComparator,float,Float,Float.floatToRawIntBits>( )
  #MACRO DoSort<sort,float,float>(Float)
  #MACRO MoveZeros<sort,float>(Float.floatToRawIntBits)
  #MACRO MergeMethod<sort,float,float>()
  #MACRO InsertSort<sort,float,float>()
  #MACRO SentinelInsertSort<sort,float,float>()
  #MACRO QuickSort<sort,float,float,true>()
  #MACRO QuickSort<sort,float,float,false>()
  #MACRO QuickSortSinglePivot<sort,float,float,true>()
  #MACRO QuickSortSinglePivot<sort,float,float,false>()
  #MACRO QuickSortDualPivot<sort,float,float,true>()
  #MACRO QuickSortDualPivot<sort,float,float,false>()
  
  #MACRO noncomparatorSortMethod<reverseSort,float,FloatComparator,float,Float,Float.floatToRawIntBits>( )
  #MACRO DoSort<reverseSort,float,float>(Float)
  #MACRO MoveZeros<reverseSort,float>(Float.floatToRawIntBits)
  #MACRO MergeMethod<reverseSort,float,float>()
  #MACRO InsertSort<reverseSort,float,float>()
  #MACRO SentinelInsertSort<reverseSort,float,float>()
  #MACRO QuickSort<reverseSort,float,float,true>()
  #MACRO QuickSort<reverseSort,float,float,false>()
  #MACRO QuickSortSinglePivot<reverseSort,float,float,true>()
  #MACRO QuickSortSinglePivot<reverseSort,float,float,false>()
  #MACRO QuickSortDualPivot<reverseSort,float,float,true>()
  #MACRO QuickSortDualPivot<reverseSort,float,float,false>()
  
  #MACRO noncomparatorSortMethod<sort,double,DoubleComparator,double,Double,Double.doubleToRawLongBits>( )
  #MACRO DoSort<sort,double,double>(Double)
  #MACRO MoveZeros<sort,double>(Double.doubleToRawLongBits)
  #MACRO MergeMethod<sort,double,double>()
  #MACRO InsertSort<sort,double,double>()
  #MACRO SentinelInsertSort<sort,double,double>()
  #MACRO QuickSort<sort,double,double,true>()
  #MACRO QuickSort<sort,double,double,false>()
  #MACRO QuickSortSinglePivot<sort,double,double,true>()
  #MACRO QuickSortSinglePivot<sort,double,double,false>()
  #MACRO QuickSortDualPivot<sort,double,double,true>()
  #MACRO QuickSortDualPivot<sort,double,double,false>()
  
  #MACRO noncomparatorSortMethod<reverseSort,double,DoubleComparator,double,Double,Double.doubleToRawLongBits>( )
  #MACRO DoSort<reverseSort,double,double>(Double)
  #MACRO MoveZeros<reverseSort,double>(Double.doubleToRawLongBits)
  #MACRO MergeMethod<reverseSort,double,double>()
  #MACRO InsertSort<reverseSort,double,double>()
  #MACRO SentinelInsertSort<reverseSort,double,double>()
  #MACRO QuickSort<reverseSort,double,double,true>()
  #MACRO QuickSort<reverseSort,double,double,false>()
  #MACRO QuickSortSinglePivot<reverseSort,double,double,true>()
  #MACRO QuickSortSinglePivot<reverseSort,double,double,false>()
  #MACRO QuickSortDualPivot<reverseSort,double,double,true>()
  #MACRO QuickSortDualPivot<reverseSort,double,double,false>()
  
  #MACRO TimSort<comparatorSort,byte,ByteComparator,byte>( ,Byte)
  #MACRO TimSort<comparatorSort,char,CharComparator,char>( ,Char)
  #MACRO TimSort<comparatorSort,short,ShortComparator,short>( ,Short)
  #MACRO TimSort<comparatorSort,int,IntBinaryOperator,int>( ,Int)
  #MACRO TimSort<comparatorSort,long,LongComparator,long>( ,Long)
  #MACRO TimSort<comparatorSort,float,FloatComparator,float>( ,Float)
  #MACRO TimSort<comparatorSort,double,DoubleComparator,double>( ,Double)
  #MACRO TimSort<comparatorSort,Object,Comparator<? super E>,E>(<E>,Ref)
  #MACRO TimSort<sort,Object,NULL,Comparable<E>>(<E>,Ref)
  #MACRO TimSort<reverseSort,Object,NULL,Comparable<E>>(<E>,Ref)
  
  private static abstract class AbstractTimSort
  {
    private transient int stackSize;
    private transient final int runLenAndBase[];
    AbstractTimSort(int nRemaining)
    {
      this.runLenAndBase=new int[nRemaining<120?10:nRemaining<1542?20:nRemaining<119151?48:98];
    }
    private static int minRunLength(int n)
    {
      assert n >= 0;
      int r = 0;      // Becomes 1 if any 1 bits are shifted off
      while (n >= 32)
      {
        r |= (n & 1);
        n >>= 1;
      }
      return n + r;
     }
    abstract int mergeAt(int n,int stackSize,int[] runLenAndBase);
    private void mergeCollapse(int runBase,int runLength)
    {
      int stackSize;
      int[] runLenAndBase;
      (runLenAndBase=this.runLenAndBase)[stackSize=this.stackSize]=runLength;
      runLenAndBase[++stackSize]=runBase;
      ++stackSize;
      int n;
      gotoReturn:
      do
      {
        gotoMergeAt:
        for(;;)
        {
          switch((n=stackSize-4)>>1)
          {
            default:
              if(runLenAndBase[n-4]<=runLenAndBase[n]+runLenAndBase[n-2])
              {
                break;
              }
            case 1:
              if(runLenAndBase[n-2]<=runLenAndBase[n]+runLenAndBase[n+2])
              {
                break;
              }
            case 0:
              if(runLenAndBase[n]<=runLenAndBase[n+2])
              {
                break gotoMergeAt;
              }
            case -1:
             break gotoReturn;
          }
          if(runLenAndBase[n-2]<runLenAndBase[n+2])
          {
            n-=2;
          }
          break gotoMergeAt;
        }
        //gotoMergeAt goes here
      }
      while((stackSize=mergeAt(n,stackSize,runLenAndBase))>2);
      //gotoReturn goes here
      this.stackSize=stackSize;
    }
    private void mergeForceCollapse()
    {
      int stackSize;
      if((stackSize=this.stackSize)>2)
      {
        final var runLenAndBase=this.runLenAndBase;
        int n;
        do
        {
          if((n=stackSize-4)>0&&runLenAndBase[n-2]<runLenAndBase[n+2])
          {
            n-=2;
          }
        }
        while((stackSize=mergeAt(n,stackSize,runLenAndBase))>2);
      }
      //no need to set the stack size field since we are done
    }
  }
  private static abstract class AbstractObjectTimSort<E> extends AbstractTimSort
  {
    transient final Object[] arr;
    transient Object[] tmp;
    transient int tmpLength;
    transient int tmpOffset;
    transient int minGallop;
    AbstractObjectTimSort(Object[] arr,int nRemaining)
    {
      super(nRemaining);
      this.arr=arr;
      this.tmpLength=nRemaining=nRemaining<512?nRemaining>>>1:256;
      this.tmp=new Object[nRemaining];
      this.minGallop=7;
    }
    #MACRO EnsureCapacity(Object)
  }
}

#MACRODEF noncomparatorSortMethod<METHODNAME,ARRTYPE,COMPARATORTYPE,EXPOSEDTYPE,BOXEDTYPE,CONVERTTOBITS>(TYPEPARAMETER)
#IFNOTSWITCH ARRTYPE==long,int
public static TYPEPARAMETER void uncheckedMETHODNAME(ARRTYPE[] arr,int begin,int end)
{
  assert arr!=null;
  assert begin>=0;
  assert end<arr.length;
  assert begin<end;
#IFSWITCH ARRTYPE==boolean
  #IFSWITCH METHODNAME==sort
  while(!arr[begin])
  #ELSE
  while(arr[begin])
  #ENDIF
  {
    if(++begin==end)
    {
      //already sorted
      return;
    }
  }
  do
  {
  #IFSWITCH METHODNAME==sort
    if(!arr[end])
  #ELSE
    if(arr[end])
  #ENDIF
    {
      uncheckedSortHelper(arr,begin,end,
  #IFSWITCH METHODNAME==sort
      false
  #ELSE
      true
  #ENDIF
      );
      return;
    }
  }
  while(--end!=begin);
  //already sorted
#ELSEIFSWITCH ARRTYPE==byte
  if(end-begin<30)
  {
    insertMETHODNAME(arr,begin,end);
  }
  else
  {
    countingMETHODNAME(arr,begin,end);
  }
#ELSEIFSWITCH ARRTYPE==char,short
  if(end-begin>3200)
  {
    countingMETHODNAME(arr,begin,end);
  }
  else
  {
    doMETHODNAME(arr,begin,end);
  }
#ELSEIFSWITCH ARRTYPE==double,float
  #IFSWITCH METHODNAME==sort
  #MACRO MoveNaN(begin,end,>=,--)
  #ELSE
  #MACRO MoveNaN(end,begin,<=,++) 
  #ENDIF
  doMETHODNAME(arr,begin,end);
  moveZerosMETHODNAME(arr,begin,end);
#ELSE
ERROR Unknown array type ARRTYPE
#ENDIF
}
#ENDIF
#ENDDEF

#MACRODEF TimSort<METHODNAME,ARRTYPE,COMPARATORTYPE,EXPOSEDTYPE>(TYPEPARAMETER,CLASSPREFIX)
public static class METHODNAMEARRTYPETimSortTYPEPARAMETER
#IFSWITCH ARRTYPE==Object
  extends  AbstractARRTYPETimSortTYPEPARAMETER
{
  #IFSWITCH METHODNAME==comparatorSort
  private final COMPARATORTYPE sorter;
  private METHODNAMEARRTYPETimSort(ARRTYPE[] arr,int nRemaining,COMPARATORTYPE sorter)
  {
    super(arr,nRemaining);
    this.sorter=sorter;
  }
  #ELSE
  private METHODNAMEARRTYPETimSort(ARRTYPE[] arr,int nRemaining)
  {
    super(arr,nRemaining);
  }
  #ENDIF
#ELSE
  extends AbstractTimSort
{
  private transient final COMPARATORTYPE sorter;
  private transient final ARRTYPE[] arr;
  private transient ARRTYPE[] tmp;
  private transient int tmpOffset;
  private transient int tmpLength;
  private transient int minGallop;
  private METHODNAMEARRTYPETimSort(ARRTYPE[] arr,int nRemaining,COMPARATORTYPE sorter)
  {
    super(nRemaining);
    this.sorter=sorter;
    this.arr=arr;
    this.tmpLength=nRemaining=nRemaining<512?nRemaining>>>1:256;
    this.tmp=new ARRTYPE[nRemaining];
    this.minGallop=7;
  }
  #MACRO EnsureCapacity(ARRTYPE)
#ENDIF
  public static TYPEPARAMETER void uncheckedsort(ARRTYPE[] arr,int begin,int end
#IFSWITCH METHODNAME==comparatorSort
    ,COMPARATORTYPE sorter
#ENDIF
  )
  {
    int nRemaining;
    if((nRemaining=end-begin)<32)
    {
       binarySort(arr,begin,end,begin+countRunAndMakeAscending(arr,begin,end
#IFSWITCH METHODNAME==comparatorSort
       ,sorter),sorter);
#ELSE  
       ));
#ENDIF
       return;
    }
    final AbstractTimSort ts=new METHODNAMEARRTYPETimSortTYPEPARAMETER(arr,nRemaining
#IFSWITCH METHODNAME==comparatorSort
      ,sorter
#ENDIF
    );
    int minRun=AbstractTimSort.minRunLength(nRemaining);
    int runLen;
    do
    {
      if((runLen=countRunAndMakeAscending(arr,begin,end
#IFSWITCH METHODNAME==comparatorSort
      ,sorter
#ENDIF
      ))<minRun)
      {
        int force;

        binarySort(arr,begin,begin+(force=nRemaining<=minRun?nRemaining:minRun),begin+runLen
#IFSWITCH METHODNAME==comparatorSort
        ,sorter
#ENDIF
        );
        runLen=force;
      }
      ts.mergeCollapse(begin,runLen);
      begin+=runLen;
    }
    while((nRemaining-=runLen)!=0);
    assert begin==end;
    ts.mergeForceCollapse(); 
  }
  #MACRO SuppressUnchecked()
  @Override
  int mergeAt(int n,int stackSize,int[] runLenAndBase)
  {
    assert stackSize>=4;
    assert n>=0;
    assert n==stackSize-4 || n==stackSize-6;
    assert runLenAndBase[n]>0;
    assert runLenAndBase[n+2]>0;
    assert runLenAndBase[n]+runLenAndBase[n+1]==runLenAndBase[n+3];
    int len1,base1,len2,base2;
    runLenAndBase[n]=(len1=runLenAndBase[n])+(len2=runLenAndBase[n+2]);
    if(n==stackSize-6)
    {
      runLenAndBase[n+3]=runLenAndBase[n+5];
      runLenAndBase[n+2]=runLenAndBase[n+4];
    }
    ARRTYPE[] arr;
    int k;
    base1=(base1=runLenAndBase[n+1])+(k=gallopRight((EXPOSEDTYPE)(arr=this.arr)[base2=runLenAndBase[n+3]],arr,base1,len1,0
#IFSWITCH METHODNAME==comparatorSort
      ,sorter
#ENDIF
    ));
    assert k>=0;
    if((len1-=k)!=0)
    {
      if((len2=gallopLeft((EXPOSEDTYPE)arr[base1+len1-1],arr,base2,len2,len2-1
#IFSWITCH METHODNAME==comparatorSort
        ,sorter
#ENDIF
      ))!=0)
      {
        assert len2>0;
        if(len1<=len2)
        {
          mergeLo(arr,base1,len1,base2,len2);
        }
        else
        {
          mergeHi(arr,base1,len1,base2,len2);
        }
      }
    }
    return stackSize-2;
  }
  #MACRO Merge<Lo,arr,tmp,++,1,2>()
  #MACRO Merge<Hi,tmp,arr,--,2,1>()
  #MACRO Gallop<Left,Right>(TYPEPARAMETER,GreaterThan,hint+1,len-hint,LessThanOrEqual,-,+,GreaterThan)
  #MACRO Gallop<Right,Left>(TYPEPARAMETER,LessThan,len-hint,hint+1,GreaterThanOrEqual,+,-,GreaterThanOrEqual)
  #MACRO SuppressUnchecked()
  private static TYPEPARAMETER void binarySort(ARRTYPE[] arr,int lo,int hi,int start
#IFSWITCH METHODNAME==comparatorSort
    ,COMPARATORTYPE sorter
#ENDIF
  )
  {
    assert lo<=start;
    assert start<=hi;
    //TODO streamline
    if(start==lo)
    {
      ++start;
    }
    for(;start<hi;++start)
    {
      final EXPOSEDTYPE pivot=(EXPOSEDTYPE)arr[start];
      assert lo<=start;
      int left,right;
      if((left=lo)<(right=start))
      {
        do
        {
          int mid;
          #MACRO IfClause(LessThan,pivot,arr[mid=(left+right)>>>1])
          {
            right=mid;
          }
          else
          {
            left=mid+1;
          }
        }
        while(left<right);
      }
      assert left==right;
      ArrCopy.uncheckedCopy(arr,left,arr,left+1,start-left);
      arr[left]=pivot;
    }
  }
  #MACRO SuppressUnchecked()
  private static TYPEPARAMETER int countRunAndMakeAscending(ARRTYPE[] arr,int lo,int hi
#IFSWITCH METHODNAME==comparatorSort
    ,COMPARATORTYPE sorter
#ENDIF
  )
  {
    //TODO streamline
    assert lo<hi;
    int runHi;
    if((runHi=lo+1)==hi)
    {
      return 1;
    }
    #MACRO IfClause(LessThan,arr[runHi++],arr[lo])
    {
      if(runHi<hi)
      {
        #MACRO WhileClause(LessThan,arr[runHi],arr[runHi-1])
        {
          if(++runHi==hi)
          {
            break;
          }
        }
      }
      OmniArray.OfCLASSPREFIX.reverseRange(arr,lo,runHi-1);
    }
    else
    {
      if(runHi<hi)
      {
        #MACRO WhileClause(GreaterThanOrEqual,arr[runHi],arr[runHi-1])
        {
          if(++runHi==hi)
          {
            break;
          }
        }
        
      }
    }
    return runHi-lo;
  }
}
#ENDDEF

#MACRODEF GallopHelper<HELPERDIRECTION>(MAXOFS,COMPARISON,PLUS)
int maxOfs;
if(ofs<(maxOfs=MAXOFS))
{
  #MACRO WhileClause(COMPARISON,key,arr[base+hintPLUSofs])
  {
    lastOfs=ofs;
    if((ofs=(ofs<<1)+1)<=0 || ofs>=maxOfs)
    {
      ofs=maxOfs;
      break;
    }
  }
}
else
{
  ofs=maxOfs;
}
#IFSWITCH HELPERDIRECTION==Left
int tmp=lastOfs;
lastOfs=hint-ofs;
ofs=hint-tmp;
#ELSE
lastOfs+=hint;
ofs+=hint;
#ENDIF
#ENDDEF

#MACRODEF Gallop<LEFT,RIGHT>(TYPEPARAMETER,GREATERTHAN,LMAXOFS,RMAXOFS,LCOMPARISON,LPLUS,RPLUS,BINARYSEARCHCOMPARISON)
#MACRO SuppressUnchecked()
private static TYPEPARAMETER int gallopLEFT(EXPOSEDTYPE key,ARRTYPE[] arr,int base,int len,int hint
#IFSWITCH METHODNAME==comparatorSort
  ,COMPARATORTYPE sorter
#ENDIF
)
{
  assert len>0;
  assert hint>=0;
  assert hint<len;
  int ofs=1;
  int lastOfs=0;
  #MACRO IfClause(GREATERTHAN,key,arr[base+hint])
  {
    #MACRO GallopHelper<RIGHT>(RMAXOFS,GREATERTHAN,RPLUS)
  }
  else
  {
    #MACRO GallopHelper<LEFT>(LMAXOFS,LCOMPARISON,LPLUS)
  }
  assert -1<=lastOfs;
  assert lastOfs<ofs;
  assert ofs<=len;
  if(++lastOfs<ofs)
  {
    do
    {
      int m;
      #MACRO IfClause(BINARYSEARCHCOMPARISON,key,arr[base+(m=lastOfs+((ofs-lastOfs)>>>1))])
      {
        lastOfs=m+1;
      }
      else
      {
        ofs=m;
      }
    }
    while(lastOfs<ofs);
  }
  assert lastOfs==ofs;
  return ofs;
}
#ENDDEF

#MACRODEF Merge<HILO,LEFTARR,RIGHTARR,INCREMENT,ONE,TWO>()
#MACRO SuppressUnchecked()
private void mergeHILO(ARRTYPE[] arr,int base1,int len1,int base2,int len2)
{
  assert len1>0;
  assert len2>0;
  assert base1+len1==base2;
  ARRTYPE[] tmp;
#IFSWITCH HILO==Lo
  int cursor1;
  int dest;
  ArrCopy.uncheckedCopy(arr,dest=base1,tmp=
  #IFSWITCH ARRTYPE==Object
  super.
  #ENDIF
  ensureCapacity(len1),cursor1=this.tmpOffset,len1);
  int cursor2=base2;
  arr[dest++]=arr[cursor2++];
  //TODO make these pre-decrement for performance
  if(--len2==0)
  {
    ArrCopy.uncheckedCopy(tmp,cursor1,arr,dest,len1);
    return;
  }
  if(len1==1)
  {
    ArrCopy.uncheckedCopy(arr,cursor2,arr,dest,len2);
    arr[dest+len2]=tmp[cursor1];
    return;
  }
#ELSE
  int tmpOffset;
  ArrCopy.uncheckedCopy(arr,base2,tmp=
  #IFSWITCH ARRTYPE==Object
  super.
  #ENDIF
  ensureCapacity(len2),tmpOffset=this.tmpOffset,len2);
  int cursor1=base1+len1-1;
  int cursor2=tmpOffset+len2-1;
  int dest=base2+len2-1;
  arr[dest--]=arr[cursor1--];
  //TODO make these pre-decrement for performance
  if(--len1==0)
  {
    ArrCopy.uncheckedCopy(tmp,tmpOffset,arr,dest-(len2-1),len2);
    return;
  }
  if(len2==1)
  {
    ArrCopy.uncheckedCopy(arr,cursor1-len1+1,arr,(dest-=len1)+1,len1);
    arr[dest]=tmp[cursor2];
    return;
  }
#ENDIF
  int minGallop=this.minGallop;
#IFSWITCH METHODNAME==comparatorSort
  final var sorter=this.sorter;
#ENDIF
  outer:
  for(;;)
  {
    int count1=0;
    int count2=0;
    do
    {
      assert lenONE>1;
      assert lenTWO>0;
      #MACRO IfClause(LessThan,LEFTARR[cursor2],RIGHTARR[cursor1])
      {
        arr[destINCREMENT]=arr[cursorTWOINCREMENT];
        ++countTWO;
        countONE=0;
        if(--lenTWO==0)
        {
          break outer;
        }
      }
      else
      {
        arr[destINCREMENT]=tmp[cursorONEINCREMENT];
        ++countONE;
        countTWO=0;
        if(--lenONE==1)
        {
          break outer;
        }
      }
    }
    while((count1|count2)<minGallop);
    do
    {
      assert lenONE>1;
      assert lenTWO>0;
      if((
#IFSWITCH HILO==Lo
      count1=gallopRight((EXPOSEDTYPE)arr[cursor2],tmp,cursor1,len1,0
#ELSE
      count1=len1-gallopRight((EXPOSEDTYPE)tmp[cursor2],arr,base1,len1,len1-1
#ENDIF
#IFSWITCH METHODNAME==comparatorSort
        ,sorter
#ENDIF
        ))!=0)
      {
#IFSWITCH HILO==Lo
        ArrCopy.uncheckedCopy(tmp,cursor1,arr,dest,count1);
        dest+=count1;
        cursor1+=count1;
        if((len1-=count1)<2)
        {
          break outer;
        }
#ELSE
        ArrCopy.uncheckedCopy(arr,(cursor1-=count1)+1,arr,(dest-=count1)+1,count1);
        if((len1-=count1)==0)
        {
          break outer;
        }
#ENDIF
      }
      arr[destINCREMENT]=LEFTARR[cursor2INCREMENT];
#IFSWITCH HILO==Lo
      if(--len2==0)
      {
        break outer;
      }
      if((count2=gallopLeft((EXPOSEDTYPE)tmp[cursor1],arr,cursor2,len2,0
#ELSE
      if(--len2==1)
      {
        break outer;
      }
      if((count2=len2-gallopLeft((EXPOSEDTYPE)arr[cursor1],tmp,tmpOffset,len2,len2-1
#ENDIF
#IFSWITCH METHODNAME==comparatorSort
        ,sorter
#ENDIF
      ))!=0)
      {
#IFSWITCH HILO==Lo
        ArrCopy.uncheckedCopy(arr,cursor2,arr,dest,count2);
        dest+=count2;
        cursor2+=count2;
        if((len2-=count2)==0)
        {
          break outer;
        }
#ELSE
        ArrCopy.uncheckedCopy(tmp,(cursor2-=count2)+1,arr,(dest-=count2)+1,count2);
        if((len2-=count2)<2)
        {
          break outer;
        }
#ENDIF
      }
      arr[destINCREMENT]=RIGHTARR[cursor1INCREMENT];
#IFSWITCH HILO==Lo
      if(--len1==1)
#ELSE
      if(--len1==0)
#ENDIF
      {
        break outer;
      }
      --minGallop;
    }
    while(count1>=7 || count2>=7);
    if(minGallop<0)
    {
      minGallop=2;
    }
    else
    {
      minGallop+=2;
    }
  }
  this.minGallop = minGallop < 1 ? 1 : minGallop;
  if(lenONE==1)
  {
    assert lenTWO>0;
#IFSWITCH HILO==Lo
    ArrCopy.uncheckedSelfCopy(arr,cursor2,dest,len2);
    arr[dest+len2]=tmp[cursor1];
#ELSE
    ArrCopy.uncheckedCopy(arr,(cursor1-=len1)+1,arr,(dest-=len1)+1,len1);
    arr[dest]=tmp[cursor2];
#ENDIF
  }
  else
  {
#IFSWITCH HILO==Lo
    assert len2==0;
    assert len1>1;
    ArrCopy.uncheckedCopy(tmp,cursor1,arr,dest,len1);
#ELSE
    assert len1==0;
    assert len2>0;
    ArrCopy.uncheckedCopy(tmp,tmpOffset,arr,dest+(len2-1),len2);
#ENDIF
  }
}
#ENDDEF

#MACRODEF EnsureCapacity(THETYPE)
private THETYPE[] ensureCapacity(int minCapacity)
{
  THETYPE[] tmp;
  if(tmpLength<minCapacity)
  {
    int newSize;
    if((newSize=(-1>>>Integer.numberOfLeadingZeros(minCapacity))+1)<0 || newSize>(minCapacity=arr.length>>>1))
    {
      newSize=minCapacity;
    }
    this.tmp=tmp=new THETYPE[newSize];
    this.tmpLength=newSize;
    tmpOffset=0;
  }
  else
  {
    tmp=this.tmp;
  }
  return tmp;
}
#ENDDEF

#MACRODEF MoveNaN(BEGIN,END,GREATERTHANOREQUAL,DECREMENT)
for(;;)
{
  if(!BOXEDTYPE.isNaN(arr[END]))
  {
    break;
  }
  if(DECREMENTEND==BEGIN)
  {
    //already sorted
    return;
  }
}
for(int k=END;DECREMENTkGREATERTHANOREQUALBEGIN;)
{
  ARRTYPE ak;
  if(BOXEDTYPE.isNaN(ak=arr[k]))
  {
    arr[k]=arr[END];
    arr[END]=ak;
    DECREMENTEND;
  }
}
#ENDDEF

#MACRODEF MoveZeros<METHODNAME,ARRTYPE>(CONVERTTOBITS)
private static void moveZerosMETHODNAME(ARRTYPE[] arr,int begin,int end)
{
#IFSWITCH METHODNAME==sort
  int hi;
  switch(Integer.signum(begin-(hi=end)))
  {
    case -1:
      //find the first zero, or first positive, or last negative
      do
      {
        int middle;
        if(arr[middle=(begin+hi)>>>1]<0)
        {
          begin=middle+1;
        }
        else
        {
          hi=middle;
        }
      }
      while(begin<hi);
    case 0:
      //skip the last negative or all leading negative zeros
      while(CONVERTTOBITS(arr[begin])<0)
      {
        if(++begin>end)
        {
          return;
        }
      }
      //move the negative zeros to the beginning of the sub-range
      for(int p=begin-1;++begin<=end;)
      {
  #IFSWITCH ARRTYPE==float
        switch(CONVERTTOBITS(arr[begin]))
        {
        default:
          return;
        case Integer.MIN_VALUE:
          arr[begin]=0.0f;
          arr[++p]=-0.0f;
        case 0:
        }
  #ELSE
       long bits;
       if((bits=CONVERTTOBITS(arr[begin]))==Long.MIN_VALUE)
       {
          arr[begin]=0.0d;
          arr[++p]=-0.0d;
       }
       else if(bits!=0L)
       {
         return;
       }
  #ENDIF
      }
    default:
  }
#ELSE
  int hi;
  switch(Integer.signum(begin-(hi=end)))
  {
    case -1:
      //find the first zero, or first negative, or last positive
      do
      {
        int middle;
        if(arr[middle=(begin+hi)>>>1]>0)
        {
          begin=middle+1;
        }
        else
        {
          hi=middle;
        }
      }
      while(begin<hi);
    case 0:
      //skip the last positive or all leading positive zeros
      while(CONVERTTOBITS(arr[begin])>=0)
      {
        if(++begin>end)
        {
          return;
        }
      }
      //move the positive zeros to the beginning of the sub-range
      for(int p=begin-1;++begin<=end;)
      {
  #IFSWITCH ARRTYPE==float
        switch(CONVERTTOBITS(arr[begin]))
        {
        default:
          return;
        case 0:
          arr[begin]=-0.0f;
          arr[++p]=0.0f;
        case Integer.MIN_VALUE:
        }
  #ELSE
       long bits;
       if((bits=CONVERTTOBITS(arr[begin]))==0L)
       {
          arr[begin]=-0.0d;
          arr[++p]=0.0d;
       }
       else if(bits!=Long.MIN_VALUE)
       {
         return;
       }
  #ENDIF
      }
    default:
  }
#ENDIF
}
#ENDDEF

#MACRODEF CountingSort<METHODNAME,ARRTYPE>(BOXEDTYPE)
private static void countingMETHODNAME(ARRTYPE[] arr,int begin,int end)
{
  int[] count=new int[(BOXEDTYPE.MAX_VALUE+1)-BOXEDTYPE.MIN_VALUE];
  for(int i=begin;;++i)
  {
    #IFSWITCH ARRTYPE==char
    ++count[arr[i]];
    #ELSE
    ++count[arr[i]-BOXEDTYPE.MIN_VALUE];
    #ENDIF
    if(i==end)
    {
      break;
    }
  }
    #IFSWITCH METHODNAME==sort
  for(int i=(BOXEDTYPE.MAX_VALUE+1)-BOXEDTYPE.MIN_VALUE;;)
  {
    int s;
    while((s=count[--i])==0){}
    #ELSE
  for(int i=-1;;)
  {
    int s;
    while((s=count[++i])==0){}
    #ENDIF
    #IFSWITCH ARRTYPE==char
    var value=(ARRTYPE)i;
    #ELSE
    var value=(ARRTYPE)(i+BOXEDTYPE.MIN_VALUE);
    #ENDIF
    do
    {
      arr[end]=value;
      if(--end<begin)
      {
        return;
      }
    }
    while(--s!=0);
  }
}
#ENDDEF

#MACRODEF InsertSort<METHODNAME,ARRTYPE,EXPOSEDTYPE>()
private static void insertMETHODNAME(ARRTYPE[] arr,int begin,int end)
{
  for(int i=begin,j=i;i!=end;j=++i)
  {
    final var ai=arr[i+1];
    ARRTYPE aj;
    #MACRO WhileClause(LessThan,ai,aj=arr[j])
    {
      arr[j+1]=aj;
      if(j--==begin)
      {
        break;
      }
    }
    arr[j+1]=ai;
  }
}
#ENDDEF

#MACRODEF SentinelInsertSort<METHODNAME,ARRTYPE,EXPOSEDTYPE>()
private static void sentinelInsertMETHODNAME(ARRTYPE[] arr,int begin,int end)
{
  do
  {
    if(begin>=end)
    {
      return;
    }
  }
  #MACRO WhileClause(LessThanOrEqual,arr[begin],arr[++begin])
  ;
  for(int k=begin;++begin<=end;k=++begin)
  {
    ARRTYPE a1,a2;
    #MACRO IfClause(LessThan,a1=arr[k],a2=arr[begin])
    {
      a2=a1;
      a1=arr[begin];
    }
    ARRTYPE ak;
    #MACRO WhileClause(LessThan,a1,ak=arr[--k])
    {
      arr[k+2]=ak;
    }
    arr[++k+1]=a1;
    #MACRO WhileClause(LessThan,a2,ak=arr[--k])
    {
      arr[k+1]=ak;
    }
    arr[k+1]=a2;
  }
  ARRTYPE ae,last=arr[end];
  #MACRO WhileClause(LessThan,last,ae=arr[--end])
  {
    arr[end+1]=ae;
  }
  arr[end+1]=last;
}
#ENDDEF

#MACRODEF DoSort<METHODNAME,ARRTYPE,EXPOSEDTYPE>(CLASSPREFIX)
#IFSWITCH ARRTYPE==int,long
public static void uncheckedMETHODNAME(ARRTYPE[] arr,int begin,int end)
#ELSE
public static void doMETHODNAME(ARRTYPE[] arr,int begin,int end)
#ENDIF
{
  if(end-begin<286)
  {
    quickMETHODNAMEleftmost(arr,begin,end);
  }
  else
  {
    int[] run;
    int count=0;
    (run=new int[68])[0]=begin;
    //checkIfSortedLoop:
    for(int k=begin;k!=end;)
    {
  #IFSWITCH ARRTYPE==double,float
      #MACRO IfClause(LessThan,arr[k],arr[k+1])
      {
  #ELSE
      #MACRO SwitchSigNum(arr[k],arr[k+1])
      {
      case -1:
  #ENDIF
        for(;;)
        {
          if(++k==end ||
          #MACRO METHODNAMELessThan(arr[k],arr[k-1])
          )
          {
            break;
          }
        }
  #IFSWITCH ARRTYPE==double,float
      }
      else
      #MACRO IfClause(GreaterThan,arr[k],arr[k+1])
      {
  #ELSE
        break;
      default:
  #ENDIF
        for(;;)
        {
          if(++k==end||
          #MACRO METHODNAMELessThan(arr[k-1],arr[k])
          )
          {
            break;
          }
        }
        OmniArray.OfCLASSPREFIX.reverseRange(arr,run[count],k-1);
  #IFSWITCH ARRTYPE==double,float
      }
      else
      {
  #ELSE
        break;
      case 0:
  #ENDIF
        ++k;
        continue;
      }
      int r;
      if(count==0)
      {
        ++count;
      }
      else if(
      #MACRO METHODNAMELessThan(arr[r=run[count]],arr[r-1])
      && ++count==67)
      {
        quickMETHODNAMEleftmost(arr,begin,end);
        return;
      }
      run[count]=k;
    }
    if(count!=0)
    {
      METHODNAMEmerge(arr,begin,end,run,count);
    }
  }
}
#ENDDEF  

#MACRODEF QuickSortSinglePivot<METHODNAME,ARRTYPE,EXPOSEDTYPE,LEFTMOST>()
#IFSWITCH LEFTMOST==true
private static void quickMETHODNAMEleftmostSinglePivot(ARRTYPE[] arr,int begin,int end,ARRTYPE pivot)
#ELSE
private static void quickMETHODNAMESinglePivot(ARRTYPE[] arr,int begin,int end,ARRTYPE pivot)
#ENDIF
{
  int less=begin;
  int great=end;
  for(int k=less;k<=great;++k)
  {
    ARRTYPE ak;
#IFSWITCH ARRTYPE==double,float
    #MACRO IfClause(LessThan,ak=arr[k],pivot)
    {
      arr[k]=arr[less];
      arr[less]=ak;
      ++less;
    }
    else
    #MACRO IfClause(GreaterThan,ak,pivot)
    {
      ARRTYPE ag;
      #MACRO WhileClause(GreaterThan,ag=arr[great],pivot)
      {
        --great;
      }
      #MACRO IfClause(LessThan,ag,pivot)
      {
        arr[k]=arr[less];
        arr[less]=ag;
        ++less;
      }
      else
      {
        arr[k]=ag;
      }
      arr[great]=ak;
      --great;
    }
#ELSE
    #MACRO SwitchSigNum(ak=arr[k],pivot)
    {
    case -1:
      arr[k]=arr[less];
      arr[less]=ak;
      ++less;
    case 0:
      break;
    default:
      forLoop: for(;;)
      {
        ARRTYPE ag;
        #MACRO SwitchSigNum(pivot,ag=arr[great])
        {
          case 0:
            arr[k]=pivot;
            break forLoop;
          default:
            arr[k]=arr[less];
            arr[less]=ag;
            ++less;
            break forLoop;
          case -1:
            --great;
        }
      }
      arr[great]=ak;
      --great;
    }
#ENDIF
  }
  if(--less>begin)
  {
#IFSWITCH LEFTMOST==true
  quickMETHODNAMEleftmost(arr,begin,less);
#ELSE
  quickMETHODNAME(arr,begin,less);
#ENDIF
  }
  quickMETHODNAME(arr,great+1,end);
}
#ENDDEF  
  
#MACRODEF QuickSortDualPivot<METHODNAME,ARRTYPE,EXPOSEDTYPE,LEFTMOST>()
#IFSWITCH LEFTMOST==true
private static void quickMETHODNAMEleftmostDualPivot(ARRTYPE[] arr,int begin,int end,ARRTYPE pivot1, ARRTYPE pivot2,int e1,int e5)
#ELSE
private static void quickMETHODNAMEDualPivot(ARRTYPE[] arr,int begin,int end,ARRTYPE pivot1, ARRTYPE pivot2,int e1,int e5)
#ENDIF
{
  int less=begin;
  int great=end;
  #MACRO WhileClause(LessThanOrEqual,arr[++less],pivot1)
  {
  }
  #MACRO WhileClause(GreaterThanOrEqual,arr[--great],pivot2)
  {
  }
  outer: for(int k=less;k<=great;++k)
  {
    ARRTYPE ak;
    #MACRO IfClause(LessThan,ak=arr[k],pivot1)
    {
      arr[k]=arr[less];
      arr[less]=ak;
      ++less;
    }
    else
    #MACRO IfClause(GreaterThan,ak,pivot2)
    {
      ARRTYPE ag;
      #MACRO WhileClause(GreaterThan,ag=arr[great],pivot2)
      {
        if(great--==k)
        {
          break outer;
        }
      }
      #MACRO IfClause(LessThan,ag,pivot1)
      {
        arr[k]=arr[less];
        arr[less]=ag;
        ++less;
      }
      else
      {
        arr[k]=ag;
      }
      arr[great]=ak;
      --great;
    }
  }
  arr[begin]=arr[less-1];
  arr[less-1]=pivot1;
  arr[end]=arr[great+1];
  arr[great+1]=pivot2;
#IFSWITCH LEFTMOST==true
  quickMETHODNAMEleftmost(arr,begin,less-2);
#ELSE
  quickMETHODNAME(arr,begin,less-2);
#ENDIF
  quickMETHODNAME(arr,great+2,end);
  if(less<e1 && e5<great)
  {
    #MACRO WhileClause(Equal,arr[less],pivot1)
    {
      ++less;
    }
    #MACRO WhileClause(Equal,arr[great],pivot2)
    {
      --great;
    }
    outer: for(int k=less;k<=great;++k)
    {
      ARRTYPE ak;
      #MACRO IfClause(Equal,ak=arr[k],pivot1)
      {
        arr[k]=arr[less];
        arr[less]=ak;
        ++less;
      }
      else
      #MACRO IfClause(Equal,ak,pivot2)
      {
        ARRTYPE ag;
        #MACRO WhileClause(Equal,ag=arr[great],pivot2)
        {
          if(great--==k)
          {
            break outer;
          }
        }
        #MACRO IfClause(Equal,ag,pivot1)
        {
          arr[k]=arr[less];
          arr[less]=ag;
          ++less;
        }
        else
        {
          arr[k]=ag;
        }
        arr[great]=ak;
        --great;
      }
    }
  }
  quickMETHODNAME(arr,less,great);
}
#ENDDEF

#MACRODEF QuickSort<METHODNAME,ARRTYPE,EXPOSEDTYPE,LEFTMOST>()
#IFSWITCH LEFTMOST==true
private static void quickMETHODNAMEleftmost(ARRTYPE[] arr,int begin,int end)
#ELSE
private static void quickMETHODNAME(ARRTYPE[] arr,int begin,int end)
#ENDIF
{
  int length;
  if((length=end-begin+1)<47)
  {
#IFSWITCH LEFTMOST==true
    insertMETHODNAME(arr,begin,end);
#ELSE
    sentinelInsertMETHODNAME(arr,begin,end);
#ENDIF
    return;
  }
  int seventh,e1,e2,e3,e4,e5;
  ARRTYPE val1,val2,val3,val4,val5;
  #MACRO IfClause(LessThan,val2=arr[e2=(e3=(begin+end)>>>1)-(seventh=(length>>3)+(length>>6)+1)],val1=arr[e1=e2-seventh])
  {
    var tmp=val2;
    val2=val1;
    val1=tmp;
  }
  #MACRO IfClause(LessThan,val3=arr[e3],val2)
  {
    var tmp=val3;
    val3=val2;
    #MACRO IfClause(LessThan,tmp,val1)
    {
      val2=val1;
      val1=tmp;
    }
    else
    {
      val2=tmp;
    }
  }
  #MACRO IfClause(LessThan,val4=arr[e4=e3+seventh],val3)
  {
    var tmp=val4;
    val4=val3;
    #MACRO IfClause(LessThan,tmp,val2)
    {
      val3=val2;
      #MACRO IfClause(LessThan,tmp,val1)
      {
        val2=val1;
        val1=tmp;
      }
      else
      {
        val2=tmp;
      }
    }
    else
    {
      val3=tmp;
    }
  }
  #MACRO IfClause(LessThan,val5=arr[e5=e4+seventh],val4)
  {
    var tmp=val5;
    val5=val4;
    #MACRO IfClause(LessThan,tmp,val3)
    {
      val4=val3;
      #MACRO IfClause(LessThan,tmp,val2)
      {
        val3=val2;
        #MACRO IfClause(LessThan,tmp,val1)
        {
          val2=val1;
          val1=tmp;
        }
        else
        {
          val2=tmp;
        }
      }
      else
      {
        val3=tmp;
      }
    }
    else
    {
      val4=tmp;
    }
  }
  arr[e1]=val1;
  arr[e3]=val3;
  arr[e5]=val5;
  if(
  #MACRO METHODNAMEEqual(val1,val2)
  ||
  #MACRO METHODNAMEEqual(val2,val3)
  ||
  #MACRO METHODNAMEEqual(val3,val4)
  ||
  #MACRO METHODNAMEEqual(val4,val5)
  )
  {
    arr[e2]=val2;
    arr[e4]=val4;
#IFSWITCH LEFTMOST==true
    quickMETHODNAMEleftmostSinglePivot(arr,begin,end,val3);
#ELSE
    quickMETHODNAMESinglePivot(arr,begin,end,val3);
#ENDIF
  }
  else
  {
     arr[e2]=arr[begin];
     arr[e4]=arr[end];
#IFSWITCH LEFTMOST==true
    quickMETHODNAMEleftmostDualPivot(arr,begin,end,val2,val4,e1,e5);
#ELSE
    quickMETHODNAMEDualPivot(arr,begin,end,val2,val4,e1,e5);
#ENDIF
  }
}
#ENDDEF

#MACRODEF MergeMethod<METHODNAME,ARRTYPE,EXPOSEDTYPE>()
private static void METHODNAMEmerge(ARRTYPE[] arr,int begin,int end,int[] run,int count)
{
  
  byte odd=0;
  for(int n=1;(n<<=1)<=count;odd^=1){}
  ARRTYPE[] b;
  int ao,bo,blen;
  var work=new ARRTYPE[blen=end-begin+1];
  if(odd==0)
  {
    ArrCopy.uncheckedCopy(arr,begin,work,0,blen);
    b=arr;
    bo=0;
    arr=work;
    ao=-begin;
  }
  else
  {
    b=work;
    ao=0;
    bo=-begin;
  }
  run[++count]=++end;
  int last,k;
  do
  {
    for(last=0,k=2;k<=count;k+=2)
    {
      int hi=run[k];
      int mi;
      for(int i=run[k-2],p=i,q=(mi=run[k-1]);i<hi;++i)
      {
        if(q<hi && (p>=mi ||
        #MACRO METHODNAMELessThan(arr[q+ao],arr[p+ao])
        ))
        {
          b[i+bo]=arr[q++ +ao];
        }
        else
        {
          b[i+bo]=arr[p++ +ao];
        }
      }
      run[++last]=hi;
    }
    if((count&1)!=0)
    {
      for(int i=end,lo=run[count-1];--i>=lo;b[i+bo]=arr[i+ao]){}
      run[++last]=end;
    }
    var tmp=arr;
    arr=b;
    b=tmp;
    int o=ao;
    ao=bo;
    bo=o;
  }
  while((count=last)>1);
}
#ENDDEF

#MACRODEF SuppressUnchecked()
#IFSWITCH ARRTYPE==Object
@SuppressWarnings("unchecked")
#ENDIF
#ENDDEF

#MACRODEF IfClause(COMPARE,Val1,Val2)
if(
#MACRO METHODNAMECOMPARE(Val1,Val2)
)
#ENDDEF

#MACRODEF WhileClause(COMPARE,Val1,Val2)
while(
#MACRO METHODNAMECOMPARE(Val1,Val2)
)
#ENDDEF

#MACRODEF comparatorSortLessThan(Val1,Val2)
#IFSWITCH ARRTYPE==int
sorter.applyAsInt((int)(Val1),(int)(Val2))<0
#ELSEIFSWITCH ARRTYPE==Object
sorter.compare((E)(Val1),(E)(Val2))<0
#ELSE
sorter.compare((ARRTYPE)(Val1),(ARRTYPE)(Val2))<0
#ENDIF
#ENDDEF
#MACRODEF sortLessThan(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))<0
#ELSE
(Val1)<(Val2)
#ENDIF
#ENDDEF
#MACRODEF reverseSortLessThan(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))>0
#ELSE
(Val1)>(Val2)
#ENDIF
#ENDDEF

#MACRODEF comparatorSortLessThanOrEqual(Val1,Val2)
#IFSWITCH ARRTYPE==int
sorter.applyAsInt((int)(Val1),(int)(Val2))<=0
#ELSEIFSWITCH ARRTYPE==Object
sorter.compare((E)(Val1),(E)(Val2))<=0
#ELSE
sorter.compare((ARRTYPE)(Val1),(ARRTYPE)(Val2))<=0
#ENDIF
#ENDDEF
#MACRODEF sortLessThanOrEqual(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))<=0
#ELSE
(Val1)<=(Val2)
#ENDIF
#ENDDEF
#MACRODEF reverseSortLessThanOrEqual(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))>=0
#ELSE
(Val1)>=(Val2)
#ENDIF
#ENDDEF

#MACRODEF comparatorSortGreaterThanOrEqual(Val1,Val2)
#IFSWITCH ARRTYPE==int
sorter.applyAsInt((int)(Val1),(int)(Val2))>=0
#ELSEIFSWITCH ARRTYPE==Object
sorter.compare((E)(Val1),(E)(Val2))>=0
#ELSE
sorter.compare((ARRTYPE)(Val1),(ARRTYPE)(Val2))>=0
#ENDIF
#ENDDEF
#MACRODEF sortGreaterThanOrEqual(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))>=0
#ELSE
(Val1)>=(Val2)
#ENDIF
#ENDDEF
#MACRODEF reverseSortGreaterThanOrEqual(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))<=0
#ELSE
(Val1)<=(Val2)
#ENDIF
#ENDDEF

#MACRODEF comparatorSortGreaterThan(Val1,Val2)
#IFSWITCH ARRTYPE==int
sorter.applyAsInt((int)(Val1),(int)(Val2))>0
#ELSEIFSWITCH ARRTYPE==Object
sorter.compare((E)(Val1),(E)(Val2))>0
#ELSE
sorter.compare((ARRTYPE)(Val1),(ARRTYPE)(Val2))>0
#ENDIF
#ENDDEF
#MACRODEF sortGreaterThan(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))>0
#ELSE
(Val1)>(Val2)
#ENDIF
#ENDDEF
#MACRODEF reverseSortGreaterThan(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))<0
#ELSE
(Val1)<(Val2)
#ENDIF
#ENDDEF

#MACRODEF sortEqual(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))==0
#ELSE
(Val1)==(Val2)
#ENDIF
#ENDDEF
#MACRODEF reverseSortEqual(Val1,Val2)
#IFSWITCH ARRTYPE==Object
((Comparable<E>)(Val1)).compareTo((E)(Val2))==0
#ELSE
(Val1)==(Val2)
#ENDIF
#ENDDEF

#MACRODEF SwitchSigNum(Val1,Val2)
switch(
#MACRO METHODNAMESigNumCall(Val1,Val2)
)
#ENDDEF
#MACRODEF reverseSortSigNumCall(Val1,Val2)
#IFSWITCH ARRTYPE==long
Long.signum((Val2)-(Val1))
#ELSE
Integer.signum((Val2)-(Val1))
#ENDIF
#ENDDEF
#MACRODEF sortSigNumCall(Val1,Val2)
#IFSWITCH ARRTYPE==long
Long.signum((Val1)-(Val2))
#ELSE
Integer.signum((Val1)-(Val2))
#ENDIF
#ENDDEF

