#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.util;
#IF OfInt
import java.util.function.$Comparator$;
#ELSEIF OfRef
import java.util.$Comparator$;
#ELSE
import omni.function.$Comparator$;
#ENDIF
public final class $ClassPrefix$SortUtil
{
  private $ClassPrefix$SortUtil()
  {
     super();
  }


#MACRODEF SuppressUnchecked()
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
#ENDDEF
#IF OfBoolean
  private static void uncheckedSortHelper($ArrayType$[] arr,int begin,int end,$ArrayType$ firstVal)
  {
    //assert arr!=null;
    //assert begin>=0;
    //assert end<arr.length;
    //assert begin<end;
    //assert firstVal!=arr[begin];
    //assert firstVal==arr[end];
    int endValCounter=1;
    for(int curr=begin+1;curr!=end;++curr)
    {
      if(arr[curr]^firstVal)
      {
        ++endValCounter;
      }
    }
    for(final $ArrayType$ endVal=!firstVal;;--end)
    {
      arr[end]=endVal;
      if(--endValCounter==0)
      {
        do
        {
          arr[--end]=firstVal;
        }
        while(end!=begin);
        return;
      }
    }
  }
#ENDIF
#MACRODEF WhileLessThan(Val1,Val2)
while(
#MACRO MethodNameCall(Val1,Val2)
)
#ENDDEF
#MACRODEF WhileGreaterThan(Val1,Val2)
while(
#MACRO MethodNameCall(Val2,Val1)
)
#ENDDEF
#MACRODEF WhileEqualTo(Val1,Val2)
while(
#MACRO MethodNameEqualsCall(Val1,Val2)
)
#ENDDEF
#MACRODEF IfLessThan(Val1,Val2)
if(
#MACRO MethodNameCall(Val1,Val2)
)
#ENDDEF
#MACRODEF IfGreaterThan(Val1,Val2)
if(
#MACRO MethodNameCall(Val2,Val1)
)
#ENDDEF
#MACRODEF IfEqualTo(Val1,Val2)
if(
#MACRO MethodNameEqualsCall(Val1,Val2)
)
#ENDDEF
#MACRODEF SwitchSigNum(Val1,Val2)
switch(
#MACRO MethodNameSigNumCall(Val1,Val2)
)
#ENDDEF
#MACRODEF comparatorSortSigNumCall(Val1,Val2)
Integer.signum(sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(Val2)))
#ENDDEF
#MACRODEF reverseSortSigNumCall(Val1,Val2)
#IF OfLong
Long.signum((Val2)-(Val1))
#ELSE
Integer.signum((Val2)-(Val1))
#ENDIF
#ENDDEF
#MACRODEF sortSigNumCall(Val1,Val2)
#IF OfLong
Long.signum((Val1)-(Val2))
#ELSE
Integer.signum((Val1)-(Val2))
#ENDIF
#ENDDEF
#MACRODEF sortEqualsCall(Val1,Val2)
(Val1)==(Val2)
#ENDDEF
#MACRODEF comparatorSortEqualsCall(Val1,Val2)
sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(val2))==0
#ENDDEF
#MACRODEF reverseSortEqualsCall(Val1,Val2)
(Val1)==(Val2)
#ENDDEF
#MACRODEF sortCall(Val1,Val2)
(Val1)<(Val2)
#ENDDEF
#MACRODEF reverseSortCall(Val1,Val2)
(Val1)>(Val2)
#ENDDEF
#MACRODEF comparatorSortCall(Val1,Val2)
sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(Val2))<0
#ENDDEF
#MACRODEF MoveNaN(BEGIN,END,ITERATE)
for(;;)
{
  if(!$BoxedType$.isNaN(arr[END]))
  {
    break;
  }
  if(ITERATEEND==BEGIN)
  {
    return;
  }
}
for(int k=END;ITERATEk!=BEGIN;)
{
  $ArrayType$ ak;
  if($BoxedType$.isNaN(ak=arr[k]))
  {
    arr[k]=arr[END];
    arr[END]=ak;
    ITERATEEND;
  }
}
#ENDDEF
#MACRODEF Gallop<Direction>()
#MACRO SuppressUnchecked()
private static $<E>$ int gallopDirection($exposedType$ key,$ArrayType$[] arr,int base,int len,int hint,$Comparator$$<? super E>$ sorter)
{
  //assert len > 0 && hint >= 0 && hint < len;
  int ofs=1;
  int lastOfs=0;
#IFSWITCH Direction==Right
  #MACRO IfLessThan(key,arr[base+hint])
  {
    int maxOfs=hint+1;
    while(ofs < maxOfs &&
    #MACRO MethodNameCall(key,arr[base+hint-ofs])
#ELSE
  #MACRO IfLessThan(arr[base+hint],key)
  {
    int maxOfs=len-hint;
    while(ofs < maxOfs &&
    #MACRO MethodNameCall(arr[base+hint+ofs],key)
#ENDIF
    )
    {
      if((ofs=((lastOfs=ofs)<<1)+1)<=0)
      {
        ofs=maxOfs;
      }
    }
    if(ofs>maxOfs)
    {
      ofs=maxOfs;
    }
#IFSWITCH Direction==Right
    int tmp=lastOfs;
    lastOfs=hint-ofs;
    ofs=hint-tmp;
  }
  else
  {
    int maxOfs=len-hint;
#ELSE
    lastOfs+=hint;
    ofs+=hint;
  }
  else
  {
    final int maxOfs=hint+1;
#ENDIF
    for(;;)
    {
      if(ofs>=maxOfs || 
#IFSWITCH Direction==Right
      #MACRO MethodNameCall(key,arr[base+hint+ofs])
#ELSE
      #MACRO MethodNameCall(arr[base+hint-ofs],key)
#ENDIF
      )
      {
        break;
      }
      if((ofs=((lastOfs=ofs)<<1)+1)<=0)
      {
        ofs=maxOfs;
      }
    }
    if(ofs>maxOfs)
    {
      ofs=maxOfs;
    }
#IFSWITCH Direction==Right
    lastOfs+=hint;
    ofs+=hint;
#ELSE
    int tmp=lastOfs;
    lastOfs=hint-ofs;
    ofs=hint-tmp;
#ENDIF
  }
  //assert -1 <= lastOfs && lastOfs < ofs && ofs <=len;
  int diff;
  if((diff=ofs-(++lastOfs))>0)
  {
    do
    {
      int m;
#IFSWITCH Direction==Right
      #MACRO IfLessThan(key,arr[base+(m=lastOfs+(diff>>>1))])
      {
        ofs=m;
      }
      else
      {
        lastOfs=m+1;
      }
#ELSE
      #MACRO IfLessThan(arr[base+(m=lastOfs+(diff>>>1))],key)
      {
        lastOfs=m+1;
      }
      else
      {
        ofs=m;
      }
#ENDIF
    }
    while((diff=ofs-lastOfs)>0);
  }
  //assert lastOfs==ofs;
  return ofs;
}
#ENDDEF
#MACRODEF MergeImpl(LEN1,LEN2,INCREMENT,CURSOR1,CURSOR2,COUNT1,COUNT2,ARR,TMP)
int minGallop=this.minGallop;
outer:for(;;)
{
  int count1=0;
  int count2=0;
  do
  {
    //assert LEN1>1 && LEN2>0;
    #MACRO IfLessThan(ARR[cursor2],TMP[cursor1])
    {
      arr[destINCREMENT]=arr[CURSOR2INCREMENT];
      ++COUNT2;
      COUNT1=0;
      if(--LEN2==0)
      {
        break outer;
      }
    }
    else
    {
      arr[destINCREMENT]=tmp[CURSOR1INCREMENT];
      ++COUNT1;
      COUNT2=0;
      if(--LEN1==0)
      {
        break;
      }
    }
  }
  while((count1|count2)<minGallop);
  do
  {
    //assert LEN1>1 && LEN2>0;
#IFSWITCH Side==Lo
    if((count1=gallopRight(($exposedType$)arr[cursor2],tmp,cursor1,len1,0,sorter))!=0)
    {
      ArrCopy.uncheckedCopy(tmp,cursor1,arr,dest,count1);
      dest+=count1;
      cursor1+=count1;
      if((len1-=count1)<=1)
      {
        break outer;
      }
    }
#ELSE
    if((count1=len1-gallopRight(($exposedType$)tmp[cursor2],arr,base1,len1,len1-1,sorter))!=0)
    {
      ArrCopy.uncheckedCopy(arr,(cursor1-=count1),arr,(dest-=count1)+1,count1);
      if((len1-=count1)==0)
      {
        break outer;
      }
    }
#ENDIF
    arr[destINCREMENT]=tmp[cursor2INCREMENT];
#IFSWITCH Side==Lo
    if(--len2==0)
#ELSE
    if(--len2==1)
#ENDIF
    {
      break outer;
    }
#IFSWITCH Side==Lo
    if((count2=gallopLeft(($exposedType$)tmp[cursor1],arr,cursor2,len2,0,sorter))!=0)
    {
      ArrCopy.uncheckedCopy(arr,cursor2,arr,dest,count2);
      dest+=count2;
      cursor2+=count2;
      if((len2-=count2)==0)
#ELSE
    if((count2=len2-gallopLeft(($exposedType$)arr[cursor1],tmp,tmpBase,len2,len2-1,sorter))!=0)
    {
      ArrCopy.uncheckedCopy(tmp,(cursor2-=count2)+1,arr,(dest-=count2)+1,count2);
      if((len2-=count2)<=1)
#ENDIF
      {
        break outer;
      }
    }
    arr[destINCREMENT]=tmp[CURSOR1INCREMENT];
#IFSWITCH Side==Lo
    if(len1==1)
#ELSE
    if(len1==0)
#ENDIF
    {
      break outer;
    }
    --minGallop;
  }
  while(count1>=7 || count2>=7);
  if(minGallop<0)
  {
    minGallop=0;
  }
  minGallop+=2;
}
this.minGallop=(minGallop<1?1:minGallop);
switch(LEN1)
{
  case 0:
    throw new IllegalArgumentException("Comparison method violates its general contract!");
  case 1:
    //assert LEN2>0;
#ENDDEF
#MACRODEF MergeMethod<Side>()
#MACRO SuppressUnchecked()
private void mergeSide($ArrayType$[] arr,int base1,int len1,int base2,int len2,$Comparator$$<? super E>$ sorter)
{
  $ArrayType$[] tmp;
  int cursor1,dest;
#IFSWITCH Side==Lo
  int cursor2=base2;
  ArrCopy.uncheckedCopy(arr,dest=base1,tmp=ensureCapacity(len1),cursor1=this.tmpBase,len1);
  arr[dest++]=arr[cursor2++];
  if(--len2==0)
  {
    ArrCopy.uncheckedCopy(tmp,cursor1,arr,dest,len1);
    return;
  }
  if(len1==1)
  {
    ArrCopy.uncheckedCopy(arr,cursor2,arr,dest,len2);
    arr[dest+len2]=tmp[cursor1];
    return;
  }
  #MACRO MergeImpl(len1,len2,++,cursor1,cursor2,count1,count2,arr,tmp)
    ArrCopy.uncheckedCopy(arr,cursor2,arr,dest,len2);
    arr[dest+len2]=tmp[cursor1];
    break;
  default:
    assert len2==0;
    assert len1>1;
    ArrCopy.uncheckedCopy(tmp,cursor1,arr,dest,len1);
#ELSE
  int tmpBase;
  ArrCopy.uncheckedCopy(arr,base2,tmp=ensureCapacity(len2),tmpBase=this.tmpBase,len2);
  dest=base2+len2-1;
  cursor1=base1+len1-1;
  arr[dest--]=arr[cursor1--];
  if(--len1==0)
  {
    ArrCopy.uncheckedCopy(tmp,tmpBase,arr,dest-(len2-1),len2);
    return;
  }
  if(len2==1)
  {
    dest-=len1;
    cursor1-=len1;
    ArrCopy.uncheckedCopy(arr,(cursor1-=len1)+1,arr,(dest-=len1)+1,len1);
    arr[dest]=tmp[tmpBase];
    return;
  }
  int cursor2=tmpBase+len2-1;
  #MACRO MergeImpl(len2,len1,--,cursor2,cursor1,count2,count1,tmp,arr)
    ArrCopy.uncheckedCopy(arr,(cursor1-=len1)+1,arr,(dest-=len1)+1,len1);
    arr[dest]=tmp[cursor2];
  default:
    assert len1==0;
    assert len2>0;
    ArrCopy.uncheckedCopy(tmp,tmpBase,arr,dest-(len2-1),len2);
#ENDIF
  }
}
#ENDDEF
#MACRODEF UncheckedSort<MethodName>()
#IFSWITCH MethodName==comparatorSort
  #IFNOT OfBoolean
private static int minRunLength(int n)
{
  //assert n>=0;
  int r=0;
  while(n>31)
  {
    r|=(n&1);
    n>>=1;
  }
  return n+r;
}
private static void reverseRange($ArrayType$[] arr,int begin,int end)
{
  //assert arr!=null;
  //assert begin<end;
  //assert begin>=0;
  //assert end<arr.length;
  do
  {
    $ArrayType$ tmp=arr[begin];
    arr[begin]=arr[end];
    arr[end]=tmp;
  }
  while(++begin<--end);
}
#MACRO SuppressUnchecked()
private static $<E>$ int countRunAndMakeAscending($ArrayType$[] arr,int begin,int end,$Comparator$$<? super E>$ sorter)
{
  //assert arr!=null;
  //assert begin<end;
  //assert begin>=0;
  //assert end<arr.length;
  //assert sorter!=null;
  int runHi;
  #MACRO IfLessThan(arr[runHi=begin+1],arr[begin])
  {
    for(;;)
    {
      if(runHi==end)
      {
        reverseRange(arr,begin,runHi++);
        break;
      }
      if(sorter.$compareMethod$(($exposedType$)arr[runHi],($exposedType$)arr[++runHi])<=0)
      {
        reverseRange(arr,begin,runHi-1);
        break;
      }
    }
  }
  else
  {
    for(;;)
    {
      if(runHi==end)
      {
        ++runHi;
        break;
      }
      if(sorter.$compareMethod$(($exposedType$)arr[runHi],($exposedType$)arr[++runHi])>0)
      {
        break;
      }
    }
  }
  return runHi-begin;
}
#MACRO SuppressUnchecked()
private static $<E>$ void binarySort($ArrayType$[] arr,int lo,int hi,int begin,$Comparator$$<? super E>$ sorter)
{
  //assert lo < begin;
  for(;begin<=hi;++begin)
  {
    final $exposedType$ pivot=($exposedType$)arr[begin];
    int left=lo;
    for(int right=begin;left<right;)
    {
      final int mid;
      if(sorter.$compareMethod$(pivot,($exposedType$)arr[mid=(left+right)>>>1])<0)
      {
        right=mid;
      }
      else
      {
        left=mid+1;
      }
    }
    ArrCopy.uncheckedCopy(arr,left,arr,left+1,begin-left);
    arr[left]=pivot;
  }
}
private static class TimSort$<E>$
{
  final $ArrayType$[] arr;
  final $Comparator$$<? super E>$ sorter;
  $ArrayType$[] tmp;
  int tmpLen;
  int tmpBase;
  int stackSize;
  int minGallop;
  int[] runBase;
  int[] runLen;
  private TimSort($ArrayType$[] arr,$Comparator$$<? super E>$ sorter,int nRemaining)
  {
    this.arr=arr;
    this.sorter=sorter;
    int tmpLen;
    this.tmp=new $ArrayType$[tmpLen=nRemaining<512?nRemaining>>>1:256];
    this.tmpLen=tmpLen;
    this.tmpBase=0;
    this.stackSize=0;
    this.minGallop=7;
    this.runBase=new int[nRemaining=(nRemaining<120?5:nRemaining<1542?10:nRemaining<119151?24:49)];
    this.runLen=new int[nRemaining];
  }
  private $ArrayType$[] ensureCapacity(int minCapacity)
  {
    $ArrayType$[] tmp;
    if(tmpLen<minCapacity)
    {
      int newSize;
      if((newSize=(-1>>>Integer.numberOfLeadingZeros(minCapacity))+1)<0 || newSize>(minCapacity=arr.length>>>1))
      {
        newSize=minCapacity;
      }
      this.tmp=tmp=new $ArrayType$[newSize];
      this.tmpLen=newSize;
      tmpBase=0;
    }
    else
    {
      tmp=this.tmp;
    }
    return tmp;
  }
  #MACRO Gallop<Right>()
  #MACRO Gallop<Left>()
  #MACRO MergeMethod<Lo>()
  #MACRO MergeMethod<Hi>()
  #MACRO SuppressUnchecked()
  private int mergeAt(int i,int stackSize,int[] runLen)
  {
    //assert stackSize>=2;
    //assert i>=0;
    //assert i==stackSize-2 || i==stackSize-3;
    int base1,len1,base2,len2;
    int[] runBase=this.runBase;
    //assert runLen[i]>0 && runLen[i+1]>0;
    //assert runBase[i]+runLen[i]==runBase[i+1];
    runLen[i]=(len1=runLen[i])+(len2=runLen[i+1]);
    if(i==stackSize-3)
    {
      runBase[i+1]=runBase[i+2];
      runLen[i+1]=runLen[i+2];
    }
    --stackSize;
    $ArrayType$[] arr;
    int k;
    base1=(base1=runBase[i])+(k=gallopRight(($exposedType$)(arr=this.arr)[base2=runBase[i+1]],arr,base1,len1,0,sorter));
    if((len1-=k)!=0)
    {
       //assert k>=0;
       if((len2=gallopLeft(($exposedType$)arr[base1+len1-1],arr,base2,len2,len2-1,sorter))!=0)
       {
         //assert len2>0;
         if(len1>len2)
         {
           mergeHi(arr,base1,len1,base2,len2,sorter);
         }
         else
         {
           mergeLo(arr,base1,len1,base2,len2,sorter);
         }
       }
    }
    return stackSize;
  }
  private void mergeCollapse(int runBase,int runLength)
  {
    int stackSize;
    this.runBase[stackSize=this.stackSize]=runBase;
    int[] runLen;
    (runLen=this.runLen)[stackSize]=runLength;
    if(++stackSize>1)
    {
      int n;
      do
      {
        if((n=stackSize-2)>0 && runLen[n-1]<=runLen[n]+runLen[n+1] ||
                         n>1 && runLen[n-2]<=runLen[n]+runLen[n-1])
        {
          if(runLen[n-1]<runLen[n+1])
          {
            --n;
          }
        }
        else if(n<0 ||runLen[n]>runLen[n+1])
        {
          break;
        }
      }
      while((stackSize=mergeAt(n,stackSize,runLen))>1);
    }
    this.stackSize=stackSize;
  }
  private void mergeForceCollapse()
  {
    int stackSize;
    if((stackSize=this.stackSize)>1)
    {
      int[] runLen=this.runLen;
      int n;
      do
      {
        if((n=stackSize-2)>0 && runLen[n-1]<runLen[n+1])
        {
          --n;
        }
      }
      while((stackSize=mergeAt(n,stackSize,runLen))>1);
    }
  }
}
  #ENDIF
public static $<E>$ void uncheckedMethodName($ArrayType$[] arr,int begin,int end,$Comparator$$<? super E>$ sorter)
{
    //assert sorter!=null;
    //assert arr!=null;
    //assert begin>=0;
    //assert end<arr.length;
    //assert end-begin>0;
  #IF OfBoolean
    $ArrayType$ firstVal=arr[begin];
    int newBegin;
    for(newBegin=begin+1;arr[newBegin]==firstVal;++newBegin)
    {
      if(newBegin==end)
      {
        //already sorted
        return;
      }
    }
    switch(Integer.signum(sorter.compare(firstVal,!firstVal)))
    {
      case -1:
        for(int newEnd=end;newEnd!=newBegin;--newEnd)
        {
          if(arr[newEnd]==firstVal)
          {
            uncheckedSortHelper(arr,newBegin,newEnd,firstVal);
            return;
          }
        }
        //already sorted
      case 0:
        //unsorted comparator
        return;
      default:
        int endValCounter=newBegin-begin;
        while(newBegin!=end)
        {
          if(arr[++newBegin]==firstVal)
          {
            ++endValCounter;
          }
        }
        for(;;--end)
        {
          arr[end]=firstVal;
          if(--endValCounter==0)
          {
            do
            {
              arr[--end]=!firstVal;
            }
            while(end!=begin);
            return;
          }
        }
    }
  #ELSE
    int nRemaining;
    if((nRemaining=end-begin)<31)
    {
       
       binarySort(arr,begin,end,begin+countRunAndMakeAscending(arr,begin,end,sorter),sorter);
       return;
    }
    TimSort$<E>$ ts=new TimSort$<E>$(arr,sorter,++nRemaining);
    int minRun=minRunLength(nRemaining);
    int runLen;
    do
    {
      if((runLen=countRunAndMakeAscending(arr,begin,end,sorter))<minRun)
      {
        int force;
        binarySort(arr,begin,begin+(force=nRemaining<=minRun?nRemaining:minRun),begin+runLen,sorter);
        runLen=force;
      }
      ts.mergeCollapse(begin,runLen);
      begin+=runLen;
    }
    while((nRemaining-=runLen)!=0);
    //assert begin==end+1;
    ts.mergeForceCollapse();
  #ENDIF
}
#ELSE
  #IFNOT OfLong,OfInt
public static void uncheckedMethodName($ArrayType$[] arr,int begin,int end)
{
  //assert arr!=null;
  //assert begin>=0;
  //assert end<arr.length;
  //assert begin<end;
    #IF OfBoolean
      #IFSWITCH MethodName==sort
  while(!arr[begin])
      #ELSE
  while(arr[begin])
      #ENDIF
  {
    if(++begin==end)
    {
      //already sorted
      return;
    }
  }
      #IFSWITCH MethodName==sort
  while(arr[end])
      #ELSE
  while(!arr[end])
      #ENDIF
  {
    --end;
  }
  if(begin==end)
  {
    //already sorted
    return;
  }
      #IFSWITCH MethodName==sort
  uncheckedSortHelper(arr,begin,end,false);
      #ELSE
  uncheckedSortHelper(arr,begin,end,true);
      #ENDIF
    #ELSEIF OfByte
  if(end-begin<30)
  {
    //Use insertion sort on small arrays
    insertMethodName(arr,begin,end);
  }
  else
  {
    // Use counting sort on large arrays
    countingMethodName(arr,begin,end);
  }
    #ELSEIF OfChar,OfShort
  if(end-begin>3200)
  {
    countingMethodName(arr,begin,end);
  }
  else
  {
    doMethodName(arr,begin,end);
  }
    #ELSEIF OfDouble,OfFloat
      #IFSWITCH MethodName==sort
  #MACRO MoveNaN(begin,end,--)
      #ELSE
  #MACRO MoveNaN(end,begin,++)
      #ENDIF
  doMethodName(arr,begin,end);
  int hi=end;
  for(;;)
  {
    int middle;
    #MACRO IfLessThan(arr[middle=(begin+hi)>>>1],($exposedType$)0.0)
    {
      begin=middle+1;
    }
    else
    {
      hi=middle;
    }
    if(begin<hi)
    {
      break;
    }
  }
  while(begin<=end &&
  #MACRO MethodNameCall($convertToBits$(arr[begin]),0)
  )
  {
    ++begin;
  }
  for(int k=begin;++k<=end;)
  {
    $ArrayType$ ak;
    if((ak=arr[k])!=($exposedType$)0.0)
    {
      break;
    }
    #MACRO IfLessThan($convertToBits$(ak),0)
    {
      #IFSWITCH MethodName==sort
      arr[k]=($exposedType$)0.0;
      arr[begin]=($exposedType$)-0.0;
      #ELSE
      arr[k]=($exposedType$)-0.0;
      arr[begin]=($exposedType$)0.0;
      #ENDIF
      ++begin;
    }
  }
    #ENDIF
}
  #ENDIF
  #IF OfChar,OfByte,OfShort
private static void countingMethodName($ArrayType$[] arr,int begin,int end)
{
  int[] count=new int[($BoxedType$.MAX_VALUE+1)-$BoxedType$.MIN_VALUE];
  for(int i=begin;;++i)
  {
    #IF OfChar
    ++count[arr[i]];
    #ELSE
    ++count[arr[i]-$BoxedType$.MIN_VALUE];
    #ENDIF
    if(i==end)
    {
      break;
    }
  }
    #IFSWITCH MethodName==sort
  for(int i=($BoxedType$.MAX_VALUE+1)-$BoxedType$.MIN_VALUE;;)
  {
    int s;
    while((s=count[--i])==0){}
    #ELSE
  for(int i=-1;;)
  {
    int s;
    while((s=count[++i])==0){}
    #ENDIF
    #IF OfChar
    $ArrayType$ value=($ArrayType$)i;
    #ELSE
    $ArrayType$ value=($ArrayType$)(i+$BoxedType$.MIN_VALUE);
    #ENDIF
    for(;;--end)
    {
      arr[end]=value;
      if(end==begin)
      {
        return;
      }
      if(--s==0)
      {
        break;
      }
    }
  }
}
  #ENDIF
  #IFNOT OfRef,OfBoolean
private static void insertMethodName($ArrayType$[] arr,int begin,int end)
{
  for(int i=begin,j=i;i!=end;j=++i)
  {
    final $ArrayType$ ai=arr[i+1];
    $ArrayType$ aj;
    #MACRO WhileLessThan(ai,aj=arr[j])
    {
      arr[j+1]=aj;
      if(--j==begin)
      {
        break;
      }
    }
    arr[j+1]=ai;
  }
}
  #ENDIF
  #IF OfChar,OfShort,OfInt,OfLong,OfFloat,OfDouble
private static void sentinelInsertMethodName($ArrayType$[] arr,int begin,int end)
{
  for(;;)
  {
    if(begin>=end)
    {
      return;
    }
    #MACRO IfLessThan(arr[++begin],arr[begin-1])
    {
      break;
    }
  }
  for(int k=begin;++begin<=end;k=++begin)
  {
    $ArrayType$ a1,a2;
    #MACRO IfLessThan(a1=arr[k],a2=arr[begin])
    {
      a2=a1;
      a1=arr[begin];
    }
    $ArrayType$ ak;
    #MACRO WhileLessThan(a1,ak=arr[--k])
    {
      arr[k+2]=ak;
    }
    arr[++k+1]=a1;
    #MACRO WhileLessThan(a2,ak=arr[--k])
    {
      arr[k+1]=ak;
    }
    arr[k+1]=a2;
  }
  $ArrayType$ ae,last=arr[end];
  #MACRO WhileLessThan(last,ae=arr[--end])
  {
    arr[end+1]=ae;
  }
  arr[end+1]=last;
}
  #IF OfInt,OfLong
public static void uncheckedMethodName($ArrayType$[] arr,int begin,int end)
  #ELSE
public static void doMethodName($ArrayType$[] arr,int begin,int end)
  #ENDIF
{
  if(end-begin<286)
  {
    quickMethodNameleftmost(arr,begin,end);
  }
  else
  {
    int[] run;
    int count=0;
    (run=new int[68])[0]=begin;
    for(int k=begin;k!=end;)
    {
    #IF OfDouble,OfFloat
      #MACRO IfLessThan(arr[k],arr[k+1])
      {
    #ELSE
      #MACRO SwitchSigNum(arr[k],arr[k+1])
      {
      case -1:
    #ENDIF
        for(;;)
        {
          if(++k>end
          ||
          #MACRO MethodNameCall(arr[k],arr[k-1])
          )
          {
            break;
          }
        }
    #IF OfDouble,OfFloat
      }
      else
      #MACRO IfGreaterThan(arr[k],arr[k+1])
      {
    #ELSE
        break;
      default:
    #ENDIF
        for(;;)
        {
          if(++k>end
          ||
          #MACRO MethodNameCall(arr[k-1],arr[k])
          )
          {
            break;
          }
        }
        for(int lo=run[count],hi=k;lo<--hi;++lo)
        {
          $ArrayType$ tmp=arr[lo];
          arr[lo]=arr[hi];
          arr[hi]=tmp;
        }
    #IF OfDouble,OfFloat
      }
      else
      {
    #ELSE
        break;
      case 0:
    #ENDIF
        ++k;
        continue;
      }
      if(run[count]<=begin ||
      #MACRO MethodNameCall(arr[run[count]],arr[run[count]-1])
      )
      {
        if(++count==67)
        {
          quickMethodNameleftmost(arr,begin,end);
          return;
        }
      }
      run[count]=k;
    }
    if(count==0 || (count==1 && run[count]>end))
    {
      return;
    }
    if(run[count]<++end)
    {
      run[++count]=end;
    }
    MethodNamemerge(arr,begin,end,run,count);
  }
}
private static void MethodNamemerge($ArrayType$[] arr,int begin,int end,int[] run,int count)
{
  byte odd=0;
  for(int n=1;(n<<=1)<count;odd^=1){}
  $ArrayType$[] b;
  int ao,bo,blen;
  $ArrayType$[] work=new $ArrayType$[blen=end-begin];
  if(odd==0)
  {
    ArrCopy.uncheckedCopy(arr,begin,work,0,blen);
    b=arr;
    bo=0;
    arr=work;
    ao=-begin;
  }
  else
  {
    b=work;
    ao=0;
    bo=-begin;
  }
  for(int last;count>1;count=last)
  {
    for(int k=(last=0)+2;k<=count;k+=2)
    {
      int hi=run[k];
      int mi;
      for(int i=run[k-2],p=i,q=(mi=run[k-1]);i<hi;++i)
      {
        if(q<hi && (p>=mi || 
        #MACRO MethodNameCall(arr[q+ao],arr[p+ao])
        ))
        {
          b[i+bo]=arr[q++ +ao];
        }
        else
        {
          b[i+bo]=arr[p++ +ao];
        }
      }
      run[++last]=hi;
    }
    if((count&1)!=0)
    {
      for(int i=end,lo=run[count-1];--i>=lo;b[i+bo]=arr[i+ao]){}
      run[++last]=end;
    }
    $ArrayType$[] tmp=arr;
    arr=b;
    b=tmp;
    int o=ao;
    ao=bo;
    bo=o;
  }
}
#MACRO QuickSort<true>()
#MACRO QuickSort<false>()
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF QuickSort<LeftMost>()
#IFSWITCH LeftMost==true
private static void quickMethodNameleftmostSinglePivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot)
#ELSE
private static void quickMethodNameSinglePivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot)
#ENDIF
{
  int less=begin;
  int great=end;
  for(int k=less;k<=great;++k)
  {
    $ArrayType$ ak;
#IF OfDouble,OfFloat
    #MACRO IfLessThan(ak=arr[k],pivot)
    {
      arr[k]=arr[less];
      arr[less]=ak;
      ++less;
    }
    else
    #MACRO IfGreaterThan(ak,pivot)
    {
      $ArrayType$ ag;
      #MACRO WhileGreaterThan(ag=arr[great],pivot)
      {
        --great;
      }
      #MACRO IfLessThan(ag,pivot)
      {
        arr[k]=arr[less];
        arr[less]=ag;
        ++less;
      }
      else
      {
        arr[k]=pivot;
      }
      arr[great]=ak;
      --great;
    }
#ELSE
    #MACRO SwitchSigNum(ak=arr[k],pivot)
    {
    case -1:
      arr[k]=arr[less];
      arr[less]=ak;
      ++less;
    case 0:
      break;
    default:
      forLoop: for(;;)
      {
        $ArrayType$ ag;
        #MACRO SwitchSigNum(pivot,ag=arr[great])
        {
          case 0:
            arr[k]=pivot;
            break forLoop;
          default:
            arr[k]=arr[less];
            arr[less]=ag;
            ++less;
            break forLoop;
          case -1:
            --great;
        }
      }
      arr[great]=ak;
      --great;
    }
#ENDIF
  }
#IFSWITCH LeftMost==true
  quickMethodNameleftmost(arr,begin,less-1);
#ELSE
  quickMethodName(arr,begin,less-1);
#ENDIF
  quickMethodName(arr,great+1,end);
}
#IFSWITCH LeftMost==true
private static void quickMethodNameleftmostDualPivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot1, $ArrayType$ pivot2,int e1,int e5)
#ELSE
private static void quickMethodNameDualPivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot1, $ArrayType$ pivot2,int e1,int e5)
#ENDIF
{
  int less=begin;
  int great=end;
  #MACRO WhileLessThan(arr[++less],pivot1)
  {
  }
  #MACRO WhileGreaterThan(arr[--great],pivot2)
  {
  }
  outer: for(int k=less;k<=great;++k)
  {
    $ArrayType$ ak;
    #MACRO IfLessThan(ak=arr[k],pivot1)
    {
      arr[k]=arr[less];
      arr[less]=ak;
      ++less;
    }
    else
    #MACRO IfGreaterThan(ak,pivot2)
    {
      $ArrayType$ ag;
      #MACRO WhileGreaterThan(ag=arr[great],pivot2)
      {
        if(great--==k)
        {
          break outer;
        }
      }
      #MACRO IfLessThan(ag,pivot1)
      {
        arr[k]=arr[less];
        arr[less]=ag;
        ++less;
      }
      else
      {
        arr[k]=ag;
      }
      arr[great]=ak;
      --great;
    }
  }
  arr[begin]=arr[less-1];
  arr[less-1]=pivot1;
  arr[end]=arr[great+1];
  arr[great+1]=pivot2;
#IFSWITCH LeftMost==true
  quickMethodNameleftmost(arr,begin,less-2);
#ELSE
  quickMethodName(arr,begin,less-2);
#ENDIF
  quickMethodName(arr,great+2,end);
  if(less<e1 && e5<great)
  {
    #MACRO WhileEqualTo(arr[less],pivot1)
    {
      ++less;
    }
    #MACRO WhileEqualTo(arr[great],pivot2)
    {
      --great;
    }
    outer: for(int k=less;k<=great;++k)
    {
      $ArrayType$ ak;
      #MACRO IfEqualTo(ak=arr[k],pivot1)
      {
        arr[k]=arr[less];
        arr[less]=ak;
        ++less;
      }
      else
      #MACRO IfEqualTo(ak,pivot2)
      {
        $ArrayType$ ag;
        #MACRO WhileEqualTo(ag=arr[great],pivot2)
        {
          if(great--==k)
          {
            break outer;
          }
        }
        #MACRO IfEqualTo(ag,pivot1)
        {
          arr[k]=arr[less];
          arr[less]=pivot1;
          ++less;
        }
        else
        {
          arr[k]=ag;
        }
        arr[great]=ak;
        --great;
      }
    }
  }
  quickMethodName(arr,less,great);
}
#IFSWITCH LeftMost==true
private static void quickMethodNameleftmost($ArrayType$[] arr,int begin,int end)
#ELSE
private static void quickMethodName($ArrayType$[] arr,int begin,int end)
#ENDIF
{
  int length;
  if((length=end-begin+1)<47)
  {
#IFSWITCH LeftMost==true
    insertMethodName(arr,begin,end);
#ELSE
    sentinelInsertMethodName(arr,begin,end);
#ENDIF
    return;
  }
  int seventh,e1,e2,e3,e4,e5;
  $ArrayType$ val1,val2,val3,val4,val5;
  #MACRO IfLessThan(val2=arr[e2=(e3=(begin+end)>>>1)-(seventh=(length>>3)+(length>>6)+1)],val1=arr[e1=e2-seventh])
  {
    $ArrayType$ tmp=val2;
    val2=val1;
    val1=tmp;
  }
  #MACRO IfLessThan(val3=arr[e3],val2)
  {
    $ArrayType$ tmp=val3;
    val3=val2;
    #MACRO IfLessThan(tmp,val1)
    {
      val2=val1;
      val1=tmp;
    }
    else
    {
      val2=tmp;
    }
  }
  #MACRO IfLessThan(val4=arr[e4=e3+seventh],val3)
  {
    $ArrayType$ tmp=val4;
    val4=val3;
    #MACRO IfLessThan(tmp,val2)
    {
      val3=val2;
      #MACRO IfLessThan(tmp,val1)
      {
        val2=val1;
        val1=tmp;
      }
      else
      {
        val2=tmp;
      }
    }
    else
    {
      val3=tmp;
    }
  }
  #MACRO IfLessThan(val5=arr[e5=e4+seventh],val4)
  {
    $ArrayType$ tmp=val5;
    val5=val4;
    #MACRO IfLessThan(tmp,val3)
    {
      val4=val3;
      #MACRO IfLessThan(tmp,val2)
      {
        val3=val2;
        #MACRO IfLessThan(tmp,val1)
        {
          val2=val1;
          val1=tmp;
        }
        else
        {
          val2=tmp;
        }
      }
      else
      {
        val3=tmp;
      }
    }
    else
    {
      val4=tmp;
    }
  }
  
  arr[e1]=val1;
  arr[e3]=val3;
  arr[e5]=val5;
  if(
  #MACRO MethodNameEqualsCall(val1,val2)
  ||
  #MACRO MethodNameEqualsCall(val2,val3)
  ||
  #MACRO MethodNameEqualsCall(val3,val4)
  ||
  #MACRO MethodNameEqualsCall(val4,val5)
  )
  {
    arr[e2]=val2;
    arr[e4]=val4;
#IFSWITCH LeftMost==true
    quickMethodNameleftmostSinglePivot(arr,begin,end,val3);
#ELSE
    quickMethodNameSinglePivot(arr,begin,end,val3);
#ENDIF
  }
  else
  {
     arr[e2]=arr[begin];
     arr[e4]=arr[end];
#IFSWITCH LeftMost==true
    quickMethodNameleftmostDualPivot(arr,begin,end,val2,val4,e1,e5);
#ELSE
    quickMethodNameDualPivot(arr,begin,end,val2,val4,e1,e5);
#ENDIF

  }
}
#ENDDEF
#IFNOT OfBoolean
 
#ENDIF
  #MACRO UncheckedSort<sort>()
  #MACRO UncheckedSort<reverseSort>()
  #MACRO UncheckedSort<comparatorSort>()
  
}