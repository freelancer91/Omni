#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.util;
#IF OfRef
import java.util.Comparator;
#ELSEIF OfInt
import java.util.function.$Comparator$;
#ELSE
import omni.function.$Comparator$;
#ENDIF

public final class $ClassPrefix$SortUtil
{
  private $ClassPrefix$SortUtil()
  {
    super();
  }

#IF OfBoolean
  public static void uncheckedSort($ArrayType$[] arr,int offset,int bound,$Comparator$ sorter)
  {
    final $ArrayType$ lastVal;
    int i;
    if((lastVal=arr[--bound])==arr[i=bound-1])
    {
      do
      {
        if(i==offset)
        {
          //homogenous array
          return;
        }
      }
      while(arr[--i]==lastVal);
    }
    switch(Integer.signum(sorter.compare(lastVal,!lastVal)))
    {
    case 1:
      for(;i!=offset;++offset)
      {
        if(arr[offset]==lastVal)
        {
          uncheckedSortHelper(arr,offset,i,!lastVal);
          return;
        }
      }
    case 0:
      //already sorted
      return;
    default:
      int firstValCounter=1;
      while(i!=offset)
      {
        if(arr[--i]^lastVal)
        {
          ++firstValCounter;
        }
      }
      final $ArrayType$ firstVal;
      for(arr[bound]=(firstVal=!lastVal);--firstValCounter!=0;arr[--bound]=firstVal){}
      do
      {
        arr[--bound]=lastVal;
      }
      while(offset!=bound);
    }
  }
  #MACRO BooleanSort<Ascending>()
  #MACRO BooleanSort<Descending>()
#MACRODEF BooleanSort<DIRECTION>()
public static void uncheckedDIRECTIONSort($ArrayType$[] arr,int offset,int bound)
{
while(
  #IFSWITCH DIRECTION==Descending
    !
  #ENDIF
    arr[--bound])
  {
    if(bound==offset)
    {
      //already sorted
      return;
    }
  }
  for(;offset!=bound;++offset)
  {
     if(
  #IFSWITCH DIRECTION==Descending
      !
  #ENDIF
      arr[offset])
    {
      uncheckedSortHelper(arr,offset,bound,
  #IFSWITCH DIRECTION==Descending
        true
  #ELSE
        false
  #ENDIF
      );
      return;
    }
  }
  //already sorted
}
#ENDDEF

  private static void uncheckedSortHelper($ArrayType$[] arr,int begin,int end,$ArrayType$ firstVal)
  {
    #MACRO Assert(arr!=null)
    #MACRO Assert(begin>=0)
    #MACRO Assert(end<arr.length)
    #MACRO Assert(begin<end)
    #MACRO Assert(firstVal!=arr[begin])
    #MACRO Assert(firstVal==arr[end])
    int endValCounter=1;
    for(int curr=begin+1;curr!=end;++curr)
    {
      if(arr[curr]^firstVal)
      {
        ++endValCounter;
      }
    }
    for(final var endVal=!firstVal;;--end)
    {
      arr[end]=endVal;
      if(--endValCounter==0)
      {
        do
        {
          arr[--end]=firstVal;
        }
        while(end!=begin);
        return;
      }
    }
  }
#ELSE
  #MACRO UnstableComparatorSort<$Comparator$>()
#MACRODEF UnstableComparatorSort<COMPARATORTYPE>()
  #MACRO SuppressUnchecked()
  public static $<E>$ void uncheckedUnstableSort($ArrayType$[] arr,int offset,int bound,$Comparator$$<? super E>$ sorter)
  {
     #MACRO MainUnstableSortImpl()
  }
#ENDDEF


  #MACRO NonComparatorUnstableSort<Ascending>()
  #MACRO NonComparatorUnstableSort<Descending>()
#MACRODEF NonComparatorUnstableSort<COMPARATORTYPE>()
#MACRO SuppressUnchecked()
#IF OfRef
public static $<E>$ void uncheckedUnstableCOMPARATORTYPESort($ArrayType$[] arr,int offset,int bound)
#ELSE
public static void uncheckedCOMPARATORTYPESort($ArrayType$[] arr,int offset,int bound)
#ENDIF
{
#IF OfByte
  if((--bound)-offset<30)
  {
    COMPARATORTYPEinsertSort(arr,offset,bound);
  }
  else
  {
    COMPARATORTYPEcountingSort(arr,offset,bound);
  }
#ELSE
  #IF OfChar,OfShort
  int nRemaining;
  if((nRemaining=(--bound)-offset)>3200)
  {
    COMPARATORTYPEcountingSort(arr,offset,bound);
    return;
  }
  #ELSEIF OfFloat,OfDouble
  for(--bound;;)
  {
    #IFSWITCH COMPARATORTYPE==Ascending
    if(!$BoxedType$.isNaN(arr[bound]))
    #ELSE
    if(!$BoxedType$.isNaN(arr[offset]))
    #ENDIF
    {
      break;
    }
    #IFSWITCH COMPARATORTYPE==Ascending
    if(--bound==offset)
    #ELSE
    if(++offset==bound)
    #ENDIF
    {
      //already sorted
      return;
    }
  }
  #IFSWITCH COMPARATORTYPE==Ascending
  for(int k=bound;--k>=offset;)
  #ELSE
  for(int k=offset;++k<=bound;)
  #ENDIF
  {
    $ArrayType$ ak;
    if($BoxedType$.isNaN(ak=arr[k]))
    {
  #IFSWITCH COMPARATORTYPE==Ascending
      arr[k]=arr[bound];
      arr[bound]=ak;
      --bound;
  #ELSE
      arr[k]=arr[offset];
      arr[offset]=ak;
      ++offset;
  #ENDIF
    }
  }
  #ENDIF
  #MACRO MainUnstableSortImpl()
  #IF OfFloat,OfDouble
  COMPARATORTYPEmoveZeros(arr,offset,bound);
  #ENDIF
#ENDIF
}
#ENDDEF

  #MACRO StableSort<$Comparator$$<? super E>$>()
  #IF OfRef
  #MACRO StableSort<Ascending>()
  #MACRO StableSort<Descending>()
  #ENDIF
#MACRODEF StableSort<COMPARATORTYPE>()
#IFSWITCH COMPARATORTYPE==Ascending,Descending
public static $<E>$ void uncheckedStableCOMPARATORTYPESort($ArrayType$[] arr,int offset,int bound)
#ELSE
public static $<E>$ void uncheckedStableSort($ArrayType$[] arr,int offset,int bound,COMPARATORTYPE sorter)
#ENDIF
{
  int nRemaining;
  if((nRemaining=bound-offset)<32)
  {
#IFSWITCH COMPARATORTYPE==Ascending,Descending
    COMPARATORTYPE$ClassPrefix$TimSort.binarySort(arr,offset,bound,offset+COMPARATORTYPE$ClassPrefix$TimSort.countRunAndMakeAscending(arr,offset,bound));
#ELSE
    $ClassPrefix$TimSort.binarySort(arr,offset,bound,offset+$ClassPrefix$TimSort.countRunAndMakeAscending(arr,offset,bound,sorter),sorter);
#ENDIF
    return;
  }
#IFSWITCH COMPARATORTYPE==Ascending,Descending
  new COMPARATORTYPE$ClassPrefix$TimSort$<E>$(arr,nRemaining,offset,bound);
#ELSE
  new $ClassPrefix$TimSort$<E>$(arr,nRemaining,sorter,offset,bound);
#ENDIF
}

#IFSWITCH COMPARATORTYPE==Ascending,Descending
private static class COMPARATORTYPE$ClassPrefix$TimSort$<E>$ extends Abstract$ClassPrefix$TimSort$<E>$
#ELSE
private static class $ClassPrefix$TimSort$<E>$
  #IF OfRef
  extends Abstract$ClassPrefix$TimSort$<E>$
  #ELSE
  extends AbstractTimSort
  #ENDIF
#ENDIF
{
#IFNOTSWITCH COMPARATORTYPE==Ascending,Descending
  private transient final COMPARATORTYPE sorter;
  #IFNOT OfRef
  private transient final $ArrayType$[] arr;
  private transient $ArrayType$[] tmp;
  private transient int tmpOffset;
  private transient int tmpLength;
  private transient int minGallop;
  #MACRO EnsureCapacity()
  private $ClassPrefix$TimSort($ArrayType$[] arr,int nRemaining,COMPARATORTYPE sorter,int offset,int bound)
  {
    super(nRemaining);
    this.sorter=sorter;
    this.arr=arr;
    int tmpLength;
    this.tmpLength=tmpLength=nRemaining<512?nRemaining>>>1:256;
    this.tmp=new $ArrayType$[tmpLength];
    this.minGallop=7;
  #ELSE
  private $ClassPrefix$TimSort($ArrayType$[] arr,int nRemaining,COMPARATORTYPE sorter,int offset,int bound)
  {
    super(arr,nRemaining);
    this.sorter=sorter;
  #ENDIF
#ELSE
  private COMPARATORTYPE$ClassPrefix$TimSort($ArrayType$[] arr,int nRemaining,int offset,int bound)
  {
    super(arr,nRemaining);
#ENDIF
    int minRun=AbstractTimSort.minRunLength(nRemaining);
    int runLen;
    do
    {
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
      if((runLen=COMPARATORTYPE$ClassPrefix$TimSort.countRunAndMakeAscending(arr,offset,bound))<minRun)
  #ELSE
      if((runLen=$ClassPrefix$TimSort.countRunAndMakeAscending(arr,offset,bound,sorter))<minRun)
  #ENDIF
      {
        int force;
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
        COMPARATORTYPE$ClassPrefix$TimSort.binarySort(arr,offset,offset+(force=nRemaining<=minRun?nRemaining:minRun),offset+runLen);
  #ELSE
        $ClassPrefix$TimSort.binarySort(arr,offset,offset+(force=nRemaining<=minRun?nRemaining:minRun),offset+runLen,sorter);
  #ENDIF
        runLen=force;
      }
      super.mergeCollapse(offset,runLen);
      offset+=runLen;
    }
    while((nRemaining-=runLen)!=0);
    #MACRO Assert(offset==bound)
    super.mergeForceCollapse(); 
  }
  #MACRO SuppressUnchecked()
  @Override
  int mergeAt(int n,int stackSize,int[] runLenAndBase)
  {
    #MACRO Assert(stackSize>=4)
    #MACRO Assert(n>=0)
    #MACRO Assert(n==stackSize-4 || n==stackSize-6)
    #MACRO Assert(runLenAndBase[n]>0)
    #MACRO Assert(runLenAndBase[n+2]>0)
    #MACRO Assert(runLenAndBase[n]+runLenAndBase[n+1]==runLenAndBase[n+3])
    int len1,len2;
    runLenAndBase[n]=(len1=runLenAndBase[n])+(len2=runLenAndBase[n+2]);
    int base2=runLenAndBase[n+3];
    if(n==stackSize-6)
    {
      runLenAndBase[n+3]=runLenAndBase[n+5];
      runLenAndBase[n+2]=runLenAndBase[n+4];
    }
    $ArrayType$[] arr;
    int k,base1;
    //TODO streamline this?
#IFSWITCH COMPARATORTYPE==Ascending,Descending
    base1=(base1=runLenAndBase[n+1])+(k=mergeAtGallopRight(($comparableType$)(arr=this.arr)[base2],arr,base1,len1));
#ELSE
    base1=(base1=runLenAndBase[n+1])+(k=mergeAtGallopRight(($exposedType$)(arr=this.arr)[base2],arr,base1,len1,sorter));
#ENDIF
    #MACRO Assert(k>=0)
    if((len1-=k)!=0)
    {

#IFSWITCH COMPARATORTYPE==Ascending,Descending
      //if((len2=mergeAtGallopLeft(($comparableType$)arr[base1+len1-1],arr,base2,len2))!=0)
      //{
      //  if(len1<=len2)
      if(len1<=(len2=mergeAtGallopLeft(($comparableType$)arr[base1+len1-1],arr,base2,len2)))
#ELSE
      //if((len2=mergeAtGallopLeft(($exposedType$)arr[base1+len1-1],arr,base2,len2),sorter)!=0)
      //{
      //  if(len1<=len2)
      if(len1<=(len2=mergeAtGallopLeft(($exposedType$)arr[base1+len1-1],arr,base2,len2,sorter)))
#ENDIF
      {
      
        mergeLo(arr,base1,len1,base2,len2);
      }
      else
      {
        mergeHi(arr,base1,len1,base2,len2);
      }
      //}
    }
    return stackSize-2;
  }
  #MACRO SuppressUnchecked()
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
  private static $<E>$ int mergeAtGallopLeft($comparableType$ key,$ArrayType$[] arr,int base,int len)
  #ELSE
  private static $<E>$ int mergeAtGallopLeft($exposedType$ key,$ArrayType$[] arr,int base,int len,COMPARATORTYPE sorter)
  #ENDIF
  {
    #MACRO Assert(len>0)
    int ofs;
    int lastOfs;
    #MACRO IfClause(GreaterThan,key,arr[base+len-1])
    {
      return len;
    }
    #MACRO Assert(len>=2)
    //#if(len<2 ||
    //#MACRO LessThanOrEqualTo(key,arr[base+len-2])
    //)
    #MACRO IfClause(LessThanOrEqualTo,key,arr[base+len-2])
    {
      lastOfs=-1;
    }
    else
    {
      lastOfs=len-2;
    }
    #MACRO Assert(-1<=lastOfs)
    #MACRO Assert(lastOfs<(len-1))
    if(++lastOfs<(ofs=(len-1)))
    {
      do
      {
        int m;
        #MACRO IfClause(GreaterThan,key,arr[base+(m=lastOfs+((ofs-lastOfs)>>>1))])
        {
          lastOfs=m+1;
        }
        else
        {
          ofs=m;
        }
      }
      while(lastOfs<ofs);
    }
    #MACRO Assert(lastOfs==ofs)
    return ofs;
  }
  #MACRO SuppressUnchecked()
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
  private static $<E>$ int mergeAtGallopRight($comparableType$ key,$ArrayType$[] arr,int base,int len)
  #ELSE
  private static $<E>$ int mergeAtGallopRight($exposedType$ key,$ArrayType$[] arr,int base,int len,COMPARATORTYPE sorter)
  #ENDIF
  {
    #MACRO Assert(len>0)
    int ofs;
    int lastOfs;
  
    #MACRO IfClause(LessThan,key,arr[base])
    {
      return 0;
    }
    #MACRO Assert(len>=2)
    //#if(len<2 ||
    //#MACRO GreaterThanOrEqualTo(key,arr[base+1])
    //)
    #MACRO IfClause(GreaterThanOrEqualTo,key,arr[base+1])
    {
      ofs=len;
    }
    else
    {
      ofs=1;
    }
    lastOfs=0;
    #MACRO Assert(-1<=lastOfs)
    #MACRO Assert(lastOfs<ofs)
    #MACRO Assert(ofs<=len)
    if(++lastOfs<ofs)
    {
      do
      {
        int m;
        #MACRO IfClause(GreaterThanOrEqualTo,key,arr[base+(m=lastOfs+((ofs-lastOfs)>>>1))])
        {
          lastOfs=m+1;
        }
        else
        {
          ofs=m;
        }
      }
      while(lastOfs<ofs);
    }
    #MACRO Assert(lastOfs==ofs)
    return ofs;
  }
  /**
   * Merges two adjacent runs in place in a stable fashion. THe first element of the first run
   * must be greater than the first element of the second run (arr[base1]>arr[base2]), and th elast element of the
   * first run (arr[base1+len1-1]) must be greater than all the elements of the second run.
   * For performance, this method should only be called when len1<=len2. It's twin, mergeHi, should be called win len1>=len2
   * (Either may be called when they are equal)
   * @param arr the array to merge
   * @param base1 the index of the first element in the first run to be merged
   * @param len1 the length of the first run to be merged
   * @param base2 the index of the first element in the second run to be merged
   * @param len2 the length of the second run to be merged
   */
  #MACRO Merge<Lo,arr,tmp,++,1,2>()
  /**
   * Like mergeLo, except that this method should be called only if
   * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
   * may be called if len1 == len2.)
   *
   * @param base1 index of first element in first run to be merged
   * @param len1  length of first run to be merged (must be > 0)
   * @param base2 index of first element in second run to be merged
   *        (must be aBase + aLen)
   * @param len2  length of second run to be merged (must be > 0)
   */
  #MACRO Merge<Hi,tmp,arr,--,2,1>()
  /** 
   * Locates the position at which to insert the specified key into the specified sorted range;
   * if the range contains and element equal to the key, return the index of the leftmost equal element.
   *
   * @param key the key to find the insertion point for
   * @param arr The array in which to search
   * @param base The index of the first element in the range
   * @param len The length of the range (must be >0)
   * @param hint The index at which to begin the search, 0 <= hint < len. The closer hint is to the result,
   *   this faster this method will run.
  #IFNOTSWITCH COMPARATORTYPE==Ascending,Descending
   * @param sorter The comparator used to order the range and search
  #ENDIF
   * @return the int k, 0<=k<=len such that arr[base+k-1]< key<=arr[base+k],
   *   pretending that arr[base-1] is minus infinity or add[base+len] is infinity.
   *   In other words, key belonds at index base + k; or in other words, the first k elements should precede the key,
   *   and the last len-k elements should follow it.
   */
  #MACRO Gallop<Left,Right>(GreaterThan,hint+1,len-hint,LessThanOrEqualTo,-,+,GreaterThan)
  /**
   * Like gallopLeft, except that if the range contains an element equal to key, gallopRight returns the index
   * after the rightmost equal element
   *
   * @param key the key to find the insertion point for
   * @param arr The array in which to search
   * @param base The index of the first element in the range
   * @param len The length of the range (must be >0)
   * @param hint The index at which to begin the search, 0 <= hint < len. The closer hint is to the result,
   *   this faster this method will run.
  #IFNOTSWITCH COMPARATORTYPE==Ascending,Descending
   * @param sorter The comparator used to order the range and search
  #ENDIF
   * @return the int k, 0<=k<=len such that arr[base+k-1]<= key<arr[base+k]
   */
  #MACRO Gallop<Right,Left>(LessThan,len-hint,hint+1,GreaterThanOrEqualTo,+,-,GreaterThanOrEqualTo)
  #MACRO SuppressUnchecked()
  private static $<E>$ void binarySort($ArrayType$[] arr,int lo,int hi,int start
  #IFNOTSWITCH COMPARATORTYPE==Ascending,Descending
    ,COMPARATORTYPE sorter
  #ENDIF
  )
  {
    #MACRO Assert(lo<=start)
    #MACRO Assert(start<=hi)
    //TODO streamline
    for(;start<hi;++start)
    {
      final
      #MACRO DeclareAndSetTmp(pivot,arr[start])
      #MACRO Assert(lo<start)
      int left=lo;
      int right=start;
      do
      {
        int mid;
        #MACRO IfClause(LessThan,pivot,arr[mid=(left+right)>>>1])
        {
          right=mid;
        }
        else
        {
          left=mid+1;
        }
      }
      while(left<right);
      #MACRO Assert(left==right)
      ArrCopy.semicheckedCopy(arr,left,arr,left+1,start-left);
      arr[left]=pivot;
    }
  }
  #MACRO SuppressUnchecked()
  private static $<E>$ int countRunAndMakeAscending($ArrayType$[] arr,int lo,int hi
  #IFNOTSWITCH COMPARATORTYPE==Ascending,Descending
    ,COMPARATORTYPE sorter
  #ENDIF
  )
  {
    //TODO streamline
    #MACRO Assert(lo<hi)
    int runHi;
    if((runHi=lo+1)==hi)
    {
      return 1;
    }
    #MACRO IfClause(LessThan,arr[runHi++],arr[lo])
    {
      if(runHi<hi)
      {
        #MACRO WhileClause(LessThan,arr[runHi],arr[runHi-1])
        {
          if(++runHi==hi)
          {
            break;
          }
        }
      }
      OmniArray.Of$ClassPrefix$.reverseRange(arr,lo,runHi-1);
    }
    else
    {
      if(runHi<hi)
      {
        #MACRO WhileClause(GreaterThanOrEqualTo,arr[runHi],arr[runHi-1])
        {
          if(++runHi==hi)
          {
            break;
          }
        }
        
      }
    }
    return runHi-lo;
  }
}

#ENDDEF

  #MACRO InsertSort<Ascending>()
  #MACRO InsertSort<Descending>()
  #MACRO InsertSort<$Comparator$$<? super E>$>()
#MACRODEF InsertSort<COMPARATORTYPE>()
#MACRO SuppressUnchecked()
#IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ void COMPARATORTYPEinsertSort($ArrayType$[] arr,int begin,int end)
#ELSE
private static $<E>$ void insertSort($ArrayType$[] arr,int begin,int end,COMPARATORTYPE sorter)
#ENDIF
{
  for(int i=begin,j=i;i!=end;j=++i)
  {
#IFSWITCH COMPARATORTYPE==Ascending,Descending
    final $comparableType$ ai=($comparableType$)arr[i+1];
#ELSE
    final $exposedType$ ai=($exposedType$)arr[i+1];
#ENDIF
    $ArrayType$ aj;
    #MACRO WhileClause(LessThan,ai,aj=arr[j])
    {
      arr[j+1]=aj;
      if(j--==begin)
      {
        break;
      }
    }
    arr[j+1]=ai;
  }
}
#ENDDEF
  
  #IF OfByte,OfChar,OfShort
  #MACRO CountingSort<Ascending>()
  #MACRO CountingSort<Descending>()
#MACRODEF CountingSort<COMPARATORTYPE>()
private static void COMPARATORTYPEcountingSort($ArrayType$[] arr,int begin,int end)
{
  int[] count=new int[($BoxedType$.MAX_VALUE+1)-$BoxedType$.MIN_VALUE];
  for(int i=begin;;++i)
  {
    #IF OfChar
    ++count[arr[i]];
    #ELSE
    ++count[arr[i]-$BoxedType$.MIN_VALUE];
    #ENDIF
    if(i==end)
    {
      break;
    }
  }
    #IFSWITCH COMPARATORTYPE==Ascending
  for(int i=($BoxedType$.MAX_VALUE+1)-$BoxedType$.MIN_VALUE;;)
  {
    int s;
    while((s=count[--i])==0){}
    #ELSE
  for(int i=-1;;)
  {
    int s;
    while((s=count[++i])==0){}
    #ENDIF
    #IF OfChar
    var value=($exposedType$)i;
    #ELSE
    var value=($exposedType$)(i+$BoxedType$.MIN_VALUE);
    #ENDIF
    do
    {
      arr[end]=value;
      if(--end<begin)
      {
        return;
      }
    }
    while(--s!=0);
  }
}
#ENDDEF
    #ENDIF

  #MACRO SentinelInsertSort<$Comparator$$<? super E>$>()
  #IFNOT OfByte
  #MACRO SentinelInsertSort<Ascending>()
  #MACRO SentinelInsertSort<Descending>()
  #ENDIF
#MACRODEF SentinelInsertSort<COMPARATORTYPE>()
#MACRO SuppressUnchecked()
#IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ void COMPARATORTYPEsentinelInsertSort($ArrayType$[] arr,int begin,int end)
#ELSE
private static $<E>$ void sentinelInsertSort($ArrayType$[] arr,int begin,int end,COMPARATORTYPE sorter)
#ENDIF
{
  do
  {
    if(begin>=end)
    {
      return;
    }
  }
  #MACRO WhileClause(LessThanOrEqualTo,arr[begin],arr[++begin])
  ;
  for(int k=begin;++begin<=end;k=++begin)
  {
#IFSWITCH COMPARATORTYPE==Ascending,Descending
    $comparableType$ a1,a2;
    #MACRO IfClause(LessThan,a1=($comparableType$)arr[k],a2=($comparableType$)arr[begin])
#ELSE
    $exposedType$ a1,a2;
    #MACRO IfClause(LessThan,a1=($exposedType$)arr[k],a2=($exposedType$)arr[begin])
#ENDIF
    {
      a2=a1;
#IFSWITCH COMPARATORTYPE==Ascending,Descending
      a1=($comparableType$)arr[begin];
#ELSE
      a1=($exposedType$)arr[begin];
#ENDIF
    }
    $exposedType$ ak;
    #MACRO WhileClause(LessThan,a1,ak=($exposedType$)arr[--k])
    {
      arr[k+2]=ak;
    }
    arr[++k+1]=a1;
    #MACRO WhileClause(LessThan,a2,ak=($exposedType$)arr[--k])
    {
      arr[k+1]=ak;
    }
    arr[k+1]=a2;
  }
  $exposedType$ ae;
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
  $comparableType$ last=($comparableType$)arr[end];
  #ELSE
  $exposedType$ last=($exposedType$)arr[end];
  #ENDIF
  #MACRO WhileClause(LessThan,last,ae=($exposedType$)arr[--end])
  {
    arr[end+1]=ae;
  }
  arr[end+1]=last;
}
#ENDDEF

  #MACRO QuickSort<$Comparator$$<? super E>$,true>()
  #MACRO QuickSort<$Comparator$$<? super E>$,false>()
  #IFNOT OfByte
  #MACRO QuickSort<Ascending,true>()
  #MACRO QuickSort<Ascending,false>()
  #MACRO QuickSort<Descending,true>()
  #MACRO QuickSort<Descending,false>()
  #ENDIF
#MACRODEF QuickSort<COMPARATORTYPE,LEFTMOST>()
#MACRO SuppressUnchecked()
#IFSWITCH LEFTMOST==true
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ void quickCOMPARATORTYPESortleftmost($ArrayType$[] arr,int begin,int end)
  #ELSE
private static $<E>$ void quickSortleftmost($ArrayType$[] arr,int begin,int end,COMPARATORTYPE sorter)
  #ENDIF
#ELSE
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ void quickCOMPARATORTYPESort($ArrayType$[] arr,int begin,int end)
  #ELSE
private static $<E>$ void quickSort($ArrayType$[] arr,int begin,int end,COMPARATORTYPE sorter)
  #ENDIF
#ENDIF
{
  int length;
  if((length=end-begin+1)<47)
  {
#IFSWITCH LEFTMOST==true
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
    COMPARATORTYPEinsertSort(arr,begin,end);
  #ELSE
    insertSort(arr,begin,end,sorter);
  #ENDIF
#ELSE
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
     COMPARATORTYPEsentinelInsertSort(arr,begin,end);
  #ELSE
     sentinelInsertSort(arr,begin,end,sorter);
  #ENDIF
#ENDIF
    return;
  }
  int seventh,e1,e2,e3,e4,e5;
#IFSWITCH COMPARATORTYPE==Ascending,Descending
  $comparableType$ val1,val2,val3,val4,val5;
  #MACRO IfClause(LessThan,val2=($comparableType$)arr[e2=(e3=(begin+end)>>>1)-(seventh=(length>>3)+(length>>6)+1)],val1=($comparableType$)arr[e1=e2-seventh])
#ELSE
  $exposedType$ val1,val2,val3,val4,val5;
  #MACRO IfClause(LessThan,val2=($exposedType$)arr[e2=(e3=(begin+end)>>>1)-(seventh=(length>>3)+(length>>6)+1)],val1=($exposedType$)arr[e1=e2-seventh])
#ENDIF
  {
    #MACRO DeclareAndSetTmp(tmp,val2)
    val2=val1;
    val1=tmp;
  }
  #MACRO QuickSortCompare(val3,arr[e3],val2)
  {
    #MACRO DeclareAndSetTmp(tmp,val3)
    val3=val2;
    #MACRO IfClause(LessThan,tmp,val1)
    {
      val2=val1;
      val1=tmp;
    }
    else
    {
      val2=tmp;
    }
  }
  #MACRO QuickSortCompare(val4,arr[e4=e3+seventh],val3)
  {
    #MACRO DeclareAndSetTmp(tmp,val4)
    val4=val3;
    #MACRO IfClause(LessThan,tmp,val2)
    {
      val3=val2;
      #MACRO IfClause(LessThan,tmp,val1)
      {
        val2=val1;
        val1=tmp;
      }
      else
      {
        val2=tmp;
      }
    }
    else
    {
      val3=tmp;
    }
  }
  #MACRO QuickSortCompare(val5,arr[e5=e4+seventh],val4)
  {
    #MACRO DeclareAndSetTmp(tmp,val5)
    val5=val4;
    #MACRO IfClause(LessThan,tmp,val3)
    {
      val4=val3;
      #MACRO IfClause(LessThan,tmp,val2)
      {
        val3=val2;
        #MACRO IfClause(LessThan,tmp,val1)
        {
          val2=val1;
          val1=tmp;
        }
        else
        {
          val2=tmp;
        }
      }
      else
      {
        val3=tmp;
      }
    }
    else
    {
      val4=tmp;
    }
  }
  arr[e1]=val1;
  arr[e3]=val3;
  arr[e5]=val5;
  if(
  #MACRO EqualTo(val1,val2)
  ||
  #MACRO EqualTo(val2,val3)
  ||
  #MACRO EqualTo(val3,val4)
  ||
  #MACRO EqualTo(val4,val5)
  )
  {
    arr[e2]=val2;
    arr[e4]=val4;
#IFSWITCH LEFTMOST==true
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
    quickCOMPARATORTYPESortleftmostSinglePivot(arr,begin,end,val3);
  #ELSE
    quickSortleftmostSinglePivot(arr,begin,end,val3,sorter);
  #ENDIF
#ELSE
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
    quickCOMPARATORTYPESortSinglePivot(arr,begin,end,val3);
  #ELSE
    quickSortSinglePivot(arr,begin,end,val3,sorter);
  #ENDIF
    
#ENDIF
  }
  else
  {
     arr[e2]=arr[begin];
     arr[e4]=arr[end];
#IFSWITCH LEFTMOST==true
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
     quickCOMPARATORTYPESortleftmostDualPivot(arr,begin,end,val2,val4,e1,e5);
  #ELSE
     quickSortleftmostDualPivot(arr,begin,end,val2,val4,e1,e5,sorter);
  #ENDIF
    
#ELSE
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
     quickCOMPARATORTYPESortDualPivot(arr,begin,end,val2,val4,e1,e5);
  #ELSE
     quickSortDualPivot(arr,begin,end,val2,val4,e1,e5,sorter);
  #ENDIF
    
#ENDIF
  }
}
#ENDDEF

  #MACRO QuickSortDualPivot<$Comparator$$<? super E>$,true>()
  #MACRO QuickSortDualPivot<$Comparator$$<? super E>$,false>()
  #IFNOT OfByte
  #MACRO QuickSortDualPivot<Ascending,true>()
  #MACRO QuickSortDualPivot<Ascending,false>()
  #MACRO QuickSortDualPivot<Descending,true>()
  #MACRO QuickSortDualPivot<Descending,false>()
  #ENDIF
#MACRODEF QuickSortDualPivot<COMPARATORTYPE,LEFTMOST>()
#MACRO SuppressUnchecked()
#IFSWITCH LEFTMOST==true
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ void quickCOMPARATORTYPESortleftmostDualPivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot1, $comparableType$ pivot2,int e1,int e5)
  #ELSE
private static $<E>$ void quickSortleftmostDualPivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot1, $ArrayType$ pivot2,int e1,int e5,COMPARATORTYPE sorter)
  #ENDIF
#ELSE
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ void quickCOMPARATORTYPESortDualPivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot1, $comparableType$ pivot2,int e1,int e5)
  #ELSE
private static $<E>$ void quickSortDualPivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot1, $ArrayType$ pivot2,int e1,int e5,COMPARATORTYPE sorter)
  #ENDIF
#ENDIF
{
  int less=begin;
  int great=end;
  #MACRO WhileClause(LessThanOrEqualTo,arr[++less],pivot1)
  {
  }
  #MACRO WhileClause(GreaterThanOrEqualTo,arr[--great],pivot2)
  {
  }
  outer: for(int k=less;k<=great;++k)
  {
    #MACRO IfCompareAndSetLocal(LessThan,ak,arr[k],pivot1)
    {
      arr[k]=arr[less];
      arr[less]=ak;
      ++less;
    }
    else
    #MACRO IfClause(GreaterThan,ak,pivot2)
    {
      #MACRO WhileCompareAndSetLocal(GreaterThan,ag,arr[great],pivot2)
      {
        if(--great<k)
        {
          break outer;
        }
      }
      #MACRO IfClause(LessThan,ag,pivot1)
      {
        arr[k]=arr[less];
        arr[less]=ag;
        ++less;
      }
      else
      {
        arr[k]=ag;
      }
      arr[great]=ak;
      --great;
    }
  }
  arr[begin]=arr[less-1];
  arr[less-1]=pivot1;
  arr[end]=arr[great+1];
  arr[great+1]=pivot2;
#IFSWITCH LEFTMOST==true
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
  quickCOMPARATORTYPESortleftmost(arr,begin,less-2);
  #ELSE
  quickSortleftmost(arr,begin,less-2,sorter);
  #ENDIF
#ELSE
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
  quickCOMPARATORTYPESort(arr,begin,less-2);
  #ELSE
  quickSort(arr,begin,less-2,sorter);
  #ENDIF
#ENDIF
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
  quickCOMPARATORTYPESort(arr,great+2,end);
  #ELSE
  quickSort(arr,great+2,end,sorter);
  #ENDIF
  if(less<e1 && e5<great)
  {
    #MACRO WhileClause(EqualTo,arr[less],pivot1)
    {
      ++less;
    }
    #MACRO WhileClause(EqualTo,arr[great],pivot2)
    {
      --great;
    }
    outer: for(int k=less;k<=great;++k)
    {
      #MACRO IfCompareAndSetLocal(EqualTo,ak,arr[k],pivot1)
      {
        arr[k]=arr[less];
        arr[less]=ak;
        ++less;
      }
      else
      #MACRO IfClause(EqualTo,ak,pivot2)
      {
        #MACRO WhileCompareAndSetLocal(EqualTo,ag,arr[great],pivot2)
        {
          if(--great<k)
          {
            break outer;
          }
        }
        #MACRO IfClause(EqualTo,ag,pivot1)
        {
          arr[k]=arr[less];
          arr[less]=ag;
          ++less;
        }
        else
        {
          arr[k]=ag;
        }
        arr[great]=ak;
        --great;
      }
    }
  }
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
    quickCOMPARATORTYPESort(arr,less,great);
  #ELSE
    quickSort(arr,less,great,sorter);
  #ENDIF
}
#ENDDEF

  #MACRO QuickSortSinglePivot<$Comparator$$<? super E>$,true>()
  #MACRO QuickSortSinglePivot<$Comparator$$<? super E>$,false>()
  #IFNOT OfByte
  #MACRO QuickSortSinglePivot<Ascending,true>()
  #MACRO QuickSortSinglePivot<Ascending,false>()
  #MACRO QuickSortSinglePivot<Descending,true>()
  #MACRO QuickSortSinglePivot<Descending,false>()
  #ENDIF
#MACRODEF QuickSortSinglePivot<COMPARATORTYPE,LEFTMOST>()
#MACRO SuppressUnchecked()
#IFSWITCH LEFTMOST==true
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ void quickCOMPARATORTYPESortleftmostSinglePivot($ArrayType$[] arr,int begin,int end,$comparableType$ pivot)
  #ELSE
private static $<E>$ void quickSortleftmostSinglePivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot,COMPARATORTYPE sorter)
  #ENDIF
#ELSE
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ void quickCOMPARATORTYPESortSinglePivot($ArrayType$[] arr,int begin,int end,$comparableType$ pivot)
  #ELSE
private static $<E>$ void quickSortSinglePivot($ArrayType$[] arr,int begin,int end,$ArrayType$ pivot,COMPARATORTYPE sorter)
  #ENDIF
#ENDIF
{
  int less=begin;
  int great=end;
  for(int k=less;k<=great;++k)
  {
    $ArrayType$ ak;
#IF OfFloat,OfDouble
    #MACRO IfClause(LessThan,ak=arr[k],pivot)
    {
      arr[k]=arr[less];
      arr[less]=ak;
      ++less;
    }
    else
    #MACRO IfClause(GreaterThan,ak,pivot)
    {
      $ArrayType$ ag;
      #MACRO WhileClause(GreaterThan,ag=arr[great],pivot)
      {
        --great;
      }
      #MACRO IfClause(LessThan,ag,pivot)
      {
        arr[k]=arr[less];
        arr[less]=ag;
        ++less;
      }
      else
      {
        arr[k]=ag;
      }
      arr[great]=ak;
      --great;
    }
#ELSE
    #MACRO SwitchSigNum(ak=arr[k],pivot)
    {
    case -1:
      arr[k]=arr[less];
      arr[less]=ak;
      ++less;
    case 0:
      break;
    default:
      forLoop: for(;;)
      {
        $ArrayType$ ag;
        #MACRO SwitchSigNum(pivot,ag=arr[great])
        {
          case 0:
            arr[k]=pivot;
            break forLoop;
          default:
            arr[k]=arr[less];
            arr[less]=ag;
            ++less;
            break forLoop;
          case -1:
            --great;
        }
      }
      arr[great]=ak;
      --great;
    }
#ENDIF
  }
  if(--less>begin)
  {
#IFSWITCH LEFTMOST==true
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
  quickCOMPARATORTYPESortleftmost(arr,begin,less);
  #ELSE
  quickSortleftmost(arr,begin,less,sorter);
  #ENDIF
  
#ELSE
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
  quickCOMPARATORTYPESort(arr,begin,less);
  #ELSE
  quickSort(arr,begin,less,sorter);
  #ENDIF
  
#ENDIF
  }
#IFSWITCH COMPARATORTYPE==Ascending,Descending
  quickCOMPARATORTYPESort(arr,great+1,end);
#ELSE
  quickSort(arr,great+1,end,sorter);
#ENDIF
}
#ENDDEF  

  #MACRO Merge<$Comparator$$<? super E>$>()
  #IFNOT OfByte
  #MACRO Merge<Ascending>()
  #MACRO Merge<Descending>()
  #ENDIF
#MACRODEF Merge<COMPARATORTYPE>()
#MACRO SuppressUnchecked()
#IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ void COMPARATORTYPEmerge($ArrayType$[] arr,int begin,int end,int[] run,int count)
#ELSE
private static $<E>$ void merge($ArrayType$[] arr,int begin,int end,int[] run,int count,COMPARATORTYPE sorter)
#ENDIF
{
  
  byte odd=0;
  for(int n=1;(n<<=1)<=count;odd^=1){}
  $ArrayType$[] b;
  int ao,bo,blen;
  var work=new $ArrayType$[blen=end-begin+1];
  if(odd==0)
  {
    ArrCopy.uncheckedCopy(arr,begin,work,0,blen);
    b=arr;
    bo=0;
    arr=work;
    ao=-begin;
  }
  else
  {
    b=work;
    ao=0;
    bo=-begin;
  }
  run[++count]=++end;
  int last,k;
  do
  {
    for(last=0,k=2;k<=count;k+=2)
    {
      int hi=run[k];
      int mi;
      for(int i=run[k-2],p=i,q=(mi=run[k-1]);i<hi;++i)
      {
        if(q<hi && (p>=mi ||
        #MACRO LessThan(arr[q+ao],arr[p+ao])
        ))
        {
          b[i+bo]=arr[q++ +ao];
        }
        else
        {
          b[i+bo]=arr[p++ +ao];
        }
      }
      run[++last]=hi;
    }
    if((count&1)!=0)
    {
      for(int i=end,lo=run[count-1];--i>=lo;b[i+bo]=arr[i+ao]){}
      run[++last]=end;
    }
    var tmp=arr;
    arr=b;
    b=tmp;
    int o=ao;
    ao=bo;
    bo=o;
  }
  while((count=last)>1);
}
#ENDDEF 

  #IF OfFloat,OfDouble
  #MACRO MoveZeros<Ascending>()
  #MACRO MoveZeros<Descending>()
#MACRODEF MoveZeros<COMPARATORTYPE>()
private static void COMPARATORTYPEmoveZeros($ArrayType$[] arr,int begin,int end)
{
#IFSWITCH COMPARATORTYPE==Ascending
  int hi;
  if(begin<(hi=end))
  {
    //find the first zero, or first positive, or last negative
    do
    {
      int middle;
      if(arr[middle=(begin+hi)>>>1]<0)
      {
        begin=middle+1;
      }
      else
      {
        hi=middle;
      }
    }
    while(begin<hi);
  }
  //skip the last negative or all leading negative zeros
  while($convertToBits$(arr[begin])<0)
  {
    if(++begin>end)
    {
      return;
    }
  }
  //move the negative zeros to the beginning of the sub-range
  for(int p=begin-1;++begin<=end;)
  {
  #IF OfFloat
    switch($convertToBits$(arr[begin]))
    {
    default:
      return;
    case Integer.MIN_VALUE:
      arr[begin]=0.0f;
      arr[++p]=-0.0f;
    case 0:
    }
  #ELSE
    long bits;
    if((bits=$convertToBits$(arr[begin]))==Long.MIN_VALUE)
    {
      arr[begin]=0.0d;
      arr[++p]=-0.0d;
    }
    else if(bits!=0L)
    {
      return;
    }
  #ENDIF
  }
#ELSE
  int hi;
  if(begin<(hi=end))
  {
    //find the first zero, or first negative, or last positive
    do
    {
      int middle;
      if(arr[middle=(begin+hi)>>>1]>0)
      {
        begin=middle+1;
      }
      else
      {
        hi=middle;
      }
    }
    while(begin<hi);
  }
  //skip the last positive or all leading positive zeros
  while($convertToBits$(arr[begin])>=0)
  {
    if(++begin>end)
    {
      return;
    }
  }
  //move the positive zeros to the beginning of the sub-range
  for(int p=begin-1;++begin<=end;)
  {
  #IF OfFloat
    switch($convertToBits$(arr[begin]))
    {
    default:
      return;
    case 0:
      arr[begin]=-0.0f;
      arr[++p]=0.0f;
    case Integer.MIN_VALUE:
    }
  #ELSE
    long bits;
    if((bits=$convertToBits$(arr[begin]))==0L)
    {
      arr[begin]=-0.0d;
      arr[++p]=0.0d;
    }
    else if(bits!=Long.MIN_VALUE)
    {
      return;
    }
  #ENDIF
  }
#ENDIF
}
#ENDDEF
  #ENDIF

#ENDIF
#IF OfRef
  private static abstract class Abstract$ClassPrefix$TimSort$<E>$ extends AbstractTimSort
  {
    transient final $ArrayType$[] arr;
    transient $ArrayType$[] tmp;
    transient int tmpLength;
    transient int tmpOffset;
    transient int minGallop;
    Abstract$ClassPrefix$TimSort($ArrayType$[] arr,int nRemaining)
    {
      super(nRemaining);
      this.arr=arr;
      this.tmpLength=nRemaining=nRemaining<512?nRemaining>>>1:256;
      this.tmp=new Object[nRemaining];
      this.minGallop=7;
    }
    #MACRO EnsureCapacity()
  }
#ENDIF
}

#MACRODEF Gallop<LEFT,RIGHT>(GREATERTHAN,LMAXOFS,RMAXOFS,LCOMPARISON,LPLUS,RPLUS,BINARYSEARCHCOMPARISON)
//TODO split this up into mergeLo and mergeHi versions
#MACRO SuppressUnchecked()
#IFSWITCH COMPARATORTYPE==Ascending,Descending
private static $<E>$ int gallopLEFT($comparableType$ key,$ArrayType$[] arr,int base,int len,int hint)
#ELSE
private static $<E>$ int gallopLEFT($exposedType$ key,$ArrayType$[] arr,int base,int len,int hint,COMPARATORTYPE sorter)
#ENDIF
{
  #MACRO Assert(len>0)
  #MACRO Assert(hint>=0)
  #MACRO Assert(hint<len)
  int ofs;
  int lastOfs;
  #MACRO IfClause(GREATERTHAN,key,arr[base+hint])
  {
    #MACRO GallopHelper<RIGHT>(RMAXOFS,GREATERTHAN,RPLUS)
  }
  else
  {
    #MACRO GallopHelper<LEFT>(LMAXOFS,LCOMPARISON,LPLUS)
  }
  #MACRO Assert(-1<=lastOfs)
  #MACRO Assert(lastOfs<ofs)
  #MACRO Assert(ofs<=len)
  if(++lastOfs<ofs)
  {
    do
    {
      int m;
      #MACRO IfClause(BINARYSEARCHCOMPARISON,key,arr[base+(m=lastOfs+((ofs-lastOfs)>>>1))])
      {
        lastOfs=m+1;
      }
      else
      {
        ofs=m;
      }
    }
    while(lastOfs<ofs);
  }
  #MACRO Assert(lastOfs==ofs)
  return ofs;
}
#ENDDEF
#MACRODEF GallopHelper<HELPERDIRECTION>(MAXOFS,COMPARISON,PLUS)
int maxOfs;
if(2>(maxOfs=MAXOFS)||
#MACRO COMPARISON(key,arr[base+hintPLUS1])
)
#IFSWITCH HELPERDIRECTION==Left
{
  lastOfs=hint-maxOfs;
}
else
{
  lastOfs=hint-1;
}
ofs=hint;
#ELSE
{
  ofs=maxOfs+hint;
}
else
{
  ofs=hint+1;
}
lastOfs=hint;
#ENDIF
#ENDDEF

#MACRODEF Merge<LOHI,LEFTARR,RIGHTARR,INCREMENT,ONE,TWO>()
#MACRO SuppressUnchecked()
private void mergeLOHI($ArrayType$[] arr,int base1,int len1,int base2,int len2)
{
  #MACRO Assert(len1>0)
  #MACRO Assert(len2>0)
  #MACRO Assert(base1+len1==base2)
  final $ArrayType$[] tmp;
#IFSWITCH LOHI==Lo
  //copy the first run into the tmp array
  int cursor1;
  int dest;
  ArrCopy.uncheckedCopy(arr,dest=base1,tmp=
  #IF OfRef
  super.
  #ENDIF
  ensureCapacity(len1),cursor1=this.tmpOffset,len1);
  //Move the first element of the second run and deal with degenerate cases
  int cursor2=base2;
  arr[dest++]=arr[cursor2++];
  //TODO make these pre-decrement for performance
  if(--len2==0)
  {
    ArrCopy.uncheckedCopy(tmp,cursor1,arr,dest,len1);
    return;
  }
  if(len1==1)
  {
    ArrCopy.uncheckedSelfCopy(arr,dest,cursor2,len2);
    arr[dest+len2]=tmp[cursor1]; //last element of run 1 to the end of the merge
    return;
  }
#ELSE
  //copy the second run into the tmp array
  int tmpOffset;
  ArrCopy.uncheckedCopy(arr,base2,tmp=
  #IF OfRef
  super.
  #ENDIF
  ensureCapacity(len2),tmpOffset=this.tmpOffset,len2);
  int cursor1=base1+(--len1);
  int cursor2=tmpOffset+len2-1;
  int dest=base2+len2-1;
  //TODO make these pre-decrement for performance
  //Move the last element of the first run and deal with degenerate cases
  arr[dest--]=arr[cursor1--];
  if(len2==1)
  {
    ArrCopy.uncheckedCopy(arr,cursor1-len1+1,arr,(dest-=len1)+1,len1);
    arr[dest]=tmp[cursor2];
    return;
  }
#ENDIF
  int minGallop=this.minGallop;
#IFNOTSWITCH COMPARATORTYPE==Ascending,Descending
  final var sorter=this.sorter;
#ENDIF
  outer:
  for(;;)
  {
    int count1=0; //The number of times in a row that the first run won.
    int count2=0; //The number of times in a row that the second run won
    //Do the straightforward thing until (if ever) one run starts winning consistently
    do
    {
      #MACRO Assert(lenONE>1)
      #MACRO Assert(lenTWO>0)
      #MACRO IfClause(LessThan,LEFTARR[cursor2],RIGHTARR[cursor1])
      {
        arr[destINCREMENT]=arr[cursorTWOINCREMENT];
        ++countTWO;
        countONE=0;
        if(--lenTWO==0)
        {
          break outer;
        }
      }
      else
      {
        arr[destINCREMENT]=tmp[cursorONEINCREMENT];
        ++countONE;
        countTWO=0;
        if(--lenONE==1)
        {
          break outer;
        }
      }
    }
    while((count1|count2)<minGallop);
    //One run is winning so consistently that galloping may be a huge win.
    //So try that, an continue galloping until (if ever) neither run appears to be wnning consistently anymore
    do
    {
      #MACRO Assert(lenONE>1)
      #MACRO Assert(lenTWO>0)
#IFSWITCH LOHI==Lo
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
      if((count1=gallopRight(($comparableType$)arr[cursor2],tmp,cursor1,len1,0))!=0)
  #ELSE
      if((count1=gallopRight(($exposedType$)arr[cursor2],tmp,cursor1,len1,0,sorter))!=0)
  #ENDIF
#ELSE
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
      if((count1=len1-gallopRight(($comparableType$)tmp[cursor2],arr,base1,len1,len1-1))!=0)
  #ELSE
      if((count1=len1-gallopRight(($exposedType$)tmp[cursor2],arr,base1,len1,len1-1,sorter))!=0)
  #ENDIF
#ENDIF
      {
#IFSWITCH LOHI==Lo
        ArrCopy.uncheckedCopy(tmp,cursor1,arr,dest,count1);
        dest+=count1;
        cursor1+=count1;
        if((len1-=count1)<2)
        {
          break outer;
        }
#ELSE
        ArrCopy.uncheckedCopy(arr,(cursor1-=count1)+1,arr,(dest-=count1)+1,count1);
        if((len1-=count1)==0)
        {
          break outer;
        }
#ENDIF
      }
      arr[destINCREMENT]=LEFTARR[cursor2INCREMENT];
#IFSWITCH LOHI==Lo
      if(--len2==0)
      {
        break outer;
      }
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
      if((count2=gallopLeft(($comparableType$)tmp[cursor1],arr,cursor2,len2,0))!=0)
  #ELSE
      if((count2=gallopLeft(($exposedType$)tmp[cursor1],arr,cursor2,len2,0,sorter))!=0)
  #ENDIF
#ELSE
      if(--len2==1)
      {
        break outer;
      }
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
      if((count2=len2-gallopLeft(($comparableType$)arr[cursor1],tmp,tmpOffset,len2,len2-1))!=0)
  #ELSE
      if((count2=len2-gallopLeft(($exposedType$)arr[cursor1],tmp,tmpOffset,len2,len2-1,sorter))!=0)
  #ENDIF
#ENDIF
      {
#IFSWITCH LOHI==Lo
        ArrCopy.uncheckedSelfCopy(arr,dest,cursor2,count2);
        dest+=count2;
        cursor2+=count2;
        if((len2-=count2)==0)
        {
          break outer;
        }
#ELSE
        ArrCopy.uncheckedCopy(tmp,(cursor2-=count2)+1,arr,(dest-=count2)+1,count2);
        if((len2-=count2)<2)
        {
          break outer;
        }
#ENDIF
      }
      arr[destINCREMENT]=RIGHTARR[cursor1INCREMENT];
#IFSWITCH LOHI==Lo
      if(--len1==1)
#ELSE
      if(--len1==0)
#ENDIF
      {
        break outer;
      }
      --minGallop;
    }
    while(count1>=7 || count2>=7);
    //penalize for leaving gallop mode
    if(minGallop<0)
    {
      minGallop=2;
    }
    else
    {
      minGallop+=2;
    }
  }
  this.minGallop = minGallop < 1 ? 1 : minGallop;
  if(lenONE==1)
  {
    #MACRO Assert(lenTWO>0)
#IFSWITCH LOHI==Lo
    ArrCopy.uncheckedSelfCopy(arr,dest,cursor2,len2);
    arr[dest+len2]=tmp[cursor1]; //last element of run 1 to the end of the merge
#ELSE
    ArrCopy.uncheckedCopy(arr,(cursor1-=len1)+1,arr,(dest-=len1)+1,len1);
    arr[dest]=tmp[cursor2]; //move the first element of run2 to the front of the merge
#ENDIF
  }
  else
  {
#IFSWITCH LOHI==Lo
    #MACRO Assert(len2==0)
    #MACRO Assert(len1>1)
    ArrCopy.uncheckedCopy(tmp,cursor1,arr,dest,len1);
#ELSE
    #MACRO Assert(len1==0)
    #MACRO Assert(len2>0)
    ArrCopy.uncheckedCopy(tmp,tmpOffset,arr,dest-(len2-1),len2);
#ENDIF
  }
}
#ENDDEF

#MACRODEF EnsureCapacity()
/**
 * Ensures that the external array tmp has at least the specified
 * number of elements, increasing its size if necessary.  The size
 * increases exponentially to ensure amortized linear time complexity.
 *
 * @param minCapacity the minimum required capacity of the tmp array
 * @return tmp, whether or not it grew
 */
private $ArrayType$[] ensureCapacity(int minCapacity)
{
  $ArrayType$[] tmp;
  if(tmpLength<minCapacity)
  {
    //compute the smallest power of 2 > minCapacity
    //Integer overflow is almost impossible given that every implementation of the JVM I've seen won't allow
    //an array with a length of Integer.MAX_VALUE. Still, we cover out bases with this check
    //Unfortunately, I have no idea how to coverage this branch with Junits.
    
    int newSize;
    if((newSize=(-1>>>Integer.numberOfLeadingZeros(minCapacity))+1)>(minCapacity=arr.length>>>1))
    {
      newSize=minCapacity;
    }
    #MACRO Assert(newSize>0)
    this.tmp=tmp=new $ArrayType$[newSize];
    this.tmpLength=newSize;
    tmpOffset=0;
  }
  else
  {
    tmp=this.tmp;
  }
  return tmp;
}
#ENDDEF

#MACRODEF MainUnstableSortImpl()
#IF OfChar,OfShort
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
if(nRemaining<286)
  #ELSE
if((--bound)-offset<286)
  #ENDIF
#ELSEIF OfFloat,OfDouble
  #IFSWITCH COMPARATORTYPE==Ascending,Descending
if(bound-offset<286)
  #ELSE
if((--bound)-offset<286)
  #ENDIF
#ELSE
if((--bound)-offset<286)
#ENDIF
{
#IFSWITCH COMPARATORTYPE==Ascending,Descending
  quickCOMPARATORTYPESortleftmost(arr,offset,bound);
#ELSE
  quickSortleftmost(arr,offset,bound,sorter);
#ENDIF
}
else
{
  int[] run;
  int count=0;
  (run=new int[68])[0]=offset;
  //checkIfSortedLoop:
  for(int k=offset;;)
  {
    if(k==bound)
    {
      if(count!=0)
      {
#IFSWITCH COMPARATORTYPE==Ascending,Descending
        COMPARATORTYPEmerge(arr,offset,bound,run,count);
#ELSE
        merge(arr,offset,bound,run,count,sorter);
#ENDIF
      }
      break;
    }
#IF OfDouble,OfFloat
    #MACRO IfClause(LessThan,arr[k],arr[k+1])
    {
#ELSE
    #MACRO SwitchSigNum(arr[k],arr[k+1])
    {
    case -1:
#ENDIF
      for(;;)
      {
        if(++k==bound ||
        #MACRO LessThan(arr[k],arr[k-1])
        )
        {
          break;
        }
      }
#IF OfDouble,OfFloat
    }
    else
    #MACRO IfClause(GreaterThan,arr[k],arr[k+1])
    {
#ELSE
      break;
    default:
#ENDIF
      for(;;)
      {
        if(++k==bound||
        #MACRO LessThan(arr[k-1],arr[k])
        )
        {
          break;
        }
      }
      OmniArray.Of$ClassPrefix$.reverseRange(arr,run[count],k-1);
#IF OfDouble,OfFloat
    }
    else
    {
#ELSE
      break;
    case 0:
#ENDIF
      ++k;
      continue;
    }
    int r;
    if(count==0)
    {
      ++count;
    }
    else if(
    #MACRO LessThan(arr[r=run[count]],arr[r-1])
    && ++count==67)
    {
#IFSWITCH COMPARATORTYPE==Ascending,Descending
      quickCOMPARATORTYPESortleftmost(arr,offset,bound);
#ELSE
      quickSortleftmost(arr,offset,bound,sorter);
#ENDIF
      break;
    }
    run[count]=k;
  }

}
#ENDDEF

#MACRODEF DeclareAndSetTmp(tmpValName,valName)
#IFSWITCH COMPARATORTYPE==Ascending,Descending
$comparableType$ tmpValName=($comparableType$)valName;
#ELSE
$exposedType$ tmpValName=($exposedType$)valName;
#ENDIF
#ENDDEF
#MACRODEF QuickSortCompare(Val1Name,Val1Val,Val2Val)
#IFSWITCH COMPARATORTYPE==Ascending,Descending
#MACRO IfClause(LessThan,Val1Name=($comparableType$)Val1Val,Val2Val)
#ELSE
#MACRO IfClause(LessThan,Val1Name=($exposedType$)Val1Val,Val2Val)
#ENDIF
#ENDDEF



#MACRODEF IfCompareAndSetLocal(COMPARISON,LocalName,LocalVal,Val2Val)
#IFSWITCH COMPARATORTYPE==Ascending,Descending
$comparableType$ LocalName;
#MACRO IfClause(COMPARISON,LocalName=($comparableType$)LocalVal,Val2Val)
#ELSE
$exposedType$ LocalName;
#MACRO IfClause(COMPARISON,LocalName=($exposedType$)LocalVal,Val2Val)
#ENDIF
#ENDDEF

#MACRODEF WhileCompareAndSetLocal(COMPARISON,LocalName,LocalVal,Val2Val)
#IFSWITCH COMPARATORTYPE==Ascending,Descending
$comparableType$ LocalName;
#MACRO WhileClause(COMPARISON,LocalName=($comparableType$)LocalVal,Val2Val)
#ELSE
$exposedType$ LocalName;
#MACRO WhileClause(COMPARISON,LocalName=($exposedType$)LocalVal,Val2Val)
#ENDIF
#ENDDEF




#MACRODEF IfClause(MACRONAME,Val1,Val2)
if(
#MACRO MACRONAME(Val1,Val2)
)
#ENDDEF

#MACRODEF WhileClause(MACRONAME,Val1,Val2)
while(
#MACRO MACRONAME(Val1,Val2)
)
#ENDDEF

#MACRODEF SuppressUnchecked()
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
#ENDDEF

#MACRODEF LessThan(Val1,Val2)
#IFSWITCH COMPARATORTYPE==Ascending
  #IF OfRef
(($comparableType$)(Val1)).compareTo(($exposedType$)(Val2))<0
  #ELSE
(Val1)<(Val2)
  #ENDIF
#ELSEIFSWITCH COMPARATORTYPE==Descending
  #IF OfRef
(($comparableType$)(Val1)).compareTo(($exposedType$)(Val2))>0
  #ELSE
(Val1)>(Val2)
  #ENDIF
#ELSE
sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(Val2))<0
#ENDIF
#ENDDEF

#MACRODEF LessThanOrEqualTo(Val1,Val2)
#IFSWITCH COMPARATORTYPE==Ascending
  #IF OfRef
(($comparableType$)(Val1)).compareTo(($exposedType$)(Val2))<=0
  #ELSE
(Val1)<=(Val2)
  #ENDIF
#ELSEIFSWITCH COMPARATORTYPE==Descending
  #IF OfRef
(($comparableType$)(Val1)).compareTo(($exposedType$)(Val2))>=0
  #ELSE
(Val1)>=(Val2)
  #ENDIF
#ELSE
sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(Val2))<=0
#ENDIF
#ENDDEF

#MACRODEF EqualTo(Val1,Val2)
#IFSWITCH COMPARATORTYPE==Ascending,Descending
  #IF OfRef
(($comparableType$)(Val1)).compareTo(($exposedType$)(Val2))==0
  #ELSE
(Val1)==(Val2)
  #ENDIF
#ELSE
sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(Val2))==0
#ENDIF
#ENDDEF

#MACRODEF GreaterThanOrEqualTo(Val1,Val2)
#IFSWITCH COMPARATORTYPE==Ascending
  #IF OfRef
(($comparableType$)(Val1)).compareTo(($exposedType$)(Val2))>=0
  #ELSE
(Val1)>=(Val2)
  #ENDIF
#ELSEIFSWITCH COMPARATORTYPE==Descending
  #IF OfRef
(($comparableType$)(Val1)).compareTo(($exposedType$)(Val2))<=0
  #ELSE
(Val1)<=(Val2)
  #ENDIF
#ELSE
sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(Val2))>=0
#ENDIF
#ENDDEF

#MACRODEF GreaterThan(Val1,Val2)
#IFSWITCH COMPARATORTYPE==Ascending
  #IF OfRef
(($comparableType$)(Val1)).compareTo(($exposedType$)(Val2))>0
  #ELSE
(Val1)>(Val2)
  #ENDIF
#ELSEIFSWITCH COMPARATORTYPE==Descending
  #IF OfRef
(($comparableType$)(Val1)).compareTo(($exposedType$)(Val2))<0
  #ELSE
(Val1)<(Val2)
  #ENDIF
#ELSE
sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(Val2))>0
#ENDIF
#ENDDEF

#MACRODEF SwitchSigNum(Val1,Val2)
switch(
#MACRO SigNumCall(Val1,Val2)
)
#ENDDEF

#MACRODEF SigNumCall(Val1,Val2)
#IFSWITCH COMPARATORTYPE==Ascending
  #IF OfRef
Integer.signum((($comparableType$)(Val1)).compareTo(($exposedType$)(Val2)))
  #ELSEIF OfLong
Long.signum((Val1)-(Val2))
  #ELSE
Integer.signum((Val1)-(Val2))
  #ENDIF
#ELSEIFSWITCH COMPARATORTYPE==Descending
  #IF OfRef
Integer.signum((($comparableType$)(Val2)).compareTo(($exposedType$)(Val1)))
  #ELSEIF OfLong
Long.signum((Val2)-(Val1))
  #ELSE
Integer.signum((Val2)-(Val1))
  #ENDIF
#ELSE
Integer.signum(sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(Val2)))
#ENDIF
#ENDDEF


#MACRODEF Assert(expr)
//assert expr;
#ENDDEF
