#TYPEDEF OfGeneric
package omni.util;
import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.nio.CharBuffer;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
public class ToStringUtil{
    public static final Charset IOS8859CharSet=Charset.forName("ISO-8859-1");
    private ToStringUtil(){}
    public static String getString(boolean b){
        if(b){
            return "true";
        }
        return "false";
    }
    public static void getString(boolean b,Appendable appendable) throws IOException{
        appendable.append(b?"true":"false");
    }
    public static void getString(boolean b,CharArrayWriter writer) throws IOException{
        writer.write(b?"true":"false");
    }
    public static void getString(boolean b,CharBuffer buffer){
        buffer.put(b?"true":"false");
    }
    public static void getString(boolean b,ByteBuffer buffer){
        buffer.put(b?new byte[]{(byte)'t',(byte)'r',(byte)'u',(byte)'e'}:new byte[]{(byte)'f',(byte)'a',(byte)'l',(byte)'s',(byte)'e'});
    }
    public static void getString(boolean b,PrintWriter writer){
        writer.write(b?"true":"false");
    }
    public static void getString(boolean b,StringWriter writer){
        writer.write(b?"true":"false");
    }
    public static void getString(boolean b,Writer writer) throws IOException{
        writer.write(b?"true":"false");
    }
    public static String getString(byte i){
        byte[] buffer;
        return new String(buffer=getByteByteBuffer(),0,getStringShort(i,buffer,0));
    }
    public static void getString(byte i,Appendable appendable) throws IOException{
        appendable.append(getString(i));
    }
    public static void getString(byte i,CharArrayWriter writer){
        char[] arr;
        writer.write(arr=getByteCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(byte i,CharBuffer buffer){
        char[] arr;
        buffer.put(arr=getByteCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(byte i,ByteBuffer buffer){
        byte[] arr;
        buffer.put(arr=getByteByteBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(byte i,PrintWriter writer){
        char[] arr;
        writer.write(arr=getByteCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(byte i,StringBuffer sBuffer){
        char[] arr;
        sBuffer.append(arr=getByteCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(byte i,StringBuilder sBuilder){
        char[] arr;
        sBuilder.append(arr=getByteCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(byte i,StringWriter writer){
        char[] arr;
        writer.write(arr=getByteCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(byte i,Writer writer) throws IOException{
        char[] arr;
        writer.write(arr=getByteCharBuffer(),0,getStringShort(i,arr,0));
    }
    /** Return the string representation of the provided single-precision float value.
     *
     * @param f
     *          The float value.
     * @return The string for that float value. */
    public static String getString(float f){
        byte[] buffer;
        return new String(buffer=getFloatByteBuffer(),0,getStringFloat(f,buffer,0));
    }
    public static void getString(float f,Appendable appendable) throws IOException{
        appendable.append(getString(f));
    }
    public static void getString(float f,CharArrayWriter writer){
        char[] arr;
        writer.write(arr=getFloatCharBuffer(),0,getStringFloat(f,arr,0));
    }
    public static void getString(float f,CharBuffer buffer){
        char[] arr;
        buffer.put(arr=getFloatCharBuffer(),0,getStringFloat(f,arr,0));
    }
    public static void getString(float f,ByteBuffer buffer){
        byte[] arr;
        buffer.put(arr=getFloatByteBuffer(),0,getStringFloat(f,arr,0));
    }
    public static void getString(float f,PrintWriter writer){
        char[] arr;
        writer.write(arr=getFloatCharBuffer(),0,getStringFloat(f,arr,0));
    }
    /** Write a float string representation to a StringBuffer.
     *
     * @param f
     * @param sBuffer
     */
    public static void getString(float f,StringBuffer sBuffer){
        char[] arr;
        sBuffer.append(arr=getFloatCharBuffer(),0,getStringFloat(f,arr,0));
    }
    public static void getString(float f,StringBuilder sBuilder){
        char[] arr;
        sBuilder.append(arr=getFloatCharBuffer(),0,getStringFloat(f,arr,0));
    }
    public static void getString(float f,StringWriter writer){
        char[] arr;
        writer.write(arr=getFloatCharBuffer(),0,getStringFloat(f,arr,0));
    }
    public static void getString(float f,Writer writer) throws IOException{
        char[] arr;
        writer.write(arr=getFloatCharBuffer(),0,getStringFloat(f,arr,0));
    }
    public static String getString(int i){
        byte[] buffer;
        return new String(buffer=getIntByteBuffer(),0,getStringInt(i,buffer,0));
    }
    public static void getString(int i,Appendable appendable) throws IOException{
        appendable.append(getString(i));
    }
    public static void getString(int i,CharArrayWriter writer){
        char[] arr;
        writer.write(arr=getIntCharBuffer(),0,getStringInt(i,arr,0));
    }
    public static void getString(int i,CharBuffer buffer){
        char[] arr;
        buffer.put(arr=getIntCharBuffer(),0,getStringInt(i,arr,0));
    }
    public static void getString(int i,ByteBuffer buffer){
        byte[] arr;
        buffer.put(arr=getIntByteBuffer(),0,getStringInt(i,arr,0));
    }
    public static void getString(int i,PrintWriter writer){
        char[] arr;
        writer.write(arr=getIntCharBuffer(),0,getStringInt(i,arr,0));
    }
    public static void getString(int i,StringBuffer sBuffer){
        char[] arr;
        sBuffer.append(arr=getIntCharBuffer(),0,getStringInt(i,arr,0));
    }
    public static void getString(int i,StringBuilder sBuilder){
        char[] arr;
        sBuilder.append(arr=getIntCharBuffer(),0,getStringInt(i,arr,0));
    }
    public static void getString(int i,StringWriter writer){
        char[] arr;
        writer.write(arr=getIntCharBuffer(),0,getStringInt(i,arr,0));
    }
    public static void getString(int i,Writer writer) throws IOException{
        char[] arr;
        writer.write(arr=getIntCharBuffer(),0,getStringInt(i,arr,0));
    }
    public static String getString(long i){
        byte[] buffer;
        return new String(buffer=getLongByteBuffer(),0,getStringLong(i,buffer,0));
    }
    public static void getString(long i,Appendable appendable) throws IOException{
        appendable.append(getString(i));
    }
    public static void getString(long i,CharArrayWriter writer){
        char[] arr;
        writer.write(arr=getLongCharBuffer(),0,getStringLong(i,arr,0));
    }
    public static void getString(long i,CharBuffer buffer){
        char[] arr;
        buffer.put(arr=getLongCharBuffer(),0,getStringLong(i,arr,0));
    }
    public static void getString(long i,ByteBuffer buffer){
        byte[] arr;
        buffer.put(arr=getLongByteBuffer(),0,getStringLong(i,arr,0));
    }
    public static void getString(long i,PrintWriter writer){
        char[] arr;
        writer.write(arr=getLongCharBuffer(),0,getStringLong(i,arr,0));
    }
    public static void getString(long i,StringBuffer sBuffer){
        char[] arr;
        sBuffer.append(arr=getLongCharBuffer(),0,getStringLong(i,arr,0));
    }
    public static void getString(long i,StringBuilder sBuilder){
        char[] arr;
        sBuilder.append(arr=getLongCharBuffer(),0,getStringLong(i,arr,0));
    }
    public static void getString(long i,StringWriter writer){
        char[] arr;
        writer.write(arr=getLongCharBuffer(),0,getStringLong(i,arr,0));
    }
    public static void getString(long i,Writer writer) throws IOException{
        char[] arr;
        writer.write(arr=getLongCharBuffer(),0,getStringLong(i,arr,0));
    }
    public static String getString(short i){
        byte[] buffer;
        return new String(buffer=getShortByteBuffer(),0,getStringShort(i,buffer,0));
    }
    public static void getString(short i,Appendable appendable) throws IOException{
        appendable.append(getString(i));
    }
    public static void getString(short i,CharArrayWriter writer){
        char[] arr;
        writer.write(arr=getShortCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(short i,CharBuffer buffer){
        char[] arr;
        buffer.put(arr=getShortCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(short i,ByteBuffer buffer){
        byte[] arr;
        buffer.put(arr=getShortByteBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(short i,PrintWriter writer){
        char[] arr;
        writer.write(arr=getShortCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(short i,StringBuffer sBuffer){
        char[] arr;
        sBuffer.append(arr=getShortCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(short i,StringBuilder sBuilder){
        char[] arr;
        sBuilder.append(arr=getShortCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(short i,StringWriter writer){
        char[] arr;
        writer.write(arr=getShortCharBuffer(),0,getStringShort(i,arr,0));
    }
    public static void getString(short i,Writer writer) throws IOException{
        char[] arr;
        writer.write(arr=getShortCharBuffer(),0,getStringShort(i,arr,0));
    }
    /** A streamlined method for getting the number of trailing 0 bits in the fraction of a single-precision
     * floating-point number
     *
     * @param fractBits
     *          The fraction bits of a floating point number.
     * @return the number of trailing zeros. */
    private static int fpFractNumTrailing0s(final int fractBits){
        int shift=31;
        for(;;){
            if(fractBits<<shift!=0){ return 31-shift; }
            --shift;
        }
    }
    // TODO benchmark
    // private static int div10(int val){
    // // TODO optimize the multiplication here
    // return val*52429>>>19;
    // // int tmp=((tmp=((tmp=(val<<3)+(val<<4))<<4)+tmp)<<8)+tmp+val>>>19;
    // // return tmp;
    // }
    // // TODO benchmark
    // static int mult10(int val){
    // return (val<<3)+(val<<1);
    // }
    // // TODO benchmark
    // static long mult10(long val){
    // return (val<<3)+(val<<1);
    // }
    // // TODO benchmark
    // static int mult100(int val){
    // return (val<<6)+(val<<5)+(val<<2);
    // }
    // // TODO benchmark
    // static long mult100(long val){
    // return (val<<6)+(val<<5)+(val<<2);
    // }
    private static int getStringSize(int val){
        final int[] sizeTable=INT_SIZE_TABLE;
        int index=0;
        for(;;){
            if(val<=sizeTable[index]){ return index+1; }
            ++index;
        }
    }
    private static int getStringSize(long val){
        long p=10L;
        int i=1;
        for(;;){
            if(val<p){ return i; }
            // multiply by 10
            // p=mult10(p);
            p*=10;
            if(++i==19){ return 19; }
        }
    }
    
    
    #MACRO OmniStringBuilderImpl<byte,Byte>()
    #MACRO OmniStringBuilderImpl<char,Char>()
#MACRODEF OmniStringBuilderImpl<BUFFERTYPE,SUFFIX>()
public static class OmniStringBuilderSUFFIX{
    public transient BUFFERTYPE[] buffer;
    public transient int size;
    public OmniStringBuilderSUFFIX(int size,BUFFERTYPE[] buffer){
        this.size=size;
        this.buffer=buffer;
    }
    @Override
    public String toString(){
        return new String(buffer,0,size);
    }
    public void uncheckedAppendBoolean(boolean val){
        if(val){
            uncheckedAppendTrue();
        }else{
            uncheckedAppendFalse();
        }
    }
    public void uncheckedAppendChar(BUFFERTYPE val){
        BUFFERTYPE[] buffer;
        final int currSize;
        if((currSize=this.size) == (buffer=this.buffer).length){
            ArrCopy.semicheckedCopy(buffer,0,buffer=new BUFFERTYPE[OmniArray.growBy100Pct(currSize)],0,currSize);
            this.buffer=buffer;
        }
        buffer[currSize]=val;
        this.size=currSize + 1;
    }
    public void uncheckedAppendCommaAndSpace(){
        final int currSize;
        final BUFFERTYPE[] buffer;
        (buffer=growBuffer(currSize=this.size,currSize + 2))[currSize]=',';
        buffer[currSize + 1]=(BUFFERTYPE)' ';
    }
    private BUFFERTYPE[] growBuffer(int currSize,int newSize){
        final int capacity;
        BUFFERTYPE[] buffer;
        if(newSize - (capacity=(buffer=this.buffer).length) > 0){
            ArrCopy.semicheckedCopy(buffer,0,buffer=new BUFFERTYPE[OmniArray.growBy100Pct(capacity,newSize)],0,currSize);
            this.buffer=buffer;
        }
        this.size=newSize;
        return buffer;
    }

    public void uncheckedAppendFloat(float val){
        // TODO handle overflow better
        BUFFERTYPE[] buffer;
        final int currSize,capacity,newSize;
        if((newSize=(currSize=this.size) + 15) - (capacity=(buffer=this.buffer).length) > 0){
            ArrCopy.semicheckedCopy(buffer,0,buffer=new BUFFERTYPE[OmniArray.growBy100Pct(capacity,newSize)],0,currSize);
            this.buffer=buffer;
        }
        this.size=getStringFloat(val,buffer,currSize);
    }
    // TODO uncheckedAppendDouble
    public void uncheckedAppendInt(int val){
        final BUFFERTYPE[] buffer;
        final int newSize,currSize=this.size;
        if(val < 0){
            if(val == Integer.MIN_VALUE){
                uncheckedAppendIntMinVal(currSize);
                return;
            }
            (buffer=growBuffer(currSize,newSize=currSize + 1 + getStringSize(val=-val)))[currSize]='-';
        }else{
            buffer=growBuffer(currSize,newSize=currSize + getStringSize(val));
        }
        mediumDigits(val,buffer,newSize);
    }
    public void uncheckedAppendLong(long val){
        final BUFFERTYPE[] buffer;
        final int newSize,currSize=size;
        if(val < 0L){
            if(val == Long.MIN_VALUE){
                uncheckedAppendLongMinVal(currSize);
                return;
            }
            (buffer=growBuffer(currSize,newSize=currSize + 1 + getStringSize(val=-val)))[currSize]='-';
        }else{
            buffer=growBuffer(currSize,newSize=currSize + getStringSize(val));
        }
        largeDigits(val,buffer,newSize);
    }
    public void uncheckedAppendShort(int val){
        final BUFFERTYPE[] buffer;
        final int newSize,currSize=size;
        if(val < 0){
            (buffer=growBuffer(currSize,newSize=currSize + 1 + getStringSize(val=-val)))[currSize]='-';
        }else{
            buffer=growBuffer(currSize,newSize=currSize + getStringSize(val));
        }
        smallDigits(val,buffer,newSize);
    }
    private void uncheckedAppendFalse(){
        final BUFFERTYPE[] buffer;
        final int currSize;
        (buffer=growBuffer(currSize=this.size,currSize + 5))[currSize]=(BUFFERTYPE)'f';
        buffer[currSize + 1]=(BUFFERTYPE)'a';
        buffer[currSize + 2]=(BUFFERTYPE)'l';
        buffer[currSize + 3]=(BUFFERTYPE)'s';
        buffer[currSize + 4]=(BUFFERTYPE)'e';
    }
    private void uncheckedAppendIntMinVal(int currSize){
        final BUFFERTYPE[] buffer;
        (buffer=growBuffer(currSize=this.size,currSize + 11))[currSize]=(BUFFERTYPE)'-';
        buffer[++currSize]=(BUFFERTYPE)'2';
        buffer[++currSize]=(BUFFERTYPE)'1';
        buffer[++currSize]=(BUFFERTYPE)'4';
        buffer[++currSize]=(BUFFERTYPE)'7';
        buffer[++currSize]=(BUFFERTYPE)'4';
        buffer[++currSize]=(BUFFERTYPE)'8';
        buffer[++currSize]=(BUFFERTYPE)'3';
        buffer[++currSize]=(BUFFERTYPE)'6';
        buffer[++currSize]=(BUFFERTYPE)'4';
        buffer[++currSize]=(BUFFERTYPE)'8';
    }
    private void uncheckedAppendLongMinVal(int currSize){
        final BUFFERTYPE[] buffer;
        (buffer=growBuffer(currSize=this.size,currSize + 20))[currSize]=(BUFFERTYPE)'-';
        buffer[++currSize]=(BUFFERTYPE)'9';
        buffer[++currSize]=(BUFFERTYPE)'2';
        buffer[++currSize]=(BUFFERTYPE)'2';
        buffer[++currSize]=(BUFFERTYPE)'3';
        buffer[++currSize]=(BUFFERTYPE)'3';
        buffer[++currSize]=(BUFFERTYPE)'7';
        buffer[++currSize]=(BUFFERTYPE)'2';
        buffer[++currSize]=(BUFFERTYPE)'0';
        buffer[++currSize]=(BUFFERTYPE)'3';
        buffer[++currSize]=(BUFFERTYPE)'6';
        buffer[++currSize]=(BUFFERTYPE)'8';
        buffer[++currSize]=(BUFFERTYPE)'5';
        buffer[++currSize]=(BUFFERTYPE)'4';
        buffer[++currSize]=(BUFFERTYPE)'7';
        buffer[++currSize]=(BUFFERTYPE)'7';
        buffer[++currSize]=(BUFFERTYPE)'5';
        buffer[++currSize]=(BUFFERTYPE)'8';
        buffer[++currSize]=(BUFFERTYPE)'0';
        buffer[++currSize]=(BUFFERTYPE)'8';
    }
    private void uncheckedAppendTrue(){
        final BUFFERTYPE[] buffer;
        final int currSize;
        (buffer=growBuffer(currSize=this.size,currSize + 4))[currSize]=(BUFFERTYPE)'t';
        buffer[currSize + 1]=(BUFFERTYPE)'r';
        buffer[currSize + 2]=(BUFFERTYPE)'u';
        buffer[currSize + 3]=(BUFFERTYPE)'e';
    }
}
#ENDDEF
    
    #MACRO GetStringImpls<char,Char>()
    #MACRO GetStringImpls<byte,Byte>()
#MACRODEF GetStringImpls<BUFFERTYPE,SUFFIX>()
    private final static BUFFERTYPE[] DIGIT_TENSSUFFIX={(BUFFERTYPE)'0',(BUFFERTYPE)'0',(BUFFERTYPE)'0',(BUFFERTYPE)'0',(BUFFERTYPE)'0',(BUFFERTYPE)'0',(BUFFERTYPE)'0',(BUFFERTYPE)'0',(BUFFERTYPE)'0',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'1',(BUFFERTYPE)'1',(BUFFERTYPE)'1',(BUFFERTYPE)'1',(BUFFERTYPE)'1',(BUFFERTYPE)'1',(BUFFERTYPE)'1',(BUFFERTYPE)'1',
            (BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'2',(BUFFERTYPE)'2',(BUFFERTYPE)'2',(BUFFERTYPE)'2',(BUFFERTYPE)'2',(BUFFERTYPE)'2',(BUFFERTYPE)'2',(BUFFERTYPE)'2',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'3',(BUFFERTYPE)'3',(BUFFERTYPE)'3',(BUFFERTYPE)'3',(BUFFERTYPE)'3',(BUFFERTYPE)'3',(BUFFERTYPE)'3',(BUFFERTYPE)'3',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'4',(BUFFERTYPE)'4',(BUFFERTYPE)'4',(BUFFERTYPE)'4',(BUFFERTYPE)'4',
            (BUFFERTYPE)'4',(BUFFERTYPE)'4',(BUFFERTYPE)'4',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'5',(BUFFERTYPE)'5',(BUFFERTYPE)'5',(BUFFERTYPE)'5',(BUFFERTYPE)'5',(BUFFERTYPE)'5',(BUFFERTYPE)'5',(BUFFERTYPE)'5',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'6',(BUFFERTYPE)'6',(BUFFERTYPE)'6',(BUFFERTYPE)'6',(BUFFERTYPE)'6',(BUFFERTYPE)'6',(BUFFERTYPE)'6',(BUFFERTYPE)'6',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'7',(BUFFERTYPE)'7',
            (BUFFERTYPE)'7',(BUFFERTYPE)'7',(BUFFERTYPE)'7',(BUFFERTYPE)'7',(BUFFERTYPE)'7',(BUFFERTYPE)'7',(BUFFERTYPE)'7',(BUFFERTYPE)'8',(BUFFERTYPE)'8',(BUFFERTYPE)'8',(BUFFERTYPE)'8',(BUFFERTYPE)'8',(BUFFERTYPE)'8',(BUFFERTYPE)'8',(BUFFERTYPE)'8',(BUFFERTYPE)'8',(BUFFERTYPE)'8',(BUFFERTYPE)'9',(BUFFERTYPE)'9',(BUFFERTYPE)'9',(BUFFERTYPE)'9',(BUFFERTYPE)'9',(BUFFERTYPE)'9',(BUFFERTYPE)'9',(BUFFERTYPE)'9',(BUFFERTYPE)'9',
            (BUFFERTYPE)'9',};
    private final static BUFFERTYPE[] DIGIT_ONESSUFFIX={(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',(BUFFERTYPE)'9',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',
            (BUFFERTYPE)'9',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',(BUFFERTYPE)'9',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',(BUFFERTYPE)'9',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',
            (BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',(BUFFERTYPE)'9',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',(BUFFERTYPE)'9',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',(BUFFERTYPE)'9',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',
            (BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',(BUFFERTYPE)'9',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',(BUFFERTYPE)'9',(BUFFERTYPE)'0',(BUFFERTYPE)'1',(BUFFERTYPE)'2',(BUFFERTYPE)'3',(BUFFERTYPE)'4',(BUFFERTYPE)'5',(BUFFERTYPE)'6',(BUFFERTYPE)'7',(BUFFERTYPE)'8',
            (BUFFERTYPE)'9',};
    /** Place the string representation of the provided boolean value into the provided BUFFERTYPE buffer.
     *
     * @param i
     *          The boolean value to get the string of.
     * @param buffer
     *          The BUFFERTYPE buffer.
     * @param offset
     *          The first index to begin inserting BUFFERTYPEs in the BUFFERTYPE buffer.
     * @return The last index into which a BUFFERTYPE was inserted PLUS ONE. */
    public static int getStringBoolean(boolean i,BUFFERTYPE[] buffer,int offset){
        if(i){
            buffer[offset]=(BUFFERTYPE)'t';
            buffer[++offset]=(BUFFERTYPE)'r';
            buffer[++offset]=(BUFFERTYPE)'u';
        }else{
            buffer[offset]=(BUFFERTYPE)'f';
            buffer[++offset]=(BUFFERTYPE)'a';
            buffer[++offset]=(BUFFERTYPE)'l';
            buffer[++offset]=(BUFFERTYPE)'s';
        }
        buffer[++offset]=(BUFFERTYPE)'e';
        return ++offset;
    }
    /** Place the string representation of the provided single-precision float value into the provided BUFFERTYPE buffer.
     *
     * @param f
     *          The single-precision float value to get the string of.
     * @param buffer
     *          The BUFFERTYPE buffer.
     * @param offset
     *          The first index to begin inserting BUFFERTYPEs in the BUFFERTYPE buffer.
     * @return The last index into which a BUFFERTYPE was inserted PLUS ONE. */
    public static int getStringFloat(final float f,final BUFFERTYPE[] buffer,int offset){
        final int rawBits;
        final int binaryExponent=(((rawBits=Float.floatToRawIntBits(f))&0x7f800000)>>23)-127;
        if(binaryExponent==128){ return infinityOrNaNToASCII(buffer,offset,rawBits); }
        if((rawBits&Integer.MIN_VALUE)!=0){
            buffer[offset++]=(BUFFERTYPE)'-';
        }
        final int fractBits=rawBits&0x7fffff;
        if(binaryExponent==-127){
            if(fractBits==0){
                buffer[offset]=(BUFFERTYPE)'0';
                buffer[++offset]=(BUFFERTYPE)'.';
                buffer[++offset]=(BUFFERTYPE)'0';
                return ++offset;
            }
            return FltDenorm.toASCII(fractBits,buffer,offset);
        }
        if(binaryExponent<0){ return FltLT1.toASCII(fractBits,binaryExponent,buffer,offset); }
        return FltGTE1.toASCII(fractBits,binaryExponent,buffer,offset);
    }
    /** Place the string representation of the provided int value into the provided BUFFERTYPE buffer.
     *
     * @param i
     *          The int value to get the string of.
     * @param buffer
     *          The BUFFERTYPE buffer.
     * @param offset
     *          The first index to begin inserting BUFFERTYPEs in the BUFFERTYPE buffer.
     * @return The last index into which a BUFFERTYPE was inserted PLUS ONE. */
    public static int getStringInt(int i,BUFFERTYPE[] buffer,int offset){
        if(i<0){
            buffer[offset++]=(BUFFERTYPE)'-';
            if(i==Integer.MIN_VALUE){
                buffer[offset]=(BUFFERTYPE)'2';
                buffer[++offset]=(BUFFERTYPE)'1';
                buffer[++offset]=(BUFFERTYPE)'4';
                buffer[++offset]=(BUFFERTYPE)'7';
                buffer[++offset]=(BUFFERTYPE)'4';
                buffer[++offset]=(BUFFERTYPE)'8';
                buffer[++offset]=(BUFFERTYPE)'3';
                buffer[++offset]=(BUFFERTYPE)'6';
                buffer[++offset]=(BUFFERTYPE)'4';
                buffer[++offset]=(BUFFERTYPE)'8';
                return ++offset;
            }
            i=-i;
        }
        mediumDigits(i,buffer,offset+=getStringSize(i));
        return offset;
    }
    /** Place the string representation of the provided long value into the provided BUFFERTYPE buffer.
     *
     * @param l
     *          The long value to get the string of.
     * @param buffer
     *          The BUFFERTYPE buffer.
     * @param offset
     *          The first index to begin inserting BUFFERTYPEs in the BUFFERTYPE buffer.
     * @return The last index into which a BUFFERTYPE was inserted PLUS ONE. */
    public static int getStringLong(long l,BUFFERTYPE[] buffer,int offset){
        if(l<0L){
            buffer[offset++]=(BUFFERTYPE)'-';
            if(l==Long.MIN_VALUE){
                buffer[offset]=(BUFFERTYPE)'9';
                buffer[++offset]=(BUFFERTYPE)'2';
                buffer[++offset]=(BUFFERTYPE)'2';
                buffer[++offset]=(BUFFERTYPE)'3';
                buffer[++offset]=(BUFFERTYPE)'3';
                buffer[++offset]=(BUFFERTYPE)'7';
                buffer[++offset]=(BUFFERTYPE)'2';
                buffer[++offset]=(BUFFERTYPE)'0';
                buffer[++offset]=(BUFFERTYPE)'3';
                buffer[++offset]=(BUFFERTYPE)'6';
                buffer[++offset]=(BUFFERTYPE)'8';
                buffer[++offset]=(BUFFERTYPE)'5';
                buffer[++offset]=(BUFFERTYPE)'4';
                buffer[++offset]=(BUFFERTYPE)'7';
                buffer[++offset]=(BUFFERTYPE)'7';
                buffer[++offset]=(BUFFERTYPE)'5';
                buffer[++offset]=(BUFFERTYPE)'8';
                buffer[++offset]=(BUFFERTYPE)'0';
                buffer[++offset]=(BUFFERTYPE)'8';
                return ++offset;
            }
            l=-l;
        }
        largeDigits(l,buffer,offset+=getStringSize(l));
        return offset;
    }
    /** Place the string representation of the provided long value into the provided BUFFERTYPE buffer.
     *
     * @param l
     *          The long value to get the string of.
     * @param buffer
     *          The BUFFERTYPE buffer.
     * @param offset
     *          The first index to begin inserting BUFFERTYPEs in the BUFFERTYPE buffer.
     * @return The last index into which a BUFFERTYPE was inserted PLUS ONE. */
    public static int getStringShort(int i,BUFFERTYPE[] buffer,int offset){
        if(i<0){
            buffer[offset++]=(BUFFERTYPE)'-';
            i=-i;
        }
        smallDigits(i,buffer,offset+=getStringSize(i));
        return offset;
    }
    /** Insert 0's into a BUFFERTYPE buffer.
     *
     * @param offset
     *          The index in the buffer to insert the first 0.
     * @param buffer
     *          The buffer to insert 0's into.
     * @param bound
     *          The last index into which a zero will be placed PLUS ONE.
     * @return The {@code bound} parameter. */
    private static int fillZeros(int offset,final BUFFERTYPE[] buffer,final int bound){
        for(;;){
            if(offset==bound){ return offset; }
            buffer[++offset]=(BUFFERTYPE)'0';
        }
    }
    private static BUFFERTYPE[] getByteSUFFIXBuffer(){
        return new BUFFERTYPE[4];
    }
    private static BUFFERTYPE[] getFloatSUFFIXBuffer(){
        // TODO see if this can/should be made thread-localized
        // (preferably without using ThreadLocal, which is too slow).
        return new BUFFERTYPE[15];
    }
    private static BUFFERTYPE[] getIntSUFFIXBuffer(){
        // TODO see if this can/should be made thread-localized
        // (preferably without using ThreadLocal, which is too slow).
        return new BUFFERTYPE[11];
    }
    private static BUFFERTYPE[] getLongSUFFIXBuffer(){
        return new BUFFERTYPE[20];
    }
    private static BUFFERTYPE[] getShortSUFFIXBuffer(){
        return new BUFFERTYPE[6];
    }
    /** Print the characters for "Infinity" or "NaN" (positive or negative).
     *
     * @param buffer
     *          The BUFFERTYPE buffer to point to.
     * @param offset
     *          The first index to insert BUFFERTYPEs.
     * @param rawBits
     *          The raw bits provided by Float.floatToRawIntBits(float)
     * @return The offset in the buffer just after the index where the last character was inserted. */
    private static int infinityOrNaNToASCII(final BUFFERTYPE[] buffer,int offset,final int rawBits){
        if((rawBits&0x7fffff)==0){
            if((rawBits&Integer.MIN_VALUE)!=0){
                buffer[offset++]=(BUFFERTYPE)'-';
            }
            buffer[offset]=(BUFFERTYPE)'I';
            buffer[++offset]=(BUFFERTYPE)'n';
            buffer[++offset]=(BUFFERTYPE)'f';
            buffer[++offset]=(BUFFERTYPE)'i';
            buffer[++offset]=(BUFFERTYPE)'n';
            buffer[++offset]=(BUFFERTYPE)'i';
            buffer[++offset]=(BUFFERTYPE)'t';
            buffer[++offset]=(BUFFERTYPE)'y';
        }else{
            buffer[offset]=(BUFFERTYPE)'N';
            buffer[++offset]=(BUFFERTYPE)'a';
            buffer[++offset]=(BUFFERTYPE)'N';
        }
        return ++offset;
    }
    private static void largeDigits(long val,BUFFERTYPE[] buffer,int digitOffset){
        for(;;){
            if(val<2147483648L){
                mediumDigits((int)val,buffer,digitOffset);
                break;
            }
            // TODO we could use multiplication to do this for values less than
            // 4908534099L. Would this be faster?
            //// final int tmp=(int)(((long)val*1374389535)>>>37);
            // final long tmp=val/100;
            // final int r=(int)(val-(tmp<<6)+(tmp<<5)+(tmp<<2));
            long tmp;
            int r;
            buffer[--digitOffset]=DIGIT_ONESSUFFIX[r=(int)(val-(tmp=val/100)*100)];
            buffer[--digitOffset]=DIGIT_TENSSUFFIX[r];
            val=tmp;
        }
    }
    private static void mediumDigits(int val,BUFFERTYPE[] buffer,int digitOffset){
        for(;;){
            // TODO the stock Integer class uses 66536 as the threshold, but values
            // should
            // be accurate up to 81920 even if the multplication technique were used.
            // Would performance benefit if this were changed?
            if(val<81920)
                // if(val<65536)
            {
                smallDigits(val,buffer,digitOffset);
                break;
            }
            // two digits per iteration
            // TODO Would it be faster to promote to long and use multiplication to
            // divide?
            // TODO if this is okay, then perhaps consider the same multiplication
            // with the shift-add technique
            // (valid for val < 4908534099L
            // final int tmp=(int)(((long)val*1374389535)>>>37);
            int tmp;
            // buffer[--digitOffset]=DIGIT_ONESSUFFIX[val-=mult100(tmp=val/100)];
            buffer[--digitOffset]=DIGIT_ONESSUFFIX[val-=(tmp=val/100)*100];
            buffer[--digitOffset]=DIGIT_TENSSUFFIX[val];
            val=tmp;
        }
    }
    /**
     * <p>
     * This shift-add technique was shamelessly ripped from {@link java.lang.Integer Integer}. It is equivalent to:
     *
     * <pre>
     * int tmp=(val*52429)>>>19;
     * BUFFERTYPE c=(BUFFERTYPE)(((tmp<<3)+(q<<1))+'0');
     * </pre>
     *
     * This is as it appears in {@link java.lang.Integer Integer}. It is, in turn, equivalent to
     *
     * <pre>
     *   int tmp = val / 10;
     *   BUFFERTYPE c  = (BUFFERTYPE)(( val - ( tmp * 10 ) + '0' );
     * </pre>
     *
     * which is in turn equivalent to
     *
     * <pre>
     * BUFFERTYPE c=val%10;
     * </pre>
     *
     * We want to avoid div and mod at all costs.
     * </p>
     * TODO: check the performance of this against other techniques
     *
     * @param buffer
     *          The character buffer into which the character will be placed.
     * @param digitOffset
     *          The index at which to place the character.
     * @param val
     *          The integer value from which to pull the lowest-order decimal digit. */
    private static void smallDigits(int val,BUFFERTYPE[] buffer,int digitOffset){
        for(;;){
            if(val<10){
                buffer[--digitOffset]=(BUFFERTYPE)(val+'0');
                return;
            }
            buffer[--digitOffset]=(BUFFERTYPE)(val-(val=val*52429>>>19)*10+'0');
        }
    }
#ENDDEF
    private interface BigMathFltToASCII{
        int getChars(int decimalExponent,char[] buffer,int offset);
        int getBytes(int decimalExponent,byte[] buffer,int offset);
    }
    /** This class is responsible for printing the digits of a single-precision floating point number when the floating
     * point number is de-normalized.
     *
     * @author lyonste */
    private static class FltDenorm{
        private static int estimateDecimalExponent(final int fractBits){
            if(fractBits>7136237){ return 38; }
            if(fractBits>713623){ return 39; }
            if(fractBits>71361){ return 40; }
            if(fractBits>7135){ return 41; }
            if(fractBits>713){ return 42; }
            if(fractBits>70){ return 43; }
            if(fractBits>7){ return 44; }
            return 45;
        }
        private static int fpFractLeading0s(final int fractionBits){
            int mask=1<<22;
            int result=9;
            for(;;){
                if((fractionBits&mask)!=0){ return result; }
                ++result;
                mask>>>=1;
            }
        }
        #MACRO FltDenormToASCII<char,Char>()
        #MACRO FltDenormToASCII<byte,Byte>()
#MACRODEF FltDenormToASCII<BUFFERTYPE,SUFFIX>()
static int toASCII(int fractBits,BUFFERTYPE[] buffer,int offset){
    int lead0s;
    final int decimalExponent=estimateDecimalExponent(fractBits);
    BigMathFltToASCII bsm;
    if(31-fpFractNumTrailing0s(fractBits)-(lead0s=fpFractLeading0s(fractBits))==0){
        bsm=new BigMathDenorm32Bit(decimalExponent,lead0s);
    }else{
        bsm=new BigMathDenorm64Bit(fractBits,decimalExponent);
    }
    return bsm.getSUFFIXs(decimalExponent,buffer,offset);
}
private static int printDenormalizedFltExponent(int estimatedDecimalExponent,final BUFFERTYPE[] buffer,int offset){
    buffer[++offset]=(BUFFERTYPE)'E';
    buffer[++offset]=(BUFFERTYPE)'-';
    if(estimatedDecimalExponent<40){
        buffer[++offset]=(BUFFERTYPE)'3';
        estimatedDecimalExponent+=10;
    }else{
        buffer[++offset]=(BUFFERTYPE)'4';
    }
    buffer[++offset]=(BUFFERTYPE)(estimatedDecimalExponent+8);
    return ++offset;
}
#ENDDEF
        
        /** This class is used to perform the math necessary to produce the decimal digits for de-normalized numbers
         * whenever it is possible to do so with only 32 bits of resolution.
         *
         * @author lyonste */
        private static class BigMathDenorm32Bit implements BigMathFltToASCII{
            int b;
            int m;
            public BigMathDenorm32Bit(final int decimalExponent,final int lead0s){
                long[] pow5Arr;
                int index;
                b=(int)((pow5Arr=POW_5_128)[index=(decimalExponent-26<<1)+1]<<5-lead0s+decimalExponent>>>32);
                m=(int)(pow5Arr[index+2]>>>59-decimalExponent);
            }
            #MACRO BigMathDenorm32Bit<byte,Byte>()
            #MACRO BigMathDenorm32Bit<char,Char>()
#MACRODEF BigMathDenorm32Bit<BUFFERTYPE,SUFFIX>()
@Override public int getSUFFIXs(final int decimalExponent,final BUFFERTYPE[] buffer,int offset){
    int b;
    int c=(b=this.b)>>>27;
    if(c==8){
        buffer[offset]=(BUFFERTYPE)'9';
        buffer[++offset]=(BUFFERTYPE)'.';
        buffer[++offset]=(BUFFERTYPE)'0';
    }else{
        b&=(1<<27)-1;
        buffer[offset]=(BUFFERTYPE)(c+'0');
        buffer[++offset]=(BUFFERTYPE)'.';
        int m=this.m;
        for(;;){
            c=(b*=10)>>>27;
        if((b&=(1<<27)-1)+m>1<<27){
            if(b>1<<26){
                ++c;
            }
            break;
        }
        if(b<m){
            break;
        }
        m*=10;
        buffer[++offset]=(BUFFERTYPE)(c+'0');
        }
        buffer[++offset]=(BUFFERTYPE)(c+'0');
    }
    return printDenormalizedFltExponent(decimalExponent,buffer,offset);
}
#ENDDEF
            
        }
        /** This class is used to perform the math necessary to produce the decimal digits for de-normalized numbers
         * whenever 64 bits of resolution are required.
         *
         * @author lyonste */
        private static class BigMathDenorm64Bit implements BigMathFltToASCII{
            long b;
            long m;
            public BigMathDenorm64Bit(int fractBits,int decimalExponent){
                long[] pow5Arr;
                int index;
                b=(((pow5Arr=POW_5_128)[index=(decimalExponent-=26)<<1]>>>32)*fractBits>>>32)
                        +pow5Arr[++index]*fractBits<<decimalExponent;
                m=pow5Arr[index+2]<<decimalExponent;
            }
            #MACRO BigMathDenorm64Bit<byte,Byte>()
            #MACRO BigMathDenorm64Bit<char,Char>()
#MACRODEF BigMathDenorm64Bit<BUFFERTYPE,SUFFIX>()
@Override public int getSUFFIXs(int decimalExponent,BUFFERTYPE[] buffer,int offset){
    long b;
    long m=this.m;
    buffer[offset]=(BUFFERTYPE)((int)((b=this.b)>>>59)+'0');
    buffer[++offset]=(BUFFERTYPE)'.';
    b=(b&(1L<<59)-1)*10;
    int c;
    for(;;){
        c=(int)(b>>>59);
        if((b&=(1L<<59)-1)+m>1L<<59){
            if(b>1L<<58){
                if(c==9){
                    c=0;
                    ++buffer[offset-1];
                }else{
                    ++c;
                }
            }
            break;
        }
        if(b<m){
            break;
        }
        buffer[++offset]=(BUFFERTYPE)(c+'0');
        b*=10;
        m*=10;
    }
    buffer[++offset]=(BUFFERTYPE)(c+'0');
    return printDenormalizedFltExponent(decimalExponent,buffer,offset);
}
#ENDDEF

        }
    }
    /** This class is responsible for printing the digits of a single-precision floating point number when the absolute
     * value of that floating point number is greater than or equal to 1.0.
     *
     * @author lyonste */
    private static class FltGTE1{
        private static final byte[] ESTIMATE_DECIMAL_EXPONENT=new byte[]{18,// 63
                19,19,19,// 64,64,66
                20,20,20,// 67,68,69
                21,21,21,21,// 70,71,72,73
                22,22,22,// 74,75,76
                23,23,23,// 77,78,79
                24,24,24,// 80,81,82
                25,25,25,25,// 83,84,85,86
                26,26,26,// 87,88,89
                27,27,27,27,// 90,91,92,93
                28,28,28,// 94,95,96
                29,29,29,// 97,98,99
                30,30,30,// 100,101,102
                31,31,31,31,// 103,104,105,106
                32,32,32,// 107,108,109
                33,33,33,// 110,111,112
                34,34,34,34,// 113,114,115,116
                35,35,35,// 117,118,119
                36,36,36,// 120,121,122
                37,37,37,37,// 123,124,125,126
                38,// 127
        };
        #MACRO FltGTE1ToASCII<byte,Byte>()
        #MACRO FltGTE1ToASCII<char,Char>()
#MACRODEF FltGTE1ToASCII<BUFFERTYPE,SUFFIX>()
static int toASCII(int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    if(fractBits==0){
        if(binaryExponent>86){ return BigMathGTE1.toASCII(binaryExponent,buffer,offset); }
        if(binaryExponent>62){ return LongMathGTE1.toASCII(binaryExponent,buffer,offset); }
        if(binaryExponent>23){ return Pow2GTE1.toASCII(binaryExponent,buffer,offset); }
        mediumDigits(fractBits=1<<binaryExponent,buffer,offset+=getStringSize(fractBits));
        buffer[offset]=(BUFFERTYPE)'.';
        buffer[++offset]=(BUFFERTYPE)'0';
        return ++offset;
    }else{
        if(fpFractNumTrailing0s(fractBits|=0x800000)+binaryExponent>22
                &&binaryExponent<63){ return Pow2GTE1.toASCII(fractBits,binaryExponent,buffer,offset); }
        if(binaryExponent>86||binaryExponent==86
                &&fractBits>10709187){ return BigMathGTE1.toASCII(fractBits,binaryExponent,buffer,offset); }
        if(binaryExponent>22){ return LongMathGTE1.toASCII(fractBits,binaryExponent,buffer,offset); }
        return IntMathGTE1.toASCII(fractBits,binaryExponent,buffer,offset);
    }
}
#ENDDEF
        
        private static abstract class BigMathGTE1 implements BigMathFltToASCII{
            long b;
            long m;
            private static final byte[] SHIFT_BIAS=new byte[]{1,31,29,26,24,22,20,17,15,13,10,8,6,3};
            #MACRO BigMathGTE1ToASCII<byte,Byte>()
            #MACRO BigMathGTE1ToASCII<char,Char>()
#MACRODEF BigMathGTE1ToASCII<BUFFERTYPE,SUFFIX>()
static int toASCII(int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    final int decimalExponent=ESTIMATE_DECIMAL_EXPONENT[binaryExponent-63];
    int c;
    long b=1L<<binaryExponent-decimalExponent+(c=SHIFT_BIAS[decimalExponent-25])-32;
    long m=5L<<binaryExponent-56-decimalExponent+c;
    long[] pow5Arr;
    final long s=(pow5Arr=POW_5_128)[binaryExponent=decimalExponent-26<<1]>>>32-c|pow5Arr[++binaryExponent]<<32+c;
    long sShift;
    b=(b-(c=(int)((b>>>32)/(sShift=s>>>32)))*s)*10;
    buffer[offset]=(BUFFERTYPE)(c+'0');
    buffer[++offset]=(BUFFERTYPE)'.';
    for(;;){
        if((c=(int)((b>>>32)/sShift))!=0){
            b-=c*s;
        }
        if(b+m>s){
            if(b>s>>1){
                ++c;
            }
            break;
        }else if(b<m){
            break;
        }
        buffer[++offset]=(BUFFERTYPE)(c+'0');
        b*=10;
        m*=10;
    }
    buffer[++offset]=(BUFFERTYPE)(c+'0');
    return printBigIntExponent(buffer,offset,decimalExponent);
}
static int toASCII(final int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,final int offset){
    int decimalExponent;
    BigMathFltToASCII bsm;
    switch(decimalExponent=estimateDecimalExponent(fractBits,binaryExponent)){
    case 25:
        bsm=new BigMathGTE1DecExp25(fractBits);
        break;
    case 26:
        bsm=new BigMathGTE1DecExp26(fractBits,binaryExponent+14);
        break;
    case 31:
    case 36:
    case 37:
    case 38:
        bsm=new BigMathGTE1EasyCase(fractBits,decimalExponent,binaryExponent);
        break;
    default:
        bsm=new BigMathGTE1HardCase(fractBits,decimalExponent,binaryExponent);
        break;
    }
    return bsm.getSUFFIXs(decimalExponent,buffer,offset);
}
private static int printBigIntExponent(final BUFFERTYPE[] buffer,int offset,int decimalExponent){
    buffer[++offset]=(BUFFERTYPE)'E';
    if(decimalExponent<30){
        buffer[++offset]=(BUFFERTYPE)'2';
        decimalExponent+=28;
    }else{
        buffer[++offset]=(BUFFERTYPE)'3';
        decimalExponent+=18;
    }
    buffer[++offset]=(BUFFERTYPE)decimalExponent;
    return ++offset;
}
#ENDDEF
            
            private static int estimateDecimalExponent(final int fractBits,final int binaryExponent){
                switch(binaryExponent){
                case 86:
                    if(fractBits>10842021){ return 26; }
                    break;
                case 89:
                    if(fractBits>13552526){ return 27; }
                    break;
                case 93:
                    if(fractBits>8470328){ return 28; }
                    break;
                case 96:
                    if(fractBits>10587911){ return 29; }
                    break;
                case 99:
                    if(fractBits>13234889){ return 30; }
                    break;
                case 102:
                    if(fractBits>16543611){ return 31; }
                    break;
                case 106:
                    if(fractBits>10339757){ return 32; }
                    break;
                case 109:
                    if(fractBits>12924696){ return 33; }
                    break;
                case 112:
                    if(fractBits>16155870){ return 34; }
                    break;
                case 116:
                    if(fractBits>10097419){ return 35; }
                    break;
                case 119:
                    if(fractBits>12621773){ return 36; }
                    break;
                case 122:
                    if(fractBits>15777217){ return 37; }
                    break;
                case 126:
                    if(fractBits>9860760){ return 38; }
                default:
                    break;
                }
                return ESTIMATE_DECIMAL_EXPONENT[binaryExponent-63];
            }

            private static class BigMathGTE1DecExp25 extends BigMathGTE1{
                public BigMathGTE1DecExp25(final int fractBits){
                    b=(long)fractBits<<39;
                    m=5L<<39;
                }
                #MACRO BigMathGTE1DecExp25<byte,Byte>()
                #MACRO BigMathGTE1DecExp25<char,Char>()
#MACRODEF BigMathGTE1DecExp25<BUFFERTYPE,SUFFIX>()
@Override public int getSUFFIXs(final int decimalExponent,final BUFFERTYPE[] buffer,int offset){
    long b;
    int c;
    b=((b=this.b)-(c=(int)(b/596046447753906250L))*596046447753906250L)*10;
    long m=this.m;
    buffer[offset]=(BUFFERTYPE)(c+'0');
    buffer[++offset]=(BUFFERTYPE)'.';
    for(;;){
        if((b-=(c=(int)(b/596046447753906250L))*596046447753906250L)+m>596046447753906250L){
            if(b>298023223876953125L){
                ++c;
            }
            break;
        }
        if(b<m){
            break;
        }
        b*=10;
        m*=10;
        buffer[++offset]=(BUFFERTYPE)(c+'0');
    }
    buffer[++offset]=(BUFFERTYPE)(c+'0');
    return printBigIntExponent(buffer,offset,decimalExponent);
}
#ENDDEF

            }
            private static class BigMathGTE1DecExp26 extends BigMathGTE1{
                public BigMathGTE1DecExp26(final int fractBits,final int mShift){
                    b=(long)fractBits<<mShift;
                    m=5L<<mShift;
                }
                #MACRO BigMathGTE1DecExp26<byte,Byte>()
                #MACRO BigMathGTE1DecExp26<char,Char>()
#MACRODEF BigMathGTE1DecExp26<BUFFERTYPE,SUFFIX>()
@Override public int getSUFFIXs(final int decimalExponent,final BUFFERTYPE[] buffer,int offset){
    long b;
    long m;
    int c;
    if(0x6765C793FA10079DL<(b=((b=this.b)-(c=(int)(b/0xA56FA5B99019A5CL))*0xA56FA5B99019A5CL)*10)+(m=this.m)){
        buffer[offset]=(BUFFERTYPE)(c+'1');
        buffer[++offset]=(BUFFERTYPE)'.';
        buffer[++offset]=(BUFFERTYPE)'0';
    }else{
        buffer[offset]=(BUFFERTYPE)(c+'0');
        buffer[++offset]=(BUFFERTYPE)'.';
        for(;;){
            if(0xA56FA5B99019A5CL<(b-=(c=(int)(b/0xA56FA5B99019A5CL))*0xA56FA5B99019A5CL)+m){
                if(b>0x52B7D2DCC80CD2EL){
                    ++c;
                }
                break;
            }
            if(b<m){
                break;
            }
            b*=10;
            m*=10;
            buffer[++offset]=(BUFFERTYPE)(c+'0');
        }
        buffer[++offset]=(BUFFERTYPE)(c+'0');
    }
    return printBigIntExponent(buffer,offset,decimalExponent);
}
#ENDDEF

            }
            private abstract static class BigMathGTE1WithS extends BigMathGTE1{
                final long s;
                public BigMathGTE1WithS(final long fractBits,int decimalExponent,final int binaryExponent){
                    final int shiftBias=SHIFT_BIAS[decimalExponent-25];
                    final int mShift=binaryExponent-23-decimalExponent+shiftBias;
                    b=fractBits<<mShift+32;
                    m=1L<<mShift+31;
                    long[] pow5Arr;
                    s=(pow5Arr=POW_5_128)[decimalExponent=decimalExponent-26<<1]>>>32-shiftBias
                            |pow5Arr[decimalExponent+1]<<32+shiftBias;
                }
            }
            private static class BigMathGTE1EasyCase extends BigMathGTE1WithS{
                public BigMathGTE1EasyCase(final int fractBits,final int decimalExponent,final int binaryExponent){
                    super(fractBits,decimalExponent,binaryExponent);
                }
                #MACRO BigMathGTE1EasyCase<byte,Byte>()
                #MACRO BigMathGTE1EasyCase<char,Char>()
#MACRODEF BigMathGTE1EasyCase<BUFFERTYPE,SUFFIX>()
@Override public int getSUFFIXs(final int decimalExponent,final BUFFERTYPE[] buffer,int offset){
    long b;
    long s;
    long hiS;
    int c;
    if((c=(int)(((b=this.b)>>>32)/(hiS=(s=this.s)>>>32)))==0){
        buffer[offset]=(BUFFERTYPE)'1';
        buffer[++offset]=(BUFFERTYPE)'.';
        buffer[++offset]=(BUFFERTYPE)'0';
    }else{
        long m;
        if(s<(b-=c*s)+(m=this.m)){
            buffer[offset]=(BUFFERTYPE)(c+'1');
            buffer[++offset]=(BUFFERTYPE)'.';
            buffer[++offset]=(BUFFERTYPE)'0';
        }else{
            buffer[offset]=(BUFFERTYPE)(c+'0');
            buffer[++offset]=(BUFFERTYPE)'.';
            for(;;){
                if(s<(b=(b*=10)-(c=(int)((b>>>32)/hiS))*s)+(m*=10)){
                    if(b<<1>s){
                        ++c;
                    }
                    break;
                }
                if(b<m){
                    break;
                }
                buffer[++offset]=(BUFFERTYPE)(c+'0');
            }
            buffer[++offset]=(BUFFERTYPE)(c+'0');
        }
    }
    return printBigIntExponent(buffer,offset,decimalExponent);
}
#ENDDEF

            }
            private static class BigMathGTE1HardCase extends BigMathGTE1WithS{
                public BigMathGTE1HardCase(final int fractBits,final int decimalExponent,final int binaryExponent){
                    super(fractBits,decimalExponent,binaryExponent);
                }
                #MACRO BigMathGTE1HardCase<byte,Byte>()
                #MACRO BigMathGTE1HardCase<char,Char>()
#MACRODEF BigMathGTE1HardCase<BUFFERTYPE,SUFFIX>()
private static int fractionLoop(long b,long s,long m,final BUFFERTYPE[] buffer,int offset){
    int c;
    final long hiS=s>>>32;
    final long loS=s&0xffffffffL;
    for(;;){
        long hiB;
        if((c=(int)((hiB=(b*=10)>>>32)/hiS))!=0){
            long carry;
            if((b=((carry=(b&0xffffffffL)-c*loS)>>32)+hiB-c*hiS)>>32!=0){
                break;
            }
            b=(b<<32)+(0xffffffffL&carry);
        }
        if(s<b+(m*=10)){
            if(b<<1>s){
                ++c;
            }
            break;
        }
        if(b<m){
            break;
        }
        buffer[++offset]=(BUFFERTYPE)(c+'0');
    }
    buffer[++offset]=(BUFFERTYPE)(c+'0');
    return offset;
}
@Override public int getSUFFIXs(final int decimalExponent,final BUFFERTYPE[] buffer,int offset){
    long b;
    long s;
    long hiS;
    int c;
    long hiB;
    if((c=(int)((hiB=(b=this.b)>>>32)/(hiS=(s=this.s)>>>32)))==0){
        buffer[offset]=(BUFFERTYPE)'1';
        buffer[++offset]=(BUFFERTYPE)'.';
        buffer[++offset]=(BUFFERTYPE)'0';
    }else{
        long carry;
        if((b=((carry=(b&0xffffffffL)-c*(s&0xffffffffL))>>32)+hiB-c*hiS)>>32==0){
            long m;
            if(s<(b=(b<<32)+(0xffffffffL&carry))+(m=this.m)){
                buffer[offset]=(BUFFERTYPE)(c+'1');
                buffer[++offset]=(BUFFERTYPE)'.';
                buffer[++offset]=(BUFFERTYPE)'0';
            }else{
                buffer[offset]=(BUFFERTYPE)(c+'0');
                buffer[++offset]=(BUFFERTYPE)'.';
                offset=fractionLoop(b,s,m,buffer,offset);
            }
        }else{
            buffer[offset]=(BUFFERTYPE)(c+'0');
            buffer[++offset]=(BUFFERTYPE)'.';
            buffer[++offset]=(BUFFERTYPE)'0';
        }
    }
    return printBigIntExponent(buffer,offset,decimalExponent);
}
#ENDDEF
                
            }
        }
        private static class IntMathGTE1{
            private static final byte[] ESTIMATE_DECIMAL_EXPONENT=new byte[]{0,0,0,0,// 0,1,2,3
                    1,1,1,// 4,5,6
                    2,2,2,// 7,8,9
                    3,3,3,3,// 10,11,12,13
                    4,4,4,// 14,15,16
                    5,5,5,// 17,18,19
                    6,6,6,// 20,21,22,
                    // //the rest not currently used
                    // 6,//23
                    // 7,7,7,//24,25,26
                    // 8,8,8,//27,28,29
                    // 9,9,9,9,//30,31,32,33
                    // 10,10,10,//34,35,36
                    // 11,11,11,//37,38,39
                    // 12,12,12,12,//40,41,42,43
                    // 13,13,13,//44,45,46
                    // 14,14,14,//47,48,49
                    // 15,15,15,15,//50,51,52,53
                    // 16,16,16,//54,55,56
                    // 17,17,17,//57,58,59,
                    // 18,18,18,//60,61,62
            };
            #MACRO IntMathGTE1ToASCII<byte,Byte>()
            #MACRO IntMathGTE1ToASCII<char,Char>()
#MACRODEF IntMathGTE1ToASCII<BUFFERTYPE,SUFFIX>()
static int toASCII(int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    int decimalExponent;
    int m;
    final int s=(m=POW_5_32[decimalExponent=estimateDecimalExponent(fractBits,binaryExponent)]<<decimalExponent)<<24
            -binaryExponent;
    int c;
    buffer[offset]=(BUFFERTYPE)((c=(fractBits<<=1)/s)+'0');
    fractBits-=c*s;
    for(;;){
        if(decimalExponent--==0){
            buffer[++offset]=(BUFFERTYPE)'.';
            break;
        }
        buffer[++offset]=(BUFFERTYPE)((c=(fractBits*=10)/s)+'0');
        fractBits-=c*s;
    }
    for(;;){
        c=(fractBits*=10)/s;
        if((fractBits-=c*s)+(m*=10)>s){
            if(fractBits>=m||(decimalExponent=(fractBits<<1)-s)>0||decimalExponent==0&&c==7){
                ++c;
            }
            break;
        }
        if(fractBits<m){
            break;
        }
        buffer[++offset]=(BUFFERTYPE)(c+'0');
    }
    buffer[++offset]=(BUFFERTYPE)(c+'0');
    return ++offset;
}
#ENDDEF

            private static int estimateDecimalExponent(final int fractBits,final int binaryExponent){
                switch(binaryExponent){
                case 3:
                    if(fractBits>10485759){ return 1; }
                    break;
                case 6:
                    if(fractBits>13107199){ return 2; }
                    break;
                case 9:
                    if(fractBits>16383999){ return 3; }
                    break;
                case 13:
                    if(fractBits>10239999){ return 4; }
                    break;
                case 16:
                    if(fractBits>12799999){ return 5; }
                    break;
                case 19:
                    if(fractBits>15999999){ return 6; }
                default:
                    break;
                }
                return ESTIMATE_DECIMAL_EXPONENT[binaryExponent];
            }
        }
        private static class LongMathGTE1{
          #MACRO LongMathGTE1<byte,Byte>()
          #MACRO LongMathGTE1<char,Char>()
#MACRODEF LongMathGTE1<BUFFERTYPE,SUFFIX>()
static int toASCII(final int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    int decimalExponent;
    long b;
    long m;
    final long s;
    final long tenS=(s=POW_5_64[(decimalExponent=ESTIMATE_DECIMAL_EXPONENT[binaryExponent-63])-1])*10L;
    int c=(int)((b=1L<<binaryExponent-decimalExponent)/s);
    b=(b-c*s)*10L;
    if(c==0){
        // TODO investigate how we can avoid adjusting the decimal exponent without
        // overflowing long
        b=(b-(c=(int)(b/s))*s)*10L;
        m=100L<<binaryExponent-25-decimalExponent--;
    }else{
        m=10L<<binaryExponent-25-decimalExponent;
    }
    buffer[offset]=(BUFFERTYPE)(c+'0');
    buffer[++offset]=(BUFFERTYPE)'.';
    for(;;){
        if((b=(b-(c=(int)(b/s))*s)*10L)+(m*=10)>tenS){
            if(b<<1>tenS){
                ++c;
            }
            break;
        }
        if(b<m){
            break;
        }
        buffer[++offset]=(BUFFERTYPE)(c+'0');
    }
    buffer[++offset]=(BUFFERTYPE)(c+'0');
    return printLongGTE1Exponent(buffer,offset,decimalExponent);
}
static int toASCII(final int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    int decimalExponent;
    long b=(long)fractBits<<binaryExponent-23-(decimalExponent=estimateDecimalExponent(fractBits,binaryExponent));
    long s;
    long m;
    int c;
    if((b-=(c=(int)(b/(s=POW_5_64[decimalExponent-1])))*s)+(m=1L<<binaryExponent-24-decimalExponent)>s){
        buffer[offset]=(BUFFERTYPE)(c+'1');
        buffer[++offset]=(BUFFERTYPE)'.';
        buffer[++offset]=(BUFFERTYPE)'0';
    }else{
        if(c==0){
            // TODO investigate how we can avoid adjusting the decimal exponent without
            // overflowing long
            --decimalExponent;
            m*=10;
            c=(int)((b*=10)/s);
            b-=c*s;
        }
        buffer[offset]=(BUFFERTYPE)(c+'0');
        buffer[++offset]=(BUFFERTYPE)'.';
        if(b<m){
            buffer[++offset]=(BUFFERTYPE)'0';
        }else{
            b*=10;
            m*=10;
            final long tenS=s*10L;
            for(;;){
                b-=(c=(int)(b/s))*s;
                if(m>922337203685477580L){
                    if(b<<1>s){
                        ++c;
                    }
                    break;
                }
                if((b*=10)+(m*=10)>tenS){
                    if(b<<1>tenS){
                        ++c;
                    }
                    break;
                }
                if(b<m){
                    break;
                }
                buffer[++offset]=(BUFFERTYPE)(c+'0');
            }
            buffer[++offset]=(BUFFERTYPE)(c+'0');
        }
    }
    return printLongGTE1Exponent(buffer,offset,decimalExponent);
}
private static int printLongGTE1Exponent(final BUFFERTYPE[] buffer,int offset,int decimalExponent){
    buffer[++offset]=(BUFFERTYPE)'E';
    if(decimalExponent<20){
        buffer[++offset]=(BUFFERTYPE)'1';
        decimalExponent+=10;
    }else{
        buffer[++offset]=(BUFFERTYPE)'2';
    }
    buffer[++offset]=(BUFFERTYPE)(decimalExponent+28);
    return ++offset;
}
#ENDDEF
            
            private static int estimateDecimalExponent(final int fractBits,final int binaryExponent){
                switch(binaryExponent){
                case 63:
                    if(fractBits>9094946){ return 19; }
                    break;
                case 66:
                    if(fractBits>11368683){ return 20; }
                    break;
                case 69:
                    if(fractBits>14210854){ return 21; }
                    break;
                case 73:
                    if(fractBits>8881783){ return 22; }
                    break;
                case 76:
                    if(fractBits>11102229){ return 23; }
                    break;
                case 79:
                    if(fractBits>13877787){ return 24; }
                    break;
                case 82:
                    if(fractBits>16623202){
                        // an anomaly
                        return 25;
                    }
                    break;
                case 83:
                    if(fractBits>8673616){ return 25; }
                default:
                    break;
                }
                return ESTIMATE_DECIMAL_EXPONENT[binaryExponent-63];
            }
        }
        private static class Pow2GTE1{
          private static final byte[] INSIGNIFICANT_DIGITS=new byte[]{1,1,1,// 29,30,31
                  2,2,2,// 32,33,34
                  3,3,3,3,// 35,36,37,38
                  4,4,4,// 39,40,41
                  5,5,5,// 42,43,44
                  6,6,6,6,// 45,46,47,48
                  7,7,7,// 49,50,51
                  8,8,8,// 52,53,54,
                  9,9,9,9,// 55,56,57,58
                  10,10,10,// 59,60,61
                  11// 62
          };
          #MACRO Pow2GTE1<byte,Byte>()
          #MACRO Pow2GTE1<char,Char>()
#MACRODEF Pow2GTE1<BUFFERTYPE,SUFFIX>()
static int toASCII(final int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    // TODO maybe one day, write a more straight forward method than this
    int decimalExponent;
    int c;
    int fractBits;
    if(binaryExponent>28){
        decimalExponent=INSIGNIFICANT_DIGITS[binaryExponent-29];
        if(binaryExponent>30){
            long lFractBits,pow10;
            if((lFractBits=1L<<binaryExponent)
                    -(lFractBits/=pow10=POW_5_64[decimalExponent-1]<<decimalExponent)*pow10>=pow10>>1){
                c=(fractBits=(int)lFractBits+1)-(fractBits/=10)*10;
            }
            else if((c=(fractBits=(int)lFractBits) - (fractBits/=10) * 10) == 0){
                ++decimalExponent;
                c=fractBits - (fractBits/=10) * 10;
            }
        }else{
            c=(fractBits=(1<<binaryExponent)/10)-(fractBits/=10)*10;
        }
    }else{
        decimalExponent=0;
        c=(fractBits=1<<binaryExponent)-(fractBits/=10)*10;
    }
    int strSize;
    decimalExponent+=strSize=getStringSize(fractBits);
    eFormDigits(fractBits,buffer,offset+=strSize+1);
    buffer[offset]=(BUFFERTYPE)(c+'0');
    return printExponent(buffer,offset,decimalExponent);
}
static int toASCII(int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    // TODO maybe one day, write a more straight forward method than this
    int decimalExponent;
    if(binaryExponent>28){
        final long pow10;
        long lFractBits;
        if((lFractBits=(long)fractBits<<binaryExponent-23)-(lFractBits=lFractBits
                /(pow10=POW_5_64[(decimalExponent=INSIGNIFICANT_DIGITS[binaryExponent-29])-1]<<decimalExponent))
                *pow10>=pow10>>1){
            ++lFractBits;
        }
        fractBits=(int)lFractBits;
    }else{
        decimalExponent=0;
        if(binaryExponent>22){
            fractBits<<=binaryExponent-23;
        }else{
            fractBits>>>=23-binaryExponent;
        }
    }
    int c;
    for(;;){
        if((c=fractBits-(fractBits/=10)*10)!=0||fractBits<10){
            break;
        }
        ++decimalExponent;
    }
    int strSize;
    if((decimalExponent+=strSize=getStringSize(fractBits))<7){
        // F form
        if(fractBits!=0){
            mediumDigits(fractBits,buffer,offset+=strSize);
        }
        buffer[offset]=(BUFFERTYPE)(c+'0');
        offset=fillZeros(offset,buffer,offset+decimalExponent-strSize)+1;
        buffer[offset]=(BUFFERTYPE)'.';
        buffer[++offset]=(BUFFERTYPE)'0';
        return ++offset;
    }
    eFormDigits(fractBits,buffer,offset+=strSize+1);
    buffer[offset]=(BUFFERTYPE)(c+'0');
    return printExponent(buffer,offset,decimalExponent);
}
private static void eFormDigits(int val,final BUFFERTYPE[] buffer,int digitOffset){
    int tmp;
    for(;;){
        if(val<81920){
            for(;;){
                if(val<10){
                    buffer[--digitOffset]=(BUFFERTYPE)'.';
                    buffer[--digitOffset]=(BUFFERTYPE)(val+'0');
                    return;
                }
                buffer[--digitOffset]=(BUFFERTYPE)(val-(val=val*52429>>>19)*10+'0');
            }
        }
        // two digits per iteration
        // TODO Would it be faster to promote to long and use multiplication
        // to
        // divide?
        // TODO if this is okay, then perhaps consider the same multiplication
        // with the shift-add technique
        // (valid for val < 4908534099L
        // final int tmp=(int)(((long)val*1374389535)>>>37);
        buffer[--digitOffset]=DIGIT_ONESSUFFIX[val-=(tmp=val/100)*100];
        buffer[--digitOffset]=DIGIT_TENSSUFFIX[val];
        val=tmp;
    }
}
private static int printExponent(final BUFFERTYPE[] buffer,int offset,int decimalExponent){
    buffer[++offset]=(BUFFERTYPE)'E';
    if(decimalExponent>9){
        buffer[++offset]=(BUFFERTYPE)'1';
        decimalExponent-=10;
    }
    buffer[++offset]=(BUFFERTYPE)(decimalExponent+'0');
    return ++offset;
}
#ENDDEF

        }
    }
    /** This class is responsible for printing the digits of a single-precision floating point number when the absolute
     * value of that floating point number is less than 1.0 but not equal to zero and when the value is NOT de-normalized.
     *
     * @author lyonste */
    private static class FltLT1{
        /** This table provides an estimate of the decimal exponent (absolute value) given a binary exponent. */
        private static final byte[] ESTIMATE_DECIMAL_EXPONENT=new byte[]{1,1,1,// -1,-2,-3
                2,2,2,// -4,-5,-6
                3,3,3,// -7,-8,-9
                4,4,4,4, // -10,-11,-12,-13
                5,5,5, // -14,-15,-16
                6,6,6,// -17,-18,-19
                7,7,7,7, // -20,-21,-22,-23
                8,8,8, // -24,-25,-26
                9,9,9,// -27,-28,-29
                10,10,10,10, // -30,-31,-32,-33
                11,11,11, // -34,-35-,36
                12,12,12, // -37,-38,-39
                13,13,13,13,// -40,-41,-42,-43
                14,14,14, // -44,-45,-46
                15,15,15, // -47,-48,-49
                16,16,16,16,// -50,-51,-52,-53
                17,17,17, // -54,-55,-56
                18,18,18, // -57,-58,-59
                19,19,19,19,// -60
                20,20,20, // -64
                21,21,21, // -67
                22,22,22,22,// -70
                23,23,23, // -74
                24,24,24, // -77
                25,25,25,25,// -80
                26,26,26, // -84
                27,27,27, // -87
                28,28,28,28,// -90
                29,29,29, // -94
                30,30,30, // -97
                31,31,31,// -100
                32,32,32,32, // -103
                33,33,33, // -107
                34,34,34,// -110
                35,35,35,35, // -113
                36,36,36, // -117
                37,37,37,// -120
                38,38,38,38, // -123
        };
        #MACRO FltLT1ToASCII<byte,Byte>()
        #MACRO FltLT1ToASCII<char,Char>()
#MACRODEF FltLT1ToASCII<BUFFERTYPE,SUFFIX>()
/** Print the characters of the floating point number into a BUFFERTYPE buffer.
 *
 * @param fractBits
 *          The fraction bits of the floating point number.
 * @param binaryExponent
 *          The biased binary exponent of the floating point number.
 * @param buffer
 *          The buffer to insert the characters into.
 * @param offset
 *          The first offset in the buffer to place characters at.
 * @return The index in the buffer where the last character was placed PLUS ONE. */
static int toASCII(int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,final int offset){
    if(fractBits==0){
        if(binaryExponent<-50){ return BigMathLT1.toASCII(binaryExponent,buffer,offset); }
        if(binaryExponent<-9){ return LongMathLT1.toASCIIEForm(binaryExponent,buffer,offset); }
        return pow2FForm(binaryExponent,buffer,offset);
    }
    fractBits|=0x800000;
    if(binaryExponent<-51){ return BigMathLT1.toASCII(fractBits,binaryExponent,buffer,offset); }
    if(binaryExponent<-5){ return LongMathLT1.toASCII(fractBits,binaryExponent,buffer,offset); }
    return IntMathLT1.toASCII(fractBits,binaryExponent,buffer,offset);
}
/** A specialized case where the fraction bits normalized to 1.
 *
 * @param binaryExponent
 *          The biased binary exponent of the floating point number.
 * @param buffer
 *          The buffer to insert the characters into.
 * @param offset
 *          The first offset in the buffer to place characters at.
 * @return The index in the buffer where the last character was placed PLUS ONE. */
private static int pow2FForm(final int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    buffer[offset]=(BUFFERTYPE)'0';
    buffer[++offset]=(BUFFERTYPE)'.';
    switch(binaryExponent){
    case -1:
        break;
    case -7:
    case -8:
    case -9:
        buffer[++offset]=(BUFFERTYPE)'0';
    default:
        buffer[++offset]=(BUFFERTYPE)'0';
        switch(binaryExponent){
        case -8:
            buffer[++offset]=(BUFFERTYPE)'3';
            buffer[++offset]=(BUFFERTYPE)'9';
            buffer[++offset]=(BUFFERTYPE)'0';
            buffer[++offset]=(BUFFERTYPE)'6';
            break;
        case -7:
            buffer[++offset]=(BUFFERTYPE)'7';
            buffer[++offset]=(BUFFERTYPE)'8';
            buffer[++offset]=(BUFFERTYPE)'1';
            break;
        case -6:
            buffer[++offset]=(BUFFERTYPE)'1';
            buffer[++offset]=(BUFFERTYPE)'5';
        case -4:
            buffer[++offset]=(BUFFERTYPE)'6';
            break;
        case -9:
            buffer[++offset]=(BUFFERTYPE)'1';
            buffer[++offset]=(BUFFERTYPE)'9';
            buffer[++offset]=(BUFFERTYPE)'5';
        default:
            buffer[++offset]=(BUFFERTYPE)'3';
            buffer[++offset]=(BUFFERTYPE)'1';
        }
        buffer[++offset]=(BUFFERTYPE)'2';
        break;
    case -3:
        buffer[++offset]=(BUFFERTYPE)'1';
    case -2:
        buffer[++offset]=(BUFFERTYPE)'2';
    }
    buffer[++offset]=(BUFFERTYPE)'5';
    return ++offset;
}
#ENDDEF

        private static abstract class BigMathLT1 implements BigMathFltToASCII{
            long b;
            long m;
            #MACRO BigMathLT1ToASCII<byte,Byte>()
            #MACRO BigMathLT1ToASCII<char,Char>()
#MACRODEF BigMathLT1ToASCII<BUFFERTYPE,SUFFIX>()
static int toASCII(int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    int decimalExponent;
    int s=25-binaryExponent-(decimalExponent=ESTIMATE_DECIMAL_EXPONENT[-1-binaryExponent]);
    long b,m;
    long[] pow5Arr;
    if(decimalExponent<27){
        b=(pow5Arr=POW_5_64)[decimalExponent-1]>>>(s-=60)<<24;
        m=pow5Arr[decimalExponent]>>>s;
    }else{
        b=(pow5Arr=POW_5_128)[binaryExponent=decimalExponent-26<<1]>>>s-84|pow5Arr[++binaryExponent]<<148-s;
        m=pow5Arr[binaryExponent+2]<<124-s;
    }
    s=(int)(b>>>59);
    b=(b&(1L<<59)-1)*10;
    buffer[offset]=(BUFFERTYPE)(s+'0');
    buffer[++offset]=(BUFFERTYPE)'.';
    return printBigIntLT1Exp(decimalExponent,buffer,fractionLoop(b,m,buffer,offset));
}
static int toASCII(final int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,final int offset){
    int decimalExponent;
    int shiftBias;
    BigMathFltToASCII bsm;
    if((shiftBias=24-binaryExponent-(decimalExponent=estimateDecimalExponent(fractBits,binaryExponent)))<92){
        bsm=new BigMathLT1LowBias(fractBits,decimalExponent,92-shiftBias);
    }else if(shiftBias==92){
        bsm=new BigMathLT1Unbiased(fractBits,decimalExponent);
    }else{
        bsm=new BigMathLT1HighBias(fractBits,decimalExponent,124-shiftBias);
    }
    return bsm.getSUFFIXs(decimalExponent,buffer,offset);
}
private static int fractionLoop(long b,long m,final BUFFERTYPE[] buffer,int offset){
    int c;
    for(;;){
        c=(int)(b>>>59);
        if((b&=(1L<<59)-1)+m>1L<<59){
            if(b>1L<<58){
                ++c;
            }
            break;
        }
        if(b<m){
            break;
        }
        buffer[++offset]=(BUFFERTYPE)(c+'0');
        b*=10;
        m*=10;
    }
    buffer[++offset]=(BUFFERTYPE)(c+'0');
    return offset;
}
private static int printBigIntLT1Exp(int decimalExponent,final BUFFERTYPE[] buffer,int offset){
    buffer[++offset]=(BUFFERTYPE)'E';
    buffer[++offset]=(BUFFERTYPE)'-';
    if(decimalExponent>29){
        buffer[++offset]=(BUFFERTYPE)'3';
        decimalExponent-=30;
    }else if(decimalExponent>19){
        buffer[++offset]=(BUFFERTYPE)'2';
        decimalExponent-=20;
    }else{
        buffer[++offset]=(BUFFERTYPE)'1';
        decimalExponent-=10;
    }
    buffer[++offset]=(BUFFERTYPE)(decimalExponent+'0');
    return ++offset;
}
private static int printFraction(final long b,final long m,final BUFFERTYPE[] buffer,int offset){
    buffer[++offset]=(BUFFERTYPE)'.';
    if(b<m){
        buffer[++offset]=(BUFFERTYPE)'0';
    }else{
        offset=fractionLoop(b,m,buffer,offset);
    }
    return offset;
}
#ENDDEF
            private static int estimateDecimalExponent(final int fractBits,final int binaryExponent){
                // TODO this method is probably too big.
                // consider refactoring
                switch(binaryExponent){
                case -54:
                    if(fractBits>15111572){ return 16; }
                    break;
                case -57:
                    if(fractBits>12089257){ return 17; }
                    break;
                case -60:
                    if(fractBits>9671406){ return 18; }
                    break;
                case -64:
                    if(fractBits>15474249){ return 19; }
                    break;
                case -67:
                    if(fractBits>12379399){ return 20; }
                    break;
                case -70:
                    if(fractBits>9903519){ return 21; }
                    break;
                case -74:
                    if(fractBits>15845632){ return 22; }
                    break;
                case -77:
                    if(fractBits>12676505){ return 23; }
                    break;
                case -80:
                    if(fractBits>10141204){ return 24; }
                    break;
                case -84:
                    if(fractBits>16225927){ return 25; }
                    break;
                case -87:
                    if(fractBits>12980741){ return 26; }
                    break;
                case -90:
                    if(fractBits>10384593){ return 27; }
                    break;
                case -94:
                    if(fractBits>16615349){ return 28; }
                    break;
                case -97:
                    if(fractBits>13292279){ return 29; }
                    break;
                case -100:
                    if(fractBits>10633823){ return 30; }
                    break;
                case -103:
                    if(fractBits>8507058){ return 31; }
                    break;
                case -107:
                    if(fractBits>13611294){ return 32; }
                    break;
                case -110:
                    if(fractBits>10889035){ return 33; }
                    break;
                case -113:
                    if(fractBits>8711228){ return 34; }
                    break;
                case -117:
                    if(fractBits>13937965){ return 35; }
                    break;
                case -120:
                    if(fractBits>11150372){ return 36; }
                    break;
                case -123:
                    if(fractBits>8920297){ return 37; }
                default:
                    break;
                }
                return ESTIMATE_DECIMAL_EXPONENT[-1-binaryExponent];
            }
            private static class BigMathLT1HighBias extends BigMathLT1ShortCircuit{
                public BigMathLT1HighBias(final int fractBits,int decimalExponent,final int shiftBias){
                    long[] pow5Arr;
                    long carry;
                    b=(((carry=(pow5Arr=POW_5_128)[decimalExponent=decimalExponent-26<<1])>>>32)*fractBits
                            +((carry&0xffffffffL)*fractBits>>>32)>>>32-shiftBias)+(pow5Arr[++decimalExponent]*fractBits<<shiftBias);
                    m=pow5Arr[++decimalExponent]>>>64-shiftBias|pow5Arr[++decimalExponent]<<shiftBias;
                }
            }
            private static class BigMathLT1LowBias extends BigMathLT1ShortCircuit{
                public BigMathLT1LowBias(final int fractBits,int decimalExponent,int shiftBias){
                    long[] pow5Arr;
                    long carry;
                    if(decimalExponent<27){
                        b=((carry=(pow5Arr=POW_5_64)[decimalExponent-1])>>32)*fractBits
                                +((carry=(carry&0xffffffffL)*fractBits)>>32)<<shiftBias|(carry&0xffffffffL)>>>(shiftBias=32-shiftBias);
                        m=pow5Arr[decimalExponent]>>>shiftBias;
                    }else{
                        b=(((carry=(pow5Arr=POW_5_128)[decimalExponent=decimalExponent-26<<1])>>>32)*fractBits
                                +((carry&0xffffffffL)*fractBits>>>32)<<shiftBias)+(pow5Arr[++decimalExponent]*fractBits<<shiftBias+32);
                        m=pow5Arr[++decimalExponent]>>>32-shiftBias|pow5Arr[++decimalExponent]<<32+shiftBias;
                    }
                }
            }
            private static class BigMathLT1NonShortCircuit extends BigMathLT1{
              #MACRO BigMathLT1NonShortCircuit<byte,Byte>()
              #MACRO BigMathLT1NonShortCircuit<char,Char>()
#MACRODEF BigMathLT1NonShortCircuit<BUFFERTYPE,SUFFIX>()
@Override public int getSUFFIXs(final int decimalExponent,final BUFFERTYPE[] buffer,int offset){
    long b;
    final int c=(int)((b=this.b)>>>59);
    b=(b&(1L<<59)-1)*10;
    buffer[offset]=(BUFFERTYPE)(c+'0');
    offset=printFraction(b,m,buffer,offset);
    return printBigIntLT1Exp(decimalExponent,buffer,offset);
}
#ENDDEF

            }
            private static class BigMathLT1ShortCircuit extends BigMathLT1{
              #MACRO BigMathLT1ShortCircuit<byte,Byte>()
              #MACRO BigMathLT1ShortCircuit<char,Char>()
#MACRODEF BigMathLT1ShortCircuit<BUFFERTYPE,SUFFIX>()
@Override public int getSUFFIXs(final int decimalExponent,final BUFFERTYPE[] buffer,int offset){
    long b,m;
    final int c=(int)((b=this.b)>>>59);
    if((b=(b&(1L<<59)-1)*10)+(m=this.m)>10L<<59){
        buffer[offset]=(BUFFERTYPE)(c+'1');
        buffer[++offset]=(BUFFERTYPE)'.';
        buffer[++offset]=(BUFFERTYPE)'0';
    }else{
        buffer[offset]=(BUFFERTYPE)(c+'0');
        offset=printFraction(b,m,buffer,offset);
    }
    return printBigIntLT1Exp(decimalExponent,buffer,offset);
}
#ENDDEF

            }
            private static class BigMathLT1Unbiased extends BigMathLT1NonShortCircuit{
                public BigMathLT1Unbiased(final int fractBits,int decimalExponent){
                    long[] pow5Arr;
                    long carry;
                    b=((carry=(pow5Arr=POW_5_128)[decimalExponent=decimalExponent-26<<1])>>>32)*fractBits
                            +((carry&0xffffffffL)*fractBits>>>32)+(pow5Arr[++decimalExponent]*fractBits<<32);
                    m=pow5Arr[++decimalExponent]>>>32|pow5Arr[++decimalExponent]<<32;
                }
            }
        }
        private static class IntMathLT1{
          #MACRO IntMathLT1<byte,Byte>()
          #MACRO IntMathLT1<char,Char>()
#MACRODEF IntMathLT1<BUFFERTYPE,SUFFIX>()
static int toASCII(final int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    final int decimalExponent;
    int b,m;
    final int sPow;
    int c=(b=(m=POW_5_32[decimalExponent=estimateDecimalExponent(fractBits,binaryExponent)])*fractBits<<1)>>>(sPow
            =24-binaryExponent-decimalExponent);
    int sModMask;
    int s;
    b&=sModMask=(s=1<<sPow)-1;
    buffer[offset]=(BUFFERTYPE)'0';
    buffer[++offset]=(BUFFERTYPE)'.';
    offset=fillZeros(offset,buffer,offset+decimalExponent-1)+1;
    if(b+m>s){
        buffer[offset]=(BUFFERTYPE)(c+'1');
    }else{
        buffer[offset]=(BUFFERTYPE)(c+'0');
        if(b>=m){
            for(;;){
                c=(b*=10)>>>sPow;
                if((b&=sModMask)+(m*=10)>s){
                    int lowDigitDif;
                    if(b>=m||(lowDigitDif=(b<<1)-s)>0||lowDigitDif==0&&(c&1)!=0){
                        ++c;
                    }
                    break;
                }
                if(b<m){
                    break;
                }
                buffer[++offset]=(BUFFERTYPE)(c+'0');
            }
            buffer[++offset]=(BUFFERTYPE)(c+'0');
        }
    }
    return ++offset;
}
#ENDDEF

            private static int estimateDecimalExponent(final int fractBits,final int binaryExponent){
                if(binaryExponent==-4&&fractBits>13421772){ return 1; }
                return ESTIMATE_DECIMAL_EXPONENT[-1-binaryExponent];
            }
        }
        private static class LongMathLT1{
          #MACRO LongMathLT1<byte,Byte>()
          #MACRO LongMathLT1<char,Char>()
#MACRODEF LongMathLT1<BUFFERTYPE,SUFFIX>()
static int toASCII(final int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,final int offset){
    final int decimalExponent;
    if((decimalExponent=estimateDecimalExponent(fractBits,binaryExponent))<4){ return toASCIIFForm(fractBits,binaryExponent,buffer,offset,decimalExponent); }
    return toASCIIEForm(fractBits,binaryExponent,buffer,offset,decimalExponent);
}
static int toASCIIEForm(final int binaryExponent,final BUFFERTYPE[] buffer,int offset){
    int decimalExponent;
    long b,m,s,sModMask;
    int sPow;
    buffer[offset]
            =(BUFFERTYPE)(((b=(m=POW_5_64[(decimalExponent=ESTIMATE_DECIMAL_EXPONENT[-1-binaryExponent])-1])<<25)>>>(sPow
                    =25-binaryExponent-decimalExponent))+'0');
    buffer[++offset]=(BUFFERTYPE)'.';
    b&=sModMask=(s=1L<<sPow)-1L;
    int c;
    for(;;){
        c=(int)((b*=10L)>>>sPow);
        if((b&=sModMask)+(m*=10L)>s){
            if(b<<1>s){
                ++c;
            }
            break;
        }
        if(b<m){
            break;
        }
        buffer[++offset]=(BUFFERTYPE)(c+'0');
    }
    buffer[++offset]=(BUFFERTYPE)(c+'0');
    return printLongLT1Exp(decimalExponent,buffer,offset);
}
private static int printLongLT1Exp(int decimalExponent,final BUFFERTYPE[] buffer,int offset){
    buffer[++offset]=(BUFFERTYPE)'E';
    buffer[++offset]=(BUFFERTYPE)'-';
    if(decimalExponent>9){
        buffer[++offset]=(BUFFERTYPE)'1';
        decimalExponent-=10;
    }
    buffer[++offset]=(BUFFERTYPE)(decimalExponent+'0');
    return ++offset;
}
private static int toASCIIEForm(final int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,int offset,
        final int decimalExponent){
    long m;
    final int sPow;
    long b;
    int c=(int)((b=fractBits*(m=POW_5_64[decimalExponent-1])<<1)>>>(sPow=24-binaryExponent-decimalExponent));
    long s;
    long sModMask;
    if((b&=sModMask=(s=1L<<sPow)-1L)+m>s){
        buffer[offset]=(BUFFERTYPE)(c+'1');
        buffer[++offset]=(BUFFERTYPE)'.';
        buffer[++offset]=(BUFFERTYPE)'0';
    }else{
        buffer[offset]=(BUFFERTYPE)(c+'0');
        buffer[++offset]=(BUFFERTYPE)'.';
        if(b<m){
            buffer[++offset]=(BUFFERTYPE)'0';
        }else{
            for(;;){
                c=(int)((b*=10L)>>>sPow);
                if((b&=sModMask)+(m*=10L)>s){
                    if(b<<1>s){
                        ++c;
                    }
                    break;
                }
                if(b<m){
                    break;
                }
                buffer[++offset]=(BUFFERTYPE)(c+'0');
            }
            buffer[++offset]=(BUFFERTYPE)(c+'0');
        }
    }
    return printLongLT1Exp(decimalExponent,buffer,offset);
}
private static int toASCIIFForm(final int fractBits,final int binaryExponent,final BUFFERTYPE[] buffer,int offset,
        final int decimalExponent){
    long m;
    final int sPow;
    long b;
    final long s;
    int c=(int)((b=fractBits*(m=POW_5_64[decimalExponent-1])<<1)>>>(sPow=24-binaryExponent-decimalExponent));
    buffer[offset]=(BUFFERTYPE)'0';
    buffer[++offset]=(BUFFERTYPE)'.';
    offset=fillZeros(offset,buffer,offset+decimalExponent-1);
    final long sModMask;
    if((b&=sModMask=(s=1L<<sPow)-1)+m>s){
        buffer[++offset]=(BUFFERTYPE)(c+'1');
    }else{
        buffer[++offset]=(BUFFERTYPE)(c+'0');
        if(b>=m){
            for(;;){
                c=(int)((b*=10)>>>sPow);
                if((b&=sModMask)+(m*=10)>s){
                    int lowDigitDif;
                    if(b>=m||(lowDigitDif=(int)((b<<1)-s))>0||lowDigitDif==0&&(c&1)!=0){
                        ++c;
                    }
                    break;
                }
                if(b<m){
                    break;
                }
                buffer[++offset]=(BUFFERTYPE)(c+'0');
            }
            buffer[++offset]=(BUFFERTYPE)(c+'0');
        }
    }
    return ++offset;
}
#ENDDEF

            private static int estimateDecimalExponent(final int fractBits,final int binaryExponent){
                switch(binaryExponent){
                case -7:
                    if(fractBits>10737417){ return 2; }
                    break;
                case -10:
                    if(fractBits>8589934){ return 3; }
                    break;
                case -14:
                    if(fractBits>13743894){ return 4; }
                    break;
                case -17:
                    if(fractBits>10995115){ return 5; }
                    break;
                case -20:
                    if(fractBits>8796092){ return 6; }
                    break;
                case -24:
                    if(fractBits>14073748){ return 7; }
                    break;
                case -27:
                    if(fractBits>11258998){ return 8; }
                    break;
                case -30:
                    if(fractBits>9007198){ return 9; }
                    break;
                case -34:
                    if(fractBits>14411518){ return 10; }
                    break;
                case -37:
                    if(fractBits>11529214){ return 11; }
                    break;
                case -40:
                    if(fractBits>9223371){ return 12; }
                    break;
                case -44:
                    if(fractBits>14757394){ return 13; }
                    break;
                case -47:
                    if(fractBits>11805915){ return 14; }
                    break;
                case -50:
                    if(fractBits>9444732){ return 15; }
                default:
                    break;
                }
                return ESTIMATE_DECIMAL_EXPONENT[-1-binaryExponent];
            }

        }
    }
    private final static int[] INT_SIZE_TABLE={9,99,999,9999,99999,999999,9999999,99999999,999999999,Integer.MAX_VALUE};

    /** Powers of 5. */
    private static final int[] POW_5_32={1,// pow5=0;
            5,// pow5=1
            5 * 5,// pow5=2;
            5 * 5 * 5,// pow5=3;
            5 * 5 * 5 * 5,// pow5=4;
            5 * 5 * 5 * 5 * 5,// pow5=5
            5 * 5 * 5 * 5 * 5 * 5,// pow5=6
    };
    /** Powers of 5. */
    private static final long[] POW_5_64={5L,// pow5=1
            5L * 5,// pow5=2
            5L * 5 * 5,// pow5=3
            5L * 5 * 5 * 5,// pow5=4
            5L * 5 * 5 * 5 * 5,// pow5=5
            5L * 5 * 5 * 5 * 5 * 5,// pow5=6
            5L * 5 * 5 * 5 * 5 * 5 * 5,// pow5=7
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=8
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=9
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=10
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=11
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=12
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=13
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=14
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=15
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=16
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=17
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=18
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=29
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=20
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=21
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=22
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=23
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=24
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=25
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=26
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,// pow5=27
    };
    /** Powers of 5 (each power takes up two long values) */
    private static final long[] POW_5_128=new long[]{0x14ADF4B7320334B9L,0x0000000000000000L,// pow5=26
            0x6765C793FA10079DL,0x0000000000000000L,// pow5=27
            0x04FCE5E3E2502611L,0x0000000000000002L,// pow5=28
            0x18F07D736B90BE55L,0x000000000000000AL,// pow5=29
            0x7CB2734119D3B7A9L,0x0000000000000032L,// pow5=30
            0x6F7C40458122964DL,0x00000000000000FCL,// pow5=31
            0x2D6D415B85ACEF81L,0x00000000000004EEL,// pow5=32
            0xE32246C99C60AD85L,0x00000000000018A6L,// pow5=33
            0x6FAB61F00DE36399L,0x0000000000007B42L,// pow5=34
            0x2E58E9B04570F1FDL,0x000000000002684CL,// pow5=35
            0xE7BC90715B34B9F1L,0x00000000000C097CL,// pow5=36
            0x86AED236C807A1B5L,0x00000000003C2F70L,// pow5=37
            0xA16A1B11E8262889L,0x00000000012CED32L,// pow5=38
            0x2712875988BECAADL,0x0000000005E0A1FDL,// pow5=39
            0xC35CA4BFABB9F561L,0x000000001D6329F1L,// pow5=40
            0xD0CF37BE5AA1CAE5L,0x0000000092EFD1B8L,// pow5=41
            0x140C16B7C528F679L,0x00000002DEAF189CL,// pow5=42
            0x643C7196D9CCD05DL,0x0000000E596B7B0CL,// pow5=43
            0xF52E37F2410011D1L,0x00000047BF19673DL,// pow5=44
            0xC9E717BB45005915L,0x00000166BB7F0435L,// pow5=45
            0xF18376A85901BD69L,0x00000701A97B150CL,// pow5=46
    };
}
