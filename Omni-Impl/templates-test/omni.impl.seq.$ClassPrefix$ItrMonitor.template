#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import org.junit.jupiter.api.Assertions;
import omni.impl.$ClassPrefix$InputTestArgType;
import omni.impl.FunctionCallType;
#IF OfRef,OfDouble,OfLong,OfInt
import java.util.function.$TypeNameModifier$Consumer;
#ELSE
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
abstract class $ClassPrefix$ItrMonitor
{
  static enum ItrType
  {
    Itr,
    ListItr;
  }
  final OmniIterator.Of$ClassPrefix$ itr;
  int expectedCursor;
  int expectedLastRet;
  $ClassPrefix$ItrMonitor(OmniIterator.Of$ClassPrefix$ itr,int expectedCursor){
    this.itr=itr;
    this.expectedCursor=expectedCursor;
    this.expectedLastRet=-1;
  }
  public void iterateReverse()
  {
    ((OmniListIterator.Of$ClassPrefix$)itr).previous$TypeNameModifier$();
    expectedLastRet=--expectedCursor;
  }
  
  
  public abstract void verifyIteratorState();
  public void set(int v,$ClassPrefix$InputTestArgType inputArgType){
     inputArgType.callListItrSet((OmniListIterator.Of$ClassPrefix$)itr,v);
  }
  public void set(int v)
  {
    set(v,$ClassPrefix$InputTestArgType.ARRAY_TYPE);
  }
  public void add(int v,$ClassPrefix$InputTestArgType inputArgType){
    throw new UnsupportedOperationException();
  }
  public void add(int v)
  {
    add(v,$ClassPrefix$InputTestArgType.ARRAY_TYPE);
  }
  public abstract void iterateForward();

  public abstract void remove();
  public boolean hasNext(){
    return itr.hasNext();
  }
  public boolean hasPrevious(){
    return ((OmniListIterator.Of$ClassPrefix$)itr).hasPrevious();
  }
  public int nextIndex(){
    return ((OmniListIterator.Of$ClassPrefix$)itr).nextIndex();
  }
  public int previousIndex(){
    return ((OmniListIterator.Of$ClassPrefix$)itr).previousIndex();
  }
  //TODO forEachRemaining
}