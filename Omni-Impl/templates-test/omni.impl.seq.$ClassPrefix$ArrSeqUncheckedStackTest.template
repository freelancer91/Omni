#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import java.util.ArrayList;
import omni.api.OmniCollection;
import omni.util.OmniArray;
import omni.api.OmniList;
import omni.api.OmniStack;
import java.util.function.Predicate;
import java.util.function.Consumer;
import java.util.Comparator;
import omni.util.ArrCopy;
import omni.util.$ClassPrefix$SortUtil;
import omni.impl.CheckedCollection;
import java.util.NoSuchElementException;
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import java.util.function.IntFunction;
import java.util.function.UnaryOperator;
#IF OfRef,OfInt,OfLong,OfDouble,OfBoolean
import java.util.function.$TypeNameModifier$Supplier;
#ELSE
import omni.function.$TypeNameModifier$Supplier;
#ENDIF
#IFNOT OfRef
import omni.util.TypeUtil;
#ENDIF
import java.util.ConcurrentModificationException;
#IF OfInt,OfLong,OfDouble
import java.util.function.$UnaryOperator$;
#ELSEIFNOT OfBoolean,OfRef
import omni.function.$UnaryOperator$;
#ENDIF
#IF OfInt
import java.util.function.$Comparator$;
#ELSEIFNOT OfRef
import omni.function.$Comparator$;
#ENDIF
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Predicate;
import java.util.function.$TypeNameModifier$Consumer;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Predicate;
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
#IFNOT OfDouble,OfChar,OfRef
import omni.util.ToStringUtil;
#ENDIF
#IFNOT OfBoolean
import omni.util.BitSetUtil;
#ENDIF
#IFNOT OfRef
import omni.impl.Abstract$TypeNameModifier$Itr;
#ENDIF
#IF OfRef
import omni.util.OmniPred;
#ENDIF
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import omni.impl.seq.$ClassPrefix$ArrSeq.UncheckedStack;
import omni.util.TypeConversionUtil;
@SuppressWarnings({"rawtypes","unchecked"}) 
public class $ClassPrefix$ArrSeqUncheckedStackTest
{
#IF OfRef
  private static final $ArrayType$ MIN_LENGTH_STRING_VAL=new $ArrayType$(){@Override public String toString(){return "";}};
#ELSEIF OfBoolean
  private static final $ArrayType$ MIN_LENGTH_STRING_VAL=true;
#ELSE
  private static final $ArrayType$ MIN_LENGTH_STRING_VAL=0;
#ENDIF
  private static final int MIN_TOSTRING_LENGTH=String.valueOf(MIN_LENGTH_STRING_VAL).length();

#IF OfBoolean
  private static final int MAX_TOSTRING_LENGTH=5;
#ELSEIF OfByte
  private static final int MAX_TOSTRING_LENGTH=4;
#ELSEIF OfShort
  private static final int MAX_TOSTRING_LENGTH=6;
#ELSEIF OfInt
  private static final int MAX_TOSTRING_LENGTH=11;
#ELSEIF OfLong
  private static final int MAX_TOSTRING_LENGTH=20;
#ELSEIF OfFloat
  private static final int MAX_TOSTRING_LENGTH=15;
#ENDIF
  

  
  

  @Test
  public void testConstructors()
  {
    var stack=new UncheckedStack();
    Assertions.assertEquals(stack.size(),0);
    Assertions.assertTrue(stack.isEmpty());
    Assertions.assertTrue(stack.arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR);
    stack=new UncheckedStack(0);
    Assertions.assertEquals(stack.size(),0);
    Assertions.assertTrue(stack.isEmpty());
    Assertions.assertTrue(stack.arr==null);
    stack=new UncheckedStack(OmniArray.DEFAULT_ARR_SEQ_CAP);
    Assertions.assertEquals(stack.size(),0);
    Assertions.assertTrue(stack.isEmpty());
    Assertions.assertTrue(stack.arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR);
    for(int i=1;i<OmniArray.DEFAULT_ARR_SEQ_CAP;++i)
    {
      stack=new UncheckedStack(i);
      Assertions.assertEquals(stack.size(),0);
      Assertions.assertTrue(stack.isEmpty());
      Assertions.assertEquals(stack.arr.length,i);
    }
  }
 
  
  private static UncheckedStack generateStack(int length,$TypeNameModifier$Supplier supplier)
  {
    UncheckedStack stack=new UncheckedStack(length);
    for(int i=0;i<length;++i)
    {
#IF OfRef
      $ArrayType$ v=supplier.get();
#ELSE
      $ArrayType$ v=supplier.getAs$TypeNameModifier$();
#ENDIF
      
      stack.push(v);
    }
    return stack;
  }
  private static ArrayList generateList(int length,$TypeNameModifier$Supplier supplier)
  {
    ArrayList stack=new ArrayList(length);
    for(int i=0;i<length;++i)
    {
#IF OfRef
      $ArrayType$ v=supplier.get();
#ELSE
      $ArrayType$ v=supplier.getAs$TypeNameModifier$();
#ENDIF
      stack.add(v);
    }
    return stack;
  }
  
  
  @Test
  public void testClone()
  {
    var stack=new UncheckedStack();
    Object clonedObject=stack.clone();
    Assertions.assertTrue(clonedObject instanceof UncheckedStack);
    var clonedStack=(UncheckedStack)clonedObject;
    Assertions.assertTrue(clonedStack.arr==stack.arr);
    Assertions.assertEquals(clonedStack.size(),stack.size());
    Assertions.assertTrue(stack!=clonedStack);
    for(int i=0;i<100;++i)
    {
      #IF OfRef
      var val=TypeConversionUtil.convertToInteger(i);
      #ELSE
      var val=TypeConversionUtil.convertTo$exposedType$(i);
      #ENDIF
      stack.push(val);
    }
    Assertions.assertEquals(stack.size(),100);
    clonedObject=stack.clone();
    Assertions.assertTrue(clonedObject instanceof UncheckedStack);
    clonedStack=(UncheckedStack)clonedObject;
    Assertions.assertTrue(clonedStack.arr!=stack.arr);
    Assertions.assertEquals(stack.size(),clonedStack.size());
    for(int i=0;i<stack.size();++i)
    {
      Assertions.assertTrue(stack.arr[i]==clonedStack.arr[i]);
    }
  }
  
  @Test
  public void testEmptyToString()
  {
    var stack=generateStack(0,null);
    var arrayList=generateList(0,null);
    Assertions.assertEquals(stack.toString(),arrayList.toString());
  }
  @Test
  public void testEmptyHashCode()
  {
    var stack=generateStack(0,null);
    var arrayList=generateList(0,null);
    Assertions.assertEquals(stack.hashCode(),arrayList.hashCode());
  }
  @Test
  public void testHashCode()
  {
    int length=100;
    $TypeNameModifier$Supplier stackGenerator=new $TypeNameModifier$Supplier()
    {
      int index=0;
#IF OfRef
      public $ArrayType$ get()
      {
        return TypeConversionUtil.convertToInteger(index++);
      } 
#ELSE
      public $ArrayType$ getAs$TypeNameModifier$()
      {
        return TypeConversionUtil.convertTo$exposedType$(index++);
      }
#ENDIF
    };
    $TypeNameModifier$Supplier listGenerator=new $TypeNameModifier$Supplier()
    {
      int index=length;
#IF OfRef
      public $ArrayType$ get()
      {
        return TypeConversionUtil.convertToInteger(--index);
      } 
#ELSE
      public $ArrayType$ getAs$TypeNameModifier$()
      {
        return TypeConversionUtil.convertTo$exposedType$(--index);
      }
#ENDIF
    };
    var stack=generateStack(length,stackGenerator);
    var arrayList=generateList(length,listGenerator);
    Assertions.assertEquals(stack.hashCode(),arrayList.hashCode());
    
  }
  @Test
  public void testOOMToString()
  {
    int length=Integer.MAX_VALUE/(MIN_TOSTRING_LENGTH+2);
    var stack=new UncheckedStack(length+1);
    var arrayList=new ArrayList<>(length+1);
    for(int i=0;i<length;++i)
    {
      stack.push(MIN_LENGTH_STRING_VAL);
      arrayList.add(MIN_LENGTH_STRING_VAL);
    }
    Assertions.assertEquals(stack.toString(),arrayList.toString());
    stack.push(MIN_LENGTH_STRING_VAL);
    Assertions.assertThrows(OutOfMemoryError.class,()->stack.toString());
  }
  @Test
  public void testSmallToString()
  {
    int length=100;
    $TypeNameModifier$Supplier stackGenerator=new $TypeNameModifier$Supplier()
    {
      int index=0;
#IF OfRef
      public $ArrayType$ get()
      {
        return TypeConversionUtil.convertToInteger(index++);
      } 
#ELSE
      public $ArrayType$ getAs$TypeNameModifier$()
      {
        return TypeConversionUtil.convertTo$exposedType$(index++);
      }
#ENDIF
    };
    $TypeNameModifier$Supplier listGenerator=new $TypeNameModifier$Supplier()
    {
      int index=length;
#IF OfRef
      public $ArrayType$ get()
      {
        return TypeConversionUtil.convertToInteger(--index);
      } 
#ELSE
      public $ArrayType$ getAs$TypeNameModifier$()
      {
        return TypeConversionUtil.convertTo$exposedType$(--index);
      }
#ENDIF
    };
    var stack=generateStack(length,stackGenerator);
    var arrayList=generateList(length,listGenerator);
    Assertions.assertEquals(stack.toString(),arrayList.toString());
  }
#IF OfBoolean,OfByte,OfShort,OfInt,OfLong,OfFloat
  @Test
  public void testLargeToString()
  {
    
    int length=(OmniArray.MAX_ARR_SIZE/(MAX_TOSTRING_LENGTH+2))+1;
    $TypeNameModifier$Supplier stackGenerator=new $TypeNameModifier$Supplier()
    {
      int index=0;
#IF OfRef
      public $ArrayType$ get()
      {
        return TypeConversionUtil.convertToInteger(index++);
      } 
#ELSE
      public $ArrayType$ getAs$TypeNameModifier$()
      {
        return TypeConversionUtil.convertTo$exposedType$(index++);
      }
#ENDIF
    };
    $TypeNameModifier$Supplier listGenerator=new $TypeNameModifier$Supplier()
    {
      int index=length;
#IF OfRef
      public $ArrayType$ get()
      {
        return TypeConversionUtil.convertToInteger(--index);
      } 
#ELSE
      public $ArrayType$ getAs$TypeNameModifier$()
      {
        return TypeConversionUtil.convertTo$exposedType$(--index);
      }
#ENDIF
    };
    var stack=generateStack(length,stackGenerator);
    var arrayList=generateList(length,listGenerator);
    Assertions.assertEquals(stack.toString(),arrayList.toString());
  }
#ENDIF
  
}