#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;

import java.util.function.Predicate;
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Predicate;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Predicate;
#ENDIF
#IFNOT OfBoolean
import org.junit.jupiter.api.Assertions;
import omni.util.TypeConversionUtil;
import omni.util.EqualityUtil;
#ENDIF
#IF OfRef
@SuppressWarnings({"rawtypes","unchecked"}) 
abstract class $ClassPrefix$MonitoredPredicate implements $TypeNameModifier$Predicate<Object>
#ELSE
abstract class $ClassPrefix$MonitoredPredicate implements $TypeNameModifier$Predicate,Predicate<Object>
#ENDIF
{
  int callCount;
  abstract boolean testImpl($ArrayType$ val);
  @Override public boolean test($ArrayType$ val){
    ++callCount;
    return testImpl(($ArrayType$)val);
  }
  public $ClassPrefix$MonitoredPredicate negate(){
    //don't care
    return null;
  }
#IFNOT OfRef
  @Override public boolean test(Object val){
    return test(($ArrayType$)val);
  }
#ENDIF
  
  static class RemoveAllPredicate extends $ClassPrefix$MonitoredPredicate{
    RemoveAllPredicate(){}
    RemoveAllPredicate(Object dummy){}
    boolean testImpl($ArrayType$ val){
      return true;
    }
#IFNOT OfBoolean
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
  #IF OfRef
      for(int bound=offset+originalLength;offset<bound;++offset){
        Assertions.assertNull(arr[offset]);
      }
  #ENDIF
    }
#ENDIF
  }
  static class RemoveNonePredicate extends $ClassPrefix$MonitoredPredicate{
    RemoveNonePredicate(){}
    RemoveNonePredicate(Object dummy){}
    boolean testImpl($ArrayType$ val){
      return false;
    }
#IFNOT OfBoolean
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset){
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
    }
#ENDIF
  }
  static class ThrowingPredicate extends $ClassPrefix$MonitoredPredicate{
    ThrowingPredicate(){}
    ThrowingPredicate(Object dummy){}
    @Override boolean testImpl($ArrayType$ val){
      throw new IndexOutOfBoundsException();
    }
#IFNOT OfBoolean
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset){
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
    }
#ENDIF
  }
#IF OfBoolean
  static class RemoveTruePredicate extends $ClassPrefix$MonitoredPredicate{
    RemoveTruePredicate(){}
    RemoveTruePredicate(Object dummy){}
    boolean testImpl($ArrayType$ val){
      return val;
    }
  }
  static class RemoveFalsePredicate extends $ClassPrefix$MonitoredPredicate{
    RemoveFalsePredicate(){}
    RemoveFalsePredicate(Object dummy){}
    boolean testImpl($ArrayType$ val){
      return !val;
    }
  }
#ELSE
  static class RetainSecondPredicate extends $ClassPrefix$MonitoredPredicate{
    RetainSecondPredicate(){}
    RetainSecondPredicate(Object dummy){}
    boolean testImpl($ArrayType$ val){
      return !EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(1));
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+1,valOffset=0;i<bound;++valOffset){
        if(valOffset!=1){
          continue;
        }
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
  #IF OfRef
      for(int bound=offset+originalLength;i<bound;++i){
        Assertions.assertNull(arr[i]);
      }
  #ENDIF
    }
  }
  static class RetainSecondAndLastPredicate extends $ClassPrefix$MonitoredPredicate{
    int seqLength;
    RetainSecondAndLastPredicate(int seqLength){
      this.seqLength=seqLength;
    }
    boolean testImpl($ArrayType$ val){
      return !EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(1)) && !EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(seqLength-1));
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+2,valOffset=0;i<bound;++valOffset){
        if(valOffset!=1 && valOffset!=originalLength-1){
          continue;
        }
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
  #IF OfRef
      for(int bound=offset+originalLength;i<bound;++i){
        Assertions.assertNull(arr[i]);
      }
  #ENDIF
    }
  }
  static class RemoveFirstAndThirdPredicate extends $ClassPrefix$MonitoredPredicate{
    RemoveFirstAndThirdPredicate(){}
    RemoveFirstAndThirdPredicate(Object dummy){}
    boolean testImpl($ArrayType$ val){
      return EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(0)) || EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(2));
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength-2,valOffset=0;i<bound;++valOffset){
        if(valOffset==0 || valOffset==2){
          continue;
        }
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
  #IF OfRef
      for(int bound=offset+originalLength;i<bound;++i){
        Assertions.assertNull(arr[i]);
      }
  #ENDIF
    }
  }
  static class RemoveFirstPredicate  extends $ClassPrefix$MonitoredPredicate{
    RemoveFirstPredicate(){}
    RemoveFirstPredicate(Object dummy){}
    boolean testImpl($ArrayType$ val){
      return EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(0));
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength-1,valOffset=0;i<bound;++valOffset){
        if(valOffset==0){
          continue;
        }
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
  #IF OfRef
      for(int bound=offset+originalLength;i<bound;++i){
        Assertions.assertNull(arr[i]);
      }
  #ENDIF
    }
  }
  static class RemoveFirstAndSecondToLastPredicate extends $ClassPrefix$MonitoredPredicate{
    int seqLength;
    RemoveFirstAndSecondToLastPredicate(int seqLength){
      this.seqLength=seqLength;
    }
    boolean testImpl($ArrayType$ val){
      return EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(0)) || EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(seqLength-2));
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength-2,valOffset=0;i<bound;++valOffset){
        if(valOffset==0 || valOffset==originalLength-2){
          continue;
        }
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
  #IF OfRef
      for(int bound=offset+originalLength;i<bound;++i){
        Assertions.assertNull(arr[i]);
      }
  #ENDIF
    }
  }
#ENDIF

  #MACRO StructImpl<ArrSeq,CheckedStack>()
  #MACRO StructImpl<ArrSeq,CheckedList>()


}
#MACRODEF StructImpl<ROOTIMPL,STRUCTNAME>()
static class ModifyingROOTIMPLSTRUCTNAMEAndThrowingPredicate extends ThrowingPredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    public ModifyingROOTIMPLSTRUCTNAMEAndThrowingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      this.seq=seq;
    }
    @Override boolean testImpl($ArrayType$ val){
      seq.add(val);
      throw new IndexOutOfBoundsException();
    }
  #IFNOT OfBoolean
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset)
      {
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
      Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),arr[i]);
    }
  #ENDIF
}
static class RemoveAllROOTIMPLSTRUCTNAMEModifyingPredicate extends RemoveAllPredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    RemoveAllROOTIMPLSTRUCTNAMEModifyingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val){
      seq.modCount+=2;
      return super.test(val);
    }
  #IFNOT OfBoolean
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset){
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
    }
  #ENDIF
}
static class RemoveNoneROOTIMPLSTRUCTNAMEModifyingPredicate extends RemoveNonePredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    RemoveNoneROOTIMPLSTRUCTNAMEModifyingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val){
      seq.modCount+=2;
      return super.test(val);
    }
  #IFNOT OfBoolean
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset){
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
    }
  #ENDIF
}
  #IF OfBoolean
  static class RemoveTrueROOTIMPLSTRUCTNAMEModifyingPredicate extends RemoveTruePredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    RemoveTrueROOTIMPLSTRUCTNAMEModifyingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val){
      seq.modCount+=2;
      return super.test(val);
    }
  }
  static class RemoveFalseROOTIMPLSTRUCTNAMEModifyingPredicate extends RemoveFalsePredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    RemoveFalseROOTIMPLSTRUCTNAMEModifyingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val){
      seq.modCount+=2;
      return super.test(val);
    }
  }
  #ELSE
  static class RetainSecondROOTIMPLSTRUCTNAMEModifyingPredicate extends RetainSecondPredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    RetainSecondROOTIMPLSTRUCTNAMEModifyingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val){
      seq.modCount+=2;
      return super.test(val);
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset){
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
    }
  }
  static class RetainSecondAndLastROOTIMPLSTRUCTNAMEModifyingPredicate extends RetainSecondAndLastPredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    RetainSecondAndLastROOTIMPLSTRUCTNAMEModifyingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      super(seq.size);
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val){
      seq.modCount+=2;
      return super.test(val);
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset)
      {
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
    }
  }
  static class RemoveFirstAndThirdROOTIMPLSTRUCTNAMEModifyingPredicate extends RemoveFirstAndThirdPredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    RemoveFirstAndThirdROOTIMPLSTRUCTNAMEModifyingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val){
      seq.modCount+=2;
      return super.test(val);
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset){
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
    }
  }
  static class RemoveFirstROOTIMPLSTRUCTNAMEModifyingPredicate  extends RemoveFirstPredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    RemoveFirstROOTIMPLSTRUCTNAMEModifyingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val){
      seq.modCount+=2;
      return super.test(val);
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset){
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
    }
  }
  static class RemoveFirstAndSecondToLastROOTIMPLSTRUCTNAMEModifyingPredicate extends RemoveFirstAndSecondToLastPredicate{
    $ClassPrefix$ROOTIMPL.STRUCTNAME seq;
    RemoveFirstAndSecondToLastROOTIMPLSTRUCTNAMEModifyingPredicate($ClassPrefix$ROOTIMPL.STRUCTNAME seq){
      super(seq.size);
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val){
      seq.modCount+=2;
      return super.test(val);
    }
    void verifyArray($ArrayType$[] arr,int offset,int originalLength){
      int i=offset;
      for(int bound=offset+originalLength,valOffset=0;i<bound;++valOffset){
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(valOffset),arr[i++]);
      }
    }
  }
  #ENDIF
#ENDDEF