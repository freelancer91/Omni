#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import java.util.ArrayList;
import omni.impl.seq.$ClassPrefix$ArrSeq.UncheckedList;
import omni.impl.seq.$ClassPrefix$ArrSeq.CheckedList;
import omni.impl.seq.$ClassPrefix$ArrSeq.UncheckedStack;
import omni.impl.seq.$ClassPrefix$ArrSeq.CheckedStack;
import omni.util.TypeConversionUtil;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import java.util.function.IntFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Consumer;
import java.util.function.$TypeNameModifier$Predicate;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Consumer;
import omni.function.$TypeNameModifier$Predicate;
#ENDIF
import java.util.ConcurrentModificationException;
#IFNOT OfBoolean
import omni.util.EqualityUtil;
#ENDIF
import omni.util.OmniArray;
@SuppressWarnings({"rawtypes","unchecked"}) 
public class $ClassPrefix$ArrSeqTest
{
  #MACRO StructImpl<UncheckedStack>()
  #MACRO StructImpl<UncheckedList>()
  #MACRO StructImpl<CheckedStack>()
  #MACRO StructImpl<CheckedList>()
  
  static class MonitoredConsumer extends ArrayList implements $TypeNameModifier$Consumer
#IFNOT OfRef
    ,Consumer<Object>
#ENDIF
 
  {
    private static final long serialVersionUID=1L;
    @Override public void accept($ArrayType$ val)
    {
      super.add(val);
    }
#IFNOT OfRef
    @Override public void accept(Object val)
    {
      accept(($ArrayType$)val);
    }
#ENDIF
  }
  static class ThrowingConsumer extends MonitoredConsumer
  {
    private static final long serialVersionUID=1L;
    @Override public void accept($ArrayType$ val)
    {
      super.accept(($ArrayType$)val);
      throw new IndexOutOfBoundsException();
    }
  }
  private static abstract class AbstractMonitoredPredicate implements $TypeNameModifier$Predicate
#IFNOT OfRef
    ,Predicate<Object>
#ENDIF
  {
    int callCounter;
    abstract boolean testImpl($ArrayType$ val);
    @Override public boolean test($ArrayType$ val)
    {
      ++callCounter;
      return testImpl(($ArrayType$)val);
    }
    public AbstractMonitoredPredicate negate()
    {
      //don't care
      return null;
    }
    
    
#IFNOT OfRef
    @Override public boolean test(Object val)
    {
      return test(($ArrayType$)val);
    }
#ENDIF
  }
  
  static class RemoveAllPredicate extends AbstractMonitoredPredicate
  {
    boolean testImpl($ArrayType$ val)
    {
      return true;
    }
  }
  static class RemoveNonePredicate extends AbstractMonitoredPredicate
  {
    boolean testImpl($ArrayType$ val)
    {
      return false;
    }
  }
  
  static class ThrowingPredicate extends AbstractMonitoredPredicate
  {
    @Override boolean testImpl($ArrayType$ val)
    {
      throw new IndexOutOfBoundsException();
    }
  }
#IF OfBoolean
  static class RemoveTruePredicate extends AbstractMonitoredPredicate
  {
    boolean testImpl($ArrayType$ val)
    {
      return val;
    }
  }
  static class RemoveFalsePredicate extends AbstractMonitoredPredicate
  {
    boolean testImpl($ArrayType$ val)
    {
      return !val;
    }
  }
#ELSE
  static class RetainSecondPredicate extends AbstractMonitoredPredicate
  {
    boolean testImpl($ArrayType$ val)
    {
      return !EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(1));
    }
  }
  static class RetainSecondAndLastPredicate extends AbstractMonitoredPredicate
  {
    int seqLength;
    RetainSecondAndLastPredicate(int seqLength)
    {
      this.seqLength=seqLength;
    }
    boolean testImpl($ArrayType$ val)
    {
      return !EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(1)) && !EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(seqLength-1));
    }
  }
  static class RemoveFirstAndThirdPredicate extends AbstractMonitoredPredicate
  {
    boolean testImpl($ArrayType$ val)
    {
      return EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(0)) || EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(2));
    }
  }
  static class RemoveFirstPredicate  extends AbstractMonitoredPredicate
  {
    boolean testImpl($ArrayType$ val)
    {
      return EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(0));
    }
  }
  static class RemoveFirstAndSecondToLastPredicate extends AbstractMonitoredPredicate
  {
    int seqLength;
    RemoveFirstAndSecondToLastPredicate(int seqLength)
    {
      this.seqLength=seqLength;
    }
    boolean testImpl($ArrayType$ val)
    {
      return EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(0)) || EqualityUtil.isEqual(val,TypeConversionUtil.convertTo$ArrayType$(seqLength-2));
    }
  }
#ENDIF
  
}

#MACRODEF StructImpl<STRUCTNAME>()
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
static class ModifyingSTRUCTNAMEConsumer extends MonitoredConsumer
{
  private static final long serialVersionUID=1L;
  STRUCTNAME seq;
  public ModifyingSTRUCTNAMEConsumer(STRUCTNAME seq)
  {
    this.seq=seq;
  }
  @Override public void accept($ArrayType$ val)
  {
    seq.modCount+=2;
    super.accept(($ArrayType$)val);
  }
}
static class ModifiyingSTRUCTNAMEAndThrowingConsumer extends ModifyingSTRUCTNAMEConsumer
{
  private static final long serialVersionUID=1L;
  public ModifiyingSTRUCTNAMEAndThrowingConsumer(STRUCTNAME seq)
  {
    super(seq);
  }
  @Override public void accept($ArrayType$ val)
  {
    super.accept(($ArrayType$)val);
    throw new IndexOutOfBoundsException();
  }
}

static class ModifyingAndThrowingSTRUCTNAMEPredicate extends ThrowingPredicate
{
    STRUCTNAME seq;
    public ModifyingAndThrowingSTRUCTNAMEPredicate(STRUCTNAME seq)
    {
      this.seq=seq;
    }
    @Override boolean testImpl($ArrayType$ val)
    {
      seq.add(val);
      throw new IndexOutOfBoundsException();
    }
}

static class RemoveAllSTRUCTNAMEModifyingPredicate extends RemoveAllPredicate
{
    STRUCTNAME seq;
    RemoveAllSTRUCTNAMEModifyingPredicate(STRUCTNAME seq)
    {
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val)
    {
      seq.modCount+=2;
      return super.test(val);
    }
}
static class RemoveNoneSTRUCTNAMEModifyingPredicate extends RemoveNonePredicate
{
    STRUCTNAME seq;
    RemoveNoneSTRUCTNAMEModifyingPredicate(STRUCTNAME seq)
    {
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val)
    {
      seq.modCount+=2;
      return super.test(val);
    }
}

#IF OfBoolean
  static class RemoveTrueSTRUCTNAMEModifyingPredicate extends RemoveTruePredicate
  {
    STRUCTNAME seq;
    RemoveTrueSTRUCTNAMEModifyingPredicate(STRUCTNAME seq)
    {
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val)
    {
      seq.modCount+=2;
      return super.test(val);
    }
  }
  static class RemoveFalseSTRUCTNAMEModifyingPredicate extends RemoveFalsePredicate
  {
    STRUCTNAME seq;
    RemoveFalseSTRUCTNAMEModifyingPredicate(STRUCTNAME seq)
    {
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val)
    {
      seq.modCount+=2;
      return super.test(val);
    }
  }
#ELSE
  static class RetainSecondSTRUCTNAMEModifyingPredicate extends RetainSecondPredicate
  {
    STRUCTNAME seq;
    RetainSecondSTRUCTNAMEModifyingPredicate(STRUCTNAME seq)
    {
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val)
    {
      seq.modCount+=2;
      return super.test(val);
    }
  }
  static class RetainSecondAndLastSTRUCTNAMEModifyingPredicate extends RetainSecondAndLastPredicate
  {
    STRUCTNAME seq;
    RetainSecondAndLastSTRUCTNAMEModifyingPredicate(STRUCTNAME seq)
    {
      super(seq.size);
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val)
    {
      seq.modCount+=2;
      return super.test(val);
    }
  }
  static class RemoveFirstAndThirdSTRUCTNAMEModifyingPredicate extends RemoveFirstAndThirdPredicate
  {
    STRUCTNAME seq;
    RemoveFirstAndThirdSTRUCTNAMEModifyingPredicate(STRUCTNAME seq)
    {
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val)
    {
      seq.modCount+=2;
      return super.test(val);
    }
  }
  static class RemoveFirstSTRUCTNAMEModifyingPredicate  extends RemoveFirstPredicate
  {
    STRUCTNAME seq;
    RemoveFirstSTRUCTNAMEModifyingPredicate(STRUCTNAME seq)
    {
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val)
    {
      seq.modCount+=2;
      return super.test(val);
    }
  }
  static class RemoveFirstAndSecondToLastSTRUCTNAMEModifyingPredicate extends RemoveFirstAndSecondToLastPredicate
  {
    STRUCTNAME seq;
    RemoveFirstAndSecondToLastSTRUCTNAMEModifyingPredicate(STRUCTNAME seq)
    {
      super(seq.size);
      this.seq=seq;
    }
    @Override
    public boolean test($ArrayType$ val)
    {
      seq.modCount+=2;
      return super.test(val);
    }
  }
#ENDIF




#ENDIF
#MACRO TestConstructor<DEFAULT>()
#MACRO TestConstructor<NULL>()
#MACRO TestConstructor<50>()
#MACRO TestConstructor<0>()
#MACRO TestConstructor<10>()

#MACRO TestMiscMethods<DEFAULT>()


#MACRO TestForEachMethods<DEFAULT>(,)
#MACRO TestRemoveIfMethods<DEFAULT>(,)
#MACRO TestRemoveIfMethods<NULL>(,)
#MACRO TestRemoveIfMethods<50>(,)
#IFNOT OfRef
#MACRO TestForEachMethods<DEFAULT>($TypeNameModifier$,)
#MACRO TestRemoveIfMethods<DEFAULT>($TypeNameModifier$,)
#MACRO TestRemoveIfMethods<NULL>($TypeNameModifier$,)
#MACRO TestRemoveIfMethods<50>($TypeNameModifier$,)
#ENDIF

#MACRO TestInputMethods<DEFAULT>($ArrayType$,$ArrayType$)
#MACRO TestInputMethods<NULL>($ArrayType$,$ArrayType$)
#MACRO TestInputMethods<50>($ArrayType$,$ArrayType$)
#IFNOT OfRef
#MACRO TestInputMethods<DEFAULT>($BoxedType$,$ArrayType$)
#MACRO TestInputMethods<NULL>($BoxedType$,$ArrayType$)
#MACRO TestInputMethods<50>($BoxedType$,$ArrayType$)
  #IFNOT OfBoolean
#MACRO TestInputMethods<DEFAULT>(boolean,$ArrayType$boolean)
#MACRO TestInputMethods<NULL>(boolean,$ArrayType$boolean)
#MACRO TestInputMethods<50>(boolean,$ArrayType$boolean)
#MACRO TestInputMethods<DEFAULT>(Boolean,$ArrayType$boolean)
#MACRO TestInputMethods<NULL>(Boolean,$ArrayType$boolean)
#MACRO TestInputMethods<50>(Boolean,$ArrayType$boolean)
    #IFNOT OfByte,OfChar
#MACRO TestInputMethods<DEFAULT>(byte,$ArrayType$)
#MACRO TestInputMethods<NULL>(byte,$ArrayType$)
#MACRO TestInputMethods<50>(byte,$ArrayType$)
#MACRO TestInputMethods<DEFAULT>(Byte,$ArrayType$)
#MACRO TestInputMethods<NULL>(Byte,$ArrayType$)
#MACRO TestInputMethods<50>(Byte,$ArrayType$)
      #IFNOT OfShort
#MACRO TestInputMethods<DEFAULT>(char,$ArrayType$)
#MACRO TestInputMethods<NULL>(char,$ArrayType$)
#MACRO TestInputMethods<50>(char,$ArrayType$)
#MACRO TestInputMethods<DEFAULT>(Character,$ArrayType$)
#MACRO TestInputMethods<NULL>(Character,$ArrayType$)
#MACRO TestInputMethods<50>(Character,$ArrayType$)
#MACRO TestInputMethods<DEFAULT>(short,$ArrayType$)
#MACRO TestInputMethods<NULL>(short,$ArrayType$)
#MACRO TestInputMethods<50>(short,$ArrayType$)
#MACRO TestInputMethods<DEFAULT>(Short,$ArrayType$)
#MACRO TestInputMethods<NULL>(Short,$ArrayType$)
#MACRO TestInputMethods<50>(Short,$ArrayType$)
        #IFNOT OfInt
#MACRO TestInputMethods<DEFAULT>(int,$ArrayType$)
#MACRO TestInputMethods<NULL>(int,$ArrayType$)
#MACRO TestInputMethods<50>(int,$ArrayType$)
#MACRO TestInputMethods<DEFAULT>(Integer,$ArrayType$)
#MACRO TestInputMethods<NULL>(Integer,$ArrayType$)
#MACRO TestInputMethods<50>(Integer,$ArrayType$)
          #IFNOT OfLong
#MACRO TestInputMethods<DEFAULT>(long,$ArrayType$)
#MACRO TestInputMethods<NULL>(long,$ArrayType$)
#MACRO TestInputMethods<50>(long,$ArrayType$)
#MACRO TestInputMethods<DEFAULT>(Long,$ArrayType$)
#MACRO TestInputMethods<NULL>(Long,$ArrayType$)
#MACRO TestInputMethods<50>(Long,$ArrayType$)
            #IFNOT OfFloat
#MACRO TestInputMethods<DEFAULT>(float,$ArrayType$)
#MACRO TestInputMethods<NULL>(float,$ArrayType$)
#MACRO TestInputMethods<50>(float,$ArrayType$)
#MACRO TestInputMethods<DEFAULT>(Float,$ArrayType$)
#MACRO TestInputMethods<NULL>(Float,$ArrayType$)
#MACRO TestInputMethods<50>(Float,$ArrayType$)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF

#MACRO TestOutputMethods<DEFAULT>($ArrayType$,$TypeNameModifier$,$defaultVal$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
#IFNOT OfRef
#MACRO TestOutputMethods<DEFAULT>($BoxedType$,,null,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR)
  #IFNOT OfDouble
#MACRO TestOutputMethods<DEFAULT>(double,Double,Double.NaN,OmniArray.OfDouble.DEFAULT_ARR)
    #IFNOT OfFloat
#MACRO TestOutputMethods<DEFAULT>(float,Float,Float.NaN,OmniArray.OfFloat.DEFAULT_ARR)
      #IFNOT OfLong
#MACRO TestOutputMethods<DEFAULT>(long,Long,Long.MIN_VALUE,OmniArray.OfLong.DEFAULT_ARR)
        #IFNOT OfInt
#MACRO TestOutputMethods<DEFAULT>(int,Int,Integer.MIN_VALUE,OmniArray.OfInt.DEFAULT_ARR)
          #IFNOT OfShort,OfChar
#MACRO TestOutputMethods<DEFAULT>(short,Short,Short.MIN_VALUE,OmniArray.OfShort.DEFAULT_ARR)
            #IFNOT OfByte
#MACRO TestOutputMethods<DEFAULT>(char,Char,Character.MIN_VALUE,OmniArray.OfChar.DEFAULT_ARR)
#MACRO TestOutputMethods<DEFAULT>(byte,Byte,Byte.MIN_VALUE,OmniArray.OfByte.DEFAULT_ARR)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF

#ENDDEF
#MACRODEF TestRemoveIfMethods<INITIALCAPACITY>(OUTPUTMODIFIER,dummy)
//TODO TestRemoveIfMethods<INITIALCAPACITY>(OUTPUTMODIFIER,dummy)
#ENDDEF

#MACRODEF TestForEachMethods<INITIALCAPACITY>(OUTPUTMODIFIER,dummy)
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_NoMod()
{
  #MACRO ConstructionRoutine()
  MonitoredConsumer consumer=new MonitoredConsumer();
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_NoMod()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  MonitoredConsumer consumer=new MonitoredConsumer();
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,consumer.size());
  var seqIterator=seq.iterator();
  var consumerIterator=consumer.iterator();
  for(int i=0;i<100;++i)
  {
#IF OfRef
    Assertions.assertSame(consumerIterator.next(),seqIterator.next());
#ELSE
    Assertions.assertEquals(consumerIterator.next(),seqIterator.next());
#ENDIF
  }
}
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_ModdingConsumer()
{
  #MACRO ConstructionRoutine()
  ModifyingSTRUCTNAMEConsumer consumer=new ModifyingSTRUCTNAMEConsumer(seq);
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertEquals(0,seq.modCount);
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_ModdingConsumer()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  ModifyingSTRUCTNAMEConsumer consumer=new ModifyingSTRUCTNAMEConsumer(seq);
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.forEach((OUTPUTMODIFIERConsumer)consumer));
  Assertions.assertEquals(100,seq.size());
  Assertions.assertEquals(300,seq.modCount);
  Assertions.assertEquals(100,consumer.size());
  var seqIterator=seq.iterator();
  var consumerIterator=consumer.iterator();
  for(int i=0;i<100;++i)
  {
#IF OfRef
    Assertions.assertSame(consumerIterator.next(),seqIterator.next());
#ELSE
    Assertions.assertEquals(consumerIterator.next(),seqIterator.next());
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_ThrowingConsumer()
{
  #MACRO ConstructionRoutine()
  ThrowingConsumer consumer=new ThrowingConsumer();
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertEquals(0,seq.modCount);
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_ThrowingConsumer()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  ThrowingConsumer consumer=new ThrowingConsumer();
  Assertions.assertThrows(IndexOutOfBoundsException.class,()->seq.forEach((OUTPUTMODIFIERConsumer)consumer));
  Assertions.assertEquals(100,seq.size());
  Assertions.assertEquals(100,seq.modCount);
  Assertions.assertEquals(1,consumer.size());
  var seqIterator=seq.iterator();
  var consumerIterator=consumer.iterator();
  for(int i=0;i<1;++i)
  {
#IF OfRef
    Assertions.assertSame(consumerIterator.next(),seqIterator.next());
#ELSE
    Assertions.assertEquals(consumerIterator.next(),seqIterator.next());
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_ThrowingAndModdingConsumer()
{
  #MACRO ConstructionRoutine()
  ModifiyingSTRUCTNAMEAndThrowingConsumer consumer=new ModifiyingSTRUCTNAMEAndThrowingConsumer(seq);
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertEquals(0,seq.modCount);
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_ThrowingAndModdingConsumer()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  ModifiyingSTRUCTNAMEAndThrowingConsumer consumer=new ModifiyingSTRUCTNAMEAndThrowingConsumer(seq);
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.forEach((OUTPUTMODIFIERConsumer)consumer));
  Assertions.assertEquals(100,seq.size());
  Assertions.assertEquals(102,seq.modCount);
  Assertions.assertEquals(1,consumer.size());

}
#ENDIF
#ENDDEF

#MACRODEF TestMiscMethods<INITIALCAPACITY>()

@Test
public void testSTRUCTNAMEtoArray_ObjectArray_zeroLengthArrayAndSequenceIsEmpty()
{
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[0];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[0];
#ENDIF
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
  Assertions.assertEquals(0,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertSame(paramArr,result);
}
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_zeroLengthArrayAndSequenceNotEmpty()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
#IF OfRef
  Integer[] paramArr=new Integer[0];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[0];
#ENDIF
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertNotSame(paramArr,result);
  var itr=seq.iterator();
  for(int i=0;i<100;++i)
  {
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_nonzeroLengthArrayAndSequenceIsEmpty()
{
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[5];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[5];
#ENDIF
  for(int i=0;i<paramArr.length;++i)
  {
    paramArr[i]=TypeConversionUtil.convertTo$ArrayType$(paramArr.length);
  }
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
  Assertions.assertEquals(5,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertSame(paramArr,result);
  Assertions.assertNull(result[0]);
  for(int i=1;i<result.length;++i)
  {
    Assertions.assertEquals((Object)TypeConversionUtil.convertTo$ArrayType$(paramArr.length),result[i]);
  }
}

@Test
public void testSTRUCTNAMEtoArray_ObjectArray_overSizedArray()
{
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[10];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[10];
#ENDIF
  for(int i=0;i<paramArr.length;++i)
  {
    paramArr[i]=TypeConversionUtil.convertTo$ArrayType$(paramArr.length);
  }
  #MACRO AddAscending(5,$ArrayType$)
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(5,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(5,seq.modCount);
#ENDIF
  Assertions.assertEquals(10,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertSame(paramArr,result);
  var itr=seq.iterator();
  for(int i=0;i<5;++i)
  {
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
  Assertions.assertNull(result[5]);
  for(int i=6;i<result.length;++i)
  {
    Assertions.assertEquals((Object)TypeConversionUtil.convertTo$ArrayType$(paramArr.length),result[i]);
  }
}
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_undersizedArray()
{
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[5];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[5];
#ENDIF
  for(int i=0;i<paramArr.length;++i)
  {
    paramArr[i]=TypeConversionUtil.convertTo$ArrayType$(10);
  }
  #MACRO AddAscending(10,$ArrayType$)
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(10,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(10,seq.modCount);
#ENDIF
  Assertions.assertEquals(10,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertNotSame(paramArr,result);
  var itr=seq.iterator();
  for(int i=0;i<10;++i)
  {
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_exactSizeArray()
{
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[5];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[5];
#ENDIF
  for(int i=0;i<paramArr.length;++i)
  {
    paramArr[i]=TypeConversionUtil.convertTo$ArrayType$(5);
  }
  #MACRO AddAscending(5,$ArrayType$)
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(5,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(5,seq.modCount);
#ENDIF
  Assertions.assertEquals(5,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertSame(paramArr,result);
  var itr=seq.iterator();
  for(int i=0;i<5;++i)
  {
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsEmpty_nonMod()
{
  #MACRO ConstructionRoutine()
#IF OfRef
  IntFunction<Integer[]> arrConstructor=Integer[]::new;
#ELSE
  IntFunction<$BoxedType$[]> arrConstructor=$BoxedType$[]::new;
#ENDIF
  var result=seq.toArray(arrConstructor);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertNotSame(seq.arr,result);
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
  Assertions.assertEquals(0,result.length);
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsNotEmpty_nonMod()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
#IF OfRef
  IntFunction<Integer[]> arrConstructor=Integer[]::new;
#ELSE
  IntFunction<$BoxedType$[]> arrConstructor=$BoxedType$[]::new;
#ENDIF
  var result=seq.toArray(arrConstructor);
  Assertions.assertEquals(100,seq.size());
  Assertions.assertNotSame(seq.arr,result);
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,result.length);
  var itr=seq.iterator();
  for(int i=0;i<100;++i)
  {
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
}
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsEmpty_moddingArrayConstructor()
{
  #MACRO ConstructionRoutine()
  #IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->
  {
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    return new Integer[arrSize];
  };
  #ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->
  {
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    return new $BoxedType$[arrSize];
  };
  #ENDIF
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(1,seq.size());
  Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),seq.arr[0]);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(1,seq.modCount);
  #ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsNotEmpty_moddingArrayConstructor()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  #IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->
  {
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    return new Integer[arrSize];
  };
  #ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->
  {
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    return new $BoxedType$[arrSize];
  };
  #ENDIF
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(101,seq.size());
  Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(100),seq.arr[100]);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(101,seq.modCount);
  #ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsEmpty_throwingArrayConstructor()
{
  #MACRO ConstructionRoutine()
#IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->
  {
    throw new IndexOutOfBoundsException();
  };
#ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->
  {
    throw new IndexOutOfBoundsException();
  };
#ENDIF
  Assertions.assertThrows(IndexOutOfBoundsException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsNotEmpty_throwingArrayConstructor()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
#IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->
  {
    throw new IndexOutOfBoundsException();
  };
#ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->
  {
    throw new IndexOutOfBoundsException();
  };
#ENDIF
  Assertions.assertThrows(IndexOutOfBoundsException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsEmpty_throwingAndModdingArrConstructor()
{
  #MACRO ConstructionRoutine()
  #IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->
  {
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    throw new IndexOutOfBoundsException();
  };
  #ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->
  {
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    throw new IndexOutOfBoundsException();
  };
  #ENDIF
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(1,seq.size());
  Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),seq.arr[0]);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(1,seq.modCount);
  #ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsNotEmpty_throwingAndModdingArrConstructor()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  #IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->
  {
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    throw new IndexOutOfBoundsException();
  };
  #ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->
  {
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    throw new IndexOutOfBoundsException();
  };
  #ENDIF
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(101,seq.size());
  Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(100),seq.arr[100]);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(101,seq.modCount);
  #ENDIF
}
#ENDIF
@Test
public void testSTRUCTNAMEclear_void_seqIsEmpty()
{
  #MACRO ConstructionRoutine()
  seq.clear();
  Assertions.assertTrue(seq.isEmpty());
#IFSWITCH STRUCTNAME==CheckedStack,CheckedList
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEclear_void_seqIsNotEmpty()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  seq.clear();
  Assertions.assertTrue(seq.isEmpty());
  for(int i=0;i<100;++i)
  {
#IF OfRef
    Assertions.assertNull(seq.arr[i]);
#ELSE
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(i),seq.arr[i]);
#ENDIF
  }
#IFSWITCH STRUCTNAME==CheckedStack,CheckedList
  Assertions.assertEquals(101,seq.modCount);
#ENDIF
}

@Test
public void testSTRUCTNAMEisEmpty_void_seqIsEmpty()
{
  #MACRO ConstructionRoutine()
  Assertions.assertTrue(seq.isEmpty());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEisEmpty_void_seqIsNotEmpty()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  Assertions.assertFalse(seq.isEmpty());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEisEmpty_void_seqIsBeingCleared()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var itr=seq.iterator();
  for(int i=100;--i>=0;)
  {
    Assertions.assertFalse(seq.isEmpty());
    itr.next$TypeNameModifier$();
    itr.remove();
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
    Assertions.assertEquals(100+(100-i),seq.modCount);
#ENDIF
  }
  Assertions.assertTrue(seq.isEmpty());
}

@Test
public void testSTRUCTNAMEsize_void_seqIsEmpty()
{
  #MACRO ConstructionRoutine()
  Assertions.assertEquals(0,seq.size);
  Assertions.assertEquals(seq.size,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEsize_void_seqIsNotEmpty()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  Assertions.assertEquals(100,seq.size);
  Assertions.assertEquals(seq.size,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEsize_void_seqIsBeingCleared()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var itr=seq.iterator();
  for(int i=100;--i>=0;)
  {
    itr.next$TypeNameModifier$();
    itr.remove();
    Assertions.assertEquals(i,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
    Assertions.assertEquals(100+(100-i),seq.modCount);
#ENDIF
  }
}
#ENDDEF

#MACRODEF TestConstructor<INITIALCAPACITY>()
@Test
#IFSWITCH INITIALCAPACITY==DEFAULT
public void testSTRUCTNAMEconstructor_void_initialCapacityINITIALCAPACITY()
#ELSEIFSWITCH INITIALCAPACITY==NULL
public void testSTRUCTNAMEconstructor_int$ArrayType$_initialCapacityINITIALCAPACITY()
#ELSE
public void testSTRUCTNAMEconstructor_int_initialCapacityINITIALCAPACITY()
#ENDIF
{
  #MACRO ConstructionRoutine()
  Assertions.assertEquals(0,seq.size);
#IFSWITCH INITIALCAPACITY==DEFAULT
  Assertions.assertSame(OmniArray.Of$ClassPrefix$.DEFAULT_ARR,seq.arr);
#ELSEIFSWITCH INITIALCAPACITY==NULL
  Assertions.assertNull(seq.arr);
#ELSE
  switch(INITIALCAPACITY)
  {
  case 0:
    Assertions.assertNull(seq.arr);
    break;
  case OmniArray.DEFAULT_ARR_SEQ_CAP:
    Assertions.assertSame(OmniArray.Of$ClassPrefix$.DEFAULT_ARR,seq.arr);
    break;
  default:
    Assertions.assertNotNull(seq.arr);
    Assertions.assertEquals(INITIALCAPACITY,seq.arr.length);
  #IF OfRef
    for(int i=0;i<INITIALCAPACITY;++i)
    {
      Assertions.assertNull(seq.arr[i]);
    }
  #ENDIF
  }
#ENDIF
#IFSWITCH STRUCTNAME==CheckedStack,CheckedList
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
#ENDDEF

#MACRODEF TestOutputMethods<INITIALCAPACITY>(OUTPUTTYPE,OUTPUTMODIFIER,DEFAULTVAL,DEFAULTARR)
@Test
public void testSTRUCTNAMEtoOUTPUTMODIFIERArray_void_seqIsEmpty()
{
  #MACRO ConstructionRoutine()
  Assertions.assertSame(DEFAULTARR,seq.toOUTPUTMODIFIERArray());
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEtoOUTPUTMODIFIERArray_void_seqIsNotEmpty()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var result=seq.toOUTPUTMODIFIERArray();
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,result.length);
  var itr=seq.iterator();
  for(int i=0;i<100;++i)
  {
#IF OfRef
    Assertions.assertSame(itr.nextOUTPUTMODIFIER(),result[i]);
#ELSE
    Assertions.assertEquals(itr.nextOUTPUTMODIFIER(),result[i]);
#ENDIF
  }
  Assertions.assertNotSame(seq.arr,result);
}
#ENDDEF

#MACRODEF TestInputMethods<INITIALCAPACITY>(INPUTTYPE,OUTPUTTYPE)
@Test
public void testSTRUCTNAMEadd_INPUTTYPE_initialCapacityINITIALCAPACITY()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,INPUTTYPE)
  Assertions.assertEquals(100,seq.size);
  Assertions.assertNotNull(seq.arr);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
  #ENDIF
  for(int i=0;i<seq.size;++i)
  {
    Assertions.assertEquals(TypeConversionUtil.convertToOUTPUTTYPE(i),seq.arr[i]);
  }
}
#ENDDEF


#MACRODEF ConstructionRoutine()
#IFSWITCH INITIALCAPACITY==DEFAULT
STRUCTNAME seq=new STRUCTNAME();
#ELSEIFSWITCH INITIALCAPACITY==NULL
STRUCTNAME seq=new STRUCTNAME(0,null);
#ELSE
STRUCTNAME seq=new STRUCTNAME(INITIALCAPACITY);
#ENDIF
#ENDDEF


#MACRODEF AddAscending(NUM_TO_ADD,INPUTTYPE)
for(int i=0;i<NUM_TO_ADD;++i)
{
  Assertions.assertTrue(seq.add(TypeConversionUtil.convertToINPUTTYPE(i)));
}
#ENDDEF



