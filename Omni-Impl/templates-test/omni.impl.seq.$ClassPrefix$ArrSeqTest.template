#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.util.TypeConversionUtil;
import org.junit.jupiter.api.Assertions;
import omni.impl.$ClassPrefix$InputTestArgType;
import omni.impl.$ClassPrefix$OutputTestArgType;
import org.junit.jupiter.params.provider.Arguments;
import java.util.NoSuchElementException;
import java.util.stream.Stream;
import omni.util.OmniArray;
import omni.impl.FunctionCallType;
import omni.impl.QueryCastType;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;
import omni.impl.seq.$ClassPrefix$ArrSeqMonitor.NestedType;
import omni.impl.seq.$ClassPrefix$SeqMonitor.CheckedType;
import omni.impl.seq.$ClassPrefix$SeqMonitor.PreModScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.SequenceLocation;
import omni.impl.seq.$ClassPrefix$SeqMonitor.SequenceContentsScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.ListItrSetScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.ItrType;
import omni.impl.seq.$ClassPrefix$SeqMonitor.IterationScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.ItrRemoveScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.MonitoredFunctionGen;
import omni.impl.seq.$ClassPrefix$SeqMonitor.MonitoredComparatorGen;
import omni.impl.seq.$ClassPrefix$SeqMonitor.MonitoredRemoveIfPredicateGen;
import java.nio.file.Files;
import org.junit.jupiter.api.Tag;
#IF OfRef
import omni.impl.seq.$ClassPrefix$SeqMonitor.MonitoredObjectGen;
import omni.impl.seq.$ClassPrefix$SeqMonitor.MonitoredObject;
#ENDIF
import omni.impl.seq.$ClassPrefix$SeqMonitor.SequenceVerificationItr;
import omni.impl.seq.$ClassPrefix$ArrSeqMonitor.QueryTester;
import omni.api.OmniCollection;
import omni.api.OmniList;
import java.util.ArrayList;
#IF OfRef
@SuppressWarnings({"rawtypes","unchecked"})
#ENDIF
@Execution(ExecutionMode.CONCURRENT)
@Tag("ArrSeqTest")
public class $ClassPrefix$ArrSeqTest{
  #MACRO TestMethods(true)
#MACRODEF TestMethods(PARALLEL)
#MACRO testremoveIf_Predicate<PARALLEL>()
#MACRO testhashCode_void<PARALLEL>()
#MACRO testListset_int_val<PARALLEL>()
#MACRO testListget_int<PARALLEL>()
#MACRO testtoArray_ObjectArray<PARALLEL>()
#MACRO testtoArray_IntFunction<PARALLEL>()
#MACRO testListsubList_int_int<PARALLEL>()
#MACRO testListreplaceAll_UnaryOperator<PARALLEL>()
#MACRO testiterator_void<PARALLEL>()
#MACRO testListlistIterator_void<PARALLEL>()
#MACRO testListlistIterator_int<PARALLEL>()
#MACRO testConstructor_int<PARALLEL>()
#IF OfRef
#MACRO testListunstableAscendingSort_void<PARALLEL>()
#MACRO testListunstableDescendingSort_void<PARALLEL>()
#ENDIF
#MACRO testtoArray_void<PARALLEL>() 
#MACRO testListremoveAt_int<PARALLEL>()
#MACRO testListstableDescendingSort_void<PARALLEL>()
#MACRO testclone_void<PARALLEL>()
#MACRO testsize_void<PARALLEL>()
#MACRO testisEmpty_void<PARALLEL>()
#MACRO testclear_void<PARALLEL>()
#MACRO testStackpeek_void<PARALLEL>()
#MACRO testStackpop_void<PARALLEL>()
#MACRO testStackpoll_void<PARALLEL>()
#MACRO testListstableAscendingSort_void<PARALLEL>()
#IFNOT OfBoolean
#MACRO testListunstableSort_Comparator<PARALLEL>()
#ENDIF
#MACRO testListsort_Comparator<PARALLEL>()
#MACRO testremoveVal_val<PARALLEL>()
#MACRO testsearch_val<PARALLEL>()
#MACRO testlastIndexOf_val<PARALLEL>()
#MACRO testindexOf_val<PARALLEL>()
#MACRO testcontains_val<PARALLEL>()
#MACRO testStackpush_val<PARALLEL>()
#MACRO testadd_val<PARALLEL>()
#MACRO testListput_int_val<PARALLEL>()
#MACRO testListadd_int_val<PARALLEL>()
#MACRO testforEach_Consumer<PARALLEL>()
#MACRO testItrforEachRemaining_Consumer<PARALLEL>()
#MACRO testListItrpreviousIndex_void_And_ListItrnextIndex_void<PARALLEL>()
#MACRO testItrremove_void<PARALLEL>()
#MACRO testListItrprevious_void<PARALLEL>()
#MACRO testItrnext_void<PARALLEL>()
#MACRO testListItrset_val<PARALLEL>()
#MACRO testListItradd_val<PARALLEL>()
#MACRO testtoString_void<PARALLEL>()
#MACRO testMASSIVEtoString_void<PARALLEL>()
#MACRO testreadAndwriteObject<PARALLEL>()
#ENDDEF
@FunctionalInterface
  interface ArgBuilder{
    void buildArgs(Stream.Builder<Arguments> streamBuilder,NestedType nestedType,CheckedType checkedType,PreModScenario preModScenario);
    static Stream<Arguments> buildSeqArgs(ArgBuilder argBuilder){
      Stream.Builder<Arguments> streamBuilder=Stream.builder();
      for(var nestedType:NestedType.values()){
        for(var checkedType:CheckedType.values()){
          for(var preModScenario:PreModScenario.values()){
            if(preModScenario.expectedException==null || (checkedType.checked && preModScenario!=PreModScenario.ModSeq && !nestedType.rootType)){
              argBuilder.buildArgs(streamBuilder,nestedType,checkedType,preModScenario);
            }
          }
        }
      }
      return streamBuilder.build();
    }
  }
#IF OfRef
  private static int verifyThrowCondition($ClassPrefix$ArrSeqMonitor seqMonitor,int numToAdd,MonitoredObject monitoredObject,MonitoredObjectGen monitoredObjectGen){
    int numExpectedCalls=numToAdd;
    var verifyItr=seqMonitor.verifyPreAlloc();
    for(int i=0;i<numToAdd;++i){
      verifyItr.verifyIndexAndIterate(monitoredObject);
    }
    switch(monitoredObjectGen){
      case Throw:
        numExpectedCalls=1;
        verifyItr.verifyPostAlloc();
        break;
      case ThrowModSeq:
        numExpectedCalls=1;
        verifyItr.verifyPostAlloc(PreModScenario.ModSeq);
        break;
      case ThrowModParent:
        numExpectedCalls=1;
        verifyItr.verifyPostAlloc(PreModScenario.ModParent);
        break;
      case ThrowModRoot:
        numExpectedCalls=1;
        verifyItr.verifyPostAlloc(PreModScenario.ModRoot);
        break;
      case ModSeq:
        for(int i=0;i<numExpectedCalls;++i){
          verifyItr.verifyIllegalAdd();
        }
        verifyItr.verifyPostAlloc();
        break;
      case ModParent:
        verifyItr.verifyParentPostAlloc();
        for(int i=0;i<numExpectedCalls;++i){
          verifyItr.verifyIllegalAdd();
        }
        verifyItr.verifyRootPostAlloc();
        break;
      case ModRoot:
        verifyItr.verifyPostAlloc();
        for(int i=0;i<numExpectedCalls;++i){
          verifyItr.verifyIllegalAdd();
        }
        break;
      default:
        throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
    }
    return numExpectedCalls;
  }
#ENDIF
  private static void verifyThrowCondition($ClassPrefix$ArrSeqMonitor seqMonitor,int numToAdd,PreModScenario preModScenario
#IF OfRef
    ,MonitoredObject monitoredObject,MonitoredObjectGen monitoredObjectGen
#ENDIF
  ){
     var verifyItr=seqMonitor.verifyPreAlloc();
#IF OfRef
    int numExpectedCalls=numToAdd;
    if(monitoredObject!=null){
      for(int i=0;i<numToAdd;++i){
        verifyItr.verifyIndexAndIterate(monitoredObject);
      }
      switch(monitoredObjectGen){
        case ThrowModSeq:
        case ModSeq:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModParent:
          numExpectedCalls=1;
        case ModParent:
          if(preModScenario==PreModScenario.ModRoot){
            numExpectedCalls=1;
          }
          verifyItr.verifyParentPostAlloc();
          if(preModScenario!=PreModScenario.ModRoot){
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }
          if(preModScenario==PreModScenario.ModParent){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyRootPostAlloc();
          if(preModScenario==PreModScenario.ModRoot){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ThrowModRoot:
          numExpectedCalls=1;
        case ModRoot:
          verifyItr.verifyPostAlloc(preModScenario);
          for(int i=0;i<numExpectedCalls;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case Throw:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
    }else
#ENDIF
    {
      verifyItr.verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
    }
  }
  static void buildQueryArguments(Stream.Builder<Arguments> builder,NestedType nestedType){
    for(var checkedType:CheckedType.values()){
      for(var preModScenario:PreModScenario.values()){
        if(preModScenario!=PreModScenario.ModSeq && (preModScenario.expectedException==null || (checkedType.checked && !nestedType.rootType))){
          for(var seqLocation:SequenceLocation.values()){
            if(seqLocation!=SequenceLocation.IOBLO){
              for(var seqContentsScenario:SequenceContentsScenario.values()){
                if(seqLocation==SequenceLocation.IOBHI || seqContentsScenario.nonEmpty){
                  for(var argType:QueryTester.values()){
                    for(var queryCastType:QueryCastType.values()){
                      switch(argType){
#IF OfRef
                        case ObjectNonNull:
                        case Objectnull:
                          if(queryCastType!=QueryCastType.ToObject){
                            continue;
                          }
                          break;
                        case Booleannull:
                        case Bytenull:
                        case Characternull:
                        case Shortnull:
                        case Integernull:
                        case Longnull:
                        case Floatnull:
                        case Doublenull:
                          if(queryCastType!=QueryCastType.ToBoxed){
                            continue;
                          }
#ELSE
                        case Booleannull:
                        case Bytenull:
                        case Characternull:
                        case Shortnull:
                        case Integernull:
                        case Longnull:
                        case Floatnull:
                        case Doublenull:
                          if(queryCastType!=QueryCastType.ToBoxed || (seqContentsScenario.nonEmpty && seqLocation.expectedException==null)){
                            continue;
                          }
                          break;
                        case Objectnull:
                          if(queryCastType!=QueryCastType.ToObject || (seqContentsScenario.nonEmpty && seqLocation.expectedException==null)){
                            continue;
                          }
                          break;
#ENDIF
                        case Booleanfalse:
                        case Byte0:
                        case Character0:
                        case Short0:
                        case Integer0:
                        case Long0:
                        case Floatpos0:
                        case Floatneg0:
                        case Doublepos0:
                        case Doubleneg0:
                        case Booleantrue:
                        case Bytepos1:
                        case Characterpos1:
                        case Shortpos1:
                        case Integerpos1:
                        case Longpos1:
                        case Floatpos1:
                        case Doublepos1:
#IFNOT OfBoolean
                        //values beyond the range of boolean
                        case Bytepos2:
                        case Characterpos2:
                        case Shortpos2:
                        case Integerpos2:
                        case Longpos2:
                        case Floatpos2:
                        case Doublepos2:
  #IFNOT OfChar
                        //negative values beyond the range of char
                        case Byteneg1:
                        case Shortneg1:
                        case Integerneg1:
                        case Longneg1:
                        case Floatneg1:
                        case Doubleneg1:
    #IFNOT OfByte
                        //negative values beyond the range of byte
                        case ShortMIN_BYTE_MINUS1:
                        case IntegerMIN_BYTE_MINUS1:
                        case LongMIN_BYTE_MINUS1:
                        case FloatMIN_BYTE_MINUS1:
                        case DoubleMIN_BYTE_MINUS1:
      #IFNOT OfShort
                        //negative values beyond the range of short
                        case IntegerMIN_SHORT_MINUS1:
                        case LongMIN_SHORT_MINUS1:
                        case FloatMIN_SHORT_MINUS1:
                        case DoubleMIN_SHORT_MINUS1:
        #IFNOT OfInt
                        //negative values beyond the range of int
                        case FloatMIN_INT_MINUS1:
          #IFNOT OfFloat
                        //negative values beyond the range of int and beyond the precision of float
                        case LongMIN_INT_MINUS1:
                        case DoubleMIN_INT_MINUS1:
          #ENDIF
        #ENDIF
        #IFNOT OfFloat
                        //negative values beyond MIN_SAFE_INT that are beyond the precision of float
                        case IntegerMIN_SAFE_INT_MINUS1:
                        case LongMIN_SAFE_INT_MINUS1:
                        case DoubleMIN_SAFE_INT_MINUS1:
          #IFNOT OfInt,OfDouble
                        //negative values beyond the range of int that are beyond the precision of float and double
                        case LongMIN_SAFE_LONG_MINUS1:
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #IFNOT OfByte
                        //positive values out of the range of byte
                        case CharacterMAX_BYTE_PLUS1:
                        case ShortMAX_BYTE_PLUS1:
                        case IntegerMAX_BYTE_PLUS1:
                        case LongMAX_BYTE_PLUS1:
                        case FloatMAX_BYTE_PLUS1:
                        case DoubleMAX_BYTE_PLUS1:
    #IFNOT OfShort
                        //positive values out of the range of short
                        case CharacterMAX_SHORT_PLUS1:
                        case IntegerMAX_SHORT_PLUS1:
                        case LongMAX_SHORT_PLUS1:
                        case FloatMAX_SHORT_PLUS1:
                        case DoubleMAX_SHORT_PLUS1:
      #IFNOT OfChar
                        //positive values out of the range of char
                        case IntegerMAX_CHAR_PLUS1:
                        case LongMAX_CHAR_PLUS1:
                        case FloatMAX_CHAR_PLUS1:
                        case DoubleMAX_CHAR_PLUS1:
        #IFNOT OfInt
                        //positive values out of the range of int
                        case LongMAX_INT_PLUS1:
                        case FloatMAX_INT_PLUS1:
                        case DoubleMAX_INT_PLUS1:
        #ENDIF
        #IFNOT OfFloat
                        //positive values beyond MAX_SAFE_INT that are beyond the precision of float
                        case IntegerMAX_SAFE_INT_PLUS1:
                        case LongMAX_SAFE_INT_PLUS1:
                        case DoubleMAX_SAFE_INT_PLUS1:
          #IFNOT OfInt,OfDouble
                        //positive values beyond the range of int that are beyond the precision of float and double
                        case LongMAX_SAFE_LONG_PLUS1:
          #ENDIF
        #ENDIF
        #IFNOT OfInt,OfLong
                        //floating-point values beyond the range any integral type
                        case FloatMAX_LONG_PLUS1:
                        case FloatMIN_LONG_MINUS1:
                        case FloatMAX_FLOAT_VALUE:
                        case DoubleMAX_FLOAT_VALUE:
                        //fractional floating point values that cannot be matched with any integral type
                        case FloatMIN_FLOAT_VALUE:
                        case DoubleMIN_FLOAT_VALUE:
                        //NaN values that can only be matches with NaN
                        case FloatNaN:
                        case DoubleNaN:
          #IFNOT OfFloat
                        //double-precision floating-point values beyond the range of any integral type and beyond the precision of float
                        case DoubleMAX_LONG_PLUS1:
                        case DoubleMIN_LONG_MINUS1:
                        case DoubleMAX_DOUBLE_VALUE:
                        //fractional floating point values that cannot be matched with any integral type and which are beyond the precision of float
                        case DoubleMIN_DOUBLE_VALUE:
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF  
#ENDIF
                        //these input values cannot potentially return true
                        break;
                        default:
                        if(seqContentsScenario.nonEmpty && seqLocation.expectedException==null){
                          continue;
                        }
                        //these values must necessarily return false
                      }
#IF OfRef
                      if(argType==QueryTester.ObjectNonNull){
                        if(!seqContentsScenario.nonEmpty || !checkedType.checked){
                          continue;
                        }
                        for(var monitoredObjectGen:MonitoredObjectGen.values()){
                          if(nestedType.rootType && !monitoredObjectGen.appliesToRoot || monitoredObjectGen.expectedException==null){
                            continue;
                          }
                          builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),argType,queryCastType,seqLocation,seqContentsScenario,preModScenario,monitoredObjectGen));
                        }
                      }else{
                        builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),argType,queryCastType,seqLocation,seqContentsScenario,preModScenario,null));
                      }
#ELSE
                      builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),argType,queryCastType,seqLocation,seqContentsScenario,preModScenario));
#ENDIF
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  static Stream<Arguments> getQueryStackArguments(){
    Stream.Builder<Arguments> builder=Stream.builder();
    buildQueryArguments(builder,NestedType.STACK);
    return builder.build();
  }
  static Stream<Arguments> getQueryListArguments(){
    Stream.Builder<Arguments> builder=Stream.builder();
    buildQueryArguments(builder,NestedType.LIST);
    buildQueryArguments(builder,NestedType.SUBLIST);
    return builder.build();
  }
  static Stream<Arguments> getQueryCollectionArguments(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var nestedType:NestedType.values()){
      buildQueryArguments(builder,nestedType);
    }
    return builder.build();
  }
  static Stream<Arguments> getNonComparatorSortArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var nestedType:NestedType.values()){
      if(nestedType.forwardIteration){
        for(var checkedType:CheckedType.values()){
          for(var preModScenario:PreModScenario.values()){
            if((checkedType.checked || preModScenario.expectedException==null) && ((nestedType.rootType && preModScenario.expectedException==null)||(!nestedType.rootType && preModScenario.appliesToSubList))){
              for(var monitoredComparatorGen:MonitoredComparatorGen.values()){
                if(monitoredComparatorGen.nullComparator && ((!nestedType.rootType || monitoredComparatorGen.appliesToRoot) && (checkedType.checked || monitoredComparatorGen.expectedException==null))){
                  for(var sequenceContentsScenario:SequenceContentsScenario.values()){
                    builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredComparatorGen,sequenceContentsScenario));
                  }
                }
              }
            }
          }
        }
      }
    }
    return builder.build();
  }
  static Stream<Arguments> getBasicCollectionTestArgs(){
    return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
      for(var seqContentsScenario:SequenceContentsScenario.values()){
        streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqContentsScenario));
      }
    });
  }
  static Stream<Arguments> getStackpollpeekAndpop_voidArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var checkedType:CheckedType.values()){
      for(var outputArgType:$ClassPrefix$OutputTestArgType.values()){
        builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(NestedType.STACK,checkedType),outputArgType));
      }
    }
    return builder.build();
  }
  static Stream<Arguments> gettoStringAndhashCode_voidArgs(){
   return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
     for(var seqContentsScenario:SequenceContentsScenario.values()){
  #IF OfRef
       for(var monitoredObjectGen:MonitoredObjectGen.values()){
         if(monitoredObjectGen.expectedException==null || (checkedType.checked && (!nestedType.rootType || monitoredObjectGen.appliesToRoot))){
           streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqContentsScenario,monitoredObjectGen));
         }
       }
  #ELSE
       streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqContentsScenario));
  #ENDIF
     }
   });
  }
}
#MACRODEF testConstructor_int<PARALLEL>()
static Stream<Arguments> getConstructor_intArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType!=NestedType.SUBLIST){
      for(var checkedType:CheckedType.values()){
        for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
          builder.accept(Arguments.of(nestedType,checkedType,initialCapacity));
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testConstructor_int(){
  getConstructor_intArgs().parallel().map(Arguments::get).forEach(args->{
      testConstructor_intHelper((NestedType)args[0],(CheckedType)args[1],(int)args[2]);
  });
}
private static void testConstructor_intHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getConstructor_intArgs")
public void testConstructor_int
#ENDIF
(NestedType nestedType,CheckedType checkedType,int initialCapacity){
  $ClassPrefix$ArrSeq seq;
  if(checkedType.checked){
    Assertions.assertEquals(0,nestedType==NestedType.LIST?FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(seq=new $ClassPrefix$ArrSeq.CheckedList(initialCapacity)):FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(seq=new $ClassPrefix$ArrSeq.CheckedStack(initialCapacity)));
  }else{
    seq=nestedType==NestedType.LIST?new $ClassPrefix$ArrSeq.UncheckedList(initialCapacity):new $ClassPrefix$ArrSeq.UncheckedStack(initialCapacity);
  }
  Assertions.assertEquals(0,seq.size);
  switch(initialCapacity){
    case 0:
      Assertions.assertNull(seq.arr);
      break;
    case OmniArray.DEFAULT_ARR_SEQ_CAP:
      Assertions.assertSame(OmniArray.Of$ClassPrefix$.DEFAULT_ARR,seq.arr);
      break;
    default:
      Assertions.assertEquals(initialCapacity,seq.arr.length);
#IF OfRef
      $ClassPrefix$ArrSeqMonitor.verifyRangeIsNull(seq.arr,0,initialCapacity);
#ENDIF
  }
}
#ENDDEF
#MACRODEF testListItradd_val<PARALLEL>()
static Stream<Arguments> getListItradd_valArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var preModScenario:PreModScenario.values()){
      if(checkedType.checked || preModScenario.expectedException==null){
        for(var seqContentsScenario:SequenceContentsScenario.values()){
          for(var seqLocation:SequenceLocation.values()){
            if(seqLocation.expectedException==null){
              for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
                if(preModScenario.appliesToRootItr){
                  for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
                      builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(NestedType.LIST,checkedType,initialCapacity),preModScenario,seqContentsScenario,seqLocation,inputArgType));
                  }
                }
                for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5){
                  for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5){
                    for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5){
                      for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5){
                        builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(NestedType.SUBLIST,checkedType,OmniArray.DEFAULT_ARR_SEQ_CAP,rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc),preModScenario,seqContentsScenario,seqLocation,inputArgType));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListItradd_val(){
  getListItradd_valArgs().parallel().map(Arguments::get).forEach(args->{
      testListItradd_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2],(SequenceLocation)args[3],($ClassPrefix$InputTestArgType)args[4]);
  });
}
private static void testListItradd_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListItradd_valArgs")
public void testListItradd_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario,SequenceLocation seqLocation,$ClassPrefix$InputTestArgType inputArgType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getListItrMonitor(seqLocation);
  seqMonitor.illegalAdd(preModScenario);
  SequenceVerificationItr verifyItr;
  if(preModScenario.expectedException==null){
    switch(seqLocation){
      case BEGINNING:
        for(int i=0;i<100;++i){
          itrMonitor.add(i,inputArgType);
          itrMonitor.verifyIteratorState();
          itrMonitor.iterateReverse();
          seqMonitor.verifyStructuralIntegrity();
        }
        break;
      case MIDDLE:
        for(int i=0;i<100;++i){
          itrMonitor.add(i,inputArgType);
          itrMonitor.verifyIteratorState();
          if((i&1)==0){
            itrMonitor.iterateReverse();
          }
          seqMonitor.verifyStructuralIntegrity();
        }
        break;
      case END:
        for(int i=0;i<100;++i){
          itrMonitor.add(i,inputArgType);
          itrMonitor.verifyIteratorState();
          seqMonitor.verifyStructuralIntegrity();
        }
        break;
      default:
        throw new Error("Unknown sequence locatio scenario "+seqLocation);
    }
    verifyItr=seqMonitor.verifyPreAlloc();
    switch(seqLocation){
      case BEGINNING:
        verifyItr.verifyDescending(inputArgType,100).verifyAscending(numToAdd);
        break;
      case MIDDLE:
        verifyItr.verifyAscending(numToAdd/2).verifyMidPointInsertion(inputArgType,100).verifyAscending(numToAdd/2,numToAdd-(numToAdd/2));
        break;
      case END:
        verifyItr.verifyAscending(numToAdd).verifyAscending(inputArgType,100);
        break;
      default:
        throw new Error("Unknown sequence location scenario "+seqLocation);
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->itrMonitor.add(0,inputArgType));
    itrMonitor.verifyIteratorState();
    seqMonitor.verifyStructuralIntegrity();
    verifyItr=seqMonitor.verifyPreAlloc();
    verifyItr.verifyAscending(numToAdd);
  }
  verifyItr.verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testListItrset_val<PARALLEL>()
static Stream<Arguments> getListItrset_valArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var listItrSetScenario:ListItrSetScenario.values()){
      if(checkedType.checked || listItrSetScenario.expectedException==null){
        for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
          if(listItrSetScenario.preModScenario.appliesToRootItr){
            builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(NestedType.LIST,checkedType),listItrSetScenario,inputArgType));
          }
          builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(NestedType.SUBLIST,checkedType),listItrSetScenario,inputArgType));
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListItrset_val(){
  getListItrset_valArgs().parallel().map(Arguments::get).forEach(args->{
      testListItrset_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],(ListItrSetScenario)args[1],($ClassPrefix$InputTestArgType)args[2]);
  });
}
private static void testListItrset_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListItrset_valArgs")
public void testListItrset_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,ListItrSetScenario listItrSetScenario,$ClassPrefix$InputTestArgType inputArgType){
  int numToAdd=100;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getListItrMonitor();
  switch(listItrSetScenario){
    case PostAddThrowISE:
    case PostAddThrowISESupercedesModRootCME:
    case PostAddThrowISESupercedesModParentCME:
    case PostAddThrowISESupercedesModSeqCME:
      itrMonitor.add(0);
      break;
    case PostRemoveThrowISE:
    case PostRemoveThrowISESupercedesModRootCME:
    case PostRemoveThrowISESupercedesModParentCME:
    case PostRemoveThrowISESupercedesModSeqCME:
      itrMonitor.iterateForward();
      itrMonitor.remove();
      break;
    default:
      itrMonitor.iterateForward();
    case ThrowISE:
    case ThrowISESupercedesModRootCME:
    case ThrowISESupercedesModParentCME:
    case ThrowISESupercedesModSeqCME:
  }
  seqMonitor.illegalAdd(listItrSetScenario.preModScenario);
  SequenceVerificationItr verifyItr;
  if(listItrSetScenario.expectedException==null){
    for(int j=0;j<numToAdd;++j){
      itrMonitor.set(numToAdd-j-1,inputArgType);
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
      if(!itrMonitor.hasNext()){
        break;
      }
      itrMonitor.iterateForward();
    }
    seqMonitor.verifyPreAlloc().verifyDescending(inputArgType,numToAdd).verifyPostAlloc();
    for(int j=0;j<numToAdd;++j){
      itrMonitor.iterateReverse();
      itrMonitor.set(numToAdd-j-1,inputArgType);
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
    }
    verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(inputArgType,numToAdd);
  }else{
    Assertions.assertThrows(listItrSetScenario.expectedException,()->itrMonitor.set(0));
    itrMonitor.verifyIteratorState();
    seqMonitor.verifyStructuralIntegrity();
    verifyItr=seqMonitor.verifyPreAlloc();
    switch(listItrSetScenario){
      case PostRemoveThrowISE:
      case PostRemoveThrowISESupercedesModRootCME:
      case PostRemoveThrowISESupercedesModParentCME:
      case PostRemoveThrowISESupercedesModSeqCME:
        verifyItr.verifyAscending(1,numToAdd-1);
        break;
      case PostAddThrowISE:
      case PostAddThrowISESupercedesModRootCME:
      case PostAddThrowISESupercedesModParentCME:
      case PostAddThrowISESupercedesModSeqCME:
        verifyItr.verifyIllegalAdd();
      default:
        verifyItr.verifyAscending(numToAdd);
    }
  }
  verifyItr.verifyPostAlloc(listItrSetScenario.preModScenario);
}
#ENDDEF
#MACRODEF testItrnext_void<PARALLEL>()
static Stream<Arguments> getItrnext_voidArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var itrScenario:IterationScenario.values()){
      if(checkedType.checked || itrScenario==IterationScenario.NoMod){
        for(var seqContentsScenario:SequenceContentsScenario.values()){
          if(seqContentsScenario.nonEmpty || itrScenario.validWithEmptySeq){
            for(var itrType:ItrType.values()){
              for(var nestedType:NestedType.values()){
                if((nestedType!=NestedType.STACK || itrType!=ItrType.ListItr) && (itrScenario.preModScenario.appliesToRootItr || !nestedType.rootType)){
                  for(var outputType:$ClassPrefix$OutputTestArgType.values()){
                    builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),itrScenario,seqContentsScenario,itrType,outputType));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testItrnext_void(){
  getItrnext_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testItrnext_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(IterationScenario)args[1],(SequenceContentsScenario)args[2],(ItrType)args[3],($ClassPrefix$OutputTestArgType)args[4]);
  });
}
private static void testItrnext_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getItrnext_voidArgs")
public void testItrnext_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,IterationScenario itrScenario,SequenceContentsScenario seqContentsScenario,ItrType itrType,$ClassPrefix$OutputTestArgType outputType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getItrMonitor(itrType);
  switch(itrScenario){
    case NoMod:
    case ModSeqSupercedesThrowNSEE:
    case ModParentSupercedesThrowNSEE:
    case ModRootSupercedesThrowNSEE:
      for(int i=0;;++i){
        if(itrType==ItrType.ListItr){
          Assertions.assertEquals(i,itrMonitor.nextIndex());
          Assertions.assertEquals(i-1,itrMonitor.previousIndex());
        }
        if(i==numToAdd){
          Assertions.assertFalse(itrMonitor.hasNext());
          break;
        }
        Assertions.assertTrue(itrMonitor.hasNext());
        itrMonitor.verifyNext(seqMonitor.nestedType==NestedType.STACK?numToAdd-i-1:i,outputType);
        itrMonitor.verifyIteratorState();
        seqMonitor.verifyStructuralIntegrity();
      }
    case ModSeq:
    case ModParent:
    case ModRoot:  
      break;
    default:
      throw new Error("unknown itr scenario "+itrScenario);
  }
  if(seqMonitor.checkedType.checked){
    seqMonitor.illegalAdd(itrScenario.preModScenario);
    Assertions.assertThrows(itrScenario.expectedException,()->itrMonitor.iterateForward());
  }
  itrMonitor.verifyIteratorState();
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(itrScenario.preModScenario);
}
#ENDDEF
#MACRODEF testListItrprevious_void<PARALLEL>()
static Stream<Arguments> getListItrprevious_voidArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var itrScenario:IterationScenario.values()){
      if(checkedType.checked || itrScenario==IterationScenario.NoMod){
        for(var seqContentsScenario:SequenceContentsScenario.values()){
          if(seqContentsScenario.nonEmpty || itrScenario.validWithEmptySeq){
            for(var outputType:$ClassPrefix$OutputTestArgType.values()){
              if(itrScenario.preModScenario.appliesToRootItr){
                builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(NestedType.LIST,checkedType),itrScenario,seqContentsScenario,outputType));
              }
              builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(NestedType.SUBLIST,checkedType),itrScenario,seqContentsScenario,outputType));
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListItrprevious_void(){
  getListItrprevious_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testListItrprevious_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(IterationScenario)args[1],(SequenceContentsScenario)args[2],($ClassPrefix$OutputTestArgType)args[3]);
  });
}
private static void testListItrprevious_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListItrprevious_voidArgs")
public void testListItrprevious_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,IterationScenario itrScenario,SequenceContentsScenario seqContentsScenario,$ClassPrefix$OutputTestArgType outputType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getListItrMonitor(numToAdd);
  switch(itrScenario){
    case NoMod:
    case ModSeqSupercedesThrowNSEE:
    case ModParentSupercedesThrowNSEE:
    case ModRootSupercedesThrowNSEE:
      for(int i=0;;++i){
        Assertions.assertEquals(numToAdd-i,itrMonitor.nextIndex());
        Assertions.assertEquals(numToAdd-i-1,itrMonitor.previousIndex());
        if(i==numToAdd){
          Assertions.assertFalse(itrMonitor.hasPrevious());
          break;
        }
        Assertions.assertTrue(itrMonitor.hasPrevious());
        itrMonitor.verifyPrevious(numToAdd-i-1,outputType);
        itrMonitor.verifyIteratorState();
        seqMonitor.verifyStructuralIntegrity();
      }
    case ModSeq:
    case ModParent:
    case ModRoot:  
      break;
    default:
      throw new Error("unknown itr scenario "+itrScenario);
  }
  if(seqMonitor.checkedType.checked){
    seqMonitor.illegalAdd(itrScenario.preModScenario);
    Assertions.assertThrows(itrScenario.expectedException,()->itrMonitor.iterateReverse());
  }
  itrMonitor.verifyIteratorState();
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(itrScenario.preModScenario);
}
#ENDDEF
#MACRODEF testItrremove_void<PARALLEL>()
static Stream<Arguments> getItrremove_voidArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var removeScenario:ItrRemoveScenario.values()){
      if(checkedType.checked || removeScenario.expectedException==null){
        for(var sequenceContentsScenario:SequenceContentsScenario.values()){
          if(sequenceContentsScenario.nonEmpty || removeScenario.validWithEmptySeq){
            for(var preModScenario:PreModScenario.values()){
              if(checkedType.checked || preModScenario.expectedException==null){
                for(var itrType:ItrType.values()){
                  if(itrType==ItrType.ListItr || removeScenario.validWithForwardItr){
                    for(var nestedType:NestedType.values()){
                      if((itrType==ItrType.Itr || nestedType!=NestedType.STACK) && (!nestedType.rootType || preModScenario.appliesToRootItr)){
                        for(var sequenceLocation:SequenceLocation.values()){
                          if(sequenceLocation.expectedException==null && (sequenceLocation==SequenceLocation.BEGINNING || (sequenceContentsScenario.nonEmpty && nestedType!=NestedType.STACK))){
                            builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),removeScenario,preModScenario,sequenceContentsScenario,itrType,sequenceLocation));
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testItrremove_void(){
  getItrremove_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testItrremove_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(ItrRemoveScenario)args[1],(PreModScenario)args[2],(SequenceContentsScenario)args[3],(ItrType)args[4],(SequenceLocation)args[5]);
  });
}
private static void testItrremove_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getItrremove_voidArgs")
public void testItrremove_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,ItrRemoveScenario removeScenario,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario,ItrType itrType,SequenceLocation seqLocation){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getItrMonitor(seqLocation,itrType);
  switch(removeScenario){
    case PostNext:
      if(seqLocation==SequenceLocation.END){
        itrMonitor.iterateReverse();
      }
      itrMonitor.iterateForward();
      break;
    case PostPrevious:
      if(seqLocation==SequenceLocation.BEGINNING){
         itrMonitor.iterateForward();
      }
      itrMonitor.iterateReverse();
      break;
    case PostAdd:
      itrMonitor.add(0);
      break;
    case PostRemove:
      if(seqLocation==SequenceLocation.END){
        itrMonitor.iterateReverse();
      }else{
        itrMonitor.iterateForward();
      }
      itrMonitor.remove();
    case PostInit:
      break;
    default:
       throw new Error("unknown remove scenario "+removeScenario);
  }
  seqMonitor.illegalAdd(preModScenario);
  SequenceVerificationItr verifyItr;
  if(removeScenario.expectedException==null){
    if(preModScenario.expectedException==null){
      itrMonitor.remove();
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
      switch(removeScenario){
        case PostNext:
          switch(seqLocation){
            case BEGINNING:
              while(itrMonitor.hasNext()){
                itrMonitor.iterateForward();
                itrMonitor.remove();
                itrMonitor.verifyIteratorState();
                seqMonitor.verifyStructuralIntegrity();
              }
              break;
            case MIDDLE:
              for(int j=1;;++j){
                if(itrMonitor.hasPrevious()){
                  itrMonitor.iterateReverse();
                }
                if((j&1)!=0){
                  if(itrMonitor.hasPrevious()){
                    itrMonitor.iterateReverse();
                  }
                }
                if(itrMonitor.hasNext()){
                  itrMonitor.iterateForward();
                }else{
                  if(!itrMonitor.hasPrevious()){
                    break;
                  }
                  itrMonitor.iterateReverse();
                }
                itrMonitor.remove();
                itrMonitor.verifyIteratorState();
                seqMonitor.verifyStructuralIntegrity();
              }
              break;
            case END:
              for(;;){
                if(!itrMonitor.hasPrevious()){
                  break;
                }
                itrMonitor.iterateReverse();
                itrMonitor.iterateForward();
                itrMonitor.remove();
                itrMonitor.verifyIteratorState();
                seqMonitor.verifyStructuralIntegrity();
              }
              break;
            default:
              throw new Error("Unknown sequence location "+seqLocation);
          }
          break;
        case PostPrevious:
          switch(seqLocation){
            case BEGINNING:
              while(itrMonitor.hasNext()){
                itrMonitor.iterateForward();
                itrMonitor.iterateReverse();
                itrMonitor.remove();
                itrMonitor.verifyIteratorState();
                seqMonitor.verifyStructuralIntegrity();
              }
              break;
            case MIDDLE:
              for(int j=1;;++j){
                if((j&1)!=0 && itrMonitor.hasNext()){
                  itrMonitor.iterateForward();
                }
                if(itrMonitor.hasPrevious()){
                  itrMonitor.iterateReverse();
                }else{
                  if(!itrMonitor.hasNext()){
                    break;
                  }
                  itrMonitor.iterateForward();
                }            
                itrMonitor.remove();
                itrMonitor.verifyIteratorState();
                seqMonitor.verifyStructuralIntegrity();
              }
              break;
            case END:
              while(itrMonitor.hasPrevious()){
                itrMonitor.iterateReverse();
                itrMonitor.remove();
                itrMonitor.verifyIteratorState();
                seqMonitor.verifyStructuralIntegrity();
              }
              break;
            default:
              throw new Error("Unknown sequence location "+seqLocation);
          }
          break;
        default:
          throw new Error("unknown remove scenario "+removeScenario);
      }
      Assertions.assertFalse(itrMonitor.hasNext());
      Assertions.assertTrue(seqMonitor.isEmpty());
      verifyItr=seqMonitor.verifyPreAlloc();
    }else{
      Assertions.assertThrows(preModScenario.expectedException,()->itrMonitor.remove());
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
      verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
    }
  }else{
    Assertions.assertThrows(removeScenario.expectedException,()->itrMonitor.remove());
    itrMonitor.verifyIteratorState();
    seqMonitor.verifyStructuralIntegrity();
    verifyItr=seqMonitor.verifyPreAlloc();
    switch(removeScenario){
      case PostInit:
        verifyItr.verifyAscending(numToAdd);
        break;
      case PostAdd:
        switch(seqLocation){
          case BEGINNING:
            verifyItr.verifyIllegalAdd().verifyAscending(numToAdd);
            break;
          case MIDDLE:
            verifyItr.verifyAscending(numToAdd/2).verifyIllegalAdd().verifyAscending(numToAdd/2,numToAdd-(numToAdd/2));
            break;
          case END:
            verifyItr.verifyAscending(numToAdd).verifyIllegalAdd();
            break;
          default:
            throw new Error("Unknown sequence location "+seqLocation);
        }
        break;
      case PostRemove:
        switch(seqLocation){
          case BEGINNING:
            if(seqMonitor.nestedType.forwardIteration){
              verifyItr.verifyAscending(1,numToAdd-1);
            }else{
              verifyItr.verifyAscending(numToAdd-1);
            }
            break;
          case MIDDLE:
            verifyItr.verifyAscending(numToAdd/2).verifyAscending((numToAdd/2)+1,numToAdd-(numToAdd/2)-1);
            break;
          case END:
            verifyItr.verifyAscending(numToAdd-1);
            break;
          default:
            throw new Error("Unknown sequence location "+seqLocation);
        }
        break;
      default:
        throw new Error("unknown remove scenario "+removeScenario);
    }
  }
  verifyItr.verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testListItrpreviousIndex_void_And_ListItrnextIndex_void<PARALLEL>()
static Stream<Arguments> getListItrpreviousIndex_void_And_ListItrnextIndex_voidArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var nestedType:NestedType.values()){
      if(nestedType!=NestedType.STACK){
        builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType)));
      }
    }  
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListItrpreviousIndex_void_And_ListItrnextIndex_void(){
  getListItrpreviousIndex_void_And_ListItrnextIndex_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testListItrpreviousIndex_void_And_ListItrnextIndex_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0]);
  });
}
private static void testListItrpreviousIndex_void_And_ListItrnextIndex_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListItrpreviousIndex_void_And_ListItrnextIndex_voidArgs")
public void testListItrpreviousIndex_void_And_ListItrnextIndex_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor){
  int numToAdd=100;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getListItrMonitor();
  for(int i=0;i<numToAdd;++i){
    Assertions.assertEquals(i,itrMonitor.nextIndex());
    Assertions.assertEquals(i-1,itrMonitor.previousIndex());
    itrMonitor.verifyIteratorState();
    seqMonitor.verifyStructuralIntegrity();
    itrMonitor.iterateForward();
  }
  for(int i=numToAdd;i>0;){
    Assertions.assertEquals(i,itrMonitor.nextIndex());
    Assertions.assertEquals(--i,itrMonitor.previousIndex());
    itrMonitor.verifyIteratorState();
    seqMonitor.verifyStructuralIntegrity();
    itrMonitor.iterateReverse();
  }
  seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testItrforEachRemaining_Consumer<PARALLEL>()
static Stream<Arguments> getItrforEachRemaining_ConsumerArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var nestedType:NestedType.values()){
      for(var preModScenario:PreModScenario.values()){
        if(checkedType.checked || preModScenario.expectedException==null){
          for(var monitoredFunctionGen:MonitoredFunctionGen.values()){
            if((monitoredFunctionGen.expectedException==null || checkedType.checked) && (!nestedType.rootType || (preModScenario.appliesToRootItr&&monitoredFunctionGen.appliesToRootItr))){
              for(var itrType:ItrType.values()){
                if(itrType==ItrType.Itr || nestedType.forwardIteration){
                  for(var seqContentsScenario:SequenceContentsScenario.values()){
                    builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,itrType,seqContentsScenario,FunctionCallType.Unboxed));
#IFNOT OfRef
                    builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,itrType,seqContentsScenario,FunctionCallType.Boxed));
#ENDIF
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testItrforEachRemaining_Consumer(){
  getItrforEachRemaining_ConsumerArgs().parallel().map(Arguments::get).forEach(args->{
      testItrforEachRemaining_ConsumerHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredFunctionGen)args[2],(ItrType)args[3],(SequenceContentsScenario)args[4],(FunctionCallType)args[5]);
  });
}
private static void testItrforEachRemaining_ConsumerHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getItrforEachRemaining_ConsumerArgs")
public void testItrforEachRemaining_Consumer
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredFunctionGen monitoredFunctionGen,ItrType itrType,SequenceContentsScenario seqContentsScenario,FunctionCallType functionCallType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getItrMonitor(itrType);
  seqMonitor.illegalAdd(preModScenario);
  var monitoredConsumer=monitoredFunctionGen.getMonitoredConsumer(itrMonitor);
  int numExpectedIteratedValues;
  if(preModScenario.expectedException==null || (!seqContentsScenario.nonEmpty && (preModScenario!=PreModScenario.ModSeq || !seqMonitor.nestedType.forwardIteration))){
    if(monitoredFunctionGen.expectedException==null || (!seqContentsScenario.nonEmpty && (preModScenario!=PreModScenario.ModSeq || !seqMonitor.nestedType.forwardIteration))){
      itrMonitor.forEachRemaining(monitoredConsumer,functionCallType);
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
      seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
      numExpectedIteratedValues=numToAdd;
    }else{
      Assertions.assertThrows(monitoredFunctionGen.expectedException,()->itrMonitor.forEachRemaining(monitoredConsumer,functionCallType));
      seqMonitor.verifyStructuralIntegrity();
      itrMonitor.verifyIteratorState();
      switch(monitoredFunctionGen){
        case ThrowModItr:
          numExpectedIteratedValues=1;
          if(seqMonitor.nestedType.forwardIteration){
            seqMonitor.verifyPreAlloc().verifyAscending(1,numToAdd-1).verifyPostAlloc();
          }else{
            seqMonitor.verifyPreAlloc().verifyAscending(numToAdd-1).verifyPostAlloc();
          }
          break;
        case ModItr:
          numExpectedIteratedValues=numToAdd;
          seqMonitor.verifyPreAlloc().verifyPostAlloc();
          break;
        case Throw:
          numExpectedIteratedValues=1;
          seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc();
          break;
        case ModSeq:
          numExpectedIteratedValues=numToAdd;
          var verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyPostAlloc();
          break;
        case ModParent:
          numExpectedIteratedValues=numToAdd;
          verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyParentPostAlloc();
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyRootPostAlloc();
          break;
        case ModRoot:
          numExpectedIteratedValues=numToAdd;
          verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc();
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ThrowModSeq:
          numExpectedIteratedValues=1;
          seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(PreModScenario.ModSeq);
          break;
        case ThrowModParent:
          numExpectedIteratedValues=1;
          seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(PreModScenario.ModParent);
          break;
        case ThrowModRoot:
          numExpectedIteratedValues=1;
          seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(PreModScenario.ModRoot);
          break;
        default:
          throw new Error("Unknown monitored function gen "+monitoredFunctionGen);
      }
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->itrMonitor.forEachRemaining(monitoredConsumer,functionCallType));
    seqMonitor.verifyStructuralIntegrity();
    itrMonitor.verifyIteratorState();
    switch(monitoredFunctionGen){
      case ThrowModItr:
        numExpectedIteratedValues=1;
        seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
        break;
      case ModItr:
        numExpectedIteratedValues=1;
        //verification in tis situation is tricky. Just skip it
        break;
      case NoThrow:
        numExpectedIteratedValues=numToAdd;
        if(preModScenario==PreModScenario.ModSeq && seqMonitor.nestedType.forwardIteration){
          ++numExpectedIteratedValues;
        }
        seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
        break;
      case Throw:
        numExpectedIteratedValues=1;
        seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
        break;
      case ModSeq:
        var verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
        if(preModScenario==PreModScenario.ModSeq){
          numExpectedIteratedValues=numToAdd;
          if(seqMonitor.nestedType.forwardIteration){
            ++numExpectedIteratedValues;
          }
          for(int i=0;i<numExpectedIteratedValues;++i){
            verifyItr.verifyIllegalAdd();
          }
        }else{
          numExpectedIteratedValues=1;
        }
        verifyItr.verifyPostAlloc(preModScenario);
        break;
      case ModParent:
        switch(preModScenario){
          case ModRoot:
            numExpectedIteratedValues=1;
            seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
            break;
          case ModParent:
            numExpectedIteratedValues=numToAdd;
            verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyParentPostAlloc();
            for(int i=0;i<numExpectedIteratedValues+1;++i){
              verifyItr.verifyIllegalAdd();
            }
            verifyItr.verifyRootPostAlloc();
            break;
          case ModSeq:
            numExpectedIteratedValues=numToAdd+1;
            verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyIllegalAdd().verifyParentPostAlloc();
            for(int i=0;i<numExpectedIteratedValues;++i){
              verifyItr.verifyIllegalAdd();
            }
            verifyItr.verifyRootPostAlloc();
            break;
          default:
            throw new Error("Unknown preModScenario "+preModScenario);
        }
        break;
      case ModRoot:
        numExpectedIteratedValues=numToAdd;
        if(preModScenario==PreModScenario.ModSeq){
          ++numExpectedIteratedValues;
        }
        verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
        for(int i=0;i<numExpectedIteratedValues;++i){
          verifyItr.verifyIllegalAdd();
        }
        break;
      case ThrowModSeq:
        verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
        if(preModScenario==PreModScenario.ModSeq){
          verifyItr.verifyIllegalAdd();
        }
        verifyItr.verifyPostAlloc(preModScenario);
        numExpectedIteratedValues=1;
        break;
      case ThrowModParent:
        switch(preModScenario){
          case ModSeq:
            seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyIllegalAdd().verifyPostAlloc(PreModScenario.ModParent);
            break;
          case ModParent:
            seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyParentPostAlloc().verifyIllegalAdd().verifyIllegalAdd().verifyRootPostAlloc();
            break;
          case ModRoot:
            seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
            break;
          default:
            throw new Error("Unknown preModScenario "+preModScenario);
        }
        numExpectedIteratedValues=1;
        break;
      case ThrowModRoot:
        seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario).verifyIllegalAdd();
        numExpectedIteratedValues=1;
        break;
      default:
        throw new Error("Unknown monitored function gen "+monitoredFunctionGen);
    }
  }
  Assertions.assertEquals(numExpectedIteratedValues,monitoredConsumer.encounteredValues.size());
  switch(monitoredFunctionGen){
    case ModItr:
    case ThrowModItr:{
      if(preModScenario==PreModScenario.NoMod && numToAdd!=0){
        break;
      }
      //those scenarios are kinda tricky.
      //just skip this step of verification
    }
    default:{
      var arr=(($ClassPrefix$ArrSeq)seqMonitor.root).arr;
      if(seqMonitor.nestedType.forwardIteration){
        int i=seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc;
        for(var encounteredValue:monitoredConsumer.encounteredValues){
    #IF OfRef
          Assertions.assertSame(encounteredValue,arr[i++]);
    #ELSE
          Assertions.assertEquals(encounteredValue,(Object)arr[i++]);
    #ENDIF
        }
      }else{
        int i=seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+numToAdd;
        for(var encounteredValue:monitoredConsumer.encounteredValues){
    #IF OfRef
          Assertions.assertSame(encounteredValue,arr[--i]);
    #ELSE
          Assertions.assertEquals(encounteredValue,(Object)arr[--i]);
    #ENDIF
        }
      }
    }
  }
}
#ENDDEF
#MACRODEF testforEach_Consumer<PARALLEL>()
static Stream<Arguments> getforEach_ConsumerArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
    for(var monitoredFunctionGen:MonitoredFunctionGen.values()){
      if((checkedType.checked || monitoredFunctionGen.expectedException==null)&&(!nestedType.rootType || monitoredFunctionGen.appliesToRoot) &&(nestedType.rootType || monitoredFunctionGen.appliesToSubList)){
        for(var seqContentsScenario:SequenceContentsScenario.values()){
          streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,seqContentsScenario,FunctionCallType.Unboxed));
#IFNOT OfRef
          streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,seqContentsScenario,FunctionCallType.Boxed));
#ENDIF
        }
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testforEach_Consumer(){
  getforEach_ConsumerArgs().parallel().map(Arguments::get).forEach(args->{
      testforEach_ConsumerHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredFunctionGen)args[2],(SequenceContentsScenario)args[3],(FunctionCallType)args[4]);
  });
}
private static void testforEach_ConsumerHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getforEach_ConsumerArgs")
public void testforEach_Consumer
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredFunctionGen monitoredFunctionGen,SequenceContentsScenario seqContentsScenario,FunctionCallType functionCallType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  var monitoredConsumer=monitoredFunctionGen.getMonitoredConsumer(seqMonitor);
  int numExpectedIteratedValues;
  if(preModScenario.expectedException==null){
    if(monitoredFunctionGen.expectedException==null || !seqContentsScenario.nonEmpty){
      seqMonitor.forEach(monitoredConsumer,functionCallType);
      seqMonitor.verifyStructuralIntegrity();
      seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
      numExpectedIteratedValues=numToAdd;
    }else{
      Assertions.assertThrows(monitoredFunctionGen.expectedException,()->seqMonitor.forEach(monitoredConsumer,functionCallType));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
      switch(monitoredFunctionGen){
        case Throw:
          numExpectedIteratedValues=1;
          verifyItr.verifyPostAlloc();
          break;
        case ModSeq:
          numExpectedIteratedValues=numToAdd;
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyPostAlloc();
          break;
        case ModParent:
          numExpectedIteratedValues=numToAdd;
          verifyItr.verifyParentPostAlloc();
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyRootPostAlloc();
          break;
        case ModRoot:
          numExpectedIteratedValues=numToAdd;
          verifyItr.verifyPostAlloc();
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ThrowModSeq:
          numExpectedIteratedValues=1;
          verifyItr.verifyPostAlloc(PreModScenario.ModSeq);
          break;
        case ThrowModParent:
          numExpectedIteratedValues=1;
          verifyItr.verifyPostAlloc(PreModScenario.ModParent);
          break;
        case ThrowModRoot:
          numExpectedIteratedValues=1;
          verifyItr.verifyPostAlloc(PreModScenario.ModRoot);
          break;
        default:
          throw new Error("Unknown monitored function gen "+monitoredFunctionGen);
      }
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.forEach(monitoredConsumer,functionCallType));
    seqMonitor.verifyStructuralIntegrity();
    var verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
    switch(monitoredFunctionGen){
      case NoThrow:
        numExpectedIteratedValues=numToAdd;
        verifyItr.verifyPostAlloc(preModScenario);
        break;
      case Throw:
      case ModSeq:
        numExpectedIteratedValues=numToAdd==0?0:1;
        verifyItr.verifyPostAlloc(preModScenario);
        break;
      case ModParent:
        switch(preModScenario){
          case ModRoot:
            numExpectedIteratedValues=numToAdd==0?0:1;
            verifyItr.verifyPostAlloc(preModScenario);
            break;
          case ModParent:
            numExpectedIteratedValues=numToAdd;
            verifyItr.verifyParentPostAlloc();
            for(int i=0;i<numExpectedIteratedValues+1;++i){
              verifyItr.verifyIllegalAdd();
            }
            verifyItr.verifyRootPostAlloc();
            break;
          default:
            throw new Error("Unknown preModScenario "+preModScenario);
        }
        break;
      case ModRoot:
        numExpectedIteratedValues=numToAdd;
        verifyItr.verifyPostAlloc(preModScenario);
        for(int i=0;i<numExpectedIteratedValues;++i){
          verifyItr.verifyIllegalAdd();
        }
        break;
      case ThrowModSeq:
        verifyItr.verifyPostAlloc(preModScenario);
        numExpectedIteratedValues=numToAdd==0?0:1;
        break;
      case ThrowModParent:
        numExpectedIteratedValues=numToAdd==0?0:1;
        switch(preModScenario){
          case ModParent:
            verifyItr.verifyParentPostAlloc();
            for(int i=0;i<numExpectedIteratedValues;++i){
              verifyItr.verifyIllegalAdd();
            }
            verifyItr.verifyIllegalAdd().verifyRootPostAlloc();
            break;
          case ModRoot:
            verifyItr.verifyPostAlloc(preModScenario);
            break;
          default:
            throw new Error("Unknown preModScenario "+preModScenario);
        }
        break;
      case ThrowModRoot:
        numExpectedIteratedValues=numToAdd==0?0:1;
        verifyItr.verifyPostAlloc(preModScenario);
        for(int i=0;i<numExpectedIteratedValues;++i){
          verifyItr.verifyIllegalAdd();
        }
        break;
      default:
        throw new Error("Unknown monitored function gen "+monitoredFunctionGen);
    }
  }
  Assertions.assertEquals(numExpectedIteratedValues,monitoredConsumer.encounteredValues.size());
  var arr=(($ClassPrefix$ArrSeq)seqMonitor.root).arr;
  if(seqMonitor.nestedType.forwardIteration){
    int i=seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc;
    for(var encounteredValue:monitoredConsumer.encounteredValues){
#IF OfRef
      Assertions.assertSame(encounteredValue,arr[i++]);
#ELSE
      Assertions.assertEquals(encounteredValue,(Object)arr[i++]);
#ENDIF
    }
  }else{
    int i=seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+numToAdd;
    for(var encounteredValue:monitoredConsumer.encounteredValues){
#IF OfRef
      Assertions.assertSame(encounteredValue,arr[--i]);
#ELSE
      Assertions.assertEquals(encounteredValue,(Object)arr[--i]);
#ENDIF
    }
  }
}
#ENDDEF
#MACRODEF testListadd_int_val<PARALLEL>()
static Stream<Arguments> getListadd_int_valArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var seqLocation:SequenceLocation.values()){
          if(checkedType.checked || seqLocation.expectedException==null){
            for(var preModScenario:PreModScenario.values()){
              if(preModScenario!=PreModScenario.ModSeq && (preModScenario.expectedException==null || checkedType.checked) && (!nestedType.rootType || preModScenario==PreModScenario.NoMod)){
                for(var seqContentsScenario:SequenceContentsScenario.values()){
                  if(seqContentsScenario.nonEmpty || seqLocation.validForEmpty){
                    for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
                      for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
                        switch(nestedType){
                          case LIST:
                            builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType,initialCapacity),inputArgType,seqLocation,preModScenario,seqContentsScenario));
                            break;
                          case SUBLIST:
                            for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5){
                              for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5){
                                for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5){
                                  for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5){
                                    builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType,initialCapacity,rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc),inputArgType,seqLocation,preModScenario,seqContentsScenario));
                                  }
                                }
                              }
                            }
                            break;
                          default:
                            throw new Error("Unknown nested type "+nestedType);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListadd_int_val(){
  getListadd_int_valArgs().parallel().map(Arguments::get).forEach(args->{
      testListadd_int_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],($ClassPrefix$InputTestArgType)args[1],(SequenceLocation)args[2],(PreModScenario)args[3],(SequenceContentsScenario)args[4]);
  });
}
private static void testListadd_int_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListadd_int_valArgs")
public void testListadd_int_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,$ClassPrefix$InputTestArgType inputArgType,SequenceLocation seqLocation,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  SequenceVerificationItr verifyItr;
  if(preModScenario.expectedException==null){
    switch(seqLocation){
      case IOBLO:
        Assertions.assertThrows(seqLocation.expectedException,()->seqMonitor.add(-1,0,inputArgType));
        seqMonitor.verifyStructuralIntegrity();
        verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
        break;
      case IOBHI:
        Assertions.assertThrows(seqLocation.expectedException,()->seqMonitor.add(numToAdd+1,0,inputArgType));
        seqMonitor.verifyStructuralIntegrity();
        verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
        break;
      case BEGINNING:
        for(int i=0;i<100;++i){
          seqMonitor.add(0,i,inputArgType);
          seqMonitor.verifyStructuralIntegrity();
        }
        verifyItr=seqMonitor.verifyPreAlloc().verifyDescending(inputArgType,100).verifyAscending(numToAdd);
        break;
      case MIDDLE:
        for(int i=0;i<100;++i){
          seqMonitor.add((i+numToAdd)/2,i,inputArgType);
          seqMonitor.verifyStructuralIntegrity();
        }
        verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd/2).verifyMidPointInsertion(inputArgType,100).verifyAscending(numToAdd/2,numToAdd-(numToAdd/2));
        break;
      case END:
        for(int i=0;i<100;++i){
          seqMonitor.add(i+numToAdd,i,inputArgType);
          seqMonitor.verifyStructuralIntegrity();
        }
        verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyAscending(inputArgType,100);
        break;
      default:
        throw new Error("Unknown seqLocation "+seqLocation);
    }
  }else{
    final int insertionIndex;
    switch(seqLocation){
      case IOBLO:
        insertionIndex=-1;
        break;
      case IOBHI:
         insertionIndex=numToAdd+1;
        break;
      case BEGINNING:
        insertionIndex=0;
        break;
      case MIDDLE:
        insertionIndex=numToAdd/2;
        break;
      case END:
        insertionIndex=numToAdd;
        break;
      default:
        throw new Error("Unknown seqLocation "+seqLocation);
    }
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.add(insertionIndex,0,inputArgType));
    seqMonitor.verifyStructuralIntegrity();
    verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
  }
  verifyItr.verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testListput_int_val<PARALLEL>()
static Stream<Arguments> getListput_int_valArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var seqLocation:SequenceLocation.values()){
          if((checkedType.checked || seqLocation.expectedException==null) && seqLocation.validForEmpty){
            for(var preModScenario:PreModScenario.values()){
              if(preModScenario!=PreModScenario.ModSeq && (preModScenario.expectedException==null || checkedType.checked) && (!nestedType.rootType || preModScenario==PreModScenario.NoMod)){
                for(var seqContentsScenario:SequenceContentsScenario.values()){
                  if(seqContentsScenario.nonEmpty || seqLocation.expectedException!=null){
                    for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
                      builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),inputArgType,seqLocation,preModScenario,seqContentsScenario));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListput_int_val(){
  getListput_int_valArgs().parallel().map(Arguments::get).forEach(args->{
      testListput_int_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],($ClassPrefix$InputTestArgType)args[1],(SequenceLocation)args[2],(PreModScenario)args[3],(SequenceContentsScenario)args[4]);
  });
}
private static void testListput_int_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListput_int_valArgs")
public void testListput_int_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,$ClassPrefix$InputTestArgType inputArgType,SequenceLocation seqLocation,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  SequenceVerificationItr verifyItr;
  if(preModScenario.expectedException==null){
    switch(seqLocation){
      case IOBLO:
        Assertions.assertThrows(seqLocation.expectedException,()->seqMonitor.put(-1,0,inputArgType));
        seqMonitor.verifyStructuralIntegrity();
        verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
        break;
      case IOBHI:
        Assertions.assertThrows(seqLocation.expectedException,()->seqMonitor.put(numToAdd,0,inputArgType));
        seqMonitor.verifyStructuralIntegrity();
        verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
        break;
      case BEGINNING:
        for(int i=0;i<numToAdd;++i){
          seqMonitor.put(i,numToAdd-i-1,inputArgType);
          seqMonitor.verifyStructuralIntegrity();
        }
        seqMonitor.verifyPreAlloc().verifyDescending(inputArgType,numToAdd).verifyPostAlloc();
        for(int i=0;i<numToAdd;++i){
          seqMonitor.put(i,i,inputArgType);
          seqMonitor.verifyStructuralIntegrity();
        }
        verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(inputArgType,numToAdd);
        break;
      default:
        throw new Error("Unknown seqLocation "+seqLocation);
    }
  }else{
    final int insertionIndex;
    switch(seqLocation){
      case IOBLO:
        insertionIndex=-1;
        break;
      case IOBHI:
         insertionIndex=numToAdd;
        break;
      case BEGINNING:
        insertionIndex=0;
        break;
      default:
        throw new Error("Unknown seqLocation "+seqLocation);
    }
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.put(insertionIndex,0,inputArgType));
    seqMonitor.verifyStructuralIntegrity();
    verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
  }
  verifyItr.verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testadd_val<PARALLEL>()
static Stream<Arguments> getadd_valArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
    for(var seqContentsScenario:SequenceContentsScenario.values()){
      for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
        for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
          switch(nestedType){
            case LIST:
            case STACK:
              streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType,initialCapacity),inputArgType,preModScenario,seqContentsScenario));
              break;
            case SUBLIST:
              for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5){
                for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5){
                  for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5){
                    for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5){
                      streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType,initialCapacity,rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc),inputArgType,preModScenario,seqContentsScenario));
                    }
                  }
                }
              }
              break;
            default:
              throw new Error("Unknown nested type "+nestedType);
          }
        }
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testadd_val(){
  getadd_valArgs().parallel().map(Arguments::get).forEach(args->{
      testadd_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],($ClassPrefix$InputTestArgType)args[1],(PreModScenario)args[2],(SequenceContentsScenario)args[3]);
  });
}
private static void testadd_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getadd_valArgs")
public void testadd_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,$ClassPrefix$InputTestArgType inputArgType,PreModScenario preModScenario,SequenceContentsScenario sequenceContentsScenario){
  int numToAdd=sequenceContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  SequenceVerificationItr verifyItr;
  if(preModScenario.expectedException==null){
    for(int i=0;i<100;++i){
      Assertions.assertTrue(seqMonitor.add(i,inputArgType));
      seqMonitor.verifyStructuralIntegrity();
    }
    verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyAscending(inputArgType,100);
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.add(0,inputArgType));
    seqMonitor.verifyStructuralIntegrity();
    verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
  }
  verifyItr.verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testStackpush_val<PARALLEL>()
static Stream<Arguments> getStackpush_valArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
      for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
        builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(NestedType.STACK,checkedType,initialCapacity),inputArgType));
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testStackpush_val(){
  getStackpush_valArgs().parallel().map(Arguments::get).forEach(args->{
      testStackpush_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],($ClassPrefix$InputTestArgType)args[1]);
  });
}
private static void testStackpush_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getStackpush_valArgs")
public void testStackpush_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,$ClassPrefix$InputTestArgType inputArgType){
  for(int i=0;i<100;++i){
    seqMonitor.push(i,inputArgType);
    seqMonitor.verifyStructuralIntegrity();
  }
  seqMonitor.verifyPreAlloc().verifyAscending(inputArgType,100);
}
#ENDDEF 
#MACRODEF testcontains_val<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testcontains_val(){
  getQueryCollectionArguments().parallel().map(Arguments::get).forEach(args->{
      testcontains_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],(QueryTester)args[1],(QueryCastType)args[2],(SequenceLocation)args[3],(SequenceContentsScenario)args[4],(PreModScenario)args[5]
#IF OfRef
        ,(MonitoredObjectGen)args[6]
#ENDIF
      );
  });
}
private static void testcontains_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueryCollectionArguments")
public void testcontains_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,QueryTester argType,QueryCastType queryCastType,SequenceLocation seqLocation,SequenceContentsScenario seqContentsScenario,PreModScenario preModScenario 
#IF OfRef
  ,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  if(seqContentsScenario.nonEmpty){
#IF OfRef
    if(monitoredObjectGen!=null){
      int numExpectedCalls;
      final var monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
      switch(seqLocation){
        case BEGINNING:
          numExpectedCalls=1+argType.initContainsBeginning(seqMonitor,monitoredObject);
          break;
        case MIDDLE:
          numExpectedCalls=1+argType.initContainsMiddle(seqMonitor,monitoredObject);
          break;
        case END:
          numExpectedCalls=1+argType.initContainsEnd(seqMonitor,monitoredObject);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          numExpectedCalls=seqMonitor.expectedSeqSize;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
      int seqSize=seqMonitor.expectedSeqSize;
      seqMonitor.illegalAdd(preModScenario);
      Class<? extends Throwable> expectedException=preModScenario.expectedException==null?monitoredObjectGen.expectedException:preModScenario.expectedException;
      Assertions.assertThrows(expectedException,()->argType.invokecontainsMonitored(seqMonitor,monitoredObject));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc().skip(seqSize);
      switch(monitoredObjectGen){
        case ModSeq:
          if(preModScenario==PreModScenario.NoMod){
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }else{
            numExpectedCalls=1;
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ModParent:
          verifyItr.verifyParentPostAlloc();
          if(preModScenario==PreModScenario.ModParent){
            verifyItr.verifyIllegalAdd();
          }
          if(preModScenario==PreModScenario.ModRoot){
            numExpectedCalls=1;
          }
          else{
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }
          verifyItr.verifyRootPostAlloc();
          if(preModScenario==PreModScenario.ModRoot){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ModRoot:
          verifyItr.verifyPostAlloc(preModScenario);
          for(int i=0;i<numExpectedCalls;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case Throw:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModSeq:
          numExpectedCalls=1;
          if(preModScenario==PreModScenario.NoMod){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModParent:
          numExpectedCalls=1;
          verifyItr.verifyParentPostAlloc();
          switch(preModScenario){
            case NoMod:
              verifyItr.verifyIllegalAdd().verifyRootPostAlloc();
              break;
            case ModParent:
              verifyItr.verifyIllegalAdd().verifyIllegalAdd().verifyRootPostAlloc();
              break;
            case ModRoot:
              verifyItr.verifyRootPostAlloc().verifyIllegalAdd();
              break;
            default:
              throw new Error("Unknown preModScenario "+preModScenario);
          }
          break;
        case ThrowModRoot:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario).verifyIllegalAdd();
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
      Assertions.assertEquals(numExpectedCalls,monitoredObject.numEqualsCalls);
      return;
    }else
#ENDIF
    {
      switch(seqLocation){
        case BEGINNING:
          argType.initContainsBeginning(seqMonitor);
          break;
        case MIDDLE:
          argType.initContainsMiddle(seqMonitor);
          break;
        case END:
          argType.initContainsEnd(seqMonitor);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
    }
  }
  int seqSize=seqMonitor.expectedSeqSize;
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    Assertions.assertEquals(seqLocation!=SequenceLocation.IOBHI,argType.invokecontains(seqMonitor,queryCastType));
  }else{
#IFNOT OfRef
    switch(argType)
#ENDIF
    {
#IFNOT OfRef
  #IF OfByte,OfChar,OfShort
    #IF OfChar
      case Byteneg1:
      case Shortneg1:
      case Integerneg1:
      case ShortMIN_BYTE_MINUS1:
      case IntegerMIN_BYTE_MINUS1:
    #ENDIF      
    #IF OfByte
      case CharacterMAX_BYTE_PLUS1:
      case CharacterMAX_SHORT_PLUS1:
      case ShortMAX_BYTE_PLUS1:
      case ShortMIN_BYTE_MINUS1:
      case IntegerMAX_BYTE_PLUS1:
      case IntegerMIN_BYTE_MINUS1:
      case IntegerMAX_SHORT_PLUS1:
    #ENDIF
    #IF OfShort
      case CharacterMAX_SHORT_PLUS1:
      case IntegerMAX_SHORT_PLUS1:
    #ENDIF
      case IntegerMIN_SHORT_MINUS1:
      case IntegerMAX_CHAR_PLUS1:
      case IntegerMAX_SAFE_INT_PLUS1:
      case IntegerMIN_SAFE_INT_MINUS1:
      if(preModScenario.expectedException!=null && queryCastType==QueryCastType.ToObject){
        Assertions.assertThrows(preModScenario.expectedException,()->argType.invokecontains(seqMonitor,queryCastType));
        break;
      }
  #ENDIF
      case Booleannull:
      case Bytenull:
      case Characternull:
      case Shortnull:
      case Integernull:
      case Longnull:
      case Floatnull:
      case Doublenull:
        Assertions.assertFalse(argType.invokecontains(seqMonitor,queryCastType));
        break;
      default:
#ENDIF
        Assertions.assertThrows(preModScenario.expectedException,()->argType.invokecontains(seqMonitor,queryCastType));
    }
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().skip(seqSize).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testindexOf_val<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testindexOf_val(){
  getQueryListArguments().parallel().map(Arguments::get).forEach(args->{
      testindexOf_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],(QueryTester)args[1],(QueryCastType)args[2],(SequenceLocation)args[3],(SequenceContentsScenario)args[4],(PreModScenario)args[5]
#IF OfRef
        ,(MonitoredObjectGen)args[6]
#ENDIF
      );
  });
}
private static void testindexOf_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueryListArguments")
public void testindexOf_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,QueryTester argType,QueryCastType queryCastType,SequenceLocation seqLocation,SequenceContentsScenario seqContentsScenario,PreModScenario preModScenario 
#IF OfRef
  ,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  int expectedIndex;
  if(seqContentsScenario.nonEmpty){
#IF OfRef
    if(monitoredObjectGen!=null){
      int numExpectedCalls;
      final var monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
      switch(seqLocation){
        case BEGINNING:
          numExpectedCalls=1+argType.initContainsBeginning(seqMonitor,monitoredObject);
          break;
        case MIDDLE:
          numExpectedCalls=1+argType.initContainsMiddle(seqMonitor,monitoredObject);
          break;
        case END:
          numExpectedCalls=1+argType.initContainsEnd(seqMonitor,monitoredObject);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          numExpectedCalls=seqMonitor.expectedSeqSize;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
      int seqSize=seqMonitor.expectedSeqSize;
      seqMonitor.illegalAdd(preModScenario);
      Class<? extends Throwable> expectedException=preModScenario.expectedException==null?monitoredObjectGen.expectedException:preModScenario.expectedException;
      Assertions.assertThrows(expectedException,()->argType.invokeindexOfMonitored(seqMonitor,monitoredObject));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc().skip(seqSize);
      switch(monitoredObjectGen){
        case ModSeq:
          if(preModScenario==PreModScenario.NoMod){
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }else{
            numExpectedCalls=1;
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ModParent:
          verifyItr.verifyParentPostAlloc();
          if(preModScenario==PreModScenario.ModParent){
            verifyItr.verifyIllegalAdd();
          }
          if(preModScenario==PreModScenario.ModRoot){
            numExpectedCalls=1;
          }else{
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }
          verifyItr.verifyRootPostAlloc();
          if(preModScenario==PreModScenario.ModRoot){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ModRoot:
          verifyItr.verifyPostAlloc(preModScenario);
          for(int i=0;i<numExpectedCalls;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case Throw:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModSeq:
          numExpectedCalls=1;
          if(preModScenario==PreModScenario.NoMod){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModParent:
          numExpectedCalls=1;
          verifyItr.verifyParentPostAlloc();
          switch(preModScenario){
            case NoMod:
              verifyItr.verifyIllegalAdd().verifyRootPostAlloc();
              break;
            case ModParent:
              verifyItr.verifyIllegalAdd().verifyIllegalAdd().verifyRootPostAlloc();
              break;
            case ModRoot:
              verifyItr.verifyRootPostAlloc().verifyIllegalAdd();
              break;
            default:
              throw new Error("Unknown preModScenario "+preModScenario);
          }
          break;
        case ThrowModRoot:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario).verifyIllegalAdd();
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
      Assertions.assertEquals(numExpectedCalls,monitoredObject.numEqualsCalls);
      return;
    }else
#ENDIF
    {
      switch(seqLocation){
        case BEGINNING:
          expectedIndex=argType.initContainsBeginning(seqMonitor);
          break;
        case MIDDLE:
          expectedIndex=argType.initContainsMiddle(seqMonitor);
          break;
        case END:
          expectedIndex=argType.initContainsEnd(seqMonitor);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          expectedIndex=-1;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
    }
  }else{
    expectedIndex=-1;
  }
  int seqSize=seqMonitor.expectedSeqSize;
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    Assertions.assertEquals(expectedIndex,argType.invokeindexOf(seqMonitor,queryCastType));
  }else{
#IFNOT OfRef
    switch(argType)
#ENDIF
    {
#IFNOT OfRef
  #IF OfByte,OfChar,OfShort
    #IF OfChar
      case Byteneg1:
      case Shortneg1:
      case Integerneg1:
      case ShortMIN_BYTE_MINUS1:
      case IntegerMIN_BYTE_MINUS1:
    #ENDIF      
    #IF OfByte
      case CharacterMAX_BYTE_PLUS1:
      case CharacterMAX_SHORT_PLUS1:
      case ShortMAX_BYTE_PLUS1:
      case ShortMIN_BYTE_MINUS1:
      case IntegerMAX_BYTE_PLUS1:
      case IntegerMIN_BYTE_MINUS1:
      case IntegerMAX_SHORT_PLUS1:
    #ENDIF
    #IF OfShort
      case CharacterMAX_SHORT_PLUS1:
      case IntegerMAX_SHORT_PLUS1:
    #ENDIF
      case IntegerMIN_SHORT_MINUS1:
      case IntegerMAX_CHAR_PLUS1:
      case IntegerMAX_SAFE_INT_PLUS1:
      case IntegerMIN_SAFE_INT_MINUS1:
      if(preModScenario.expectedException!=null && queryCastType==QueryCastType.ToObject){
        Assertions.assertThrows(preModScenario.expectedException,()->argType.invokecontains(seqMonitor,queryCastType));
        break;
      }
  #ENDIF
      case Booleannull:
      case Bytenull:
      case Characternull:
      case Shortnull:
      case Integernull:
      case Longnull:
      case Floatnull:
      case Doublenull:
        Assertions.assertEquals(-1,argType.invokeindexOf(seqMonitor,queryCastType));
        break;
      default:
#ENDIF
        Assertions.assertThrows(preModScenario.expectedException,()->argType.invokeindexOf(seqMonitor,queryCastType));
    }
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().skip(seqSize).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testlastIndexOf_val<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testlastIndexOf_val(){
  getQueryListArguments().parallel().map(Arguments::get).forEach(args->{
      testlastIndexOf_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],(QueryTester)args[1],(QueryCastType)args[2],(SequenceLocation)args[3],(SequenceContentsScenario)args[4],(PreModScenario)args[5]
#IF OfRef
        ,(MonitoredObjectGen)args[6]
#ENDIF
      );
  });
}
private static void testlastIndexOf_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueryListArguments")
public void testlastIndexOf_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,QueryTester argType,QueryCastType queryCastType,SequenceLocation seqLocation,SequenceContentsScenario seqContentsScenario,PreModScenario preModScenario 
#IF OfRef
  ,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  int expectedIndex;
  if(seqContentsScenario.nonEmpty){
#IF OfRef
    if(monitoredObjectGen!=null){
      int numExpectedCalls;
      final var monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
      switch(seqLocation){
        case BEGINNING:
          numExpectedCalls=argType.initContainsBeginning(seqMonitor,monitoredObject);
          numExpectedCalls=seqMonitor.expectedSeqSize-numExpectedCalls;
          break;
        case MIDDLE:
          numExpectedCalls=argType.initContainsMiddle(seqMonitor,monitoredObject);
          numExpectedCalls=seqMonitor.expectedSeqSize-numExpectedCalls;
          break;
        case END:
          numExpectedCalls=argType.initContainsEnd(seqMonitor,monitoredObject);
          numExpectedCalls=seqMonitor.expectedSeqSize-numExpectedCalls;
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          numExpectedCalls=seqMonitor.expectedSeqSize;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
      int seqSize=seqMonitor.expectedSeqSize;
      seqMonitor.illegalAdd(preModScenario);
      Class<? extends Throwable> expectedException=preModScenario.expectedException==null?monitoredObjectGen.expectedException:preModScenario.expectedException;
      Assertions.assertThrows(expectedException,()->argType.invokelastIndexOfMonitored(seqMonitor,monitoredObject));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc().skip(seqSize);
      switch(monitoredObjectGen){
        case ModSeq:
          if(preModScenario==PreModScenario.NoMod){
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }else{
            numExpectedCalls=1;
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ModParent:
          verifyItr.verifyParentPostAlloc();
          if(preModScenario==PreModScenario.ModParent){
            verifyItr.verifyIllegalAdd();
          }
          if(preModScenario==PreModScenario.ModRoot){
            numExpectedCalls=1;
          }else{
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }
          verifyItr.verifyRootPostAlloc();
          if(preModScenario==PreModScenario.ModRoot){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ModRoot:
          verifyItr.verifyPostAlloc(preModScenario);
          for(int i=0;i<numExpectedCalls;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case Throw:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModSeq:
          numExpectedCalls=1;
          if(preModScenario==PreModScenario.NoMod){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModParent:
          numExpectedCalls=1;
          verifyItr.verifyParentPostAlloc();
          switch(preModScenario){
            case NoMod:
              verifyItr.verifyIllegalAdd().verifyRootPostAlloc();
              break;
            case ModParent:
              verifyItr.verifyIllegalAdd().verifyIllegalAdd().verifyRootPostAlloc();
              break;
            case ModRoot:
              verifyItr.verifyRootPostAlloc().verifyIllegalAdd();
              break;
            default:
              throw new Error("Unknown preModScenario "+preModScenario);
          }
          break;
        case ThrowModRoot:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario).verifyIllegalAdd();
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
      Assertions.assertEquals(numExpectedCalls,monitoredObject.numEqualsCalls);
      return;
    }else
#ENDIF
    {
      switch(seqLocation){
        case BEGINNING:
          expectedIndex=argType.initContainsBeginning(seqMonitor);
          break;
        case MIDDLE:
          expectedIndex=argType.initContainsMiddle(seqMonitor);
          break;
        case END:
          expectedIndex=argType.initContainsEnd(seqMonitor);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          expectedIndex=-1;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
    }
  }else{
    expectedIndex=-1;
  }
  int seqSize=seqMonitor.expectedSeqSize;
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    Assertions.assertEquals(expectedIndex,argType.invokelastIndexOf(seqMonitor,queryCastType));
  }else{
#IFNOT OfRef
    switch(argType)
#ENDIF
    {
#IFNOT OfRef
  #IF OfByte,OfChar,OfShort
    #IF OfChar
      case Byteneg1:
      case Shortneg1:
      case Integerneg1:
      case ShortMIN_BYTE_MINUS1:
      case IntegerMIN_BYTE_MINUS1:
    #ENDIF      
    #IF OfByte
      case CharacterMAX_BYTE_PLUS1:
      case CharacterMAX_SHORT_PLUS1:
      case ShortMAX_BYTE_PLUS1:
      case ShortMIN_BYTE_MINUS1:
      case IntegerMAX_BYTE_PLUS1:
      case IntegerMIN_BYTE_MINUS1:
      case IntegerMAX_SHORT_PLUS1:
    #ENDIF
    #IF OfShort
      case CharacterMAX_SHORT_PLUS1:
      case IntegerMAX_SHORT_PLUS1:
    #ENDIF
      case IntegerMIN_SHORT_MINUS1:
      case IntegerMAX_CHAR_PLUS1:
      case IntegerMAX_SAFE_INT_PLUS1:
      case IntegerMIN_SAFE_INT_MINUS1:
      if(preModScenario.expectedException!=null && queryCastType==QueryCastType.ToObject){
        Assertions.assertThrows(preModScenario.expectedException,()->argType.invokecontains(seqMonitor,queryCastType));
        break;
      }
  #ENDIF
      case Booleannull:
      case Bytenull:
      case Characternull:
      case Shortnull:
      case Integernull:
      case Longnull:
      case Floatnull:
      case Doublenull:
        Assertions.assertEquals(-1,argType.invokelastIndexOf(seqMonitor,queryCastType));
        break;
      default:
#ENDIF
        Assertions.assertThrows(preModScenario.expectedException,()->argType.invokelastIndexOf(seqMonitor,queryCastType));
    }
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().skip(seqSize).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testsearch_val<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testsearch_val(){
  getQueryStackArguments().parallel().map(Arguments::get).forEach(args->{
      testsearch_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],(QueryTester)args[1],(QueryCastType)args[2],(SequenceLocation)args[3],(SequenceContentsScenario)args[4],(PreModScenario)args[5]
#IF OfRef
        ,(MonitoredObjectGen)args[6]
#ENDIF
      );
  });
}
private static void testsearch_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueryStackArguments")
public void testsearch_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,QueryTester argType,QueryCastType queryCastType,SequenceLocation seqLocation,SequenceContentsScenario seqContentsScenario,PreModScenario preModScenario 
#IF OfRef
  ,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  int expectedIndex;
  if(seqContentsScenario.nonEmpty){
#IF OfRef
    if(monitoredObjectGen!=null){
      int numExpectedCalls;
      final var monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
      switch(seqLocation){
        case BEGINNING:
          numExpectedCalls=argType.initContainsBeginning(seqMonitor,monitoredObject);
          numExpectedCalls=seqMonitor.expectedSeqSize-numExpectedCalls;
          break;
        case MIDDLE:
          numExpectedCalls=argType.initContainsMiddle(seqMonitor,monitoredObject);
          numExpectedCalls=seqMonitor.expectedSeqSize-numExpectedCalls;
          break;
        case END:
          numExpectedCalls=argType.initContainsEnd(seqMonitor,monitoredObject);
          numExpectedCalls=seqMonitor.expectedSeqSize-numExpectedCalls;
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          numExpectedCalls=seqMonitor.expectedSeqSize;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
      int seqSize=seqMonitor.expectedSeqSize;
      seqMonitor.illegalAdd(preModScenario);
      Assertions.assertThrows(monitoredObjectGen.expectedException,()->argType.invokesearchMonitored(seqMonitor,monitoredObject));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc().skip(seqSize);
      switch(monitoredObjectGen){
        case ModSeq:
          for(int i=0;i<numExpectedCalls;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ThrowModSeq:
          verifyItr.verifyIllegalAdd();
        case Throw:
          numExpectedCalls=1;
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
      verifyItr.verifyPostAlloc();
      Assertions.assertEquals(numExpectedCalls,monitoredObject.numEqualsCalls);
      return;
    }else
#ENDIF
    {
      switch(seqLocation){
        case BEGINNING:
          expectedIndex=argType.initContainsBeginning(seqMonitor);
          expectedIndex=seqMonitor.expectedSeqSize-expectedIndex;
          break;
        case MIDDLE:
          expectedIndex=argType.initContainsMiddle(seqMonitor);
          expectedIndex=seqMonitor.expectedSeqSize-expectedIndex;
          break;
        case END:
          expectedIndex=argType.initContainsEnd(seqMonitor);
          expectedIndex=seqMonitor.expectedSeqSize-expectedIndex;
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          expectedIndex=-1;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
    }
  }else{
    expectedIndex=-1;
  }
  int seqSize=seqMonitor.expectedSeqSize;
  Assertions.assertEquals(expectedIndex,argType.invokesearch(seqMonitor,queryCastType));
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().skip(seqSize).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testremoveVal_val<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testremoveVal_val(){
  getQueryCollectionArguments().parallel().map(Arguments::get).forEach(args->{
      testremoveVal_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],(QueryTester)args[1],(QueryCastType)args[2],(SequenceLocation)args[3],(SequenceContentsScenario)args[4],(PreModScenario)args[5]
#IF OfRef
        ,(MonitoredObjectGen)args[6]
#ENDIF
      );
  });
}
private static void testremoveVal_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueryCollectionArguments")
public void testremoveVal_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,QueryTester argType,QueryCastType queryCastType,SequenceLocation seqLocation,SequenceContentsScenario seqContentsScenario,PreModScenario preModScenario 
#IF OfRef
  ,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  if(seqContentsScenario.nonEmpty){
#IF OfRef
    if(monitoredObjectGen!=null){
      int numExpectedCalls;
      final var monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
      switch(seqLocation){
        case BEGINNING:
          numExpectedCalls=1+argType.initContainsBeginning(seqMonitor,monitoredObject);
          if(!seqMonitor.nestedType.forwardIteration){
            numExpectedCalls=seqMonitor.expectedSeqSize;
          }
          break;
        case MIDDLE:
          numExpectedCalls=1+argType.initContainsMiddle(seqMonitor,monitoredObject);
          if(!seqMonitor.nestedType.forwardIteration){
            numExpectedCalls=seqMonitor.expectedSeqSize-numExpectedCalls+1;
          }
          break;
        case END:
          numExpectedCalls=1+argType.initContainsEnd(seqMonitor,monitoredObject);
          if(!seqMonitor.nestedType.forwardIteration){
            numExpectedCalls=1;
          }
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          numExpectedCalls=seqMonitor.expectedSeqSize;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
      int seqSize=seqMonitor.expectedSeqSize;
      seqMonitor.illegalAdd(preModScenario);
      Class<? extends Throwable> expectedException=preModScenario.expectedException==null?monitoredObjectGen.expectedException:preModScenario.expectedException;
      Assertions.assertThrows(expectedException,()->argType.invokeremoveValMonitored(seqMonitor,monitoredObject));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc().skip(seqSize);
      switch(monitoredObjectGen){
        case ModSeq:
          if(preModScenario==PreModScenario.NoMod){
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }else{
            numExpectedCalls=1;
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ModParent:
          verifyItr.verifyParentPostAlloc();
          if(preModScenario==PreModScenario.ModParent){
            verifyItr.verifyIllegalAdd();
          }
          if(preModScenario==PreModScenario.ModRoot){
            numExpectedCalls=1;
          }else{
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }
          verifyItr.verifyRootPostAlloc();
          if(preModScenario==PreModScenario.ModRoot){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ModRoot:
          verifyItr.verifyPostAlloc(preModScenario);
          for(int i=0;i<numExpectedCalls;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case Throw:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModSeq:
          numExpectedCalls=1;
          if(preModScenario==PreModScenario.NoMod){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModParent:
          numExpectedCalls=1;
          verifyItr.verifyParentPostAlloc();
          switch(preModScenario){
            case NoMod:
              verifyItr.verifyIllegalAdd().verifyRootPostAlloc();
              break;
            case ModParent:
              verifyItr.verifyIllegalAdd().verifyIllegalAdd().verifyRootPostAlloc();
              break;
            case ModRoot:
              verifyItr.verifyRootPostAlloc().verifyIllegalAdd();
              break;
            default:
              throw new Error("Unknown preModScenario "+preModScenario);
          }
          break;
        case ThrowModRoot:
          numExpectedCalls=1;
          verifyItr.verifyPostAlloc(preModScenario).verifyIllegalAdd();
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
      Assertions.assertEquals(numExpectedCalls,monitoredObject.numEqualsCalls);
      return;
    }else
#ENDIF
    {
      switch(seqLocation){
        case BEGINNING:
          argType.initContainsBeginning(seqMonitor);
          break;
        case MIDDLE:
          argType.initContainsMiddle(seqMonitor);
          break;
        case END:
          argType.initContainsEnd(seqMonitor);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor);
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
    }
  }
  int seqSize=seqMonitor.expectedSeqSize;
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    boolean expectedResult;
    Assertions.assertEquals(expectedResult=seqLocation!=SequenceLocation.IOBHI,argType.invokeremoveVal(seqMonitor,queryCastType));
    if(expectedResult){
      --seqSize;
    }
  }else{
#IFNOT OfRef
    switch(argType)
#ENDIF
    {
#IFNOT OfRef
      case Booleannull:
      case Bytenull:
      case Characternull:
      case Shortnull:
      case Integernull:
      case Longnull:
      case Floatnull:
      case Doublenull:
        Assertions.assertFalse(argType.invokeremoveVal(seqMonitor,queryCastType));
        break;
      default:
#ENDIF
        Assertions.assertThrows(preModScenario.expectedException,()->argType.invokeremoveVal(seqMonitor,queryCastType));
    }
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().skip(seqSize).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testListsort_Comparator<PARALLEL>()
static Stream<Arguments> getListsort_ComparatorArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var preModScenario:PreModScenario.values()){
          if((checkedType.checked || preModScenario.expectedException==null) && ((nestedType.rootType && preModScenario.expectedException==null)||(!nestedType.rootType && preModScenario.appliesToSubList))){
            for(var monitoredComparatorGen:MonitoredComparatorGen.values()){
              if((!nestedType.rootType || monitoredComparatorGen.appliesToRoot) && (checkedType.checked || monitoredComparatorGen.expectedException==null)){
                for(var sequenceContentsScenario:SequenceContentsScenario.values()){
                  for(var functionCallType:FunctionCallType.values()){
                    builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredComparatorGen,sequenceContentsScenario,functionCallType));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListsort_Comparator(){
  getListsort_ComparatorArgs().parallel().map(Arguments::get).forEach(args->{
      testListsort_ComparatorHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredComparatorGen)args[2],(SequenceContentsScenario)args[3],(FunctionCallType)args[4]);
  });
}
private static void testListsort_ComparatorHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListsort_ComparatorArgs")
public void testListsort_Comparator
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredComparatorGen monitoredComparatorGen,SequenceContentsScenario seqContentsScenario,FunctionCallType functionCallType){
  monitoredComparatorGen.init(seqMonitor,seqContentsScenario,preModScenario);
  var sorter=monitoredComparatorGen.getMonitoredComparator(seqMonitor);
  if(preModScenario.expectedException==null){
    if(monitoredComparatorGen.expectedException==null || !seqContentsScenario.nonEmpty){
      seqMonitor.sort(sorter,functionCallType);
    }else{
      Assertions.assertThrows(monitoredComparatorGen.expectedException,()->seqMonitor.sort(sorter,functionCallType));
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.sort(sorter,functionCallType));
  }
  monitoredComparatorGen.assertSorted(seqMonitor,seqContentsScenario,preModScenario);
}
#ENDDEF
#MACRODEF testListunstableSort_Comparator<PARALLEL>()
static Stream<Arguments> getListunstableSort_ComparatorArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var preModScenario:PreModScenario.values()){
          if((checkedType.checked || preModScenario.expectedException==null) && ((nestedType.rootType && preModScenario.expectedException==null)||(!nestedType.rootType && preModScenario.appliesToSubList))){
            for(var monitoredComparatorGen:MonitoredComparatorGen.values()){
              if((!nestedType.rootType || monitoredComparatorGen.appliesToRoot) && (checkedType.checked || monitoredComparatorGen.expectedException==null)){
                for(var sequenceContentsScenario:SequenceContentsScenario.values()){
                  builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredComparatorGen,sequenceContentsScenario));
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListunstableSort_Comparator(){
  getListunstableSort_ComparatorArgs().parallel().map(Arguments::get).forEach(args->{
      testListunstableSort_ComparatorHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredComparatorGen)args[2],(SequenceContentsScenario)args[3]);
  });
}
private static void testListunstableSort_ComparatorHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListunstableSort_ComparatorArgs")
public void testListunstableSort_Comparator
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredComparatorGen monitoredComparatorGen,SequenceContentsScenario seqContentsScenario){
  monitoredComparatorGen.init(seqMonitor,seqContentsScenario,preModScenario);
  var sorter=monitoredComparatorGen.getMonitoredComparator(seqMonitor);
  if(preModScenario.expectedException==null){
    if(monitoredComparatorGen.expectedException==null || !seqContentsScenario.nonEmpty){
      seqMonitor.unstableSort(sorter);
    }else{
      Assertions.assertThrows(monitoredComparatorGen.expectedException,()->seqMonitor.unstableSort(sorter));
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.unstableSort(sorter));
  }
  monitoredComparatorGen.assertSorted(seqMonitor,seqContentsScenario,preModScenario);
}
#ENDDEF
#MACRODEF testListstableAscendingSort_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListstableAscendingSort_void(){
  getNonComparatorSortArgs().parallel().map(Arguments::get).forEach(args->{
      testListstableAscendingSort_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredComparatorGen)args[2],(SequenceContentsScenario)args[3]);
  });
}
private static void testListstableAscendingSort_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getNonComparatorSortArgs")
public void testListstableAscendingSort_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredComparatorGen monitoredComparatorGen,SequenceContentsScenario seqContentsScenario){
  monitoredComparatorGen.init(seqMonitor,seqContentsScenario,preModScenario);
  if(preModScenario.expectedException==null){
    if(monitoredComparatorGen.expectedException==null || !seqContentsScenario.nonEmpty){
      seqMonitor.stableAscendingSort();
    }else{
      Assertions.assertThrows(monitoredComparatorGen.expectedException,()->seqMonitor.stableAscendingSort());
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.stableAscendingSort());
  }
  monitoredComparatorGen.assertSorted(seqMonitor,seqContentsScenario,preModScenario);
}
#ENDDEF
#MACRODEF testListstableDescendingSort_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListstableDescendingSort_void(){
  getNonComparatorSortArgs().parallel().map(Arguments::get).forEach(args->{
      testListstableDescendingSort_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredComparatorGen)args[2],(SequenceContentsScenario)args[3]);
  });
}
private static void testListstableDescendingSort_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getNonComparatorSortArgs")
public void testListstableDescendingSort_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredComparatorGen monitoredComparatorGen,SequenceContentsScenario seqContentsScenario){
  monitoredComparatorGen.initReverse(seqMonitor,seqContentsScenario,preModScenario);
  if(preModScenario.expectedException==null){
    if(monitoredComparatorGen.expectedException==null || !seqContentsScenario.nonEmpty){
      seqMonitor.stableDescendingSort();
    }else{
      Assertions.assertThrows(monitoredComparatorGen.expectedException,()->seqMonitor.stableDescendingSort());
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.stableDescendingSort());
  }
  monitoredComparatorGen.assertReverseSorted(seqMonitor,seqContentsScenario,preModScenario);
}
#ENDDEF
#MACRODEF testListunstableAscendingSort_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListunstableAscendingSort_void(){
  getNonComparatorSortArgs().parallel().map(Arguments::get).forEach(args->{
      testListunstableAscendingSort_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredComparatorGen)args[2],(SequenceContentsScenario)args[3]);
  });
}
private static void testListunstableAscendingSort_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getNonComparatorSortArgs")
public void testListunstableAscendingSort_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredComparatorGen monitoredComparatorGen,SequenceContentsScenario seqContentsScenario){
  monitoredComparatorGen.init(seqMonitor,seqContentsScenario,preModScenario);
  if(preModScenario.expectedException==null){
    if(monitoredComparatorGen.expectedException==null || !seqContentsScenario.nonEmpty){
      seqMonitor.unstableAscendingSort();
    }else{
      Assertions.assertThrows(monitoredComparatorGen.expectedException,()->seqMonitor.unstableAscendingSort());
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.unstableAscendingSort());
  }
  monitoredComparatorGen.assertSorted(seqMonitor,seqContentsScenario,preModScenario);
}
#ENDDEF
#MACRODEF testListunstableDescendingSort_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListunstableDescendingSort_void(){
  getNonComparatorSortArgs().parallel().map(Arguments::get).forEach(args->{
      testListunstableDescendingSort_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredComparatorGen)args[2],(SequenceContentsScenario)args[3]);
  });
}
private static void testListunstableDescendingSort_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getNonComparatorSortArgs")
public void testListunstableDescendingSort_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredComparatorGen monitoredComparatorGen,SequenceContentsScenario seqContentsScenario){
  monitoredComparatorGen.initReverse(seqMonitor,seqContentsScenario,preModScenario);
  if(preModScenario.expectedException==null){
    if(monitoredComparatorGen.expectedException==null || !seqContentsScenario.nonEmpty){
      seqMonitor.unstableDescendingSort();
    }else{
      Assertions.assertThrows(monitoredComparatorGen.expectedException,()->seqMonitor.unstableDescendingSort());
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.unstableDescendingSort());
  }
  monitoredComparatorGen.assertReverseSorted(seqMonitor,seqContentsScenario,preModScenario);
}
#ENDDEF
#MACRODEF testListremoveAt_int<PARALLEL>()
static Stream<Arguments> getListremoveAt_intArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var preModScenario:PreModScenario.values()){
          if(preModScenario!=PreModScenario.ModSeq && (preModScenario.expectedException==null || (!nestedType.rootType && checkedType.checked))){
            for(var seqLocation:SequenceLocation.values()){
              if(checkedType.checked || seqLocation.expectedException==null){
                for(var seqContentsScenario:SequenceContentsScenario.values()){
                  if(seqContentsScenario.nonEmpty || (seqLocation==SequenceLocation.IOBHI)){
                    for(var outputArgType:$ClassPrefix$OutputTestArgType.values()){
                      builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqLocation,seqContentsScenario,outputArgType));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListremoveAt_int(){
  getListremoveAt_intArgs().parallel().map(Arguments::get).forEach(args->{
      testListremoveAt_intHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceLocation)args[2],(SequenceContentsScenario)args[3],($ClassPrefix$OutputTestArgType)args[4]);
  });
}
private static void testListremoveAt_intHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListremoveAt_intArgs")
public void testListremoveAt_int
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceLocation seqLocation,SequenceContentsScenario seqContentsScenario,$ClassPrefix$OutputTestArgType outputArgType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  int expectedSize=numToAdd;
  seqMonitor.illegalAdd(preModScenario);
  Class<? extends Throwable> expectedException=preModScenario.expectedException==null?seqLocation.expectedException:preModScenario.expectedException;
  switch(seqLocation){
    case IOBLO:
      Assertions.assertThrows(expectedException,()->seqMonitor.removeAt(0,outputArgType,-1));
      seqMonitor.verifyStructuralIntegrity();
      break;
    case IOBHI:
      Assertions.assertThrows(expectedException,()->seqMonitor.removeAt(numToAdd,outputArgType,-1));
      seqMonitor.verifyStructuralIntegrity();
      break;
    case BEGINNING:
      if(expectedException==null){
        for(int i=0;i<numToAdd;++i){
          seqMonitor.removeAt(i,outputArgType,0);
          seqMonitor.verifyStructuralIntegrity();
        }
        expectedSize=0;
      }else{
        Assertions.assertThrows(expectedException,()->seqMonitor.removeAt(0,outputArgType,0));
        seqMonitor.verifyStructuralIntegrity();
      }
      break;
    case MIDDLE:
      if(expectedException==null){
        for(int i=0,expectedLo=numToAdd/2,expectedHi=numToAdd/2;i<numToAdd;++i){
          if((i&1)==0){
            seqMonitor.removeAt(expectedHi++,outputArgType,(numToAdd-i)/2);
          }else{
            seqMonitor.removeAt(--expectedLo,outputArgType,(numToAdd-i)/2);
          }
          seqMonitor.verifyStructuralIntegrity();
        }
        expectedSize=0;
      }else{
        Assertions.assertThrows(expectedException,()->seqMonitor.removeAt(numToAdd/2,outputArgType,numToAdd/2));
        seqMonitor.verifyStructuralIntegrity();
      }
      break;
    case END:
      if(expectedException==null){
        for(int i=0;i<numToAdd;++i){
          seqMonitor.removeAt(numToAdd-i-1,outputArgType,numToAdd-i-1);
          seqMonitor.verifyStructuralIntegrity();
        }
        expectedSize=0;
      }else{
        Assertions.assertThrows(expectedException,()->seqMonitor.removeAt(numToAdd-1,outputArgType,numToAdd-1));
        seqMonitor.verifyStructuralIntegrity();
      }
      break;
    default:
      throw new Error("Unknown seqLocation "+seqLocation);
  }
  seqMonitor.verifyPreAlloc().verifyAscending(expectedSize).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testtoArray_void<PARALLEL>()
static Stream<Arguments> gettoArray_voidArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
    for(var seqContentsScenario:SequenceContentsScenario.values()){
      for(var outputArgType:$ClassPrefix$OutputTestArgType.values()){
        streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqContentsScenario,outputArgType));
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testtoArray_void(){
  gettoArray_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testtoArray_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2],($ClassPrefix$OutputTestArgType)args[3]);
  });
}
private static void testtoArray_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoArray_voidArgs")
public void testtoArray_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario,$ClassPrefix$OutputTestArgType outputArgType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    outputArgType.verifyToArray(seqMonitor.seq,numToAdd);
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->outputArgType.verifyToArray(seqMonitor.seq,numToAdd));
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testclone_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testclone_void(){
  getBasicCollectionTestArgs().parallel().map(Arguments::get).forEach(args->{
      testclone_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2]);
  });
}
private static void testclone_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getBasicCollectionTestArgs")
public void testclone_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    var clone=(OmniCollection.Of$ClassPrefix$)seqMonitor.seq.clone();
    Assertions.assertNotSame(clone,seqMonitor.seq);
    switch(seqMonitor.nestedType){
      case STACK:
        if(seqMonitor.checkedType.checked){
          Assertions.assertTrue(clone instanceof $ClassPrefix$ArrSeq.CheckedStack);
          Assertions.assertEquals(0,(($ClassPrefix$ArrSeq.CheckedStack)clone).modCount);
        }else{
          Assertions.assertTrue(clone instanceof $ClassPrefix$ArrSeq.UncheckedStack);
        }
        break;
      case LIST:
      case SUBLIST:
        if(seqMonitor.checkedType.checked){
          Assertions.assertTrue(clone instanceof $ClassPrefix$ArrSeq.CheckedList);
          Assertions.assertEquals(0,(($ClassPrefix$ArrSeq.CheckedList)clone).modCount);
        }else{
          Assertions.assertTrue(clone instanceof $ClassPrefix$ArrSeq.UncheckedList);
        }
        break;
      default:
        throw new Error("Unknown nested type "+seqMonitor.nestedType);
    }
    var arrSeqClone=($ClassPrefix$ArrSeq)clone;
    var originalArr=(($ClassPrefix$ArrSeq)seqMonitor.root).arr;
    var cloneArr=arrSeqClone.arr;
    Assertions.assertEquals(numToAdd,arrSeqClone.size);
    if(arrSeqClone.size==0){
      Assertions.assertSame(cloneArr,OmniArray.Of$ClassPrefix$.DEFAULT_ARR);
    }else{
      Assertions.assertNotSame(originalArr,cloneArr);
      for(int i=0,origOffset=seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc;i<numToAdd;++i,++origOffset){
  #IF OfRef
        Assertions.assertSame(originalArr[origOffset],cloneArr[i]);
  #ELSE
        Assertions.assertEquals(originalArr[origOffset],cloneArr[i]);
  #ENDIF
      }
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.seq.clone());
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testsize_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testsize_void(){
  getBasicCollectionTestArgs().parallel().map(Arguments::get).forEach(args->{
      testsize_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2]);
  });
}
private static void testsize_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getBasicCollectionTestArgs")
public void testsize_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    Assertions.assertEquals(i,seqMonitor.seq.size());
    seqMonitor.verifyStructuralIntegrity();
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    var itrMonitor=seqMonitor.getItrMonitor();
    while(numToAdd>0){
      Assertions.assertEquals(numToAdd--,seqMonitor.seq.size());
      seqMonitor.verifyStructuralIntegrity();
      itrMonitor.iterateForward();
      itrMonitor.remove();
    }
    Assertions.assertEquals(numToAdd,seqMonitor.seq.size());
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.seq.size());
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testisEmpty_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testisEmpty_void(){
  getBasicCollectionTestArgs().parallel().map(Arguments::get).forEach(args->{
      testisEmpty_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2]);
  });
}
private static void testisEmpty_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getBasicCollectionTestArgs")
public void testisEmpty_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    Assertions.assertEquals(i==0,seqMonitor.seq.isEmpty());
    seqMonitor.verifyStructuralIntegrity();
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    var itrMonitor=seqMonitor.getItrMonitor();
    while(numToAdd>0){
      Assertions.assertEquals((numToAdd--)==0,seqMonitor.seq.isEmpty());
      seqMonitor.verifyStructuralIntegrity();
      itrMonitor.iterateForward();
      itrMonitor.remove();
    }
    Assertions.assertTrue(seqMonitor.seq.isEmpty());
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.seq.isEmpty());
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testclear_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testclear_void(){
  getBasicCollectionTestArgs().parallel().map(Arguments::get).forEach(args->{
      testclear_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2]);
  });
}
private static void testclear_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getBasicCollectionTestArgs")
public void testclear_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    seqMonitor.clear();
    Assertions.assertTrue(seqMonitor.seq.isEmpty());
    numToAdd=0;
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.seq.isEmpty());
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testStackpeek_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testStackpeek_void(){
  getStackpollpeekAndpop_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testStackpeek_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],($ClassPrefix$OutputTestArgType)args[1]);
  });
}
private static void testStackpeek_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getStackpollpeekAndpop_voidArgs")
public void testStackpeek_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,$ClassPrefix$OutputTestArgType outputArgType){
  for(int i=0;i<100;){
    outputArgType.verifyPeek(seqMonitor.seq,i,i);
    seqMonitor.verifyStructuralIntegrity();
    seqMonitor.add(++i);
  }
}
#ENDDEF
#MACRODEF testStackpop_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testStackpop_void(){
  getStackpollpeekAndpop_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testStackpop_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],($ClassPrefix$OutputTestArgType)args[1]);
  });
}
private static void testStackpop_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getStackpollpeekAndpop_voidArgs")
public void testStackpop_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,$ClassPrefix$OutputTestArgType outputArgType){
  for(int i=0;i<100;++i){
    seqMonitor.add(i);
  }
  for(int i=100;--i>=0;){
    seqMonitor.pop(i,outputArgType);
    seqMonitor.verifyStructuralIntegrity();
  }
  if(seqMonitor.checkedType.checked){
    Assertions.assertThrows(NoSuchElementException.class,()->seqMonitor.pop(0,outputArgType));
    seqMonitor.verifyStructuralIntegrity();
  }
}
#ENDDEF
#MACRODEF testStackpoll_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testStackpoll_void(){
  getStackpollpeekAndpop_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testStackpoll_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],($ClassPrefix$OutputTestArgType)args[1]);
  });
}
private static void testStackpoll_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getStackpollpeekAndpop_voidArgs")
public void testStackpoll_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,$ClassPrefix$OutputTestArgType outputArgType){
  for(int i=0;i<100;++i){
    seqMonitor.add(i);
  }
  for(int i=100;--i>=0;){
    seqMonitor.poll(i,outputArgType);
    seqMonitor.verifyStructuralIntegrity();
  }
  seqMonitor.poll(0,outputArgType);
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF
#MACRODEF testiterator_void<PARALLEL>()
static Stream<Arguments> getiterator_voidArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
    streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario));
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testiterator_void(){
  getiterator_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testiterator_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1]);
  });
}
private static void testiterator_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getiterator_voidArgs")
public void testiterator_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario){
  for(int i=0;i<100;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    var itrMonitor=seqMonitor.getItrMonitor();
    itrMonitor.verifyIteratorState();
    if(seqMonitor.nestedType.forwardIteration){
      Assertions.assertEquals(0,itrMonitor.expectedCursor);
    }else{
      Assertions.assertEquals(100,itrMonitor.expectedCursor);
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.getItrMonitor());
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(100).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testListlistIterator_void<PARALLEL>()
static Stream<Arguments> getListlistIterator_voidArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var preModScenario:PreModScenario.values()){
          if(preModScenario!=PreModScenario.ModSeq && (preModScenario.expectedException==null || (checkedType.checked && !nestedType.rootType))){
            builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario));
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListlistIterator_void(){
  getListlistIterator_intArgs().parallel().map(Arguments::get).forEach(args->{
      testListlistIterator_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1]);
  });
}
private static void testListlistIterator_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListlistIterator_voidArgs")
public void testListlistIterator_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario){
  for(int i=0;i<100;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    var itrMonitor=seqMonitor.getListItrMonitor();
    itrMonitor.verifyIteratorState();
    Assertions.assertEquals(0,itrMonitor.expectedCursor);
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.getListItrMonitor());
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(100).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testListlistIterator_int<PARALLEL>()
static Stream<Arguments> getListlistIterator_intArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var preModScenario:PreModScenario.values()){
          if(preModScenario!=PreModScenario.ModSeq && (preModScenario.expectedException==null || (checkedType.checked && !nestedType.rootType))){
            for(var seqLocation:SequenceLocation.values()){
              if(seqLocation.expectedException!=null && checkedType.checked)
                builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqLocation));
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListlistIterator_int(){
  getListlistIterator_intArgs().parallel().map(Arguments::get).forEach(args->{
      testListlistIterator_intHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceLocation)args[2]);
  });
}
private static void testListlistIterator_intHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListlistIterator_intArgs")
public void testListlistIterator_int
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceLocation seqLocation){
  for(int i=0;i<100;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  final int itrIndex;
  switch(seqLocation){
    case IOBLO:
      itrIndex=-1;
      break;
    case IOBHI:
      itrIndex=101;
      break;
    case BEGINNING:
      itrIndex=0;
      break;
    case MIDDLE:
      itrIndex=50;
      break;
    case END:
      itrIndex=100;
      break;
    default:
      throw new Error("Unknown seqLocation "+seqLocation);
  }
  Class<? extends Throwable> expectedException=(preModScenario.expectedException==null)?(seqLocation.expectedException):(preModScenario.expectedException);
  if(expectedException==null){
    var itrMonitor=seqMonitor.getListItrMonitor(itrIndex);
    itrMonitor.verifyIteratorState();
    Assertions.assertEquals(itrIndex,itrMonitor.expectedCursor);
  }else{
    Assertions.assertThrows(expectedException,()->seqMonitor.getListItrMonitor(itrIndex));
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(100).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testListreplaceAll_UnaryOperator<PARALLEL>()
static Stream<Arguments> getListreplaceAll_UnaryOperatorArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var nestedType:NestedType.values()){
      if(nestedType.forwardIteration){
        for(var preModScenario:PreModScenario.values()){
          if(preModScenario!=PreModScenario.ModSeq&&(preModScenario.expectedException==null||(!nestedType.rootType&&checkedType.checked))){
            for(var monitoredFunctionGen:MonitoredFunctionGen.values()){
              if((checkedType.checked || monitoredFunctionGen.expectedException==null)&&(!nestedType.rootType || monitoredFunctionGen.appliesToRoot) &&(nestedType.rootType || monitoredFunctionGen.appliesToSubList)){
                for(var seqContentsScenario:SequenceContentsScenario.values()){
                  builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,seqContentsScenario,FunctionCallType.Unboxed));
#IFNOT OfRef
                  builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,seqContentsScenario,FunctionCallType.Boxed));
#ENDIF
                }
              }
            }   
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListreplaceAll_UnaryOperator(){
  getListreplaceAll_UnaryOperatorArgs().parallel().map(Arguments::get).forEach(args->{
      testListreplaceAll_UnaryOperatorHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredFunctionGen)args[2],(SequenceContentsScenario)args[3],(FunctionCallType)args[4]);
  });
}
private static void testListreplaceAll_UnaryOperatorHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListreplaceAll_UnaryOperatorArgs")
public void testListreplaceAll_UnaryOperator
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredFunctionGen monitoredFunctionGen,SequenceContentsScenario seqContentsScenario,FunctionCallType functionCallType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  var monitoredUnaryOperator=monitoredFunctionGen.getMonitoredUnaryOperator(seqMonitor);
  int numExpectedIteratedValues;
  if(preModScenario.expectedException==null){
    if(monitoredFunctionGen.expectedException==null || !seqContentsScenario.nonEmpty){
      seqMonitor.replaceAll(monitoredUnaryOperator,functionCallType);
      seqMonitor.verifyStructuralIntegrity();
      seqMonitor.verifyPreAlloc().verifyAscending(1,numToAdd).verifyPostAlloc(preModScenario);
      numExpectedIteratedValues=numToAdd;
    }else{
      Assertions.assertThrows(monitoredFunctionGen.expectedException,()->seqMonitor.replaceAll(monitoredUnaryOperator,functionCallType));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc();
      switch(monitoredFunctionGen){
        case Throw:
          numExpectedIteratedValues=1;
          verifyItr.verifyAscending(numToAdd).verifyPostAlloc();
          break;
        case ModSeq:
          numExpectedIteratedValues=numToAdd;
          //don't bother verifying the array values
          //If the function adds to the array and triggers a resize, it can cause unexpected results
          verifyItr.skip(numToAdd);
          //verifyItr.verifyAscending(1,numToAdd);
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyPostAlloc();
          break;
        case ModParent:
          numExpectedIteratedValues=numToAdd;
          //don't bother verifying the array values
          //If the function adds to the array and triggers a resize, it can cause unexpected results
          //verifyItr.verifyAscending(1,numToAdd).verifyParentPostAlloc();
          verifyItr.skip(numToAdd).verifyParentPostAlloc();
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyRootPostAlloc();
          break;
        case ModRoot:
          numExpectedIteratedValues=numToAdd;
          //don't bother verifying the array values
          //If the function adds to the array and triggers a resize, it can cause unexpected results
          //verifyItr.verifyAscending(1,numToAdd)
          verifyItr.skip(numToAdd).verifyPostAlloc();
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ThrowModSeq:
          numExpectedIteratedValues=1;
          verifyItr.verifyAscending(numToAdd).verifyPostAlloc(PreModScenario.ModSeq);
          break;
        case ThrowModParent:
          numExpectedIteratedValues=1;
          verifyItr.verifyAscending(numToAdd).verifyPostAlloc(PreModScenario.ModParent);
          break;
        case ThrowModRoot:
          numExpectedIteratedValues=1;
          verifyItr.verifyAscending(numToAdd).verifyPostAlloc(PreModScenario.ModRoot);
          break;
        default:
          throw new Error("Unknown monitored function gen "+monitoredFunctionGen);
      }
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.replaceAll(monitoredUnaryOperator,functionCallType));
    seqMonitor.verifyStructuralIntegrity();
    var verifyItr=seqMonitor.verifyPreAlloc();
    switch(monitoredFunctionGen){
      case NoThrow:
        numExpectedIteratedValues=numToAdd;
        verifyItr.verifyAscending(1,numToAdd).verifyPostAlloc(preModScenario);
        break;
      case Throw:
        numExpectedIteratedValues=numToAdd==0?0:1;
        verifyItr.verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
        break;
      case ModSeq:
        numExpectedIteratedValues=numToAdd==0?0:1;
        verifyItr.verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
        break;
      case ModParent:
        switch(preModScenario){
          case ModRoot:
            numExpectedIteratedValues=numToAdd==0?0:1;
            verifyItr.verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
            break;
          case ModParent:
            numExpectedIteratedValues=numToAdd;
            //don't bother verifying the array values
            //If the function adds to the array and triggers a resize, it can cause unexpected results
            //verifyItr.verifyAscending(1,numToAdd)
            verifyItr.skip(numToAdd);
            verifyItr.verifyParentPostAlloc();
            for(int i=0;i<numExpectedIteratedValues+1;++i){
              verifyItr.verifyIllegalAdd();
            }
            verifyItr.verifyRootPostAlloc();
            break;
          default:
            throw new Error("Unknown preModScenario "+preModScenario);
        }
        break;
      case ModRoot:
        numExpectedIteratedValues=numToAdd;
        //don't bother verifying the array values
        //If the function adds to the array and triggers a resize, it can cause unexpected results
        //verifyItr.verifyAscending(1,numToAdd);
        verifyItr.skip(numToAdd);
        verifyItr.verifyPostAlloc(preModScenario);
        for(int i=0;i<numExpectedIteratedValues;++i){
          verifyItr.verifyIllegalAdd();
        }
        break;
      case ThrowModSeq:
        verifyItr.verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
        numExpectedIteratedValues=numToAdd==0?0:1;
        break;
      case ThrowModParent:
        numExpectedIteratedValues=numToAdd==0?0:1;
        switch(preModScenario){
          case ModParent:
            verifyItr.verifyAscending(numToAdd).verifyParentPostAlloc();
            verifyItr.verifyIllegalAdd();
            for(int i=0;i<numExpectedIteratedValues;++i){
               verifyItr.verifyIllegalAdd();
            }
            verifyItr.verifyRootPostAlloc();
            break;
          case ModRoot:
            verifyItr.verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
            break;
          default:
            throw new Error("Unknown preModScenario "+preModScenario);
        }
        break;
      case ThrowModRoot:
        numExpectedIteratedValues=numToAdd==0?0:1;
        verifyItr.verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
        for(int i=0;i<numExpectedIteratedValues;++i){
          verifyItr.verifyIllegalAdd();
        }
        break;
      default:
        throw new Error("Unknown monitored function gen "+monitoredFunctionGen);
    }
  }
  Assertions.assertEquals(numExpectedIteratedValues,monitoredUnaryOperator.encounteredValues.size());
  var arr=(($ClassPrefix$ArrSeq)seqMonitor.root).arr;
  int i=seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc;
  if(numExpectedIteratedValues==numToAdd){
    if(monitoredFunctionGen.expectedException==null){
      for(var encounteredValue:monitoredUnaryOperator.encounteredValues){
#IF OfRef
        var expectedVal=($ArrayType$)(Integer.valueOf((int)encounteredValue)+1);
#ELSEIF OfBoolean
        var expectedVal=($ArrayType$)!((boolean)encounteredValue);
#ELSE
        var expectedVal=($ArrayType$)((($ArrayType$)encounteredValue)+1);
#ENDIF
        Assertions.assertEquals(expectedVal,arr[i++]);
      }
    }
  }else{
    for(var encounteredValue:monitoredUnaryOperator.encounteredValues){
#IF OfRef
      Assertions.assertSame(encounteredValue,arr[i++]);
#ELSE
      Assertions.assertEquals(encounteredValue,(Object)arr[i++]);
#ENDIF
    }
  }
}
#ENDDEF
#MACRODEF testListsubList_int_int<PARALLEL>()
static Stream<Arguments> getListsubList_int_intArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var preModScenario:PreModScenario.values()){
          if(preModScenario!=PreModScenario.ModSeq && (preModScenario.expectedException==null || (checkedType.checked && !nestedType.rootType))){
            for(int seqSize=0;seqSize<=5;++seqSize){
              for(int fromIndex=-2;fromIndex<=seqSize+1;++fromIndex){
                if(checkedType.checked || fromIndex>=0){
                  for(int toIndex=-1;toIndex<=seqSize+2;++toIndex){
                    if(checkedType.checked || (toIndex>=fromIndex && toIndex<=seqSize)){
                      builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqSize,fromIndex,toIndex));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListsubList_int_int(){
  getListsubList_int_intArgs().parallel().map(Arguments::get).forEach(args->{
      testListsubList_int_intHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(int)args[2],(int)args[3],(int)args[4]);
  });
}
private static void testListsubList_int_intHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListsubList_int_intArgs")
public void testListsubList_int_int
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,int seqSize,int fromIndex,int toIndex){
  for(int i=0;i<seqSize;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    if(fromIndex>=0 && fromIndex<=toIndex && toIndex<=seqSize){
      var subList=((OmniList.Of$ClassPrefix$)seqMonitor.seq).subList(fromIndex,toIndex);
      if(seqMonitor.checkedType.checked){
        Assertions.assertEquals(seqMonitor.expectedRootModCount,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.modCount(subList));
        if(seqMonitor.nestedType.rootType){
          Assertions.assertNull(FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.parent(subList));
        }else{
          Assertions.assertSame(seqMonitor.seq,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.parent(subList));
        }
        Assertions.assertSame(seqMonitor.root,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.root(subList));
        Assertions.assertEquals(toIndex-fromIndex,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.size(subList));
        Assertions.assertEquals(seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+fromIndex,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.rootOffset(subList));
      }else{
        if(seqMonitor.nestedType.rootType){
          Assertions.assertNull(FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.parent(subList));
        }else{
          Assertions.assertSame(seqMonitor.seq,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.parent(subList));
        }
        Assertions.assertSame(seqMonitor.root,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.root(subList));
        Assertions.assertEquals(toIndex-fromIndex,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.size(subList));
        Assertions.assertEquals(seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+fromIndex,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.rootOffset(subList));
      }
    }else{
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->((OmniList.Of$ClassPrefix$)seqMonitor.seq).subList(fromIndex,toIndex));
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->((OmniList.Of$ClassPrefix$)seqMonitor.seq).subList(fromIndex,toIndex));
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(seqSize).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testtoArray_IntFunction<PARALLEL>()
static Stream<Arguments> gettoArray_IntFunctionArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
    for(var monitoredFunctionGen:MonitoredFunctionGen.values()){
      if((checkedType.checked || monitoredFunctionGen.expectedException==null)&&(!nestedType.rootType || monitoredFunctionGen.appliesToRoot) &&(nestedType.rootType || monitoredFunctionGen.appliesToSubList)){
        for(var seqContentsScenario:SequenceContentsScenario.values()){
          streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,seqContentsScenario));
        }
      }
    }   
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testtoArray_IntFunction(){
  gettoArray_IntFunctionArgs().parallel().map(Arguments::get).forEach(args->{
      testtoArray_IntFunctionHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredFunctionGen)args[2],(SequenceContentsScenario)args[3]);
  });
}
private static void testtoArray_IntFunctionHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoArray_IntFunctionArgs")
public void testtoArray_IntFunction
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredFunctionGen monitoredFunctionGen,SequenceContentsScenario seqContentsScenario){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  var arrConstructor=monitoredFunctionGen.getMonitoredArrayConstructor(seqMonitor);
  if(preModScenario.expectedException==null){
    if(monitoredFunctionGen.expectedException==null){
      var resultArr=seqMonitor.seq.toArray(arrConstructor);
      Assertions.assertEquals(numToAdd,resultArr.length);
      var itr=seqMonitor.seq.iterator();
      for(int i=0;i<numToAdd;++i){
#IF OfRef
        Assertions.assertSame(resultArr[i],itr.next$TypeNameModifier$());
#ELSE
        Assertions.assertEquals(resultArr[i],(Object)itr.next$TypeNameModifier$());
#ENDIF
      }
    }else{
       Assertions.assertThrows(monitoredFunctionGen.expectedException,()->seqMonitor.seq.toArray(arrConstructor));
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.seq.toArray(arrConstructor));
  }
  var verifyItr=seqMonitor.verifyPreAlloc().verifyAscending(numToAdd);
  switch(monitoredFunctionGen){
    case NoThrow:
    case Throw:
      verifyItr.verifyPostAlloc(preModScenario);
      break;
    case ModSeq:
    case ThrowModSeq:
      if(preModScenario==PreModScenario.NoMod){
         verifyItr.verifyIllegalAdd().verifyPostAlloc();
      }else{
        verifyItr.verifyPostAlloc(preModScenario);
      }
      break;
    case ModParent:
    case ThrowModParent:
      if(preModScenario==PreModScenario.ModSeq){
        verifyItr.verifyIllegalAdd();
      }
      verifyItr.verifyParentPostAlloc();
      if(preModScenario!=PreModScenario.ModRoot){
        verifyItr.verifyIllegalAdd();
        if(preModScenario!=PreModScenario.NoMod){
          verifyItr.verifyIllegalAdd();
        }
      }
      verifyItr.verifyRootPostAlloc();
      if(preModScenario==PreModScenario.ModRoot){
        verifyItr.verifyIllegalAdd();
      }
      break;
    case ModRoot:
    case ThrowModRoot:
      verifyItr.verifyPostAlloc(preModScenario).verifyIllegalAdd();
      break;
    default:
      throw new Error("Unknown monitoredFunctionGen "+monitoredFunctionGen);
  }
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF
#MACRODEF testtoArray_ObjectArray<PARALLEL>()
static Stream<Arguments> gettoArray_ObjectArrayArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
    for(int seqSize=0;seqSize<=15;seqSize+=5){
      for(int arrSize=0;arrSize<=20;arrSize+=5){
        streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqSize,arrSize));
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testtoArray_ObjectArray(){
  gettoArray_ObjectArrayArgs().parallel().map(Arguments::get).forEach(args->{
      testtoArray_ObjectArrayHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(int)args[2],(int)args[3]);
  });
}
private static void testtoArray_ObjectArrayHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoArray_ObjectArrayArgs")
public void testtoArray_ObjectArray
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,int seqSize,int arrSize){
  for(int i=0;i<seqSize;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
#IF OfRef
  Integer[] paramArr=new Integer[arrSize];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[arrSize];
#ENDIF
  for(int i=seqSize,bound=seqSize+arrSize;i<bound;++i){
    #IF OfRef
    paramArr[i-seqSize]=TypeConversionUtil.convertToInteger(i);
    #ELSE
    paramArr[i-seqSize]=TypeConversionUtil.convertTo$BoxedType$(i);
    #ENDIF
  }
  if(preModScenario.expectedException==null){
    var resultArr=seqMonitor.seq.toArray(paramArr);
    if(arrSize<seqSize){
      Assertions.assertNotSame(paramArr,resultArr);
      Assertions.assertEquals(seqSize,resultArr.length);
    }else if(arrSize>seqSize){
      Assertions.assertSame(paramArr,resultArr);
      Assertions.assertNull(resultArr[seqSize]);
      for(int i=seqSize+1;i<arrSize;++i){
      #IF OfRef
        Assertions.assertEquals(TypeConversionUtil.convertToInteger(i+seqSize),resultArr[i]);
      #ELSE
        Assertions.assertEquals(TypeConversionUtil.convertTo$BoxedType$(i+seqSize),resultArr[i]);
      #ENDIF
      }
    }else{
      Assertions.assertSame(paramArr,resultArr);
    }
    var itr=seqMonitor.seq.iterator();
    for(int i=0;i<seqSize;++i){
#IF OfRef
      Assertions.assertSame(itr.next$TypeNameModifier$(),resultArr[i]);
#ELSE
      Assertions.assertEquals((Object)itr.next$TypeNameModifier$(),resultArr[i]);
#ENDIF
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.seq.toArray(paramArr));
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyAscending(seqSize).verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testListset_int_val<PARALLEL>()
static Stream<Arguments> getListset_int_valArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var preModScenario:PreModScenario.values()){
          if(preModScenario.expectedException==null || (checkedType.checked && preModScenario!=PreModScenario.ModSeq && !nestedType.rootType)){
            for(var seqContentsScenario:SequenceContentsScenario.values()){
              for(var seqLocation:SequenceLocation.values()){
                if((seqLocation==SequenceLocation.BEGINNING && seqContentsScenario.nonEmpty) || (checkedType.checked && seqLocation.expectedException!=null)){
                  builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqContentsScenario,seqLocation,FunctionCallType.Unboxed));
#IFNOT OfRef
                  builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqContentsScenario,seqLocation,FunctionCallType.Boxed));
#ENDIF               
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListset_int_val(){
  getListset_int_valArgs().parallel().map(Arguments::get).forEach(args->{
      testListset_int_valHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2],(SequenceLocation)args[3],(FunctionCallType)args[4]);
  });
}
private static void testListset_int_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListset_int_valArgs")
public void testListset_int_val
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario,SequenceLocation seqLocation,FunctionCallType functionCallType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    switch(seqLocation){
      case IOBLO:
        Assertions.assertThrows(seqLocation.expectedException,()->seqMonitor.verifySet(-1,-1,0,functionCallType));
        seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc();
        break;
      case IOBHI:
        Assertions.assertThrows(seqLocation.expectedException,()->seqMonitor.verifySet(numToAdd,numToAdd+1,numToAdd,functionCallType));
        seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc();
        break;
      case BEGINNING:
        for(int i=0;i<numToAdd;++i){
          seqMonitor.verifySet(i,i+numToAdd,i,functionCallType);
          seqMonitor.verifyStructuralIntegrity();
        }
        seqMonitor.verifyPreAlloc().verifyAscending(numToAdd,numToAdd).verifyPostAlloc();
        break;
      default:
        throw new Error("Unknown seqLocation "+seqLocation);
    }
  }else{
    final int setIndex;
    switch(seqLocation){
      case IOBLO:
        setIndex=-1;
        break;
      case IOBHI:
        setIndex=numToAdd;
        break;
      case BEGINNING:
        setIndex=0;
        break;
      default:
        throw new Error("Unknown seqLocation "+seqLocation);
    }
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.verifySet(setIndex,numToAdd+1,setIndex,functionCallType));
    seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
  }
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF
#MACRODEF testListget_int<PARALLEL>()
static Stream<Arguments> getListget_intArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var nestedType:NestedType.values()){
    if(nestedType.forwardIteration){
      for(var checkedType:CheckedType.values()){
        for(var preModScenario:PreModScenario.values()){
          if(preModScenario.expectedException==null || (checkedType.checked && preModScenario!=PreModScenario.ModSeq && !nestedType.rootType)){
            for(var seqContentsScenario:SequenceContentsScenario.values()){
              for(var seqLocation:SequenceLocation.values()){
                if((seqLocation==SequenceLocation.BEGINNING && seqContentsScenario.nonEmpty) || (checkedType.checked && seqLocation.expectedException!=null)){
                  for(var outputArgType:$ClassPrefix$OutputTestArgType.values()){
                    builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,seqContentsScenario,seqLocation,outputArgType));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testListget_int(){
  getListget_intArgs().parallel().map(Arguments::get).forEach(args->{
      testListget_intHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2],(SequenceLocation)args[3],($ClassPrefix$OutputTestArgType)args[4]);
  });
}
private static void testListget_intHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getListget_intArgs")
public void testListget_int
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario,SequenceLocation seqLocation,$ClassPrefix$OutputTestArgType outputArgType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
    switch(seqLocation){
      case IOBLO:
        Assertions.assertThrows(seqLocation.expectedException,()->outputArgType.verifyListGet(seqMonitor.seq,-1,0));
        break;
      case IOBHI:
        Assertions.assertThrows(seqLocation.expectedException,()->outputArgType.verifyListGet(seqMonitor.seq,numToAdd,0));
        break;
      case BEGINNING:
        for(int i=0;i<numToAdd;++i){
          outputArgType.verifyListGet(seqMonitor.seq,i,i);
          seqMonitor.verifyStructuralIntegrity();
        }
        break;
      default:
        throw new Error("Unknown seqLocation "+seqLocation);
    }
  }else{
    final int getIndex;
    switch(seqLocation){
      case IOBLO:
        getIndex=-1;
        break;
      case IOBHI:
        getIndex=numToAdd;
        break;
      case BEGINNING:
        getIndex=0;
        break;
      default:
        throw new Error("Unknown seqLocation "+seqLocation);
    }
    Assertions.assertThrows(preModScenario.expectedException,()->outputArgType.verifyListGet(seqMonitor.seq,getIndex,0));
  }
  seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF
#MACRODEF testhashCode_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testhashCode_void(){
  gettoStringAndhashCode_voidArgs().parallel().map(Arguments::get).forEach(args->{
    testhashCode_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2]
#IF OfRef
    ,(MonitoredObjectGen)args[3]
#ENDIF
    );
  });
}
private static void testhashCode_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoStringAndhashCode_voidArgs")
public void testhashCode_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario
#IF OfRef
,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
#IF OfRef
  MonitoredObject monitoredObject=null;
  if(numToAdd!=0 && monitoredObjectGen.expectedException!=null){
    monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
    for(int i=0;i<numToAdd;++i){
      seqMonitor.seq.add(monitoredObject);
      ++seqMonitor.expectedSeqSize;
      ++seqMonitor.expectedParentSize;
      ++seqMonitor.expectedRootSize;
      ++seqMonitor.expectedSeqModCount;
      ++seqMonitor.expectedParentModCount;
      ++seqMonitor.expectedRootModCount;
    }
  }else
#ENDIF
  {
    for(int i=0;i<numToAdd;++i){
      seqMonitor.add(i);
    }
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
#IF OfRef
    if(monitoredObject!=null){
      Assertions.assertThrows(monitoredObjectGen.expectedException,()->seqMonitor.seq.hashCode());
      Assertions.assertEquals(verifyThrowCondition(seqMonitor,numToAdd,monitoredObject,monitoredObjectGen),monitoredObject.numHashCodeCalls);
    }else
#ENDIF
    {
      int resultHash=seqMonitor.seq.hashCode();
      seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc();
      var itr=seqMonitor.seq.iterator();
      int expectedHash=1;
      for(int i=0;i<numToAdd;++i){
        expectedHash=(expectedHash*31)+itr.next().hashCode();
      }
      Assertions.assertEquals(expectedHash,resultHash);
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.seq.hashCode());
    verifyThrowCondition(seqMonitor,numToAdd,preModScenario
#IF OfRef
      ,monitoredObject,monitoredObjectGen
#ENDIF
    );
  }
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF
#MACRODEF testremoveIf_Predicate<PARALLEL>()
static Stream<Arguments> getremoveIf_PredicateArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
    for(var monitoredRemoveIfPredicateGen:MonitoredRemoveIfPredicateGen.values()){
      if(monitoredRemoveIfPredicateGen.expectedException==null || (checkedType.checked && (!nestedType.rootType || monitoredRemoveIfPredicateGen.appliesToRoot))){
        for(var functionCallType:FunctionCallType.values()){
#IF OfRef
          if(functionCallType==FunctionCallType.Boxed){
            continue;
          }
#ENDIF
#IF OfBoolean
          for(int seqSize=0;seqSize<=10;++seqSize){
            long randSeedBound;
            if(seqSize==0 || !monitoredRemoveIfPredicateGen.isRandomized){
              randSeedBound=0;
            }else{
              randSeedBound=100;
            }
            for(long randSeed=0;randSeed<=randSeedBound;++randSeed){
              for(int period=1,inc=Math.max(1,seqSize/10);;period+=inc){
                for(int initVal=0;initVal<=1;++initVal){
                  streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredRemoveIfPredicateGen,0.5,randSeed,functionCallType,seqSize,initVal,period));
                }
                if(period>=seqSize){
                  break;
                }
              }
            }
          }
#ELSE
          for(int seqSize=0;seqSize<=100;seqSize+=10){
            double[] thresholdArr;
            long randSeedBound;
            if(seqSize==0 || !monitoredRemoveIfPredicateGen.isRandomized){
              thresholdArr=new double[]{0.5};
              randSeedBound=0;
            }else{
              thresholdArr=new double[]{0.01,0.05,0.10,0.25,0.50,0.75,0.90,0.95,0.99};
              randSeedBound=100;
            }
            for(long randSeed=0;randSeed<=randSeedBound;++randSeed){
              for(double threshold:thresholdArr){
                streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredRemoveIfPredicateGen,threshold,randSeed,functionCallType,seqSize));
              }
            }
          }
#ENDIF
        }
      }
    }
 });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testremoveIf_Predicate(){
  getremoveIf_PredicateArgs().parallel().map(Arguments::get).forEach(args->{
    testremoveIf_PredicateHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredRemoveIfPredicateGen)args[2],(double)args[3],(long)args[4],(FunctionCallType)args[5],(int)args[6]
#IF OfBoolean
    ,(int)args[7],(int)args[8]
#ENDIF
    );
  });
}
private static void testremoveIf_PredicateHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getremoveIf_PredicateArgs")
public void testremoveIf_Predicate
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredRemoveIfPredicateGen monitoredRemoveIfPredicateGen,double threshold,long randSeed,final FunctionCallType functionCallType,int seqSize
#IF OfBoolean
,int initVal,int period
#ENDIF
){
#IF OfBoolean
int trueCount=0;
for(int i=0;i<seqSize;){
  seqMonitor.add(initVal);
  if((initVal&1)!=0){
    ++trueCount;
  }
  if((++i)%period==0){
    ++initVal;
  }
}
#ELSE
  for(int i=0;i<seqSize;++i){
    seqMonitor.add(i);
  }
#ENDIF
  final var clone=(OmniCollection.Of$ClassPrefix$)seqMonitor.seq.clone();
#IF OfBoolean
  final int numExpectedCalls=seqMonitor.seq.contains(true)?seqMonitor.seq.contains(false)?2:1:seqMonitor.seq.contains(false)?1:0;
#ELSE
  final int numExpectedCalls=seqSize;
#ENDIF
  final int numExpectedRemoved;
  switch(monitoredRemoveIfPredicateGen){
#IF OfBoolean
    case RemoveTrue:
      numExpectedRemoved=trueCount;
      break;
    case RemoveFalse:
      numExpectedRemoved=seqSize-trueCount;
      break;
#ENDIF
    case RemoveAll:
      numExpectedRemoved=seqSize;
      break;
    case Random:
      numExpectedRemoved=-1;
      break;
    case RemoveNone:
    case Throw:
    case ModSeq:
    case ModParent:
    case ModRoot:
    case ThrowModSeq:
    case ThrowModParent:
    case ThrowModRoot:
      numExpectedRemoved=0;
      break;
    default:
      throw new Error("Unknown monitoredRemoveIfPredicateGen "+monitoredRemoveIfPredicateGen);
  }
  seqMonitor.illegalAdd(preModScenario);
  final var monitoredRemoveIfPredicate=monitoredRemoveIfPredicateGen.getMonitoredRemoveIfPredicate(seqMonitor,randSeed,numExpectedCalls,threshold);
  if(preModScenario.expectedException==null){
    if(monitoredRemoveIfPredicateGen.expectedException==null || seqSize==0){
      seqMonitor.verifyRemoveIf(monitoredRemoveIfPredicate,functionCallType,numExpectedRemoved,clone);
      seqMonitor.verifyPreAlloc().skip(seqMonitor.expectedSeqSize).verifyPostAlloc();
      return;
    }else{
      Assertions.assertThrows(monitoredRemoveIfPredicateGen.expectedException,()->seqMonitor.verifyRemoveIf(monitoredRemoveIfPredicate,functionCallType,numExpectedRemoved,clone));
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.verifyRemoveIf(monitoredRemoveIfPredicate,functionCallType,numExpectedRemoved,clone));
  }
  var verifyItr=seqMonitor.verifyPreAlloc();
  if(seqMonitor.nestedType.forwardIteration){
    var cloneItr=clone.iterator();
    while(cloneItr.hasNext()){
      verifyItr.verifyLiteralIndexAndIterate(cloneItr.next$TypeNameModifier$());
    }
  }else{
    var arr=clone.to$TypeNameModifier$Array();
    for(int i=arr.length;--i>=0;){
       verifyItr.verifyLiteralIndexAndIterate(arr[i]);
    }
  }
  switch(monitoredRemoveIfPredicateGen){
    case ModRoot:
    case ThrowModRoot:
      //The nature of concurrent modification makes verifying the contents of the array tricky due to array reallocations
      //skip it in this scenario
    case Random:
    case RemoveAll:
    case RemoveNone:
#IF OfBoolean
    case RemoveTrue:
    case RemoveFalse:
#ENDIF
    case Throw:
      verifyItr.verifyPostAlloc(preModScenario);
      break;
    case ModParent:
    case ThrowModParent:
      verifyItr.verifyParentPostAlloc();
      if(preModScenario==PreModScenario.ModRoot){
        verifyItr.verifyRootPostAlloc();
        verifyItr.verifyIllegalAdd();
      }
    case ModSeq:
    case ThrowModSeq:
      //The nature of concurrent modification makes verifying the contents of the array tricky due to array reallocations
      //skip it in this scenario
      break;
    default:
      throw new Error("Unknown monitoredRemoveIfPredicateGen "+monitoredRemoveIfPredicateGen);
  }
}
#ENDDEF
#MACRODEF testMASSIVEtoString_void<PARALLEL>()
#IF OfBoolean
  private static final int MAX_TOSTRING_LENGTH=5;
#ELSEIF OfByte
  private static final int MAX_TOSTRING_LENGTH=4;
#ELSEIF OfShort
  private static final int MAX_TOSTRING_LENGTH=6;
#ELSEIF OfInt
  private static final int MAX_TOSTRING_LENGTH=11;
#ELSEIF OfLong
  private static final int MAX_TOSTRING_LENGTH=20;
#ELSEIF OfFloat
  private static final int MAX_TOSTRING_LENGTH=15;
#ENDIF
#IF OfBoolean,OfByte,OfShort,OfInt,OfLong,OfFloat
static Stream<Arguments> getMASSIVEtoString_voidArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  final int seqLength=(OmniArray.MAX_ARR_SIZE/(MAX_TOSTRING_LENGTH+2))+1;
  final int arrLength=seqLength+20;
  $ArrayType$[] arr=new $ArrayType$[arrLength];
  for(int i=0;i<arrLength;++i){
    arr[i]=TypeConversionUtil.convertTo$ArrayType$(1);
  }
  for(var nestedType:NestedType.values()){
    for(var checkedType:CheckedType.values()){
      builder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType,seqLength,arr)));
    }
  }
  return builder.build();
}
@Tag("MASSIVEtoString")
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getMASSIVEtoString_voidArgs")
public void testMASSIVEtoString_void
($ClassPrefix$ArrSeqMonitor seqMonitor){
  seqMonitor.verifyMASSIVEString();
}
#ENDIF
#ENDDEF
#MACRODEF testtoString_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testtoString_void(){
  gettoStringAndhashCode_voidArgs().parallel().map(Arguments::get).forEach(args->{
    testtoString_voidHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(SequenceContentsScenario)args[2]
#IF OfRef
    ,(MonitoredObjectGen)args[3]
#ENDIF
    );
  });
}
private static void testtoString_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoStringAndhashCode_voidArgs")
public void testtoString_void
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario
#IF OfRef
,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
#IF OfRef
  MonitoredObject monitoredObject=null;
  if(numToAdd!=0 && monitoredObjectGen.expectedException!=null){
    monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
    for(int i=0;i<numToAdd;++i){
      seqMonitor.seq.add(monitoredObject);
      ++seqMonitor.expectedSeqSize;
      ++seqMonitor.expectedParentSize;
      ++seqMonitor.expectedRootSize;
      ++seqMonitor.expectedSeqModCount;
      ++seqMonitor.expectedParentModCount;
      ++seqMonitor.expectedRootModCount;
    }
  }else
#ENDIF
  {
    for(int i=0;i<numToAdd;++i){
      seqMonitor.add(i);
    }
  }
  seqMonitor.illegalAdd(preModScenario);
  if(preModScenario.expectedException==null){
#IF OfRef
    if(monitoredObject!=null){
      Assertions.assertThrows(monitoredObjectGen.expectedException,()->seqMonitor.seq.toString());
      Assertions.assertEquals(verifyThrowCondition(seqMonitor,numToAdd,monitoredObject,monitoredObjectGen),monitoredObject.numToStringCalls);
    }
    else
#ENDIF
    {
      var resultStr=seqMonitor.seq.toString();
      seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc();
      var itr=seqMonitor.seq.iterator();
      var arrList=new ArrayList<Object>();
      for(int i=0;i<numToAdd;++i){
        arrList.add(itr.next());
      }
      Assertions.assertEquals(arrList.toString(),resultStr);
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->seqMonitor.seq.toString());
    verifyThrowCondition(seqMonitor,numToAdd,preModScenario
#IF OfRef
      ,monitoredObject,monitoredObjectGen
#ENDIF
    );
  }
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF
#MACRODEF testreadAndwriteObject<PARALLEL>()
static Stream<Arguments> getreadAndwriteObjectArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType,preModScenario)->{
    for(var monitoredFunctionGen:MonitoredFunctionGen.values()){
      if((checkedType.checked || monitoredFunctionGen.expectedException==null)&&(!nestedType.rootType || monitoredFunctionGen.appliesToRoot) &&(nestedType.rootType || monitoredFunctionGen.appliesToSubList)){
        for(var seqContentsScenario:SequenceContentsScenario.values()){
          streamBuilder.accept(Arguments.of(new $ClassPrefix$ArrSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,seqContentsScenario));
        }
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testreadAndwriteObject(){
  getreadAndwriteObjectArgs().parallel().map(Arguments::get).forEach(args->{
      testreadAndwriteObjectHelper(($ClassPrefix$ArrSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredFunctionGen)args[2],(SequenceContentsScenario)args[3]);
  });
}
private static void testreadAndwriteObjectHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getreadAndwriteObjectArgs")
public void testreadAndwriteObject
#ENDIF
($ClassPrefix$ArrSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredFunctionGen monitoredFunctionGen,SequenceContentsScenario seqContentsScenario)
{
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.illegalAdd(preModScenario);
  final File file;
  try{
    file=Files.createTempFile(null,null).toFile();
  }catch(Exception e){
    Assertions.fail(e);
    return;
  }
  if(preModScenario.expectedException==null){
    if(monitoredFunctionGen.expectedException==null){
      try(var oos=new ObjectOutputStream(new FileOutputStream(file));){
        oos.writeObject(seqMonitor.seq);
      }catch(Exception e){
        Assertions.fail(e);
      }
      seqMonitor.verifyPreAlloc().verifyAscending(numToAdd).verifyPostAlloc(preModScenario);
      OmniCollection.Of$ClassPrefix$ readCol=null;
      try(var ois=new ObjectInputStream(new FileInputStream(file));){
        readCol=(OmniCollection.Of$ClassPrefix$)ois.readObject();
      }catch(Exception e){
        Assertions.fail(e);
        return;
      }
      var itr=readCol.iterator();
      if(seqMonitor.nestedType.forwardIteration){
        for(int i=0;i<numToAdd;++i){
          Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(i),itr.next$TypeNameModifier$());
        }
      }else{
        for(int i=0;i<numToAdd;++i){
          Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(numToAdd-i-1),itr.next$TypeNameModifier$());
        }
      }
      Assertions.assertFalse(itr.hasNext());
    }else{
      Assertions.assertThrows(monitoredFunctionGen.expectedException,()->{
        try(var moos=monitoredFunctionGen.getMonitoredObjectOutputStream(file,seqMonitor);){
          seqMonitor.writeObject(moos);
        }
      });
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->{
      try(var moos=monitoredFunctionGen.getMonitoredObjectOutputStream(file,seqMonitor);){
        seqMonitor.writeObject(moos);
      }
    });
  }
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF