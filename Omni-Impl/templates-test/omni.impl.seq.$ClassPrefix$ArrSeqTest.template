#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import omni.util.TypeConversionUtil;
import omni.util.EqualityUtil;
import omni.util.OmniArray;
import omni.impl.seq.$ClassPrefix$ArrSeq.UncheckedList;
import omni.impl.seq.$ClassPrefix$ArrSeq.CheckedList;
import omni.impl.seq.$ClassPrefix$ArrSeq.UncheckedStack;
import omni.impl.seq.$ClassPrefix$ArrSeq.CheckedStack;
import java.util.ConcurrentModificationException;
#IF OfRef
@SuppressWarnings({"rawtypes","unchecked"}) 
#ENDIF
public class $ClassPrefix$ArrSeqTest
{
  #MACRO Impl<UncheckedStack>()
  #MACRO Impl<UncheckedList>()
  #MACRO Impl<CheckedStack>()
  #MACRO Impl<CheckedList>()
  #MACRO Impl<UncheckedSubList>()
  #MACRO Impl<CheckedSubList>()
}

#MACRODEF TestAdd<CLASSPREFIX,ADDTYPE,GETCAST,CONVERTTYPE>()
#IFSWITCH STRUCTNAME==CheckedList,UncheckedList,CheckedSubList,UncheckedSubList
@Test
public void testListAddCLASSPREFIXSTRUCTNAME()
{
  #IFSWITCH STRUCTNAME==CheckedSubList
  var root=new CheckedList();
  var subList=root.subList(0,0);
  var seq=subList.subList(0,0);
  #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  var root=new UncheckedList();
  var subList=root.subList(0,0);
  var seq=subList.subList(0,0);
  #ELSE
  var seq=new STRUCTNAME();
  #ENDIF
  
  for(int i=100;--i>=0;)
  {
    //test add at beginning
    seq.add(0,(ADDTYPE)TypeConversionUtil.convertToCONVERTTYPE(i));
  }
  for(int i=0;i<100;++i)
  {
    Assertions.assertEquals(GETCAST(TypeConversionUtil.convertToCONVERTTYPE(i)),seq.getCLASSPREFIX(i));
  }
  int currSize=seq.size();
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  Assertions.assertEquals(subList.size(),currSize);
  Assertions.assertEquals(root.size(),currSize);
  #ENDIF
  Assertions.assertEquals(100,currSize);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedSubList
    #IFSWITCH STRUCTNAME==CheckedList
  int modCount=seq.modCount;
    #ELSE
  int modCount=root.modCount;
    #ENDIF
  Assertions.assertEquals(modCount,100);
  Assertions.assertThrows(IndexOutOfBoundsException.class,()->seq.add(-1,TypeConversionUtil.convertToCONVERTTYPE(0)));
  Assertions.assertThrows(IndexOutOfBoundsException.class,()->seq.add(seq.size()+1,TypeConversionUtil.convertToCONVERTTYPE(0)));
    #IFSWITCH STRUCTNAME==CheckedList
  Assertions.assertEquals(modCount,seq.modCount);
    #ELSE
  Assertions.assertEquals(modCount,root.modCount);
    #ENDIF
  Assertions.assertEquals(currSize,seq.size());
  #ENDIF
  
  for(int i=200;i<300;++i)
  {
    //add at end
    seq.add(seq.size(),(ADDTYPE)TypeConversionUtil.convertToCONVERTTYPE(i));
  }
  for(int i=100;i<200;++i)
  {
    Assertions.assertEquals(GETCAST(TypeConversionUtil.convertToCONVERTTYPE(i+100)),seq.getCLASSPREFIX(i));
  }
  currSize=seq.size();
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  Assertions.assertEquals(subList.size(),currSize);
  Assertions.assertEquals(root.size(),currSize);
  #ENDIF
  Assertions.assertEquals(200,currSize);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedSubList
    #IFSWITCH STRUCTNAME==CheckedList
  modCount=seq.modCount;
    #ELSE
  modCount=root.modCount;
    #ENDIF
  Assertions.assertEquals(modCount,200);
  #ENDIF
  for(int i=200;--i>=100;)
  {
    //add in middle
    seq.add(100,(ADDTYPE)TypeConversionUtil.convertToCONVERTTYPE(i));
  }
  for(int i=100;i<200;++i)
  {
    Assertions.assertEquals(GETCAST(TypeConversionUtil.convertToCONVERTTYPE(i)),seq.getCLASSPREFIX(i));
  }
  currSize=seq.size();
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  Assertions.assertEquals(subList.size(),currSize);
  Assertions.assertEquals(root.size(),currSize);
  #ENDIF
  Assertions.assertEquals(300,currSize);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedSubList
    #IFSWITCH STRUCTNAME==CheckedList
  modCount=seq.modCount;
    #ELSE
  modCount=root.modCount;
    #ENDIF
  Assertions.assertEquals(modCount,300);
  #ENDIF
  
}
#ENDIF
#ENDDEF


#MACRODEF Impl<STRUCTNAME>()

#IF OfRef
  #MACRO TestAdd<$TypeNameModifier$,Integer,,Integer>()
#ELSE
  #MACRO TestAdd<$TypeNameModifier$,$BoxedType$,,$exposedType$>()
#ENDIF

@Test
public void testCloneSTRUCTNAME()
{
#IFSWITCH STRUCTNAME==CheckedSubList
  var seq=new CheckedList();
  {
    var subList=seq.subList(0,0);
    var clonedObject=subList.clone();
    Assertions.assertTrue(clonedObject instanceof CheckedList);
    var clonedSubSeq=(CheckedList)clonedObject;
    Assertions.assertTrue(clonedSubSeq.arr==seq.arr);
    Assertions.assertEquals(clonedSubSeq.size(),subList.size());
    Assertions.assertTrue(subList!=clonedSubSeq);
  }
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    seq.push(val);
  }
  {
    var subList=seq.subList(25,75);
    Assertions.assertEquals(subList.size(),75-25);
    var clonedObject=subList.clone();
    Assertions.assertTrue(clonedObject instanceof CheckedList);
    var clonedSeq=(CheckedList)clonedObject;
    Assertions.assertTrue(clonedSeq.arr!=seq.arr);
    Assertions.assertEquals(subList.size(),clonedSeq.size());
    EqualityUtil.uncheckedparallelassertarraysAreEqual(seq.arr,25,clonedSeq.arr,0,subList.size());
    seq.add($defaultVal$);
    Assertions.assertThrows(ConcurrentModificationException.class,()->subList.clone());
    
  }
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  var seq=new UncheckedList();
  {
    var subList=seq.subList(0,0);
    var clonedObject=subList.clone();
    Assertions.assertTrue(clonedObject instanceof UncheckedList);
    var clonedSubSeq=(UncheckedList)clonedObject;
    Assertions.assertTrue(clonedSubSeq.arr==seq.arr);
    Assertions.assertEquals(clonedSubSeq.size(),subList.size());
    Assertions.assertTrue(subList!=clonedSubSeq);
  }
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    seq.push(val);
  }
  {
    var subList=seq.subList(25,75);
    Assertions.assertEquals(subList.size(),75-25);
    var clonedObject=subList.clone();
    Assertions.assertTrue(clonedObject instanceof UncheckedList);
    var clonedSeq=(UncheckedList)clonedObject;
    Assertions.assertTrue(clonedSeq.arr!=seq.arr);
    Assertions.assertEquals(subList.size(),clonedSeq.size());
    EqualityUtil.uncheckedparallelassertarraysAreEqual(seq.arr,25,clonedSeq.arr,0,subList.size());
  }
#ELSE
  var seq=new STRUCTNAME();
  Object clonedObject=seq.clone();
  Assertions.assertTrue(clonedObject instanceof STRUCTNAME);
  var clonedSeq=(STRUCTNAME)clonedObject;
  Assertions.assertTrue(clonedSeq.arr==seq.arr);
  Assertions.assertEquals(clonedSeq.size(),seq.size());
  Assertions.assertTrue(seq!=clonedSeq);
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    seq.push(val);
  }
  Assertions.assertEquals(seq.size(),100);
  clonedObject=seq.clone();
  Assertions.assertTrue(clonedObject instanceof STRUCTNAME);
  clonedSeq=(STRUCTNAME)clonedObject;
  Assertions.assertTrue(clonedSeq.arr!=seq.arr);
  Assertions.assertEquals(seq.size(),clonedSeq.size());
  EqualityUtil.uncheckedparallelassertarraysAreEqual(seq.arr,0,clonedSeq.arr,0,seq.size());
#ENDIF
}


@Test
public void testConstructorsSTRUCTNAME()
{

#IFSWITCH STRUCTNAME==CheckedSubList
  var root=new CheckedList();
  {
    var subList=root.subList(0,0);
    Assertions.assertEquals(subList.size(),0);
    Assertions.assertTrue(subList.isEmpty());
    var subsubList=subList.subList(0,0);
    Assertions.assertEquals(subsubList.size(),0);
    Assertions.assertTrue(subsubList.isEmpty());
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(-1,0));
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(0,1));
  }
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    root.add(val);
  }
  {
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->root.subList(-1,75));
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->root.subList(25,101));
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->root.subList(75,25));
    var subList=root.subList(25,75);
    Assertions.assertEquals(subList.size(),75-25);
    Assertions.assertFalse(subList.isEmpty());
    for(int i=25;i<75;++i)
    {
  #IF OfRef
      var val=TypeConversionUtil.convertToInteger(i);
  #ELSE
      var val=TypeConversionUtil.convertTo$exposedType$(i);
  #ENDIF
      Assertions.assertEquals(val,subList.get$TypeNameModifier$(i-25));
    }
    {
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(-1,30));
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(0,51));
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(30,10));
      var subsubList=subList.subList(10,30);
      Assertions.assertEquals(subsubList.size(),30-10);
      Assertions.assertFalse(subsubList.isEmpty());
      for(int i=10;i<30;++i)
      {
  #IF OfRef
        var val=TypeConversionUtil.convertToInteger(i+25);
  #ELSE
        var val=TypeConversionUtil.convertTo$exposedType$(i+25);
  #ENDIF
        Assertions.assertEquals(val,subsubList.get$TypeNameModifier$(i-10));
      }
    }
    root.add($defaultVal$);
    Assertions.assertThrows(ConcurrentModificationException.class,()->subList.subList(10,30));

    
  }


#ELSEIFSWITCH STRUCTNAME==UncheckedSubList

  var root=new UncheckedList();
  {
    var subList=root.subList(0,0);
    Assertions.assertEquals(subList.size(),0);
    Assertions.assertTrue(subList.isEmpty());
    var subsubList=subList.subList(0,0);
    Assertions.assertEquals(subsubList.size(),0);
    Assertions.assertTrue(subsubList.isEmpty());
  }
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    root.add(val);
  }
  {
    var subList=root.subList(25,75);
    Assertions.assertEquals(subList.size(),75-25);
    for(int i=25;i<75;++i)
    {
  #IF OfRef
      var val=TypeConversionUtil.convertToInteger(i);
  #ELSE
      var val=TypeConversionUtil.convertTo$exposedType$(i);
  #ENDIF
      Assertions.assertEquals(val,subList.get$TypeNameModifier$(i-25));
    }
    var subsubList=subList.subList(10,30);
    Assertions.assertEquals(subsubList.size(),30-10);
    Assertions.assertFalse(subsubList.isEmpty());
    for(int i=10;i<30;++i)
    {
  #IF OfRef
      var val=TypeConversionUtil.convertToInteger(i+25);
  #ELSE
      var val=TypeConversionUtil.convertTo$exposedType$(i+25);
  #ENDIF
      Assertions.assertEquals(val,subsubList.get$TypeNameModifier$(i-10));
    }
    
  }

#ELSE
  var seq=new STRUCTNAME();
  Assertions.assertEquals(seq.size(),0);
  Assertions.assertTrue(seq.isEmpty());
  Assertions.assertTrue(seq.arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR);
  seq=new STRUCTNAME(0);
  Assertions.assertEquals(seq.size(),0);
  Assertions.assertTrue(seq.isEmpty());
  Assertions.assertTrue(seq.arr==null);
  seq=new STRUCTNAME(OmniArray.DEFAULT_ARR_SEQ_CAP);
  Assertions.assertEquals(seq.size(),0);
  Assertions.assertTrue(seq.isEmpty());
  Assertions.assertTrue(seq.arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR);
  for(int i=1;i<OmniArray.DEFAULT_ARR_SEQ_CAP;++i)
  {
    seq=new STRUCTNAME(i);
    Assertions.assertEquals(seq.size(),0);
    Assertions.assertTrue(seq.isEmpty());
    Assertions.assertEquals(seq.arr.length,i);
  }
#ENDIF

 
}
#ENDDEF