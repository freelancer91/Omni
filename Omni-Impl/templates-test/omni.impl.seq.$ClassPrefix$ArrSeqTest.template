#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.util.TypeConversionUtil;
import org.junit.jupiter.api.Assertions;
import java.util.function.IntFunction;
import java.util.function.Consumer;
import omni.impl.$ClassPrefix$InputTestArgType;
import omni.impl.$ClassPrefix$OutputTestArgType;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.Arguments;
import java.util.stream.Stream;
import java.util.Objects;
import omni.impl.QueryTestInputType;
import omni.impl.QueryTestScenario;
import omni.impl.ModCheckTestObject;
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Consumer;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
import java.util.ConcurrentModificationException;
import omni.util.OmniArray;
import omni.api.OmniList;
import omni.api.OmniStack;
import omni.api.OmniCollection;
import omni.api.OmniListIterator;
import omni.api.OmniIterator;
import omni.impl.MonitoredArrayConstructor;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;

import omni.impl.seq.$ClassPrefix$SeqMonitor.NestedType;
import omni.impl.seq.$ClassPrefix$SeqMonitor.StructType;
import omni.impl.seq.$ClassPrefix$SeqMonitor.CheckedType;
import omni.impl.seq.$ClassPrefix$SeqMonitor.PreModScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.SequenceLocation;
import omni.impl.seq.$ClassPrefix$SeqMonitor.FunctionExceptionScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.SequenceContentsScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.ListItrSetExceptionScenario;

//TODO replace this with a custom collection
import java.util.ArrayList;
@SuppressWarnings({"rawtypes","unchecked"})
@Execution(ExecutionMode.CONCURRENT)
public class $ClassPrefix$ArrSeqTest{
    /*
  private static enum StructType{
    CHECKEDSTACK(true),
    CHECKEDLIST(true),
    CHECKEDSUBLIST(true),
    UNCHECKEDSTACK(false),
    UNCHECKEDLIST(false),
    UNCHECKEDSUBLIST(false);
    boolean checked;
    StructType(boolean checked){this.checked=checked;}
  }
  private static final Arguments[] NON_SUBLIST_TYPES=new Arguments[]{
    Arguments.of(StructType.CHECKEDLIST),
    Arguments.of(StructType.UNCHECKEDLIST),
    Arguments.of(StructType.CHECKEDSTACK),
    Arguments.of(StructType.UNCHECKEDSTACK)
  };
  private static class ConstructionArguments{
    final int initialCapacity;
    final int rootPreAlloc;
    final int rootPostAlloc;
    final int parentPreAlloc;
    final int parentPostAlloc;
    final StructType structType;
    final OmniCollection.Of$ClassPrefix$ seq;
    final OmniCollection.Of$ClassPrefix$ parent;
    final $ClassPrefix$ArrSeq root;
    ConstructionArguments(StructType structType){
      initialCapacity=OmniArray.DEFAULT_ARR_SEQ_CAP;
      this.structType=structType;
      $ArrayType$[] arr;
      switch(structType){
        case CHECKEDSUBLIST:
        case UNCHECKEDSUBLIST:
          rootPreAlloc=5;
          parentPreAlloc=5;
          parentPostAlloc=5;
          rootPostAlloc=5;
          arr=new $ArrayType$[rootPreAlloc+rootPostAlloc+parentPreAlloc+parentPostAlloc];
          initAscendingArray(arr,0,-(rootPreAlloc+parentPreAlloc),0);
          initAscendingArray(arr,rootPreAlloc+parentPreAlloc,100,100+rootPostAlloc+parentPostAlloc);
          break;
        default:
          rootPreAlloc=0;
          parentPreAlloc=0;
          parentPostAlloc=0;
          rootPostAlloc=0;
          arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
      }
      switch(structType){
        
        case UNCHECKEDLIST:
        case UNCHECKEDSUBLIST:
          this.root=new $ClassPrefix$ArrSeq.UncheckedList(rootPreAlloc+rootPostAlloc+parentPreAlloc+parentPostAlloc,arr);
          break;
        case CHECKEDSTACK:
          this.root=new $ClassPrefix$ArrSeq.CheckedStack();
          break;
        case UNCHECKEDSTACK:
          this.root=new $ClassPrefix$ArrSeq.UncheckedStack();
          break;
        default:
          this.root=new $ClassPrefix$ArrSeq.CheckedList(rootPreAlloc+rootPostAlloc+parentPreAlloc+parentPostAlloc,arr);
      }
      switch(structType){
        case CHECKEDSUBLIST:
        case UNCHECKEDSUBLIST:
          this.parent=((OmniList.Of$ClassPrefix$)root).subList(rootPreAlloc,rootPreAlloc+parentPreAlloc+parentPostAlloc);
          this.seq=((OmniList.Of$ClassPrefix$)parent).subList(parentPreAlloc,parentPreAlloc);
          break;
        default:
          this.parent=root;
          this.seq=root;
      }
    }
    ConstructionArguments(int rootPreAlloc,int parentPreAlloc,int parentPostAlloc,int rootPostAlloc,StructType structType){
      this.initialCapacity=OmniArray.DEFAULT_ARR_SEQ_CAP;
      this.rootPreAlloc=rootPreAlloc;
      this.rootPostAlloc=rootPostAlloc;
      this.parentPreAlloc=parentPreAlloc;
      this.parentPostAlloc=parentPostAlloc;
      this.structType=structType;
      final int rootSize;
      if((rootSize=parentPreAlloc+parentPostAlloc+rootPreAlloc+rootPostAlloc)==0){
        this.root=structType.checked?new $ClassPrefix$ArrSeq.CheckedList():new $ClassPrefix$ArrSeq.UncheckedList();
      }else{
        $ArrayType$[] arr=new $ArrayType$[rootSize];
        initAscendingArray(arr,0,-(rootPreAlloc+parentPreAlloc),0);
        initAscendingArray(arr,rootPreAlloc+parentPreAlloc,100,100+rootPostAlloc+parentPostAlloc);
        this.root=structType.checked?new $ClassPrefix$ArrSeq.CheckedList(rootSize,arr):new $ClassPrefix$ArrSeq.UncheckedList(rootSize,arr);
      }
      this.parent=((OmniList.Of$ClassPrefix$)root).subList(rootPreAlloc,rootPreAlloc+parentPreAlloc+parentPostAlloc);
      this.seq=((OmniList.Of$ClassPrefix$)parent).subList(parentPreAlloc,parentPreAlloc);
    }
    ConstructionArguments(int initialCapacity,StructType structType){
      this.initialCapacity=initialCapacity;
      this.rootPreAlloc=0;
      this.rootPostAlloc=0;
      this.parentPreAlloc=0;
      this.parentPostAlloc=0;
      this.structType=structType;
      switch(structType){
        case CHECKEDSTACK:
          this.root=new $ClassPrefix$ArrSeq.CheckedStack(initialCapacity);
          break;
        case UNCHECKEDSTACK:
          this.root=new $ClassPrefix$ArrSeq.UncheckedStack(initialCapacity);
          break;
        case CHECKEDLIST:
        case CHECKEDSUBLIST:
          this.root=new $ClassPrefix$ArrSeq.CheckedList(initialCapacity);
          break;
        default:
          this.root=new $ClassPrefix$ArrSeq.UncheckedList(initialCapacity);
      }
      this.parent=root;
      this.seq=root;
    }
    public String toString(){
      StringBuilder builder=new StringBuilder(structType.checked?"Checked":"Unchecked");
      switch(structType){
        case CHECKEDSTACK:
        case UNCHECKEDSTACK:
          builder.append("Stack{").append(initialCapacity);
          break;
        case CHECKEDLIST:
        case UNCHECKEDLIST:
          builder.append("List{").append(initialCapacity);
          break;
        case CHECKEDSUBLIST:
        case UNCHECKEDSUBLIST:
          builder.append("SubList{").append(rootPreAlloc).append(',').append(parentPreAlloc).append(',').append(parentPostAlloc).append(',').append(rootPostAlloc);
      }
      return builder.append('}').toString();
    }
    private OmniListIterator.Of$ClassPrefix$ constructSeqListIterator(){return ((OmniList.Of$ClassPrefix$)seq).listIterator();}
    private void verifyIteratorState(Object itr,int expectedCursor,int expectedLastRet,int expectedModCount){
      int actualCursor;
      Object actualParent;
      switch(structType){
        case CHECKEDLIST:
          actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.cursor(itr);
          actualParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.parent(itr);
          Assertions.assertEquals(expectedModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.modCount(itr));
          Assertions.assertEquals(expectedLastRet<0?expectedLastRet:expectedLastRet+(rootPreAlloc+parentPreAlloc),FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.lastRet(itr));
          break;
        case UNCHECKEDLIST:
          actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedList.Itr.cursor(itr);
          actualParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedList.Itr.parent(itr);
          break;
        case CHECKEDSTACK:
          actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.cursor(itr);
          actualParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.parent(itr);
          Assertions.assertEquals(expectedModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.modCount(itr));
          Assertions.assertEquals(expectedLastRet<0?expectedLastRet:expectedLastRet+(rootPreAlloc+parentPreAlloc),FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.lastRet(itr));
          break;
        case UNCHECKEDSTACK:
          actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedStack.Itr.cursor(itr);
          actualParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedStack.Itr.parent(itr);
          break;
        case CHECKEDSUBLIST:
          actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.cursor(itr);
          actualParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.parent(itr);
          Assertions.assertEquals(expectedModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.modCount(itr));
          Assertions.assertEquals(expectedLastRet<0?expectedLastRet:expectedLastRet+(rootPreAlloc+parentPreAlloc),FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.lastRet(itr));
          break;
        default:
          actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.Itr.cursor(itr);
          actualParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.Itr.parent(itr);
      }
      Assertions.assertEquals(expectedCursor+(rootPreAlloc+parentPreAlloc),actualCursor);
      Assertions.assertSame(seq,actualParent);
    }
    private void verifyStructuralIntegrity(int expectedSize,int expectedModCount){verifyStructuralIntegrity(expectedSize,expectedModCount,expectedSize,expectedModCount,expectedSize,expectedModCount);}
    private void verifyStructuralIntegrity(int expectedSeqSize,int expectedSeqModCount,int expectedParentAndRootSize,int expectedParentAndRootModCount){verifyStructuralIntegrity(expectedSeqSize,expectedSeqModCount,expectedParentAndRootSize,expectedParentAndRootModCount,expectedParentAndRootSize,expectedParentAndRootModCount);}
    private void verifyStructuralIntegrity(int expectedSeqSize,int expectedModCount,int expectedParentSize,int expectedParentModCount,int expectedRootSize,int expectedRootModCount){
      switch(structType){
        case CHECKEDSTACK:
          Assertions.assertEquals(expectedRootModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(root));
          break;
        case CHECKEDLIST:
          Assertions.assertEquals(expectedRootModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(root));
        case UNCHECKEDSTACK:
        case UNCHECKEDLIST:
          break;
        case CHECKEDSUBLIST:
        case UNCHECKEDSUBLIST:
          OmniList.Of$ClassPrefix$ actualSeqParent;
          Object actualSeqRoot;
          OmniList.Of$ClassPrefix$ actualParentParent;
          Object actualParentRoot;
          int actualParentSize;
          int actualSeqSize;
          if(structType.checked){
            actualSeqParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.parent(seq);
            actualSeqRoot=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.root(seq);
            actualParentParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.parent(parent);
            actualParentRoot=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.root(parent);
            actualSeqSize=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.size(seq);
            actualParentSize=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.size(parent);
            Assertions.assertEquals(expectedModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.modCount(seq));
            Assertions.assertEquals(expectedParentModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.modCount(parent));
            Assertions.assertEquals(expectedRootModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(root));
          }else{
            actualSeqParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.parent(seq);
            actualSeqRoot=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.root(seq);
            actualParentParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.parent(parent);
            actualParentRoot=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.root(parent);
            actualSeqSize=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.size(seq);
            actualParentSize=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.size(parent);
          }
          Assertions.assertSame(root,actualSeqRoot);
          Assertions.assertSame(root,actualParentRoot);
          Assertions.assertSame(parent,actualSeqParent);
          Assertions.assertNull(actualParentParent);
          Assertions.assertEquals(expectedSeqSize,actualSeqSize);
          Assertions.assertEquals(expectedParentSize+parentPreAlloc+parentPostAlloc,actualParentSize);
      }
      Assertions.assertEquals(expectedRootSize+parentPreAlloc+parentPostAlloc+rootPreAlloc+rootPostAlloc,FieldAccessor.$ClassPrefix$ArrSeq.size(root));
    }
    private int verifyPreAlloc(){
      var arr=root.arr;
      int offset=0;
      for(int bound=rootPreAlloc+parentPreAlloc,v=-bound;offset<bound;++offset,++v){$ClassPrefix$InputTestArgType.ARRAY_TYPE.verifyVal(v,arr[offset]);}
      return offset;
    }
    private int verifyParentPostAlloc(int offset){
      var arr=root.arr;
      for(int bound=offset+parentPostAlloc,v=100;offset<bound;++offset,++v){$ClassPrefix$InputTestArgType.ARRAY_TYPE.verifyVal(v,arr[offset]);}
      return offset;
    }
    private int verifyRootPostAlloc(int offset){
      var arr=root.arr;
      for(int bound=offset+rootPostAlloc,v=100+parentPostAlloc;offset<bound;++offset,++v){$ClassPrefix$InputTestArgType.ARRAY_TYPE.verifyVal(v,arr[offset]);}
      return offset;
    }
    private int verifyIndex(int offset,$ClassPrefix$InputTestArgType inputArgType,int v){
      inputArgType.verifyVal(v,root.arr[offset]);
      return offset+1;
    }
    private int verifyAscending(int offset,$ClassPrefix$InputTestArgType inputArgType,int length){
      var arr=root.arr;
      for(int bound=offset+length,v=0;offset<bound;++offset,++v){inputArgType.verifyVal(v,arr[offset]);}
      return offset;
    }
    private int verifyDescending(int offset,$ClassPrefix$InputTestArgType inputArgType,int length){
      var arr=root.arr;
      for(int bound=offset+length,v=length;offset<bound;++offset){inputArgType.verifyVal(--v,arr[offset]);}
      return offset;
    }
    private int verifyMidPointInsertion(int offset,$ClassPrefix$InputTestArgType inputArgType,int length){
      var arr=root.arr;
      int i;
      for(int v=1,b=(i=offset)+length/2;i<b;++i,v+=2){inputArgType.verifyVal(v,arr[i]);}
      for(int v=length-2,b=i+length/2;i<b;++i,v-=2){inputArgType.verifyVal(v,arr[i]);}
      return offset+length;
    }
  }
  static class InputTestMonitor{
    int expectedItrModCount=0;
    int expectedSeqModCount=0;
    int expectedParentModCount=0;
    int expectedRootModCount=0;
    int expectedSeqSize=0;
    int expectedParentSize=0;
    int expectedRootSize=0;
    int expectedCursor=0;
    int expectedLastRet=-1;
    public void seqItrAdd(OmniListIterator.Of$ClassPrefix$ seqItr,$ClassPrefix$InputTestArgType inputArgType,int valToAdd){
      inputArgType.callListItrAdd(seqItr,valToAdd);
      ++expectedItrModCount;
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
      ++expectedSeqSize;
      ++expectedParentSize;
      ++expectedRootSize;
      ++expectedCursor;
      expectedLastRet=-1;
    }
    public void seqItrPrevious(OmniListIterator.Of$ClassPrefix$ seqItr){
      seqItr.previous$TypeNameModifier$();
      expectedLastRet=--expectedCursor; 
    }
    public void seqItrNext(OmniListIterator.Of$ClassPrefix$ seqItr){
      seqItr.next$TypeNameModifier$();
      expectedLastRet=expectedCursor++;
    }
    public void seqItrRemove(OmniListIterator.Of$ClassPrefix$ seqItr){
      seqItr.remove();
      expectedCursor=expectedLastRet;
      expectedLastRet=-1;
      ++expectedItrModCount;
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
      --expectedSeqSize;
      --expectedParentSize;
      --expectedRootSize;
    }
    public void rootMod(ConstructionArguments constructionArgs,$ClassPrefix$InputTestArgType inputArgType){
      ++expectedRootSize;
      ++expectedRootModCount;
      inputArgType.callCollectionAdd(constructionArgs.root,0);
    }
    public void parentMod(ConstructionArguments constructionArgs,$ClassPrefix$InputTestArgType inputArgType){
      ++expectedRootSize;
      ++expectedRootModCount;
      ++expectedParentSize;
      ++expectedParentModCount;
      inputArgType.callCollectionAdd(constructionArgs.parent,0);
    }
    public void seqMod(ConstructionArguments constructionArgs,$ClassPrefix$InputTestArgType inputArgType){
      ++expectedRootSize;
      ++expectedRootModCount;
      ++expectedParentSize;
      ++expectedParentModCount;
      ++expectedSeqSize;
      ++expectedSeqModCount;
      inputArgType.callCollectionAdd(constructionArgs.seq,0);
    }
    public void collectionAdd(ConstructionArguments constructionArgs,$ClassPrefix$InputTestArgType inputArgType,int val){
      ++expectedRootSize;
      ++expectedRootModCount;
      ++expectedParentSize;
      ++expectedParentModCount;
      ++expectedSeqSize;
      ++expectedSeqModCount;
      inputArgType.callCollectionAdd(constructionArgs.seq,val);
    }
    public void listAdd(ConstructionArguments constructionArgs,$ClassPrefix$InputTestArgType inputArgType,int index,int val){
      ++expectedRootSize;
      ++expectedRootModCount;
      ++expectedParentSize;
      ++expectedParentModCount;
      ++expectedSeqSize;
      ++expectedSeqModCount;
      inputArgType.callListAdd(constructionArgs.seq,index,val);
    }
    public void illegalMod(ConstructionArguments constructionArgs,$ClassPrefix$InputTestArgType inputArgType,CMEScenario modScenario){
      switch(modScenario){
        case ModRoot:
          rootMod(constructionArgs,inputArgType);
          break;
        case ModParent:
          parentMod(constructionArgs,inputArgType);
          break;
        case ModSeq:
          seqMod(constructionArgs,inputArgType);
        case NoMod:
      }
    }
    public void verifyItrState(OmniListIterator.Of$ClassPrefix$ seqItr,ConstructionArguments constructionArgs){
      constructionArgs.verifyIteratorState(seqItr,expectedCursor,expectedLastRet,expectedItrModCount);
    }
    public void verifyStructuralIntegrity(ConstructionArguments constructionArgs){
      constructionArgs.verifyStructuralIntegrity(expectedSeqSize,expectedSeqModCount,expectedParentSize,expectedParentModCount,expectedRootSize,expectedRootModCount);
    }
  }

  private static void initAscendingArray($ArrayType$[] arr,int offset,int lo,int hi){
    int bound=offset+(hi-lo);
    for(int i=offset;i<bound;++i,++lo){arr[i]=TypeConversionUtil.convertTo$ArrayType$(lo);}
  }
  static enum CMEScenario{
    NoMod,
    ModSeq,
    ModParent,
    ModRoot;
  }

  static Stream<Arguments> getListAddIntValArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for($ClassPrefix$InputTestArgType inputTestArgType:$ClassPrefix$InputTestArgType.values()){
      for(ListAddIntValTestScenario testScenario: ListAddIntValTestScenario.values()){
        for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
          if(testScenario.expectedException==null){builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(initialCapacity,StructType.UNCHECKEDLIST)));}
          if(testScenario.expectedException!=ConcurrentModificationException.class){builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(initialCapacity,StructType.CHECKEDLIST)));}
        }
        for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5){
          for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5){
            for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5){
              for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5){
                builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,StructType.CHECKEDSUBLIST)));
                if(testScenario.expectedException==null){builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,StructType.UNCHECKEDSUBLIST)));}
              }
            }
          }
        }
      }
    }
    return builder.build().parallel();
  }
  static Stream<Arguments> getStackPushArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for($ClassPrefix$InputTestArgType inputTestArgType:$ClassPrefix$InputTestArgType.values()){
      for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,StructType.CHECKEDSTACK)));
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,StructType.UNCHECKEDSTACK)));
      }
    }
    return builder.build().parallel();
  }
  static Stream<Arguments> getArgsForNonSubListTypes(){return Stream.of(NON_SUBLIST_TYPES);}
  @ParameterizedTest
  @MethodSource("getArgsForNonSubListTypes")
  public void testConstructor_happyPath(StructType structType){
    $ClassPrefix$ArrSeq seq;
    if(structType.checked){
      Assertions.assertEquals(0,structType==StructType.CHECKEDLIST?FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(seq=new $ClassPrefix$ArrSeq.CheckedList()):FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(seq=new $ClassPrefix$ArrSeq.CheckedStack()));
    }else{
      seq=structType==StructType.UNCHECKEDLIST?new $ClassPrefix$ArrSeq.UncheckedList():new $ClassPrefix$ArrSeq.UncheckedStack();
    }
    Assertions.assertSame(OmniArray.Of$ClassPrefix$.DEFAULT_ARR,seq.arr);
  }
  @ParameterizedTest
  @MethodSource("getArgsForNonSubListTypes")
  public void testConstructor_int_$ArrayType$arr_happyPath(StructType structType){
    int size=5;
    $ArrayType$[] arr=new $ArrayType$[10];
    $ClassPrefix$ArrSeq seq;
    if(structType.checked){
      Assertions.assertEquals(0,structType==StructType.CHECKEDLIST?FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(seq=new $ClassPrefix$ArrSeq.CheckedList(size,arr)):FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(seq=new $ClassPrefix$ArrSeq.CheckedStack(size,arr)));
    }else{
      seq=structType==StructType.UNCHECKEDLIST?new $ClassPrefix$ArrSeq.UncheckedList(size,arr):new $ClassPrefix$ArrSeq.UncheckedStack(size,arr);
    }
    Assertions.assertEquals(size,seq.size);
    Assertions.assertSame(arr,seq.arr);
  }
  static Stream<Arguments> getArgsFortestConstructor_int_happyPath(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
      builder.add(Arguments.of(initialCapacity,StructType.UNCHECKEDLIST));
      builder.add(Arguments.of(initialCapacity,StructType.CHECKEDLIST));
      builder.add(Arguments.of(initialCapacity,StructType.UNCHECKEDSTACK));
      builder.add(Arguments.of(initialCapacity,StructType.CHECKEDSTACK));
    }
    return builder.build().parallel();
  }
  */
  static Stream<Arguments> getArgsForConstructor_int(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var nestedType:NestedType.values()){
      if(nestedType==NestedType.SUBLIST){
        continue;
      }
      for(var checkedType:CheckedType.values()){
        for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
          builder.add(Arguments.of(nestedType,checkedType,initialCapacity));
        }
      }
    }
    return builder.build().parallel();
  }
  @ParameterizedTest
  @MethodSource("getArgsForConstructor_int")
  public void testConstructor_int(NestedType nestedType,CheckedType checkedType,int initialCapacity){
    $ClassPrefix$ArrSeq seq;
    if(checkedType.checked){
      Assertions.assertEquals(0,nestedType==NestedType.LIST?FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(seq=new $ClassPrefix$ArrSeq.CheckedList(initialCapacity)):FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(seq=new $ClassPrefix$ArrSeq.CheckedStack(initialCapacity)));
    }else{
      seq=nestedType==NestedType.LIST?new $ClassPrefix$ArrSeq.UncheckedList(initialCapacity):new $ClassPrefix$ArrSeq.UncheckedStack(initialCapacity);
    }
    Assertions.assertEquals(0,seq.size);
    switch(initialCapacity){
      case 0:
        Assertions.assertNull(seq.arr);
        break;
      case OmniArray.DEFAULT_ARR_SEQ_CAP:
        Assertions.assertSame(OmniArray.Of$ClassPrefix$.DEFAULT_ARR,seq.arr);
        break;
      default:
        Assertions.assertEquals(initialCapacity,seq.arr.length);
#IF OfRef
        $ClassPrefix$SeqMonitor.verifyRangeIsNull(seq.arr,0,initialCapacity);
#ENDIF
    }
  }
  static Stream<Arguments> getListItrAddArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var checkedType:CheckedType.values()){
      for(var preModScenario:PreModScenario.values()){
        if(!checkedType.checked && preModScenario.expectedException!=null){
          continue;
        }
        for(var seqContentsScenario:SequenceContentsScenario.values()){
          for(var seqLocation:SequenceLocation.values()){
            for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
              for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
                  builder.add(Arguments.of(new $ClassPrefix$SeqMonitor(StructType.ARRSEQ,NestedType.LIST,checkedType,initialCapacity),preModScenario,seqContentsScenario,seqLocation,inputArgType));
              }
              for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5){
                for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5){
                  for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5){
                    for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5){
                      builder.add(Arguments.of(new $ClassPrefix$SeqMonitor(StructType.ARRSEQ,NestedType.SUBLIST,checkedType,OmniArray.DEFAULT_ARR_SEQ_CAP,rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc),preModScenario,seqContentsScenario,seqLocation,inputArgType));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return builder.build().parallel();
  }
  @ParameterizedTest
  @MethodSource("getListItrAddArgs")
  public void testListItradd_val($ClassPrefix$SeqMonitor seqMonitor,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario,SequenceLocation seqLocationScenario,$ClassPrefix$InputTestArgType inputArgType){
    int numToAdd=seqContentsScenario.nonEmpty?100:0;
    for(int i=0;i<numToAdd;++i){
      seqMonitor.add(i);
    }
    $ClassPrefix$ItrMonitor itrMonitor;
    switch(seqLocationScenario){
      case BEGINNING:
        itrMonitor=seqMonitor.getListItrMonitor();
        break;
      case MIDDLE:
        itrMonitor=seqMonitor.getListItrMonitor(numToAdd/2);
        break;
      case END:
        itrMonitor=seqMonitor.getListItrMonitor(numToAdd);
        break;
      default:
        throw new Error("Unknown sequence locatio scenario "+seqLocationScenario);
    }
    seqMonitor.illegalAdd(preModScenario);
    if(preModScenario.expectedException==null){
      switch(seqLocationScenario){
        case BEGINNING:
          for(int i=0;i<100;++i){
            itrMonitor.add(i,inputArgType);
            itrMonitor.verifyIteratorState();
            itrMonitor.iterateReverse();
            seqMonitor.verifyStructuralIntegrity();
          }
          break;
        case MIDDLE:
          for(int i=0;i<100;++i){
            itrMonitor.add(i,inputArgType);
            itrMonitor.verifyIteratorState();
            if((i&1)!=0){
              itrMonitor.iterateReverse();
            }
            seqMonitor.verifyStructuralIntegrity();
          }
          break;
        case END:
          for(int i=0;i<100;++i){
            itrMonitor.add(i,inputArgType);
            itrMonitor.verifyIteratorState();
            seqMonitor.verifyStructuralIntegrity();
          }
          break;
        default:
          throw new Error("Unknown sequence locatio scenario "+seqLocationScenario);
      }
      var i=seqMonitor.verifyPreAlloc();
      switch(seqLocationScenario){
        case BEGINNING:
          i=seqMonitor.verifyDescending(i,inputArgType,100);
          i=seqMonitor.verifyAscending(i,numToAdd);
          break;
        case MIDDLE:
          i=seqMonitor.verifyAscending(i,numToAdd/2);
          i=seqMonitor.verifyMidPointInsertion(i,inputArgType,100);
          i=seqMonitor.verifyAscending(numToAdd/2,i,numToAdd-(numToAdd/2));
          break;
        case END:
          i=seqMonitor.verifyAscending(i,numToAdd);
          i=seqMonitor.verifyAscending(i,inputArgType,100);
          break;
        default:
          throw new Error("Unknown sequence location scenario "+seqLocationScenario);
      }
      i=seqMonitor.verifyParentPostAlloc(i);
      seqMonitor.verifyRootPostAlloc(i);
    }else{
      Assertions.assertThrows(preModScenario.expectedException,()->itrMonitor.add(0,inputArgType));
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
      var i=seqMonitor.verifyPreAlloc();
      i=seqMonitor.verifyAscending(i,numToAdd);
      if(preModScenario==PreModScenario.ModSeq){i=seqMonitor.verifyIllegalAdd(i);}
      i=seqMonitor.verifyParentPostAlloc(i);
      if(preModScenario==PreModScenario.ModParent){i=seqMonitor.verifyIllegalAdd(i);}
      i=seqMonitor.verifyRootPostAlloc(i);
      if(preModScenario==PreModScenario.ModRoot){i=seqMonitor.verifyIllegalAdd(i);}
    }
  }
  static Stream<Arguments> getListItrSetArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var checkedType:CheckedType.values()){
      for(var listItrSetExceptionScenario:ListItrSetExceptionScenario.values()){
        if(!checkedType.checked && listItrSetExceptionScenario.expectedException!=null){
          continue;
        }
        for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
          builder.add(Arguments.of(new $ClassPrefix$SeqMonitor(StructType.ARRSEQ,NestedType.LIST,checkedType),listItrSetExceptionScenario,inputArgType));
          builder.add(Arguments.of(new $ClassPrefix$SeqMonitor(StructType.ARRSEQ,NestedType.SUBLIST,checkedType),listItrSetExceptionScenario,inputArgType));
        }
      }
    }
    return builder.build().parallel();
  }
  @ParameterizedTest
  @MethodSource("getListItrSetArgs")
  public void testListItrset_val($ClassPrefix$SeqMonitor seqMonitor,ListItrSetExceptionScenario listItrSetExceptionScenario,$ClassPrefix$InputTestArgType inputArgType){
    int numToAdd=100;
    for(int i=0;i<numToAdd;++i){
      seqMonitor.add(i);
    }
    $ClassPrefix$ItrMonitor itrMonitor=seqMonitor.getListItrMonitor();
    switch(listItrSetExceptionScenario){
      case PostAddThrowISE:
      case PostAddThrowISESupercedesModRootCME:
      case PostAddThrowISESupercedesModParentCME:
      case PostAddThrowISESupercedesModSeqCME:
        itrMonitor.add(0);
        break;
      case PostRemoveThrowISE:
      case PostRemoveThrowISESupercedesModRootCME:
      case PostRemoveThrowISESupercedesModParentCME:
      case PostRemoveThrowISESupercedesModSeqCME:
        itrMonitor.iterateForward();
        itrMonitor.remove();
        break;
      default:
        itrMonitor.iterateForward();
      case ThrowISE:
      case ThrowISESupercedesModRootCME:
      case ThrowISESupercedesModParentCME:
      case ThrowISESupercedesModSeqCME:
    }
    seqMonitor.illegalAdd(listItrSetExceptionScenario.preModScenario);
    $ClassPrefix$SeqMonitor.SeqMonitorItr i;
    if(listItrSetExceptionScenario.expectedException==null){
      for(int j=0;j<numToAdd;++j){
        itrMonitor.set(numToAdd-j-1,inputArgType);
        itrMonitor.verifyIteratorState();
        seqMonitor.verifyStructuralIntegrity();
        if(!itrMonitor.hasNext()){
          break;
        }
        itrMonitor.iterateForward();
      }
      i=seqMonitor.verifyPreAlloc();
      i=seqMonitor.verifyDescending(i,inputArgType,numToAdd);
      i=seqMonitor.verifyParentPostAlloc(i);
      seqMonitor.verifyRootPostAlloc(i);
      for(int j=0;j<numToAdd;++j){
        itrMonitor.iterateReverse();
        itrMonitor.set(numToAdd-j-1,inputArgType);
        itrMonitor.verifyIteratorState();
        seqMonitor.verifyStructuralIntegrity();
      }
      i=seqMonitor.verifyPreAlloc();
      i=seqMonitor.verifyAscending(i,inputArgType,numToAdd);
    }else{
      Assertions.assertThrows(listItrSetExceptionScenario.expectedException,()->itrMonitor.set(0));
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
      i=seqMonitor.verifyPreAlloc();
      switch(listItrSetExceptionScenario){
        case PostRemoveThrowISE:
        case PostRemoveThrowISESupercedesModRootCME:
        case PostRemoveThrowISESupercedesModParentCME:
        case PostRemoveThrowISESupercedesModSeqCME:
          i=seqMonitor.verifyAscending(1,i,numToAdd-1);
          break;
        case PostAddThrowISE:
        case PostAddThrowISESupercedesModRootCME:
        case PostAddThrowISESupercedesModParentCME:
        case PostAddThrowISESupercedesModSeqCME:
          i=seqMonitor.verifyIllegalAdd(i);
        default:
          i=seqMonitor.verifyAscending(i,numToAdd);
      }
    }
    if(listItrSetExceptionScenario.preModScenario==PreModScenario.ModSeq){i=seqMonitor.verifyIllegalAdd(i);}
    i=seqMonitor.verifyParentPostAlloc(i);
    if(listItrSetExceptionScenario.preModScenario==PreModScenario.ModParent){i=seqMonitor.verifyIllegalAdd(i);}
    i=seqMonitor.verifyRootPostAlloc(i);
    if(listItrSetExceptionScenario.preModScenario==PreModScenario.ModRoot){seqMonitor.verifyIllegalAdd(i);}
  }
  /*
  static enum ListAddIntValTestScenario{
    HappyPathInsertBegin(false,CMEScenario.NoMod,null),
    HappyPathInsertEnd(false,CMEScenario.NoMod,null),
    HappyPathInsertMidPoint(false,CMEScenario.NoMod,null),
    ThrowIOBE(false,CMEScenario.NoMod,IndexOutOfBoundsException.class),
    EmptyModRootThrowCME(false,CMEScenario.ModRoot,ConcurrentModificationException.class),
    EmptyModParentThrowCME(false,CMEScenario.ModParent,ConcurrentModificationException.class),
    NonEmptyModRootThrowCME(true,CMEScenario.ModRoot,ConcurrentModificationException.class),
    NonEmptyModParentThrowCME(true,CMEScenario.ModParent,ConcurrentModificationException.class),
    EmptyModRootThrowCMESupercedesIOBE(false,CMEScenario.ModRoot,ConcurrentModificationException.class),
    NonEmptyModRootThrowCMESupercedesIOBE(true,CMEScenario.ModRoot,ConcurrentModificationException.class),
    EmptyModParentThrowCMESupercedesIOBE(false,CMEScenario.ModParent,ConcurrentModificationException.class),
    NonEmptyModParentThrowCMESupercedesIOBE(true,CMEScenario.ModParent,ConcurrentModificationException.class);
    final boolean nonEmpty;
    final CMEScenario modScenario;
    final Class<? extends Throwable> expectedException;
    ListAddIntValTestScenario(boolean nonEmpty,CMEScenario modScenario,Class<? extends Throwable> expectedException){
      this.expectedException=expectedException;
      this.nonEmpty=nonEmpty;
      this.modScenario=modScenario;
    }
  }
  @ParameterizedTest
  @MethodSource("getListAddIntValArgs")
  public void testListadd_int_val(ListAddIntValTestScenario testScenario,$ClassPrefix$InputTestArgType inputArgType,ConstructionArguments constructionArgs){
    var testMonitor=new InputTestMonitor();
    if(testScenario.nonEmpty){for(int i=0;i<100;++i){testMonitor.collectionAdd(constructionArgs,inputArgType,i);}}
    var expectedException=testScenario.expectedException;
    if(expectedException==ConcurrentModificationException.class){
      testMonitor.illegalMod(constructionArgs,inputArgType,testScenario.modScenario);
      switch(testScenario){
        case EmptyModRootThrowCMESupercedesIOBE:
        case NonEmptyModRootThrowCMESupercedesIOBE:
        case EmptyModParentThrowCMESupercedesIOBE:
        case NonEmptyModParentThrowCMESupercedesIOBE:
          //attempt an insertion too low
          Assertions.assertThrows(expectedException,()->inputArgType.callListAdd(constructionArgs.seq,-1,0));
          //attempt an insertion too high
          Assertions.assertThrows(expectedException,()->inputArgType.callListAdd(constructionArgs.seq,testMonitor.expectedSeqSize+1,0));
          break;
        default:
          Assertions.assertThrows(expectedException,()->inputArgType.callListAdd(constructionArgs.seq,testMonitor.expectedSeqSize,0));
      }
    }else{
      switch(testScenario){
        case HappyPathInsertBegin:
          for(int i=0;i<100;++i){testMonitor.listAdd(constructionArgs,inputArgType,0,i);}
          break;
        case HappyPathInsertEnd:
          for(int i=0;i<100;++i){testMonitor.listAdd(constructionArgs,inputArgType,testMonitor.expectedSeqSize,i);}
          break;
        case HappyPathInsertMidPoint:
          for(int i=0;i<100;++i){testMonitor.listAdd(constructionArgs,inputArgType,testMonitor.expectedSeqSize/2,i);}
          break;
        case ThrowIOBE:
          for(int i=0;i<100;++i){
            //too low
            Assertions.assertThrows(expectedException,()->inputArgType.callListAdd(constructionArgs.seq,-1,0));
            //too high
            Assertions.assertThrows(expectedException,()->inputArgType.callListAdd(constructionArgs.seq,testMonitor.expectedSeqSize+1,0));
            testMonitor.collectionAdd(constructionArgs,inputArgType,i);
          }
        default:
      }
    }
    testMonitor.verifyStructuralIntegrity(constructionArgs);
    int offset=constructionArgs.verifyPreAlloc();
    switch(testScenario){
      case HappyPathInsertBegin:
        offset=constructionArgs.verifyDescending(offset,inputArgType,100);
        break;
      case HappyPathInsertMidPoint:
        offset=constructionArgs.verifyMidPointInsertion(offset,inputArgType,100);
        break;
      default:
        if(!testScenario.nonEmpty){break;}
      case HappyPathInsertEnd:
      case ThrowIOBE:
        offset=constructionArgs.verifyAscending(offset,inputArgType,100);
        break;
    }
    offset=constructionArgs.verifyParentPostAlloc(offset);
    if(testScenario.modScenario==CMEScenario.ModParent){offset=constructionArgs.verifyIndex(offset,inputArgType,0);}
    offset=constructionArgs.verifyRootPostAlloc(offset);
    if(testScenario.modScenario==CMEScenario.ModRoot){constructionArgs.verifyIndex(offset,inputArgType,0);}
  }
  static enum ListPutIntValTestScenario{
    HappyPath(true,CMEScenario.NoMod,null),
    ThrowIOBE(false,CMEScenario.NoMod,IndexOutOfBoundsException.class),
    NonEmptyListModRootThrowCME(true,CMEScenario.ModRoot,ConcurrentModificationException.class),
    NonEmptyListModParentThrowCME(true,CMEScenario.ModParent,ConcurrentModificationException.class),
    EmptyListModRootThrowCMESupercedesIOBE(false,CMEScenario.ModRoot,ConcurrentModificationException.class),
    EmptyListModParentThrowCMESupercedesIOBE(false,CMEScenario.ModParent,ConcurrentModificationException.class),
    NonEmptyListModRootThrowCMESupercedesIOBE(true,CMEScenario.ModRoot,ConcurrentModificationException.class),
    NonEmptyListModParentThrowCMESupercedesIOBE(true,CMEScenario.ModParent,ConcurrentModificationException.class);
    final boolean nonEmpty;
    final CMEScenario modScenario;
    final Class<? extends Throwable> expectedException;
    ListPutIntValTestScenario(boolean nonEmpty,CMEScenario modScenario,Class<? extends Throwable> expectedException){
      this.expectedException=expectedException;
      this.nonEmpty=nonEmpty;
      this.modScenario=modScenario;
    }
  }
  static Stream<Arguments> getListPutIntValArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for($ClassPrefix$InputTestArgType inputTestArgType:$ClassPrefix$InputTestArgType.values()){
      for(ListPutIntValTestScenario testScenario: ListPutIntValTestScenario.values()){
        for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
          if(testScenario.expectedException==null){builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(initialCapacity,StructType.UNCHECKEDLIST)));}
          if(testScenario.expectedException!=ConcurrentModificationException.class){builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(initialCapacity,StructType.CHECKEDLIST)));}
        }
        for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5){
          for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5){
            for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5){
              for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5){
                builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,StructType.CHECKEDSUBLIST)));
                if(testScenario.expectedException==null){builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,StructType.UNCHECKEDSUBLIST)));}
              }
            }
          }
        }
      }
    }
    return builder.build().parallel();
  }
  @ParameterizedTest
  @MethodSource("getListPutIntValArgs")
  public void testListput_int_val(ListPutIntValTestScenario testScenario,$ClassPrefix$InputTestArgType inputArgType,ConstructionArguments constructionArgs){
    var testMonitor=new InputTestMonitor();
    if(testScenario.nonEmpty){for(int i=0;i<100;++i){testMonitor.collectionAdd(constructionArgs,inputArgType,i);}}
    var expectedException=testScenario.expectedException;
    if(expectedException==null){
      for(int i=0;i<100;++i){inputArgType.callListPut(constructionArgs.seq,100-i-1,i);}
    }else if(expectedException==IndexOutOfBoundsException.class){
      for(int i=0;i<100;++i){
        //attempt a put too low
        Assertions.assertThrows(expectedException,()->inputArgType.callListPut(constructionArgs.seq,-1,0));
        //attempt a put too high
        Assertions.assertThrows(expectedException,()->inputArgType.callListPut(constructionArgs.seq,testMonitor.expectedSeqSize,0));
        testMonitor.collectionAdd(constructionArgs,inputArgType,i);
      }
    }else{
      testMonitor.illegalMod(constructionArgs,inputArgType,testScenario.modScenario);
      switch(testScenario){
        case NonEmptyListModRootThrowCME:
        case NonEmptyListModParentThrowCME:
          Assertions.assertThrows(expectedException,()->inputArgType.callListPut(constructionArgs.seq,0,0));
          break;
        case EmptyListModRootThrowCMESupercedesIOBE:
        case EmptyListModParentThrowCMESupercedesIOBE:
        case NonEmptyListModRootThrowCMESupercedesIOBE:
        case NonEmptyListModParentThrowCMESupercedesIOBE:
          //attempt a put too low
          Assertions.assertThrows(expectedException,()->inputArgType.callListPut(constructionArgs.seq,-1,0));
          //attempt a put too high
          Assertions.assertThrows(expectedException,()->inputArgType.callListPut(constructionArgs.seq,testMonitor.expectedSeqSize,0));
        default:
      }
    }
    testMonitor.verifyStructuralIntegrity(constructionArgs);
    int offset=constructionArgs.verifyPreAlloc();
    switch(testScenario){
      case HappyPath:
        offset=constructionArgs.verifyDescending(offset,inputArgType,100);
        break;
      default:
        if(!testScenario.nonEmpty){break;}
      case ThrowIOBE:
        offset=constructionArgs.verifyAscending(offset,inputArgType,100);
    }
    offset=constructionArgs.verifyParentPostAlloc(offset);
    if(testScenario.modScenario==CMEScenario.ModParent){offset=constructionArgs.verifyIndex(offset,inputArgType,0);}
    offset=constructionArgs.verifyRootPostAlloc(offset);
    if(testScenario.modScenario==CMEScenario.ModRoot){constructionArgs.verifyIndex(offset,inputArgType,0);}
  }

  //TODO develop the parameterization of some of these tests to improve code dryness
  
  static enum CollectionAddValTestScenario{
    HappyPath(false,CMEScenario.NoMod,null),
    EmptyListModRootThrowCME(false,CMEScenario.ModRoot,ConcurrentModificationException.class),
    EmptyListModParentThrowCME(false,CMEScenario.ModParent,ConcurrentModificationException.class),
    NonEmptyListModRootThrowCME(true,CMEScenario.ModRoot,ConcurrentModificationException.class),
    NonEmptyListModParentThrowCME(true,CMEScenario.ModParent,ConcurrentModificationException.class);
  
    final boolean nonEmpty;
    final CMEScenario modScenario;
    final Class<? extends Throwable> expectedException;
    CollectionAddValTestScenario(boolean nonEmpty,CMEScenario modScenario,Class<? extends Throwable> expectedException){
      this.expectedException=expectedException;
      this.nonEmpty=nonEmpty;
      this.modScenario=modScenario;
    }
  }
  static Stream<Arguments> getCollectionAddValArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for($ClassPrefix$InputTestArgType inputTestArgType:$ClassPrefix$InputTestArgType.values()){
      for(CollectionAddValTestScenario testScenario: CollectionAddValTestScenario.values()){
        for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5){
          if(testScenario.expectedException==null){
            builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(initialCapacity,StructType.UNCHECKEDLIST)));
            builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(initialCapacity,StructType.CHECKEDLIST)));
            builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(initialCapacity,StructType.UNCHECKEDSTACK)));
            builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(initialCapacity,StructType.CHECKEDSTACK)));
          }
        }
        for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5){
          for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5){
            for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5){
              for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5){
                builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,StructType.CHECKEDSUBLIST)));
                if(testScenario.expectedException==null){builder.add(Arguments.of(testScenario,inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,StructType.UNCHECKEDSUBLIST)));}
              }
            }
          }
        }
      }
    }
    return builder.build().parallel();
  }
  @ParameterizedTest
  @MethodSource("getCollectionAddValArgs")
  public void testCollectionadd_val(CollectionAddValTestScenario testScenario,$ClassPrefix$InputTestArgType inputArgType,ConstructionArguments constructionArgs){
    var testMonitor=new InputTestMonitor();
    if(testScenario.nonEmpty){for(int i=0;i<100;++i){testMonitor.collectionAdd(constructionArgs,inputArgType,i);}}
    var expectedException=testScenario.expectedException;
    if(expectedException==null){
      for(int i=0;i<100;++i){
        testMonitor.collectionAdd(constructionArgs,inputArgType,i);
        testMonitor.verifyStructuralIntegrity(constructionArgs);
      }
    }else{
      testMonitor.illegalMod(constructionArgs,inputArgType,testScenario.modScenario);
      Assertions.assertThrows(expectedException,()->inputArgType.callCollectionAdd(constructionArgs.seq,0));
      testMonitor.verifyStructuralIntegrity(constructionArgs);
    }
    int offset=constructionArgs.verifyPreAlloc();
    switch(testScenario){
      default:
        if(!testScenario.nonEmpty){break;}
      case HappyPath:
        offset=constructionArgs.verifyAscending(offset,inputArgType,100);
        break;
    }
    offset=constructionArgs.verifyParentPostAlloc(offset);
    if(testScenario.modScenario==CMEScenario.ModParent){offset=constructionArgs.verifyIndex(offset,inputArgType,0);}
    offset=constructionArgs.verifyRootPostAlloc(offset);
    if(testScenario.modScenario==CMEScenario.ModRoot){constructionArgs.verifyIndex(offset,inputArgType,0);}
  }
  @ParameterizedTest
  @MethodSource("getStackPushArgs")
  public void testpush_val_happyPath($ClassPrefix$InputTestArgType inputArgType,ConstructionArguments constructionArgs){
    for(int i=0;i<100;++i){inputArgType.callStackPush(constructionArgs.seq,i);}
    constructionArgs.verifyStructuralIntegrity(100,100);
    int offset=constructionArgs.verifyPreAlloc();
    offset=constructionArgs.verifyAscending(offset,inputArgType,100);
    offset=constructionArgs.verifyParentPostAlloc(offset);
    constructionArgs.verifyRootPostAlloc(offset);
  }
  static enum QueryCast{
    AsIs,
    ToBoxed,
    ToObject;
  }
  static void buildQueryArguments(Stream.Builder<Arguments> builder,StructType structType){
    for(QueryTestInputType argType:QueryTestInputType.values()){
        for(QueryCast queryCast:QueryCast.values()){
          if(structType==StructType.CHECKEDSUBLIST){
            for(CMEScenario modScenario:CMEScenario.values()){
              builder.add(Arguments.of(modScenario,queryCast,QueryTestScenario.EMPTY,argType,structType));
              builder.add(Arguments.of(modScenario,queryCast,QueryTestScenario.DOESNOTCONTAIN,argType,structType));
            }
          }else{
            builder.add(Arguments.of(CMEScenario.NoMod,queryCast,QueryTestScenario.EMPTY,argType,structType));
            builder.add(Arguments.of(CMEScenario.NoMod,queryCast,QueryTestScenario.DOESNOTCONTAIN,argType,structType));
          }
          switch(argType){
#IF OfRef
            case Booleannull:
            case Bytenull:
            case Characternull:
            case Shortnull:
            case Integernull:
            case Longnull:
            case Floatnull:
            case Doublenull:
            case Objectnull:
#ENDIF
            case Booleanfalse:
            case Byte0:
            case Character0:
            case Short0:
            case Integer0:
            case Long0:
            case Floatpos0:
            case Floatneg0:
            case Doublepos0:
            case Doubleneg0:
            case Booleantrue:
            case Bytepos1:
            case Characterpos1:
            case Shortpos1:
            case Integerpos1:
            case Longpos1:
            case Floatpos1:
            case Doublepos1:
#IFNOT OfBoolean
            //values beyond the range of boolean
            case Bytepos2:
            case Characterpos2:
            case Shortpos2:
            case Integerpos2:
            case Longpos2:
            case Floatpos2:
            case Doublepos2:
  #IFNOT OfChar
            //negative values beyond the range of char
            case Byteneg1:
            case Shortneg1:
            case Integerneg1:
            case Longneg1:
            case Floatneg1:
            case Doubleneg1:
    #IFNOT OfByte
            //negative values beyond the range of byte
            case ShortMIN_BYTE_MINUS1:
            case IntegerMIN_BYTE_MINUS1:
            case LongMIN_BYTE_MINUS1:
            case FloatMIN_BYTE_MINUS1:
            case DoubleMIN_BYTE_MINUS1:
      #IFNOT OfShort
            //negative values beyond the range of short
            case IntegerMIN_SHORT_MINUS1:
            case LongMIN_SHORT_MINUS1:
            case FloatMIN_SHORT_MINUS1:
            case DoubleMIN_SHORT_MINUS1:
        #IFNOT OfInt
            //negative values beyond the range of int
            case FloatMIN_INT_MINUS1:
          #IFNOT OfFloat
            //negative values beyond the range of int and beyond the precision of float
            case LongMIN_INT_MINUS1:
            case DoubleMIN_INT_MINUS1:
          #ENDIF
        #ENDIF
        #IFNOT OfFloat
            //negative values beyond MIN_SAFE_INT that are beyond the precision of float
            case IntegerMIN_SAFE_INT_MINUS1:
            case LongMIN_SAFE_INT_MINUS1:
            case DoubleMIN_SAFE_INT_MINUS1:
          #IFNOT OfInt,OfDouble
            //negative values beyond the range of int that are beyond the precision of float and double
            case LongMIN_SAFE_LONG_MINUS1:
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #IFNOT OfByte
            //positive values out of the range of byte
            case CharacterMAX_BYTE_PLUS1:
            case ShortMAX_BYTE_PLUS1:
            case IntegerMAX_BYTE_PLUS1:
            case LongMAX_BYTE_PLUS1:
            case FloatMAX_BYTE_PLUS1:
            case DoubleMAX_BYTE_PLUS1:
    #IFNOT OfShort
            //positive values out of the range of short
            case CharacterMAX_SHORT_PLUS1:
            case IntegerMAX_SHORT_PLUS1:
            case LongMAX_SHORT_PLUS1:
            case FloatMAX_SHORT_PLUS1:
            case DoubleMAX_SHORT_PLUS1:
      #IFNOT OfChar
            //positive values out of the range of char
            case IntegerMAX_CHAR_PLUS1:
            case LongMAX_CHAR_PLUS1:
            case FloatMAX_CHAR_PLUS1:
            case DoubleMAX_CHAR_PLUS1:
        #IFNOT OfInt
            //positive values out of the range of int
            case LongMAX_INT_PLUS1:
            case FloatMAX_INT_PLUS1:
            case DoubleMAX_INT_PLUS1:
        #ENDIF
        #IFNOT OfFloat
            //positive values beyond MAX_SAFE_INT that are beyond the precision of float
            case IntegerMAX_SAFE_INT_PLUS1:
            case LongMAX_SAFE_INT_PLUS1:
            case DoubleMAX_SAFE_INT_PLUS1:
          #IFNOT OfInt,OfDouble
            //positive values beyond the range of int that are beyond the precision of float and double
            case LongMAX_SAFE_LONG_PLUS1:
          #ENDIF
        #ENDIF
        #IFNOT OfInt,OfLong
            //floating-point values beyond the range any integral type
            case FloatMAX_LONG_PLUS1:
            case FloatMIN_LONG_MINUS1:
            case FloatMAX_FLOAT_VALUE:
            case DoubleMAX_FLOAT_VALUE:
            //fractional floating point values that cannot be matched with any integral type
            case FloatMIN_FLOAT_VALUE:
            case DoubleMIN_FLOAT_VALUE:
            //NaN values that can only be matches with NaN
            case FloatNaN:
            case DoubleNaN:
          #IFNOT OfFloat
            //double-precision floating-point values beyond the range of any integral type and beyond the precision of float
            case DoubleMAX_LONG_PLUS1:
            case DoubleMIN_LONG_MINUS1:
            case DoubleMAX_DOUBLE_VALUE:
            //fractional floating point values that cannot be matched with any integral type and which are beyond the precision of float
            case DoubleMIN_DOUBLE_VALUE:
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF  
#ENDIF
              //these input values cannot potentially return true
              if(structType==StructType.CHECKEDSUBLIST){
                for(CMEScenario modScenario:CMEScenario.values()){
                  builder.add(Arguments.of(modScenario,queryCast,QueryTestScenario.CONTAINSBEGINNING,argType,structType));
                  builder.add(Arguments.of(modScenario,queryCast,QueryTestScenario.CONTAINSMIDDLE,argType,structType));
                  builder.add(Arguments.of(modScenario,queryCast,QueryTestScenario.CONTAINSEND,argType,structType));
                }
              }else{
                builder.add(Arguments.of(CMEScenario.NoMod,queryCast,QueryTestScenario.CONTAINSBEGINNING,argType,structType));
                builder.add(Arguments.of(CMEScenario.NoMod,queryCast,QueryTestScenario.CONTAINSMIDDLE,argType,structType));
                builder.add(Arguments.of(CMEScenario.NoMod,queryCast,QueryTestScenario.CONTAINSEND,argType,structType));
              }
            default:
              //all other enumerated values MUST return false because they are either out of range or are too precise
          }
        }
      }
  }
  static Stream<Arguments> getQueryStackArguments(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(StructType structType:StructType.values()){
      switch(structType){
        default:
          continue;
        case CHECKEDSTACK:
        case UNCHECKEDSTACK:
      }
      buildQueryArguments(builder,structType);
    }
    return builder.build().parallel();
  }
  static Stream<Arguments> getQueryListArguments(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(StructType structType:StructType.values()){
      switch(structType){
        case CHECKEDSTACK:
        case UNCHECKEDSTACK:
          continue;
        default:
      }
      buildQueryArguments(builder,structType);
    }
    return builder.build().parallel();
  }
  static Stream<Arguments> getQueryCollectionArguments(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(StructType structType:StructType.values()){
      buildQueryArguments(builder,structType);
    }
    return builder.build().parallel();
  }
  
  
  
  private static boolean illegallyModForQuery(QueryCast queryCast,CMEScenario modScenario,QueryTestInputType inputArgType,QueryTestScenario testScenario,ConstructionArguments constructionArgs){
    boolean expectThrow=false;
    switch(modScenario){
      case ModParent:
      case ModRoot:
        #IF OfRef
          expectThrow=true;
        #ELSE
          switch(inputArgType){
            default:
              expectThrow=true;
              break;
            case Booleannull:
            case Bytenull:
            case Characternull:
            case Shortnull:
            case Integernull:
            case Longnull:
            case Floatnull:
            case Doublenull:
              expectThrow=(queryCast==QueryCast.ToObject);
          }
        #ENDIF
      default:
    }
    switch(modScenario){
      case ModParent:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.parent,0);
        break;
      case ModRoot:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.root,0);
        break;
      default:
    }
    return expectThrow;
  }
  private static ConstructionArguments initializeSeqForQuery(QueryTestScenario testScenario,QueryTestInputType inputArgType,StructType structType){
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    switch(testScenario){
      case CONTAINSBEGINNING:
        Assertions.assertTrue(inputArgType.attemptAdd(constructionArgs.seq));
        for(int i=1;i<100;++i){
          inputArgType.addNotEqualsVal(constructionArgs.seq);
        }
        break;
      case CONTAINSMIDDLE:
        for(int i=0;i<49;++i){
          inputArgType.addNotEqualsVal(constructionArgs.seq);
        }
        Assertions.assertTrue(inputArgType.attemptAdd(constructionArgs.seq));
        for(int i=50;i<100;++i){
          inputArgType.addNotEqualsVal(constructionArgs.seq);
        }
        break;
      case CONTAINSEND:
        for(int i=0;i<99;++i){
          inputArgType.addNotEqualsVal(constructionArgs.seq);
        }
        Assertions.assertTrue(inputArgType.attemptAdd(constructionArgs.seq));
        break;
      case DOESNOTCONTAIN:
        for(int i=0;i<100;++i){
          inputArgType.addNotEqualsVal(constructionArgs.seq);
        }
      default:
        break;
    }
    return constructionArgs;
  }
  private static void verifyQueryDidNotModify(CMEScenario modScenario,ConstructionArguments constructionArgs,QueryTestScenario testScenario){
    int offset=constructionArgs.verifyPreAlloc();
    if(testScenario==QueryTestScenario.EMPTY){
      switch(modScenario){
        case ModParent:
          constructionArgs.verifyStructuralIntegrity(0,0,1,1);
          offset=constructionArgs.verifyParentPostAlloc(offset);
          offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
          constructionArgs.verifyRootPostAlloc(offset);
          break;
        case ModRoot:
          constructionArgs.verifyStructuralIntegrity(0,0,0,0,1,1);
          offset=constructionArgs.verifyParentPostAlloc(offset);
          offset=constructionArgs.verifyRootPostAlloc(offset);
          constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
          break;
        default:
          constructionArgs.verifyStructuralIntegrity(0,0);
          offset=constructionArgs.verifyParentPostAlloc(offset);
          constructionArgs.verifyRootPostAlloc(offset);
      }
    }else{
      switch(modScenario){
        case ModParent:
          constructionArgs.verifyStructuralIntegrity(100,100,101,101);
          offset=constructionArgs.verifyParentPostAlloc(offset+100);
          offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
          constructionArgs.verifyRootPostAlloc(offset);
          break;
        case ModRoot:
          constructionArgs.verifyStructuralIntegrity(100,100,100,100,101,101);
          offset=constructionArgs.verifyParentPostAlloc(offset+100);
          offset=constructionArgs.verifyRootPostAlloc(offset);
          constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
          break;
        default:
          constructionArgs.verifyStructuralIntegrity(100,100);
          offset=constructionArgs.verifyParentPostAlloc(offset+100);
          constructionArgs.verifyRootPostAlloc(offset);
      }
    }
  }
  static enum ObjModScenario{
    ModSeq,
    ModParent,
    ModRoot,
    ModSeqThrow,
    ModParentThrow,
    ModRootThrow,
    NoMod,
    Throw;
  }
  private static class ModCheckTestData{
    final ModCheckTestObject modCheckTestObject;
    final ConstructionArguments constructionArgs;
    ModCheckTestData(ModCheckTestObject modCheckTestObject,ConstructionArguments constructionArgs){
      this.modCheckTestObject=modCheckTestObject;
      this.constructionArgs=constructionArgs;
    }
  }
#IF OfRef
  private static ModCheckTestData initializeSeqForModCheckQueryTest(QueryTestScenario testScenario,StructType structType,ObjModScenario objModScenario){
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    ModCheckTestObject modCheckTestObject;
    switch(objModScenario){
      case ModSeq:
        modCheckTestObject=new ModCheckTestObject.Modding(constructionArgs.seq);
        break;
      case ModParent:
        modCheckTestObject=new ModCheckTestObject.Modding(constructionArgs.parent);
        break;
      case ModRoot:
        modCheckTestObject=new ModCheckTestObject.Modding(constructionArgs.root);
        break;
      case ModSeqThrow:
        modCheckTestObject=new ModCheckTestObject.ModdingAndThrowing(constructionArgs.seq);
        break;
      case ModParentThrow:
        modCheckTestObject=new ModCheckTestObject.ModdingAndThrowing(constructionArgs.seq);
        break;
      case ModRootThrow:
        modCheckTestObject=new ModCheckTestObject.ModdingAndThrowing(constructionArgs.seq);
        break;
      default:
        modCheckTestObject=new ModCheckTestObject();
    }
    switch(testScenario){
      case CONTAINSBEGINNING:
        Assertions.assertTrue(((OmniCollection.OfRef)constructionArgs.seq).add(modCheckTestObject));
        for(int i=1;i<100;++i){
          ((OmniCollection.OfRef)constructionArgs.seq).add(Boolean.FALSE);
        }
        break;
      case CONTAINSMIDDLE:
        for(int i=0;i<49;++i){
          ((OmniCollection.OfRef)constructionArgs.seq).add(Boolean.FALSE);
        }
        Assertions.assertTrue(((OmniCollection.OfRef)constructionArgs.seq).add(modCheckTestObject));
        for(int i=50;i<100;++i){
          ((OmniCollection.OfRef)constructionArgs.seq).add(Boolean.FALSE);
        }
        break;
      case CONTAINSEND:
        for(int i=0;i<99;++i){
          ((OmniCollection.OfRef)constructionArgs.seq).add(Boolean.FALSE);
        }
        Assertions.assertTrue(((OmniCollection.OfRef)constructionArgs.seq).add(modCheckTestObject));
        break;
      case DOESNOTCONTAIN:
        for(int i=0;i<100;++i){
          ((OmniCollection.OfRef)constructionArgs.seq).add(Boolean.FALSE);
        }
      default:
        break;
    }
    return new ModCheckTestData(modCheckTestObject,constructionArgs);
  }
  private static Class<? extends Throwable> illegallyModForQuery(CMEScenario preModScenario,ConstructionArguments constructionArgs,QueryTestScenario testScenario,ObjModScenario objModScenario){
    switch(preModScenario){
      default:
        if(testScenario==QueryTestScenario.EMPTY){
          return null;
        }
        if(objModScenario==ObjModScenario.Throw){
          return IndexOutOfBoundsException.class;
        }
      case ModParent:
      case ModRoot:
    }
    switch(preModScenario){
      case ModParent:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.parent,0);
        break;
      case ModRoot:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.root,0);
      default:
    }
    return ConcurrentModificationException.class;
  }
  private static void buildModCheckQueryTestArgs(Stream.Builder<Arguments> builder,StructType structType){
    for(QueryTestScenario testScenario:QueryTestScenario.values()){
      if(structType==StructType.CHECKEDSUBLIST){
        builder.add(Arguments.of(ObjModScenario.ModRoot,CMEScenario.ModRoot,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModParent,CMEScenario.ModRoot,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModSeq,CMEScenario.ModRoot,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModRootThrow,CMEScenario.ModRoot,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModParentThrow,CMEScenario.ModRoot,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModSeqThrow,CMEScenario.ModRoot,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.Throw,CMEScenario.ModRoot,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModRoot,CMEScenario.ModParent,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModParent,CMEScenario.ModParent,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModSeq,CMEScenario.ModParent,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModRootThrow,CMEScenario.ModParent,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModParentThrow,CMEScenario.ModParent,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.ModSeqThrow,CMEScenario.ModParent,testScenario,structType));
        builder.add(Arguments.of(ObjModScenario.Throw,CMEScenario.ModParent,testScenario,structType));
      }
      builder.add(Arguments.of(ObjModScenario.ModSeq,CMEScenario.NoMod,testScenario,structType));
      builder.add(Arguments.of(ObjModScenario.ModSeqThrow,CMEScenario.NoMod,testScenario,structType));
      builder.add(Arguments.of(ObjModScenario.Throw,CMEScenario.NoMod,testScenario,structType));
    }
  }
  static Stream<Arguments> getCollectionModCheckQueryTestArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    buildModCheckQueryTestArgs(builder,StructType.CHECKEDLIST);
    buildModCheckQueryTestArgs(builder,StructType.CHECKEDSUBLIST);
    buildModCheckQueryTestArgs(builder,StructType.CHECKEDSTACK);
    return builder.build().parallel();
  }
  static Stream<Arguments> getStackModCheckQueryTestArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    buildModCheckQueryTestArgs(builder,StructType.CHECKEDSTACK);
    return builder.build().parallel();
  }
  static Stream<Arguments> getListModCheckQueryTestArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    buildModCheckQueryTestArgs(builder,StructType.CHECKEDLIST);
    buildModCheckQueryTestArgs(builder,StructType.CHECKEDSUBLIST);
    return builder.build().parallel();
  }
  private static void verifyQueryDidNotModify(ModCheckTestData moddingObjectData,int numAdded,ObjModScenario objModScenario,CMEScenario preModScenario)
  {
      ModCheckTestObject modCheckTestObject=moddingObjectData.modCheckTestObject;
      ConstructionArguments constructionArgs=moddingObjectData.constructionArgs;
      int numCalls=modCheckTestObject.numCalls;
      int offset=constructionArgs.verifyPreAlloc();
      offset+=numAdded;
      switch(preModScenario){
        case ModRoot:
          if(objModScenario!=ObjModScenario.ModRoot){
            numCalls=0;
          }
          constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded,numAdded,numAdded+numCalls+1,numAdded+numCalls+1);
          offset=constructionArgs.verifyParentPostAlloc(offset);
          offset=constructionArgs.verifyRootPostAlloc(offset);
          offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
          break;
        case ModParent:
          switch(objModScenario){
            case ModRootThrow:
            case ModRoot:
              if(objModScenario==ObjModScenario.ModRootThrow){
                 numCalls=0;
               }
              constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded+1,numAdded+1,numAdded+numCalls+1,numAdded+numCalls+1);
              offset=constructionArgs.verifyParentPostAlloc(offset);
              break;
            case ModParentThrow:
            case ModParent:
               if(objModScenario==ObjModScenario.ModParentThrow){
                 numCalls=0;
               }
              constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded+numCalls+1,numAdded+numCalls+1,numAdded+numCalls+1,numAdded+numCalls+1);
              offset=constructionArgs.verifyParentPostAlloc(offset);
              for(int i=0;i<numCalls;++i)
              {
                offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
              }
              break;
            case ModSeqThrow:
            case ModSeq:
            case Throw:
               constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded+1,numAdded+1,numAdded+1,numAdded+1);
               offset=constructionArgs.verifyParentPostAlloc(offset);
               break;
            }
            offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
            offset=constructionArgs.verifyRootPostAlloc(offset);
            break;
        default:
            switch(objModScenario){
              case ModRoot:
                constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded,numAdded,numAdded+numCalls,numAdded+numCalls);
                offset=constructionArgs.verifyParentPostAlloc(offset);
                offset=constructionArgs.verifyRootPostAlloc(offset);
                for(int i=0;i<numCalls;++i){
                  offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
                }
                break;
              case ModParentThrow:
              case ModParent:
                constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls);
                offset=constructionArgs.verifyParentPostAlloc(offset);
                for(int i=0;i<numCalls;++i)
                {
                  offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
                }
                offset=constructionArgs.verifyRootPostAlloc(offset);
                break;
              case ModSeqThrow:
              case ModSeq:
                for(int i=0;i<numCalls;++i)
                {
                  offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
                }
                constructionArgs.verifyStructuralIntegrity(numAdded+numCalls,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls); 
                offset=constructionArgs.verifyParentPostAlloc(offset);
                offset=constructionArgs.verifyRootPostAlloc(offset);
                break;
              default:
                constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded,numAdded,numAdded,numAdded);
                offset=constructionArgs.verifyParentPostAlloc(offset);
                offset=constructionArgs.verifyRootPostAlloc(offset);
            }
      }
  }
  @ParameterizedTest
  @MethodSource("getStackModCheckQueryTestArgs")
  public void testsearch_val_ModCheckScenarios(ObjModScenario objModScenario,CMEScenario preModScenario,QueryTestScenario testScenario,StructType structType){
    ModCheckTestData moddingObjectData=initializeSeqForModCheckQueryTest(testScenario,structType,objModScenario);
    ModCheckTestObject modCheckTestObject=moddingObjectData.modCheckTestObject;
    ConstructionArguments constructionArgs=moddingObjectData.constructionArgs;
    var expectedException=illegallyModForQuery(preModScenario,constructionArgs,testScenario,objModScenario);
    if(expectedException==null){
      Assertions.assertEquals(-1,((OmniStack)constructionArgs.seq).search(modCheckTestObject));
      constructionArgs.verifyStructuralIntegrity(0,0);
    }else{
      Assertions.assertThrows(expectedException,()->((OmniStack)constructionArgs.seq).search(modCheckTestObject));
      verifyQueryDidNotModify(moddingObjectData,testScenario==QueryTestScenario.EMPTY?0:100,objModScenario,preModScenario);
    }
  }

  
  @ParameterizedTest
  @MethodSource("getListModCheckQueryTestArgs")
  public void testlastIndexOf_val_ModCheckScenarios(ObjModScenario objModScenario,CMEScenario preModScenario,QueryTestScenario testScenario,StructType structType){
    ModCheckTestData moddingObjectData=initializeSeqForModCheckQueryTest(testScenario,structType,objModScenario);
    ModCheckTestObject modCheckTestObject=moddingObjectData.modCheckTestObject;
    ConstructionArguments constructionArgs=moddingObjectData.constructionArgs;
    var expectedException=illegallyModForQuery(preModScenario,constructionArgs,testScenario,objModScenario);
    if(expectedException==null)
    {
      Assertions.assertEquals(-1,((OmniList)constructionArgs.seq).lastIndexOf(modCheckTestObject));
      int offset=constructionArgs.verifyPreAlloc();
      offset=constructionArgs.verifyParentPostAlloc(offset);
      constructionArgs.verifyRootPostAlloc(offset);
    }else{
      Assertions.assertThrows(expectedException,()->((OmniList)constructionArgs.seq).lastIndexOf(modCheckTestObject));
      verifyQueryDidNotModify(moddingObjectData,testScenario==QueryTestScenario.EMPTY?0:100,objModScenario,preModScenario);
    }
  }
  @ParameterizedTest
  @MethodSource("getListModCheckQueryTestArgs")
  public void testindexOf_val_ModCheckScenarios(ObjModScenario objModScenario,CMEScenario preModScenario,QueryTestScenario testScenario,StructType structType)
  {
    ModCheckTestData moddingObjectData=initializeSeqForModCheckQueryTest(testScenario,structType,objModScenario);
    ModCheckTestObject modCheckTestObject=moddingObjectData.modCheckTestObject;
    ConstructionArguments constructionArgs=moddingObjectData.constructionArgs;
    var expectedException=illegallyModForQuery(preModScenario,constructionArgs,testScenario,objModScenario);
    if(expectedException==null)
    {
      Assertions.assertEquals(-1,((OmniList)constructionArgs.seq).indexOf(modCheckTestObject));
      int offset=constructionArgs.verifyPreAlloc();
      offset=constructionArgs.verifyParentPostAlloc(offset);
      constructionArgs.verifyRootPostAlloc(offset);
    }else{
      Assertions.assertThrows(expectedException,()->((OmniList)constructionArgs.seq).indexOf(modCheckTestObject));
      verifyQueryDidNotModify(moddingObjectData,testScenario==QueryTestScenario.EMPTY?0:100,objModScenario,preModScenario);
    }
  }
  
  
  @ParameterizedTest
  @MethodSource("getCollectionModCheckQueryTestArgs")
  public void testcontains_val_ModCheckScenarios(ObjModScenario objModScenario,CMEScenario preModScenario,QueryTestScenario testScenario,StructType structType)
  {
    ModCheckTestData moddingObjectData=initializeSeqForModCheckQueryTest(testScenario,structType,objModScenario);
    ModCheckTestObject modCheckTestObject=moddingObjectData.modCheckTestObject;
    ConstructionArguments constructionArgs=moddingObjectData.constructionArgs;
    var expectedException=illegallyModForQuery(preModScenario,constructionArgs,testScenario,objModScenario);
    if(expectedException==null)
    {
      Assertions.assertFalse(constructionArgs.seq.contains(modCheckTestObject));
      int offset=constructionArgs.verifyPreAlloc();
      offset=constructionArgs.verifyParentPostAlloc(offset);
      constructionArgs.verifyRootPostAlloc(offset);
    }else{
      Assertions.assertThrows(expectedException,()->constructionArgs.seq.contains(modCheckTestObject));
      verifyQueryDidNotModify(moddingObjectData,testScenario==QueryTestScenario.EMPTY?0:100,objModScenario,preModScenario);
    }
  }
  @ParameterizedTest
  @MethodSource("getCollectionModCheckQueryTestArgs")
  public void testremoveVal_val_ModCheckScenarios(ObjModScenario objModScenario,CMEScenario preModScenario,QueryTestScenario testScenario,StructType structType)
  {
    ModCheckTestData moddingObjectData=initializeSeqForModCheckQueryTest(testScenario,structType,objModScenario);
    ModCheckTestObject modCheckTestObject=moddingObjectData.modCheckTestObject;
    ConstructionArguments constructionArgs=moddingObjectData.constructionArgs;
    var expectedException=illegallyModForQuery(preModScenario,constructionArgs,testScenario,objModScenario);
    if(expectedException==null)
    {
      Assertions.assertFalse(constructionArgs.seq.remove(modCheckTestObject));
      int offset=constructionArgs.verifyPreAlloc();
      offset=constructionArgs.verifyParentPostAlloc(offset);
      constructionArgs.verifyRootPostAlloc(offset);
    }else{
      Assertions.assertThrows(expectedException,()->constructionArgs.seq.remove(modCheckTestObject));
      verifyQueryDidNotModify(moddingObjectData,testScenario==QueryTestScenario.EMPTY?0:100,objModScenario,preModScenario);
    }
  }
#ENDIF
  

  @ParameterizedTest
  @MethodSource("getQueryListArguments")
  public void testindexOf_val(CMEScenario modScenario,QueryCast queryCast,QueryTestScenario testScenario,QueryTestInputType inputArgType,StructType structType){
    ConstructionArguments constructionArgs=initializeSeqForQuery(testScenario,inputArgType,structType);
    boolean expectThrow=illegallyModForQuery(queryCast,modScenario,inputArgType,testScenario,constructionArgs);
    int expectedRet;
    switch(testScenario){
      case CONTAINSBEGINNING:
        expectedRet=0;
        break;
      case CONTAINSMIDDLE:
        expectedRet=49;
        break;
      case CONTAINSEND:
        expectedRet=99;
        break;
      default:
        expectedRet=-1;
    }
    switch(queryCast){
      case ToBoxed:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeBoxedindexOf(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeBoxedindexOf(constructionArgs.seq));
        }
        break;
      case ToObject:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeObjectindexOf(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeObjectindexOf(constructionArgs.seq));
        }
        break;
      case AsIs:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeindexOf(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeindexOf(constructionArgs.seq));
        }
    }
    verifyQueryDidNotModify(modScenario,constructionArgs,testScenario);
  }
  @ParameterizedTest
  @MethodSource("getQueryListArguments")
  public void testlastIndexOf_val(CMEScenario modScenario,QueryCast queryCast,QueryTestScenario testScenario,QueryTestInputType inputArgType,StructType structType){
    ConstructionArguments constructionArgs=initializeSeqForQuery(testScenario,inputArgType,structType);
    boolean expectThrow=illegallyModForQuery(queryCast,modScenario,inputArgType,testScenario,constructionArgs);
    int expectedRet;
    switch(testScenario){
      case CONTAINSBEGINNING:
        expectedRet=0;
        break;
      case CONTAINSMIDDLE:
        expectedRet=49;
        break;
      case CONTAINSEND:
        expectedRet=99;
        break;
      default:
        expectedRet=-1;
    }
    switch(queryCast){
      case ToBoxed:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeBoxedlastIndexOf(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeBoxedlastIndexOf(constructionArgs.seq));
        }
        break;
      case ToObject:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeObjectlastIndexOf(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeObjectlastIndexOf(constructionArgs.seq));
        }
        break;
      case AsIs:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokelastIndexOf(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokelastIndexOf(constructionArgs.seq));
        }
    }
    verifyQueryDidNotModify(modScenario,constructionArgs,testScenario);
  }
  @ParameterizedTest
  @MethodSource("getQueryStackArguments")
  public void testsearch_val(CMEScenario modScenario,QueryCast queryCast,QueryTestScenario testScenario,QueryTestInputType inputArgType,StructType structType){
    ConstructionArguments constructionArgs=initializeSeqForQuery(testScenario,inputArgType,structType);
    int expectedRet;
    switch(testScenario){
      case CONTAINSBEGINNING:
        expectedRet=100;
        break;
      case CONTAINSMIDDLE:
        expectedRet=51;
        break;
      case CONTAINSEND:
        expectedRet=1;
        break;
      default:
        expectedRet=-1;
    }
    switch(queryCast){
    case ToBoxed:
      Assertions.assertEquals(expectedRet,inputArgType.invokeBoxedsearch(constructionArgs.seq));
      break;
    case ToObject:
      Assertions.assertEquals(expectedRet,inputArgType.invokeObjectsearch(constructionArgs.seq));
      break;
    case AsIs:
      Assertions.assertEquals(expectedRet,inputArgType.invokesearch(constructionArgs.seq));
    }
    verifyQueryDidNotModify(modScenario,constructionArgs,testScenario);
  }
  @ParameterizedTest
  @MethodSource("getQueryCollectionArguments")
  public void testcontains_val(CMEScenario modScenario,QueryCast queryCast,QueryTestScenario testScenario,QueryTestInputType inputArgType,StructType structType){
    ConstructionArguments constructionArgs=initializeSeqForQuery(testScenario,inputArgType,structType);
    boolean expectThrow=illegallyModForQuery(queryCast,modScenario,inputArgType,testScenario,constructionArgs);
    boolean expectedRet;
    switch(testScenario){
      case CONTAINSBEGINNING:
      case CONTAINSMIDDLE:
      case CONTAINSEND:
        expectedRet=true;
        break;
      default:
        expectedRet=false;
    }
    switch(queryCast){
      case ToBoxed:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeBoxedcontains(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeBoxedcontains(constructionArgs.seq));
        }
        break;
      case ToObject:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeObjectcontains(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeObjectcontains(constructionArgs.seq));
        }
        break;
      case AsIs:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokecontains(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokecontains(constructionArgs.seq));
        }
    }
    verifyQueryDidNotModify(modScenario,constructionArgs,testScenario);
  }
  @ParameterizedTest
  @MethodSource("getQueryCollectionArguments")
  public void testremoveVal_val(CMEScenario modScenario,QueryCast queryCast,QueryTestScenario testScenario,QueryTestInputType inputArgType,StructType structType){
    ConstructionArguments constructionArgs=initializeSeqForQuery(testScenario,inputArgType,structType);
    boolean expectThrow=illegallyModForQuery(queryCast,modScenario,inputArgType,testScenario,constructionArgs);
    boolean expectedRet;
    switch(testScenario){
      case CONTAINSBEGINNING:
      case CONTAINSMIDDLE:
      case CONTAINSEND:
        expectedRet=true;
        break;
      default:
        expectedRet=false;
    }
    switch(queryCast){
      case ToBoxed:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeBoxedremoveVal(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeBoxedremoveVal(constructionArgs.seq));
          Assertions.assertFalse(inputArgType.invokeBoxedcontains(constructionArgs.seq));
        }
        break;
      case ToObject:
       if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeObjectremoveVal(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeObjectremoveVal(constructionArgs.seq));
          Assertions.assertFalse(inputArgType.invokeObjectcontains(constructionArgs.seq));
        }
        break;
      case AsIs:
        if(expectThrow){
          Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.invokeremoveVal(constructionArgs.seq));
        }else{
          Assertions.assertEquals(expectedRet,inputArgType.invokeremoveVal(constructionArgs.seq));
          Assertions.assertFalse(inputArgType.invokecontains(constructionArgs.seq));
        }
    }
    int offset=constructionArgs.verifyPreAlloc();
    switch(modScenario){
      case ModParent:
        if(testScenario==QueryTestScenario.EMPTY){
          constructionArgs.verifyStructuralIntegrity(0,0,1,1);
        }else{
          constructionArgs.verifyStructuralIntegrity(100,100,101,101);
          offset+=100;
        }
        offset=constructionArgs.verifyParentPostAlloc(offset);
        offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
        constructionArgs.verifyRootPostAlloc(offset);
        break;
      case ModRoot:
        if(testScenario==QueryTestScenario.EMPTY){
          constructionArgs.verifyStructuralIntegrity(0,0,0,0,1,1);
        }else{
          constructionArgs.verifyStructuralIntegrity(100,100,100,100,101,101);
          offset+=100;
        }
        offset=constructionArgs.verifyParentPostAlloc(offset);
        offset=constructionArgs.verifyRootPostAlloc(offset);
        constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
        break;
      case NoMod:
        switch(testScenario){
          case DOESNOTCONTAIN:
            constructionArgs.verifyStructuralIntegrity(100,100);
            offset=constructionArgs.verifyParentPostAlloc(offset+100);
            constructionArgs.verifyRootPostAlloc(offset);
            break;
          case EMPTY:
            constructionArgs.verifyStructuralIntegrity(0,0);
            offset=constructionArgs.verifyParentPostAlloc(offset);
            constructionArgs.verifyRootPostAlloc(offset);
            break;
          case CONTAINSBEGINNING:
          case CONTAINSMIDDLE:
          case CONTAINSEND:
            constructionArgs.verifyStructuralIntegrity(99,101);
            offset=constructionArgs.verifyParentPostAlloc(offset+99);
            offset=constructionArgs.verifyRootPostAlloc(offset);
#IF OfRef
            Assertions.assertTrue(constructionArgs.root.arr[offset]==null);
#ENDIF
        }
    }
  }
  static Stream<Arguments> getBasicCollectionTestArguments(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(StructType structType:StructType.values()){
      builder.add(Arguments.of(structType,0,CMEScenario.NoMod));
      builder.add(Arguments.of(structType,100,CMEScenario.NoMod));
      if(structType==StructType.CHECKEDSUBLIST){
        builder.add(Arguments.of(structType,0,CMEScenario.ModParent));
        builder.add(Arguments.of(structType,100,CMEScenario.ModParent));
        builder.add(Arguments.of(structType,0,CMEScenario.ModRoot));
        builder.add(Arguments.of(structType,100,CMEScenario.ModRoot));
      }
    }
    return builder.build().parallel();
  }
  static void illegallyMod(CMEScenario modScenario,ConstructionArguments constructionArgs){
    switch(modScenario){
      case ModSeq:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.seq,0);
        break;
      case ModParent:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.parent,0);
        break;
      case ModRoot:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.root,0);
        break;
      default:
    }
  }
  @ParameterizedTest
  @MethodSource("getBasicCollectionTestArguments")
  public void testclear_void(StructType structType,int numToAdd,CMEScenario modScenario){
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    for(int i=0;i<numToAdd;++i){
      $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.seq,i);
    }
    illegallyMod(modScenario,constructionArgs);
    if(modScenario==CMEScenario.NoMod){
      Assertions.assertDoesNotThrow(()->constructionArgs.seq.clear());
      if(numToAdd==0){
        constructionArgs.verifyStructuralIntegrity(0,0);
      }else{
        constructionArgs.verifyStructuralIntegrity(0,numToAdd+1);
      }
      int offset=constructionArgs.verifyPreAlloc();
      offset=constructionArgs.verifyParentPostAlloc(offset);
      offset=constructionArgs.verifyRootPostAlloc(offset);
#IF OfRef
      verifyRangeIsNull(constructionArgs.root.arr,offset,offset+numToAdd);
#ENDIF
    }else{
      Assertions.assertThrows(ConcurrentModificationException.class,()->constructionArgs.seq.clear());
      if(modScenario==CMEScenario.ModParent){
        constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd+1,numToAdd+1);
      }else{
        constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd,numToAdd,numToAdd+1,numToAdd+1);
      }
      int offset=constructionArgs.verifyPreAlloc();
      offset=constructionArgs.verifyAscending(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,numToAdd);
      offset=constructionArgs.verifyParentPostAlloc(offset);
      if(modScenario==CMEScenario.ModParent){offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
      offset=constructionArgs.verifyRootPostAlloc(offset);
      if(modScenario==CMEScenario.ModRoot){constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
    }
  }
  @ParameterizedTest
  @MethodSource("getBasicCollectionTestArguments")
  public void testclone_void(StructType structType,int numToAdd,CMEScenario modScenario){
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    for(int i=0;i<numToAdd;++i){
      $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.seq,i);
    }
    illegallyMod(modScenario,constructionArgs);
    if(modScenario==CMEScenario.NoMod){
      var clone=constructionArgs.seq.clone();
      constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd);
      Assertions.assertNotSame(constructionArgs.seq,clone);
      Assertions.assertNotSame(constructionArgs.parent,clone);
      Assertions.assertNotSame(constructionArgs.root,clone);
      switch(structType)
      {
        case CHECKEDLIST:
        case CHECKEDSUBLIST:
          Assertions.assertTrue(clone instanceof $ClassPrefix$ArrSeq.CheckedList);
          Assertions.assertEquals(0,(($ClassPrefix$ArrSeq.CheckedList)clone).modCount);
          break;
        case UNCHECKEDLIST:
        case UNCHECKEDSUBLIST:
          Assertions.assertTrue(clone instanceof $ClassPrefix$ArrSeq.UncheckedList);
          break;
        case CHECKEDSTACK:
          Assertions.assertTrue(clone instanceof $ClassPrefix$ArrSeq.CheckedStack);
          Assertions.assertEquals(0,(($ClassPrefix$ArrSeq.CheckedStack)clone).modCount);
          break;
        case UNCHECKEDSTACK:
          Assertions.assertTrue(clone instanceof $ClassPrefix$ArrSeq.UncheckedStack);
      }
      var cloneArr=(($ClassPrefix$ArrSeq)clone).arr;
      var cloneSize=(($ClassPrefix$ArrSeq)clone).size;
      Assertions.assertEquals(numToAdd,cloneSize);
      if(numToAdd==0)
      {
        Assertions.assertSame(OmniArray.Of$ClassPrefix$.DEFAULT_ARR,cloneArr);
      }
      else
      {
        Assertions.assertNotSame(constructionArgs.root.arr,cloneArr);
        Assertions.assertEquals(numToAdd,cloneArr.length);
        for(int i=0;i<numToAdd;++i)
        {
          #IF OfRef
          Assertions.assertSame(constructionArgs.root.arr[i+constructionArgs.rootPreAlloc+constructionArgs.parentPreAlloc],cloneArr[i]);
          #ELSE
          Assertions.assertEquals(constructionArgs.root.arr[i+constructionArgs.rootPreAlloc+constructionArgs.parentPreAlloc],cloneArr[i]);
          #ENDIF
        }
      }
    }
    else
    {
      Assertions.assertThrows(ConcurrentModificationException.class,()->constructionArgs.seq.clone());
      if(modScenario==CMEScenario.ModParent)
      {
        constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd+1,numToAdd+1);
      }
      else
      {
        constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd,numToAdd,numToAdd+1,numToAdd+1);
      }
    }
    int offset=constructionArgs.verifyPreAlloc();
    offset=constructionArgs.verifyAscending(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,numToAdd);
    offset=constructionArgs.verifyParentPostAlloc(offset);
    if(modScenario==CMEScenario.ModParent){offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
    offset=constructionArgs.verifyRootPostAlloc(offset);
    if(modScenario==CMEScenario.ModRoot){constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
  }
  static Stream<Arguments> getToArrayArrayArguments()
  {
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var structType:StructType.values()){
      for(var preModScenario:CMEScenario.values()){
        if(preModScenario==CMEScenario.ModSeq || (preModScenario!=CMEScenario.NoMod && structType!=StructType.CHECKEDSUBLIST)){
          continue;
        }
        builder.add(Arguments.of(0,0,structType,preModScenario));
        builder.add(Arguments.of(0,5,structType,preModScenario));
        builder.add(Arguments.of(3,5,structType,preModScenario));
        builder.add(Arguments.of(5,5,structType,preModScenario));
        builder.add(Arguments.of(8,5,structType,preModScenario));
      }
    }
    return builder.build().parallel();
  }
  @ParameterizedTest
  @MethodSource("getToArrayArrayArguments")
  public void testtoArray_ObjectArray(int seqSize,int arrayLength,StructType structType,CMEScenario preModScenario)
  {
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    for(int i=0;i<seqSize;++i)
    {
      $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.seq,i);
    }
    illegallyMod(preModScenario,constructionArgs);
    #IF OfRef
    final Integer[] paramArr=new Integer[arrayLength];
    #ELSE
    final $BoxedType$[] paramArr=new $BoxedType$[arrayLength];
    #ENDIF
    for(int i=0;i<arrayLength;++i)
    {
      #IF OfRef
      paramArr[i]=TypeConversionUtil.convertTo$ArrayType$(100);
      #ELSE
      paramArr[i]=TypeConversionUtil.convertTo$BoxedType$(100);
      #ENDIF
    }
    switch(preModScenario)
    {
      case ModParent:
      {
        Assertions.assertThrows(ConcurrentModificationException.class,()->constructionArgs.seq.toArray(paramArr));
        constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize+1,seqSize+1);
        for(int i=0;i<arrayLength;++i)
        {
          #IF OfRef
          Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(100),paramArr[i]);
          #ELSE
          Assertions.assertEquals(TypeConversionUtil.convertTo$BoxedType$(100),paramArr[i]);
          #ENDIF
        }
        break;
      }
      case ModRoot:
      {
        Assertions.assertThrows(ConcurrentModificationException.class,()->constructionArgs.seq.toArray(paramArr));
        constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize,seqSize,seqSize+1,seqSize+1);
        for(int i=0;i<arrayLength;++i)
        {
          #IF OfRef
          Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(100),paramArr[i]);
          #ELSE
          Assertions.assertEquals(TypeConversionUtil.convertTo$BoxedType$(100),paramArr[i]);
          #ENDIF
        }
        break;
      }
      default:
      {
        Object[] outputArr=constructionArgs.seq.toArray(paramArr);
        constructionArgs.verifyStructuralIntegrity(seqSize,seqSize);
        if(seqSize<arrayLength)
        {
          
          Assertions.assertSame(outputArr,paramArr);
          Assertions.assertNull(outputArr[seqSize]);
          for(int i=seqSize+1;i<arrayLength;++i)
          {
            #IF OfRef
            Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(100),outputArr[i]);
            #ELSE
            Assertions.assertEquals(TypeConversionUtil.convertTo$BoxedType$(100),outputArr[i]);
            #ENDIF
          }
        }
        else if(seqSize==arrayLength)
        {
          Assertions.assertSame(outputArr,paramArr);
        }
        else
        {
          Assertions.assertNotSame(outputArr,paramArr);
          for(int i=0;i<arrayLength;++i)
          {
            #IF OfRef
            Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(100),paramArr[i]);
            #ELSE
            Assertions.assertEquals(TypeConversionUtil.convertTo$BoxedType$(100),paramArr[i]);
            #ENDIF
          }
          Assertions.assertEquals(seqSize,outputArr.length);
        }
        var itr=constructionArgs.seq.iterator();
        for(int i=0;i<seqSize;++i)
        {
        #IF OfRef
          Assertions.assertSame(itr.next(),outputArr[i]);
        #ELSE
          Assertions.assertEquals(itr.next(),outputArr[i]);
        #ENDIF
        }
      }
    }
    int offset=constructionArgs.verifyPreAlloc();
    offset=constructionArgs.verifyAscending(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,seqSize);
    offset=constructionArgs.verifyParentPostAlloc(offset);
    if(preModScenario==CMEScenario.ModParent){offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
    offset=constructionArgs.verifyRootPostAlloc(offset);
    if(preModScenario==CMEScenario.ModRoot){offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
  }
  
  static Stream<Arguments> getSizeAndIsEmptyTestArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var structType:StructType.values()){
      for(var preModScenario:CMEScenario.values()){
        if(preModScenario==CMEScenario.ModSeq || (preModScenario!=CMEScenario.NoMod && structType!=StructType.CHECKEDSUBLIST)){
          continue;
        }
        builder.add(Arguments.of(0,structType,preModScenario));
        builder.add(Arguments.of(100,structType,preModScenario));
      }
    }
    return builder.build().parallel();
  }
  @ParameterizedTest
  @MethodSource("getSizeAndIsEmptyTestArgs")
  public void testsize_void(int numToAdd,StructType structType,CMEScenario preModScenario)
  {
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    for(int i=0;i<numToAdd;++i)
    {
      $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.seq,i);
    }
    illegallyMod(preModScenario,constructionArgs);
    switch(preModScenario)
    {
      case ModParent:
      {
        Assertions.assertThrows(ConcurrentModificationException.class,()->constructionArgs.seq.size());
        constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd+1,numToAdd+1);
        break;
      }
      case ModRoot:
      {
        Assertions.assertThrows(ConcurrentModificationException.class,()->constructionArgs.seq.size());
        constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd,numToAdd,numToAdd+1,numToAdd+1);
        break;
      }
      default:
      {
        
        for(int i=0;i<numToAdd;++i)
        {
          Assertions.assertEquals(numToAdd-i,constructionArgs.seq.size());
          constructionArgs.verifyStructuralIntegrity(numToAdd-i,i+numToAdd);
          switch(structType)
          {
            case CHECKEDSTACK:
            case UNCHECKEDSTACK:
              ((OmniStack.Of$ClassPrefix$)constructionArgs.seq).pop$TypeNameModifier$();
              break;
            default:
              ((OmniList.Of$ClassPrefix$)constructionArgs.seq).$removeAtIndexMethod$(numToAdd-i-1);
          }
        }
        Assertions.assertEquals(0,constructionArgs.seq.size());
        constructionArgs.verifyStructuralIntegrity(0,numToAdd*2);
      }
    }
    int offset=constructionArgs.verifyPreAlloc();
    if(preModScenario!=CMEScenario.NoMod){offset=constructionArgs.verifyAscending(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,numToAdd);}
    offset=constructionArgs.verifyParentPostAlloc(offset);
    if(preModScenario==CMEScenario.ModParent){offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
    offset=constructionArgs.verifyRootPostAlloc(offset);
    if(preModScenario==CMEScenario.ModRoot){offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
  }
  
  
  @ParameterizedTest
  @MethodSource("getSizeAndIsEmptyTestArgs")
  public void testisEmpty_void(int numToAdd,StructType structType,CMEScenario preModScenario)
  {
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    for(int i=0;i<numToAdd;++i)
    {
      $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.seq,i);
    }
    illegallyMod(preModScenario,constructionArgs);
    switch(preModScenario)
    {
      case ModParent:
      {
        Assertions.assertThrows(ConcurrentModificationException.class,()->constructionArgs.seq.isEmpty());
        constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd+1,numToAdd+1);
        break;
      }
      case ModRoot:
      {
        Assertions.assertThrows(ConcurrentModificationException.class,()->constructionArgs.seq.isEmpty());
        constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd,numToAdd,numToAdd+1,numToAdd+1);
        break;
      }
      default:
      {
        
        for(int i=0;i<numToAdd;++i)
        {
          Assertions.assertEquals(numToAdd-i==0,constructionArgs.seq.isEmpty());
          constructionArgs.verifyStructuralIntegrity(numToAdd-i,i+numToAdd);
          switch(structType)
          {
            case CHECKEDSTACK:
            case UNCHECKEDSTACK:
              ((OmniStack.Of$ClassPrefix$)constructionArgs.seq).pop$TypeNameModifier$();
              break;
            default:
              ((OmniList.Of$ClassPrefix$)constructionArgs.seq).$removeAtIndexMethod$(numToAdd-i-1);
          }
        }
        Assertions.assertTrue(constructionArgs.seq.isEmpty());
        constructionArgs.verifyStructuralIntegrity(0,numToAdd*2);
      }
    }
    int offset=constructionArgs.verifyPreAlloc();
    if(preModScenario!=CMEScenario.NoMod){offset=constructionArgs.verifyAscending(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,numToAdd);}
    offset=constructionArgs.verifyParentPostAlloc(offset);
    if(preModScenario==CMEScenario.ModParent){offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
    offset=constructionArgs.verifyRootPostAlloc(offset);
    if(preModScenario==CMEScenario.ModRoot){offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
  }
  

  
  
  
  static Stream<Arguments> getHashCodeTestArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(StructType structType:StructType.values()){
      
      switch(structType)
      {
        case CHECKEDSUBLIST:
          builder.add(Arguments.of(structType,0,ObjModScenario.NoMod,CMEScenario.ModParent));
          builder.add(Arguments.of(structType,100,ObjModScenario.NoMod,CMEScenario.ModParent));
          builder.add(Arguments.of(structType,0,ObjModScenario.NoMod,CMEScenario.ModRoot));
          builder.add(Arguments.of(structType,100,ObjModScenario.NoMod,CMEScenario.ModRoot));
        #IF OfRef
          builder.add(Arguments.of(structType,100,ObjModScenario.ModParent,CMEScenario.ModParent));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModParent,CMEScenario.ModRoot));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModRoot,CMEScenario.ModParent));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModRoot,CMEScenario.ModRoot));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModParentThrow,CMEScenario.ModParent));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModParentThrow,CMEScenario.ModRoot));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModRootThrow,CMEScenario.ModParent));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModRootThrow,CMEScenario.ModRoot));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModSeqThrow,CMEScenario.ModParent));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModSeq,CMEScenario.ModParent));
          builder.add(Arguments.of(structType,100,ObjModScenario.Throw,CMEScenario.ModParent));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModSeqThrow,CMEScenario.ModRoot));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModSeq,CMEScenario.ModRoot));
          builder.add(Arguments.of(structType,100,ObjModScenario.Throw,CMEScenario.ModRoot));
        #ENDIF
        case CHECKEDSTACK:
        case CHECKEDLIST:
          #IF OfRef
          builder.add(Arguments.of(structType,100,ObjModScenario.ModSeqThrow,CMEScenario.NoMod));
          builder.add(Arguments.of(structType,100,ObjModScenario.ModSeq,CMEScenario.NoMod));
          builder.add(Arguments.of(structType,100,ObjModScenario.Throw,CMEScenario.NoMod));
          #ENDIF
        default:
          builder.add(Arguments.of(structType,0,ObjModScenario.NoMod,CMEScenario.NoMod));
          builder.add(Arguments.of(structType,100,ObjModScenario.NoMod,CMEScenario.NoMod));
      }
    }
    return builder.build().parallel();
  }
  private static ModCheckTestData initializeForBasicModCheckableTest(StructType structType,int numToAdd,ObjModScenario objModScenario,CMEScenario preModScenario){
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    ModCheckTestObject modCheckTestObject=null;
    if(objModScenario==ObjModScenario.NoMod){
       for(int i=0;i<numToAdd;++i){
          $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.seq,i);
        }
    }else{
      switch(objModScenario){
        case ModSeq:
          modCheckTestObject=new ModCheckTestObject.Modding((OmniCollection.OfRef<?>)constructionArgs.seq);
          break;
        case ModSeqThrow:
          modCheckTestObject=new ModCheckTestObject.ModdingAndThrowing((OmniCollection.OfRef<?>)constructionArgs.seq);
          break;
        case ModParent:
          modCheckTestObject=new ModCheckTestObject.Modding((OmniCollection.OfRef<?>)constructionArgs.parent);
          break;
        case ModParentThrow:
          modCheckTestObject=new ModCheckTestObject.ModdingAndThrowing((OmniCollection.OfRef<?>)constructionArgs.parent);
          break;
        case ModRoot:
          modCheckTestObject=new ModCheckTestObject.Modding((OmniCollection.OfRef<?>)constructionArgs.root);
          break;
        case ModRootThrow:
          modCheckTestObject=new ModCheckTestObject.ModdingAndThrowing((OmniCollection.OfRef<?>)constructionArgs.root);
          break;
        default:
          modCheckTestObject=new ModCheckTestObject();
      }
      for(int i=0;i<numToAdd;++i){
        ((OmniCollection.OfRef)constructionArgs.seq).add(modCheckTestObject);
      }
    }
    illegallyMod(preModScenario,constructionArgs);
    return new ModCheckTestData(modCheckTestObject,constructionArgs);
  }
#IF OfRef
  private static void verifyTestDidNotModify(ModCheckTestData moddingObjectData,int numAdded,ObjModScenario objModScenario,CMEScenario preModScenario)
  {
      ModCheckTestObject modCheckTestObject=moddingObjectData.modCheckTestObject;
      ConstructionArguments constructionArgs=moddingObjectData.constructionArgs;
      int numCalls=modCheckTestObject.numCalls;
      int offset=constructionArgs.verifyPreAlloc();
      offset+=numAdded;
      switch(preModScenario){
        case ModRoot:
          if(objModScenario!=ObjModScenario.ModRoot && objModScenario!=ObjModScenario.ModRootThrow){
            numCalls=0;
          }
          constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded,numAdded,numAdded+numCalls+1,numAdded+numCalls+1);
          offset=constructionArgs.verifyParentPostAlloc(offset);
          offset=constructionArgs.verifyRootPostAlloc(offset);
          offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
          break;
        case ModParent:
          switch(objModScenario){
            case ModRootThrow:
            case ModRoot:
              constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded+1,numAdded+1,numAdded+numCalls+1,numAdded+numCalls+1);
              offset=constructionArgs.verifyParentPostAlloc(offset);
              break;
            case ModParentThrow:
            case ModParent:
              constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded+numCalls+1,numAdded+numCalls+1,numAdded+numCalls+1,numAdded+numCalls+1);
              offset=constructionArgs.verifyParentPostAlloc(offset);
              for(int i=0;i<numCalls;++i)
              {
                offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
              }
              break;
            case ModSeqThrow:
            case ModSeq:
            case Throw:
               constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded+1,numAdded+1,numAdded+1,numAdded+1);
               offset=constructionArgs.verifyParentPostAlloc(offset);
               break;
            }
            offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
            offset=constructionArgs.verifyRootPostAlloc(offset);
            break;
        default:
            switch(objModScenario){
              case ModRoot:
                constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded,numAdded,numAdded+numCalls,numAdded+numCalls);
                offset=constructionArgs.verifyParentPostAlloc(offset);
                offset=constructionArgs.verifyRootPostAlloc(offset);
                for(int i=0;i<numCalls;++i){
                  offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
                }
                break;
              case ModParentThrow:
              case ModParent:
                constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls);
                offset=constructionArgs.verifyParentPostAlloc(offset);
                for(int i=0;i<numCalls;++i)
                {
                  offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
                }
                offset=constructionArgs.verifyRootPostAlloc(offset);
                break;
              case ModSeqThrow:
              case ModSeq:
                for(int i=0;i<numCalls;++i)
                {
                  offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
                }
                constructionArgs.verifyStructuralIntegrity(numAdded+numCalls,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls,numAdded+numCalls); 
                offset=constructionArgs.verifyParentPostAlloc(offset);
                offset=constructionArgs.verifyRootPostAlloc(offset);
                break;
              default:
                constructionArgs.verifyStructuralIntegrity(numAdded,numAdded,numAdded,numAdded,numAdded,numAdded);
                offset=constructionArgs.verifyParentPostAlloc(offset);
                offset=constructionArgs.verifyRootPostAlloc(offset);
            }
      }
  }
#ENDIF
  @ParameterizedTest
  @MethodSource("getHashCodeTestArgs")
  public void testhashCode_void(StructType structType,int numToAdd,ObjModScenario objModScenario,CMEScenario preModScenario){
    ModCheckTestData modCheckTestData=initializeForBasicModCheckableTest(structType,numToAdd,objModScenario,preModScenario);
    ConstructionArguments constructionArgs=modCheckTestData.constructionArgs;
    #IF OfRef
    ModCheckTestObject modCheckTestObject=modCheckTestData.modCheckTestObject;
    if(modCheckTestObject==null)
    {
    #ENDIF
      if(preModScenario==CMEScenario.NoMod){
        int expectedHash=1;
        switch(structType){
          case CHECKEDSTACK:
          case UNCHECKEDSTACK:
            for(int i=numToAdd;--i>=0;)
            {
              expectedHash=(expectedHash*31)+Objects.hashCode(TypeConversionUtil.convertTo$ArrayType$(i));
            }
            break;
          default:
            for(int i=0;i<numToAdd;++i)
            {
              expectedHash=(expectedHash*31)+Objects.hashCode(TypeConversionUtil.convertTo$ArrayType$(i));
            }
        }
        Assertions.assertEquals(expectedHash,constructionArgs.seq.hashCode());
        constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd);
        
      }
      else
      {
        Assertions.assertThrows(ConcurrentModificationException.class,()->constructionArgs.seq.hashCode());
        if(preModScenario==CMEScenario.ModParent)
        {
          constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd+1,numToAdd+1);
        }
        else
        {
          constructionArgs.verifyStructuralIntegrity(numToAdd,numToAdd,numToAdd,numToAdd,numToAdd+1,numToAdd+1);
        }
      }
      int offset=constructionArgs.verifyPreAlloc();
      offset=constructionArgs.verifyAscending(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,numToAdd);
      offset=constructionArgs.verifyParentPostAlloc(offset);
      if(preModScenario==CMEScenario.ModParent){offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
      offset=constructionArgs.verifyRootPostAlloc(offset);
      if(preModScenario==CMEScenario.ModRoot){constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);}
    #IF OfRef
    }
    else
    {
      Class<? extends Throwable> expectedException=objModScenario==ObjModScenario.Throw&&preModScenario==CMEScenario.NoMod?IndexOutOfBoundsException.class:ConcurrentModificationException.class;
      Assertions.assertThrows(expectedException,()->constructionArgs.seq.hashCode());
      for(int i=0;i<numToAdd;++i)
      {
        Assertions.assertSame(modCheckTestObject,constructionArgs.root.arr[constructionArgs.rootPreAlloc+constructionArgs.parentPreAlloc+i]);
      }
      verifyTestDidNotModify(modCheckTestData,numToAdd,objModScenario,preModScenario);
    }
    #ENDIF
  }
  static Stream<Arguments> getToArrayIntFunctionArgs(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(StructType structType:StructType.values()){
      for(CMEScenario preModScenario:CMEScenario.values()){
        if(preModScenario==CMEScenario.ModSeq){
          continue;
        }
        if(preModScenario!=CMEScenario.NoMod && structType!=StructType.CHECKEDSUBLIST){
          continue;
        }
        for(int seqSize=0;seqSize<=5;seqSize+=5){
          switch(structType){
            case CHECKEDSUBLIST:
              builder.add(Arguments.of(structType,seqSize,ObjModScenario.ModParentThrow,preModScenario));
              builder.add(Arguments.of(structType,seqSize,ObjModScenario.ModRootThrow,preModScenario));
              builder.add(Arguments.of(structType,seqSize,ObjModScenario.ModParent,preModScenario));
              builder.add(Arguments.of(structType,seqSize,ObjModScenario.ModRoot,preModScenario));
            case CHECKEDLIST:
            case CHECKEDSTACK:
              builder.add(Arguments.of(structType,seqSize,ObjModScenario.ModSeqThrow,preModScenario));
              builder.add(Arguments.of(structType,seqSize,ObjModScenario.ModSeq,preModScenario));
              builder.add(Arguments.of(structType,seqSize,ObjModScenario.Throw,preModScenario));
            default:
              builder.add(Arguments.of(structType,seqSize,ObjModScenario.NoMod,preModScenario));
          }
        }
      }
    }
    return builder.build().parallel();
  }
  @ParameterizedTest
  @MethodSource("getToArrayIntFunctionArgs")
  public void testtoArray_IntFunction(StructType structType,int seqSize,ObjModScenario arrConstructorModScenario,CMEScenario preModScenario){
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    for(int i=0;i<seqSize;++i){
      $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.seq,i);
    }
    illegallyMod(preModScenario,constructionArgs);
    MonitoredArrayConstructor monitoredArrConstructor;
    #IF OfRef
    Class<Integer> componentClass=Integer.class;
    #ELSE
    Class<$BoxedType$> componentClass=$BoxedType$.class;
    #ENDIF
    switch(arrConstructorModScenario){
      case Throw:
        monitoredArrConstructor=new MonitoredArrayConstructor.Throwing<>(componentClass);
        break;
      case ModSeqThrow:
        monitoredArrConstructor=new MonitoredArrayConstructor.ModdingAndThrowing<>(componentClass,constructionArgs.seq);
        break;
      case ModParentThrow:
        monitoredArrConstructor=new MonitoredArrayConstructor.ModdingAndThrowing<>(componentClass,constructionArgs.parent);
        break;
      case ModRootThrow:
        monitoredArrConstructor=new MonitoredArrayConstructor.ModdingAndThrowing<>(componentClass,constructionArgs.root);
        break;
      case ModSeq:
        monitoredArrConstructor=new MonitoredArrayConstructor.Modding<>(componentClass,constructionArgs.seq);
        break;
      case ModParent:
        monitoredArrConstructor=new MonitoredArrayConstructor.Modding<>(componentClass,constructionArgs.parent);
        break;
      case ModRoot:
        monitoredArrConstructor=new MonitoredArrayConstructor.Modding<>(componentClass,constructionArgs.root);
        break;
      default:
        monitoredArrConstructor=new MonitoredArrayConstructor<>(componentClass);
    }
    Class<? extends Throwable> expectedException=preModScenario==CMEScenario.NoMod?monitoredArrConstructor.expectedException:ConcurrentModificationException.class;
    if(expectedException==null){
      var outputArray=constructionArgs.seq.toArray(monitoredArrConstructor);
      constructionArgs.verifyStructuralIntegrity(seqSize,seqSize);
      Assertions.assertNotSame(outputArray,constructionArgs.root.arr);
      Assertions.assertEquals(seqSize,outputArray.length);
      var itr=constructionArgs.seq.iterator();
      for(int i=0;i<seqSize;++i)
      {
        #IF OfRef
        Assertions.assertSame(itr.next(),outputArray[i]);
        #ELSE
        Assertions.assertEquals(itr.next(),outputArray[i]);
        #ENDIF
      }
    }else{
      Assertions.assertThrows(expectedException,()->constructionArgs.seq.toArray(monitoredArrConstructor));
    }
    int offset=constructionArgs.verifyPreAlloc();
    offset=constructionArgs.verifyAscending(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,seqSize);
    if(arrConstructorModScenario==ObjModScenario.ModSeq||arrConstructorModScenario==ObjModScenario.ModSeqThrow){
      switch(preModScenario)
      {
        case ModRoot:
          constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize,seqSize,seqSize+1,seqSize+1);
          break;
        case ModParent:
          constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize+1,seqSize+1);
          break;
        default:
          constructionArgs.verifyStructuralIntegrity(seqSize+1,seqSize+1);
          offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
      }
    }
    offset=constructionArgs.verifyParentPostAlloc(offset);
    if(arrConstructorModScenario==ObjModScenario.ModParent||arrConstructorModScenario==ObjModScenario.ModParentThrow){
      switch(preModScenario){
        case ModRoot:
          constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize,seqSize,seqSize+1,seqSize+1);
          break;
        case ModParent:
          constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize+2,seqSize+2);
          offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
          break;
        default:
          constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize+1,seqSize+1);
          offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
      }
    }
    if(preModScenario==CMEScenario.ModParent){
      offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
    }
    offset=constructionArgs.verifyRootPostAlloc(offset);
    if(arrConstructorModScenario==ObjModScenario.ModRoot||arrConstructorModScenario==ObjModScenario.ModRootThrow){
      switch(preModScenario){
        case ModRoot:
          constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize,seqSize,seqSize+2,seqSize+2);
          break;
        case ModParent:
          constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize+1,seqSize+1,seqSize+2,seqSize+2);
          break;
        default:
          constructionArgs.verifyStructuralIntegrity(seqSize,seqSize,seqSize,seqSize,seqSize+1,seqSize+1);
      }
      offset=constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
    }
    if(preModScenario==CMEScenario.ModRoot){
      constructionArgs.verifyIndex(offset,$ClassPrefix$InputTestArgType.ARRAY_TYPE,0);
    }
    Assertions.assertEquals(1,monitoredArrConstructor.numCalls);
  }
 
  static enum FunctionCallType
  {
#IFNOT OfRef
    BoxedType,
#ENDIF
    AsIs;
  }
  static enum ItrType
  {
    ListItr,
    Itr;
  }
  static enum ItrForEachModScenario
  {
    ModItr,
    ModItrThrow,
    ModSeq,
    ModSeqThrow,
    ModParent,
    ModParentThrow,
    ModRoot,
    ModRootThrow,
    Throw,
    NoMod;
  }
  
  static Stream<Arguments> getItrForEachArguments()
  {
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var structType:StructType.values())
    {
      for(var itrType:ItrType.values())
      {
        if(itrType==ItrType.ListItr && (structType==StructType.CHECKEDSTACK || structType==StructType.UNCHECKEDSTACK))
        {
          continue;
        }
        for(var preModScenario:CMEScenario.values())
        {
          if((!structType.checked && preModScenario!=CMEScenario.NoMod) || (structType!=StructType.CHECKEDSUBLIST && (preModScenario==CMEScenario.ModParent||preModScenario==CMEScenario.ModRoot)))
          {
            continue;
          }
          for(var itrModScenario:ItrForEachModScenario.values())
          {
            if((!structType.checked && itrModScenario!=ItrForEachModScenario.NoMod) || (structType!=StructType.CHECKEDSUBLIST && (itrModScenario==ItrForEachModScenario.ModRoot || itrModScenario==ItrForEachModScenario.ModParent || itrModScenario==ItrForEachModScenario.ModRootThrow || itrModScenario==ItrForEachModScenario.ModParentThrow)))
            {
              continue;
            }
            for(var functionCallType:FunctionCallType.values())
            {
              for(int seqSize=0;seqSize<=5;seqSize+=5)
              {
                builder.add(Arguments.of(structType,seqSize,preModScenario,itrModScenario,itrType,functionCallType));
              }
            }
          }
        }
      }
    }
    return builder.build().parallel();
  }
  
  
  @ParameterizedTest
  @MethodSource("getItrForEachArguments")
  public void testItrforEachRemaining(StructType structType,int seqSize,CMEScenario preModScenario,ItrForEachModScenario itrForEachModScenario,ItrType itrType,FunctionCallType functionCallType)
  {
    ConstructionArguments constructionArgs=new ConstructionArguments(structType);
    for(int i=0;i<seqSize;++i){
      $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(constructionArgs.seq,i);
    }
    OmniIterator.Of$ClassPrefix$ itr;
    if(itrType==ItrType.ListItr)
    {
      itr=((OmniList.Of$ClassPrefix$)constructionArgs.seq).listIterator();
    }
    else
    {
      itr=constructionArgs.seq.iterator();
    }
    
    illegallyMod(preModScenario,constructionArgs);
    ArrayList consumerMonitor=new ArrayList();
    final $TypeNameModifier$Consumer consumer;
    Class<? extends Throwable> expectedException;
    switch(itrForEachModScenario)
    {
      case ModItr:
        consumer=(v)->
        {
          itr.next$TypeNameModifier$();
          itr.remove();
          consumerMonitor.add(v);
        };
        expectedException=seqSize==0?null:ConcurrentModificationException.class;
        break;
      case ModItrThrow:
        consumer=(v)->
        {
          itr.next$TypeNameModifier$();
          itr.remove();
          consumerMonitor.add(v);
          throw new IndexOutOfBoundsException();
        };
        expectedException=seqSize==0?null:ConcurrentModificationException.class;
        break;
      case ModSeq:
        consumer=(v)->
        {
          constructionArgs.seq.remove(v);
          consumerMonitor.add(v);
        };
        expectedException=seqSize==0?null:ConcurrentModificationException.class;
        break;
      case ModSeqThrow:
        consumer=(v)->
        {
          constructionArgs.seq.remove(v);
          consumerMonitor.add(v);
          throw new IndexOutOfBoundsException();
        };
        expectedException=seqSize==0?null:ConcurrentModificationException.class;
        break;
      case ModParent:
        consumer=(v)->
        {
          constructionArgs.parent.remove(v);
          consumerMonitor.add(v);
        };
        expectedException=seqSize==0?null:ConcurrentModificationException.class;
        break;
      case ModParentThrow:
        consumer=(v)->
        {
          constructionArgs.parent.remove(v);
          consumerMonitor.add(v);
          throw new IndexOutOfBoundsException();
        };
        expectedException=seqSize==0?null:ConcurrentModificationException.class;
        break;
      case ModRoot:
        consumer=(v)->
        {
          constructionArgs.root.remove(v);
          consumerMonitor.add(v);
        };
        expectedException=seqSize==0?null:ConcurrentModificationException.class;
        break;
      case ModRootThrow:
        consumer=(v)->
        {
          constructionArgs.root.remove(v);
          consumerMonitor.add(v);
          throw new IndexOutOfBoundsException();
        };
        expectedException=seqSize==0?null:ConcurrentModificationException.class;
        break;
      case Throw:
        consumer=(v)->
        {
          consumerMonitor.add(v);
          throw new IndexOutOfBoundsException();
        };
        expectedException=seqSize==0?null:IndexOutOfBoundsException.class;
        break;
      default:
        consumer=(v)->
        {
          consumerMonitor.add(v);
        };
        expectedException=null;
    }
    if(expectedException==null)
    {
      if(functionCallType==FunctionCallType.AsIs)
      {
        itr.forEachRemaining(consumer);
      }
      #IFNOT OfRef
      else
      {
        itr.forEachRemaining((Consumer<? super $BoxedType$>)consumer::accept);
      }
      #ENDIF
    }
    else
    {
      if(functionCallType==FunctionCallType.AsIs)
      {
        Assertions.assertThrows(expectedException,()->itr.forEachRemaining(consumer));
      }
      #IFNOT OfRef
      else
      {
        Assertions.assertThrows(expectedException,()->itr.forEachRemaining((Consumer<? super $BoxedType$>)consumer::accept));
      }
      #ENDIF
    }
    verifyIteratorState(constructionArgs,itr,seqSize,preModScenario,itrForEachModScenario);
    verifyStructuralIntegrity(seqSize,constructionArgs,preModScenario,itrForEachModScenario);
    verifyConsumerMonitor(consumerMonitor,seqSize,constructionArgs,preModScenario,itrForEachModScenario); 
    
    
  }
  private static void verifyIteratorState(ConstructionArguments constructionArgs,Object iterator,int seqSize,CMEScenario preModScenario,ItrForEachModScenario itrForEachModScenario)
  {
    switch(itrForEachModScenario)
    {
      case ModItr:
        switch(preModScenario)
        {
          case ModSeq:
            switch(constructionArgs.structType)
            {
              case CHECKEDSTACK:
              case UNCHECKEDSTACK:
              default:
            }
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModItrThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModSeq:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModSeqThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModParent:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModParentThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModRoot:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModRootThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case Throw:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      default:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
    }
  }
  private static void verifyStructuralIntegrity(int seqSize,ConstructionArguments constructionArgs,CMEScenario preModScenario,ItrForEachModScenario itrForEachModScenario)
  {
    switch(itrForEachModScenario)
    {
      case ModItr:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModItrThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModSeq:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModSeqThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModParent:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModParentThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModRoot:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModRootThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case Throw:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      default:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
    }
  }
  private static void verifyConsumerMonitor(ArrayList consumerMonitor,int seqSize,ConstructionArguments constructionArgs,CMEScenario preModScenario,ItrForEachModScenario itrForEachModScenario)
  {
    switch(itrForEachModScenario)
    {
      case ModItr:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModItrThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModSeq:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModSeqThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModParent:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModParentThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModRoot:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case ModRootThrow:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      case Throw:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
        break;
      default:
        switch(preModScenario)
        {
          case ModSeq:
          case ModParent:
          case ModRoot:
          default:
        }
    }
  }
  */
  
  



}
#MACRODEF StructImpl<STRUCTNAME>()

#MACRO TestForEachMethods<DEFAULT>(,)
#IFNOT OfRef
#MACRO TestForEachMethods<DEFAULT>($TypeNameModifier$,)
#ENDIF


#MACRO TestOutputMethods<DEFAULT>($ArrayType$,$TypeNameModifier$,$defaultVal$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
#IFNOT OfRef
#MACRO TestOutputMethods<DEFAULT>($BoxedType$,,null,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR)
  #IFNOT OfDouble
#MACRO TestOutputMethods<DEFAULT>(double,Double,Double.NaN,OmniArray.OfDouble.DEFAULT_ARR)
    #IFNOT OfFloat
#MACRO TestOutputMethods<DEFAULT>(float,Float,Float.NaN,OmniArray.OfFloat.DEFAULT_ARR)
      #IFNOT OfLong
#MACRO TestOutputMethods<DEFAULT>(long,Long,Long.MIN_VALUE,OmniArray.OfLong.DEFAULT_ARR)
        #IFNOT OfInt
#MACRO TestOutputMethods<DEFAULT>(int,Int,Integer.MIN_VALUE,OmniArray.OfInt.DEFAULT_ARR)
          #IFNOT OfShort,OfChar
#MACRO TestOutputMethods<DEFAULT>(short,Short,Short.MIN_VALUE,OmniArray.OfShort.DEFAULT_ARR)
            #IFNOT OfByte
#MACRO TestOutputMethods<DEFAULT>(char,Char,Character.MIN_VALUE,OmniArray.OfChar.DEFAULT_ARR)
#MACRO TestOutputMethods<DEFAULT>(byte,Byte,Byte.MIN_VALUE,OmniArray.OfByte.DEFAULT_ARR)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF TestForEachMethods<INITIALCAPACITY>(OUTPUTMODIFIER,dummy)
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_NoMod(){
  #MACRO ConstructionRoutine()
  var consumer=new $ClassPrefix$MonitoredConsumer();
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_NoMod(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var consumer=new $ClassPrefix$MonitoredConsumer();
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,consumer.size());
  var seqIterator=seq.iterator();
  var consumerIterator=consumer.iterator();
  for(int i=0;i<100;++i){
#IF OfRef
    Assertions.assertSame(consumerIterator.next(),seqIterator.next());
#ELSE
    Assertions.assertEquals(consumerIterator.next(),seqIterator.next());
#ENDIF
  }
}
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_ModdingConsumer(){
  #MACRO ConstructionRoutine()
  var consumer=new $ClassPrefix$MonitoredConsumer.ModifyingArrSeqSTRUCTNAMEConsumer(seq);
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertEquals(0,seq.modCount);
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_ModdingConsumer(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var consumer=new $ClassPrefix$MonitoredConsumer.ModifyingArrSeqSTRUCTNAMEConsumer(seq);
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.forEach((OUTPUTMODIFIERConsumer)consumer));
  Assertions.assertEquals(100,seq.size());
  Assertions.assertEquals(300,seq.modCount);
  Assertions.assertEquals(100,consumer.size());
  var seqIterator=seq.iterator();
  var consumerIterator=consumer.iterator();
  for(int i=0;i<100;++i){
#IF OfRef
    Assertions.assertSame(consumerIterator.next(),seqIterator.next());
#ELSE
    Assertions.assertEquals(consumerIterator.next(),seqIterator.next());
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_ThrowingConsumer(){
  #MACRO ConstructionRoutine()
  var consumer=new $ClassPrefix$MonitoredConsumer.Throwing();
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertEquals(0,seq.modCount);
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_ThrowingConsumer(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var consumer=new $ClassPrefix$MonitoredConsumer.Throwing();
  Assertions.assertThrows(IndexOutOfBoundsException.class,()->seq.forEach((OUTPUTMODIFIERConsumer)consumer));
  Assertions.assertEquals(100,seq.size());
  Assertions.assertEquals(100,seq.modCount);
  Assertions.assertEquals(1,consumer.size());
  var seqIterator=seq.iterator();
  var consumerIterator=consumer.iterator();
  for(int i=0;i<1;++i){
#IF OfRef
    Assertions.assertSame(consumerIterator.next(),seqIterator.next());
#ELSE
    Assertions.assertEquals(consumerIterator.next(),seqIterator.next());
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_ThrowingAndModdingConsumer(){
  #MACRO ConstructionRoutine()
  var consumer=new $ClassPrefix$MonitoredConsumer.ModifyingArrSeqSTRUCTNAMEAndThrowingConsumer(seq);
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertEquals(0,seq.modCount);
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_ThrowingAndModdingConsumer(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var consumer=new $ClassPrefix$MonitoredConsumer.ModifyingArrSeqSTRUCTNAMEAndThrowingConsumer(seq);
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.forEach((OUTPUTMODIFIERConsumer)consumer));
  Assertions.assertEquals(100,seq.size());
  Assertions.assertEquals(102,seq.modCount);
  Assertions.assertEquals(1,consumer.size());
}
#ENDIF
#ENDDEF



#MACRODEF TestOutputMethods<INITIALCAPACITY>(OUTPUTTYPE,OUTPUTMODIFIER,DEFAULTVAL,DEFAULTARR)
@Test
public void testSTRUCTNAMEtoOUTPUTMODIFIERArray_void_seqIsEmpty(){
  #MACRO ConstructionRoutine()
  Assertions.assertSame(DEFAULTARR,seq.toOUTPUTMODIFIERArray());
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEtoOUTPUTMODIFIERArray_void_seqIsNotEmpty(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var result=seq.toOUTPUTMODIFIERArray();
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,result.length);
  var itr=seq.iterator();
  for(int i=0;i<100;++i){
#IF OfRef
    Assertions.assertSame(itr.nextOUTPUTMODIFIER(),result[i]);
#ELSE
    Assertions.assertEquals(itr.nextOUTPUTMODIFIER(),result[i]);
#ENDIF
  }
  Assertions.assertNotSame(seq.arr,result);
}
#ENDDEF

#MACRODEF ConstructionRoutine()
#IFSWITCH INITIALCAPACITY==DEFAULT
var seq=new $ClassPrefix$ArrSeq.STRUCTNAME();
#ELSEIFSWITCH INITIALCAPACITY==NULL
var seq=new $ClassPrefix$ArrSeq.STRUCTNAME(0,null);
#ELSE
var seq=new $ClassPrefix$ArrSeq.STRUCTNAME(INITIALCAPACITY);
#ENDIF
#ENDDEF
#MACRODEF AddAscending(NUM_TO_ADD,INPUTTYPE)
for(int i=0;i<NUM_TO_ADD;++i){
  Assertions.assertTrue(seq.add(TypeConversionUtil.convertToINPUTTYPE(i)));
}
#ENDDEF


