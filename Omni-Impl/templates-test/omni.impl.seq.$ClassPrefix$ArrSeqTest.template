#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import omni.util.TypeConversionUtil;
import omni.util.EqualityUtil;
import omni.util.OmniArray;
import omni.impl.seq.$ClassPrefix$ArrSeq.UncheckedList;
import omni.impl.seq.$ClassPrefix$ArrSeq.CheckedList;
import omni.impl.seq.$ClassPrefix$ArrSeq.UncheckedStack;
import omni.impl.seq.$ClassPrefix$ArrSeq.CheckedStack;
import java.util.ConcurrentModificationException;
#IF OfRef
@SuppressWarnings({"rawtypes","unchecked"}) 
#ENDIF
public class $ClassPrefix$ArrSeqTest
{
  #MACRO Impl<UncheckedStack>()
  #MACRO Impl<UncheckedList>()
  #MACRO Impl<CheckedStack>()
  #MACRO Impl<CheckedList>()
  #MACRO Impl<UncheckedSubList>()
  #MACRO Impl<CheckedSubList>()
}








#MACRODEF Impl<STRUCTNAME>()


@Test
public void testClearSTRUCTNAME()
{
#IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  #IFSWITCH STRUCTNAME==CheckedSubList
  var root=new CheckedList();
  #ELSE
  var root=new UncheckedList();
  #ENDIF
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    root.add(Integer.valueOf(i));
    #ELSE
    root.add(TypeConversionUtil.convertTo$ArrayType$(i));
    #ENDIF
  }

  var emptySubList=root.subList(50,50);
  #IFSWITCH STRUCTNAME==CheckedSubList
  int modCount=root.modCount;
  #ENDIF
  emptySubList.clear();
  Assertions.assertEquals(0,emptySubList.size());
  Assertions.assertEquals(100,root.size());
  #IFSWITCH STRUCTNAME==CheckedSubList
  Assertions.assertEquals(modCount,root.modCount);
  #ENDIF
  var nonEmptySubList=root.subList(10,90);
  var nonEmptySubSubList=nonEmptySubList.subList(15,65);
  nonEmptySubSubList.clear();
  Assertions.assertEquals(0,nonEmptySubSubList.size());
  Assertions.assertEquals(50,root.size());
  Assertions.assertEquals(30,nonEmptySubList.size());
  #IFSWITCH STRUCTNAME==CheckedSubList
  Assertions.assertNotEquals(modCount,root.modCount);
  #ENDIF
  for(int i=0;i<25;++i)
  {
    #IF OfRef
    Assertions.assertEquals(root.get(i),Integer.valueOf(i));
    #ELSE
    Assertions.assertEquals(root.get$TypeNameModifier$(i),TypeConversionUtil.convertTo$ArrayType$(i));
    #ENDIF
  }
  for(int i=25;i<50;++i)
  {
    #IF OfRef
    Assertions.assertEquals(root.get(i),Integer.valueOf(i+50));
    #ELSE
    Assertions.assertEquals(root.get$TypeNameModifier$(i),TypeConversionUtil.convertTo$ArrayType$(i+50));
    #ENDIF
  }
  #IF OfRef
  for(int i=50;i<100;++i)
  {
    Assertions.assertNull(root.arr[i]);
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList
  modCount=root.modCount;
  #ENDIF
  nonEmptySubList.clear();
  #IFSWITCH STRUCTNAME==CheckedSubList
  Assertions.assertNotEquals(modCount,root.modCount);
  modCount=root.modCount;
  Assertions.assertThrows(ConcurrentModificationException.class,()->nonEmptySubSubList.clear());
  Assertions.assertEquals(modCount,root.modCount);
  #ENDIF
  Assertions.assertEquals(20,root.size());
  
  Assertions.assertEquals(0,nonEmptySubList.size());
  for(int i=0;i<10;++i)
  {
    #IF OfRef
    Assertions.assertEquals(root.get(i),Integer.valueOf(i));
    #ELSE
    Assertions.assertEquals(root.get$TypeNameModifier$(i),TypeConversionUtil.convertTo$ArrayType$(i));
    #ENDIF
  }
  for(int i=10;i<20;++i)
  {
    #IF OfRef
    Assertions.assertEquals(root.get(i),Integer.valueOf(i+80));
    #ELSE
    Assertions.assertEquals(root.get$TypeNameModifier$(i),TypeConversionUtil.convertTo$ArrayType$(i+80));
    #ENDIF
  }
  #IF OfRef
  for(int i=20;i<100;++i)
  {
    Assertions.assertNull(root.arr[i]);
  }
  #ENDIF
  Assertions.assertTrue(root.arr.length>=100);
  #IFSWITCH STRUCTNAME==CheckedSubList
  root.add($defaultVal$);
  modCount=root.modCount;
  Assertions.assertThrows(ConcurrentModificationException.class,()->nonEmptySubList.clear());
  Assertions.assertEquals(modCount,root.modCount);
  #ENDIF
#ELSE
  var seq=new STRUCTNAME();
  seq.clear();
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
  #ENDIF
  Assertions.assertEquals(0,seq.size());
  
  
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    seq.add(Integer.valueOf(i));
    #ELSE
    seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    #ENDIF
  }
  Assertions.assertEquals(100,seq.size());
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
  #ENDIF
  seq.clear();
  Assertions.assertEquals(0,seq.size());
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertNotEquals(100,seq.modCount);
  #ENDIF
  Assertions.assertTrue(seq.arr.length>=100);
  #IF OfRef
  for(int i=0;i<100;++i)
  {
    Assertions.assertNull(seq.arr[i]);
  }
  #ENDIF
#ENDIF
}

@Test
public void testSizeSTRUCTNAME()
{
  #IFSWITCH STRUCTNAME==CheckedSubList
  var root=new CheckedList();
  var subList=root.subList(0,0);
  var seq=subList.subList(0,0);
  #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  var root=new UncheckedList();
  var subList=root.subList(0,0);
  var seq=subList.subList(0,0);
  #ELSE
  var seq=new STRUCTNAME();
  #ENDIF
  
  int i=0;
  for(;i<100;++i)
  {
    Assertions.assertEquals(i,seq.size());
    seq.add($defaultVal$);
  }
  
  Assertions.assertEquals(i,seq.size());
  var itr=seq.iterator();
  for(;;)
  {
    itr.next();
    itr.remove();
    Assertions.assertEquals(--i,seq.size());
    if(i==0)
    {
      break;
    }
  }
  #IFSWITCH STRUCTNAME==CheckedSubList
  root.add($defaultVal$);
  Assertions.assertThrows(ConcurrentModificationException.class,()->
  {
    seq.size();
  });
  #ENDIF
  
}
@Test
public void testIsEmptySTRUCTNAME()
{
  #IFSWITCH STRUCTNAME==CheckedSubList
  var root=new CheckedList();
  var subList=root.subList(0,0);
  var seq=subList.subList(0,0);
  #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  var root=new UncheckedList();
  var subList=root.subList(0,0);
  var seq=subList.subList(0,0);
  #ELSE
  var seq=new STRUCTNAME();
  #ENDIF
  Assertions.assertTrue(seq.isEmpty());
  int i=0;
  for(;i<100;++i)
  {
    seq.add($defaultVal$);
    Assertions.assertFalse(seq.isEmpty());
  }
  var itr=seq.iterator();
  for(;;)
  {
    itr.next();
    itr.remove();
    if(--i==0)
    {
      Assertions.assertTrue(seq.isEmpty());
      break;
    }
    Assertions.assertFalse(seq.isEmpty());
  }
  #IFSWITCH STRUCTNAME==CheckedSubList
  root.add($defaultVal$);
  Assertions.assertThrows(ConcurrentModificationException.class,()->
  {
    seq.isEmpty();
  });
  #ENDIF
}



@Test
public void testAddSTRUCTNAME()
{
  {
    //test with default array
    #IFSWITCH STRUCTNAME==CheckedSubList
    var root=new CheckedList();
    var subList=root.subList(0,0);
    var seq=subList.subList(0,0);
    #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
    var root=new UncheckedList();
    var subList=root.subList(0,0);
    var seq=subList.subList(0,0);
    #ELSE
    var seq=new STRUCTNAME();
    #ENDIF
    #MACRO TestAddHelper()
  }
  
  {
    //test with null array
    #IFSWITCH STRUCTNAME==CheckedSubList
    var root=new CheckedList(0,null);
    var subList=root.subList(0,0);
    var seq=subList.subList(0,0);
    #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
    var root=new UncheckedList(0,null);
    var subList=root.subList(0,0);
    var seq=subList.subList(0,0);
    #ELSE
    var seq=new STRUCTNAME(0,null);
    #ENDIF
    #MACRO TestAddHelper()
  }
  
   {
    //test with preallocated array
    #IFSWITCH STRUCTNAME==CheckedSubList
    var root=new CheckedList(20);
    var subList=root.subList(0,0);
    var seq=subList.subList(0,0);
    #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
    var root=new UncheckedList(20);
    var subList=root.subList(0,0);
    var seq=subList.subList(0,0);
    #ELSE
    var seq=new STRUCTNAME(20);
    #ENDIF
    #MACRO TestAddHelper()
  }
}




#IFSWITCH STRUCTNAME==CheckedStack,UncheckedStack
private static void testPushHelper(STRUCTNAME seq)
{
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    seq.push(Integer.valueOf(i));
    #ELSE
    seq.push(TypeConversionUtil.convertTo$ArrayType$(i));
    #ENDIF
  }
  #IFSWITCH STRUCTNAME==CheckedStack
  Assertions.assertEquals(100,seq.modCount);
  #ENDIF
  Assertions.assertEquals(100,seq.size());
  var itr=seq.iterator();
  for(int i=100;--i>=0;)
  {
    #IF OfRef
    Assertions.assertEquals(Integer.valueOf(i),itr.next());
    #ELSE
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(i),itr.next$TypeNameModifier$());
    #ENDIF
  }
  Assertions.assertFalse(itr.hasNext());
}
@Test
public void testPushSTRUCTNAME()
{
  //with default array
  testPushHelper(new STRUCTNAME());
  //with null array
  testPushHelper(new STRUCTNAME(0,null));
  //with pre-allocated capacity
  testPushHelper(new STRUCTNAME(50));
}
#ENDIF


@Test
public void testCloneSTRUCTNAME()
{
#IFSWITCH STRUCTNAME==CheckedSubList
  var seq=new CheckedList();
  {
    var subList=seq.subList(0,0);
    var clonedObject=subList.clone();
    Assertions.assertTrue(clonedObject instanceof CheckedList);
    var clonedSubSeq=(CheckedList)clonedObject;
    Assertions.assertTrue(clonedSubSeq.arr==seq.arr);
    Assertions.assertEquals(clonedSubSeq.size(),subList.size());
    Assertions.assertTrue(subList!=clonedSubSeq);
  }
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    seq.push(val);
  }
  {
    var subList=seq.subList(25,75);
    Assertions.assertEquals(subList.size(),75-25);
    var clonedObject=subList.clone();
    Assertions.assertTrue(clonedObject instanceof CheckedList);
    var clonedSeq=(CheckedList)clonedObject;
    Assertions.assertTrue(clonedSeq.arr!=seq.arr);
    Assertions.assertEquals(subList.size(),clonedSeq.size());
    EqualityUtil.uncheckedparallelassertarraysAreEqual(seq.arr,25,clonedSeq.arr,0,subList.size());
    seq.add($defaultVal$);
    Assertions.assertThrows(ConcurrentModificationException.class,()->subList.clone());
    
  }
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  var seq=new UncheckedList();
  {
    var subList=seq.subList(0,0);
    var clonedObject=subList.clone();
    Assertions.assertTrue(clonedObject instanceof UncheckedList);
    var clonedSubSeq=(UncheckedList)clonedObject;
    Assertions.assertTrue(clonedSubSeq.arr==seq.arr);
    Assertions.assertEquals(clonedSubSeq.size(),subList.size());
    Assertions.assertTrue(subList!=clonedSubSeq);
  }
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    seq.push(val);
  }
  {
    var subList=seq.subList(25,75);
    Assertions.assertEquals(subList.size(),75-25);
    var clonedObject=subList.clone();
    Assertions.assertTrue(clonedObject instanceof UncheckedList);
    var clonedSeq=(UncheckedList)clonedObject;
    Assertions.assertTrue(clonedSeq.arr!=seq.arr);
    Assertions.assertEquals(subList.size(),clonedSeq.size());
    EqualityUtil.uncheckedparallelassertarraysAreEqual(seq.arr,25,clonedSeq.arr,0,subList.size());
  }
#ELSE
  var seq=new STRUCTNAME();
  Object clonedObject=seq.clone();
  Assertions.assertTrue(clonedObject instanceof STRUCTNAME);
  var clonedSeq=(STRUCTNAME)clonedObject;
  Assertions.assertTrue(clonedSeq.arr==seq.arr);
  Assertions.assertEquals(clonedSeq.size(),seq.size());
  Assertions.assertTrue(seq!=clonedSeq);
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    seq.push(val);
  }
  Assertions.assertEquals(seq.size(),100);
  clonedObject=seq.clone();
  Assertions.assertTrue(clonedObject instanceof STRUCTNAME);
  clonedSeq=(STRUCTNAME)clonedObject;
  Assertions.assertTrue(clonedSeq.arr!=seq.arr);
  Assertions.assertEquals(seq.size(),clonedSeq.size());
  EqualityUtil.uncheckedparallelassertarraysAreEqual(seq.arr,0,clonedSeq.arr,0,seq.size());
#ENDIF
}


@Test
public void testConstructorsSTRUCTNAME()
{

#IFSWITCH STRUCTNAME==CheckedSubList
  var root=new CheckedList();
  {
    var subList=root.subList(0,0);
    Assertions.assertEquals(subList.size(),0);
    Assertions.assertTrue(subList.isEmpty());
    var subsubList=subList.subList(0,0);
    Assertions.assertEquals(subsubList.size(),0);
    Assertions.assertTrue(subsubList.isEmpty());
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(-1,0));
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(0,1));
  }
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    root.add(val);
  }
  {
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->root.subList(-1,75));
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->root.subList(25,101));
    Assertions.assertThrows(IndexOutOfBoundsException.class,()->root.subList(75,25));
    var subList=root.subList(25,75);
    Assertions.assertEquals(subList.size(),75-25);
    Assertions.assertFalse(subList.isEmpty());
    for(int i=25;i<75;++i)
    {
  #IF OfRef
      var val=TypeConversionUtil.convertToInteger(i);
  #ELSE
      var val=TypeConversionUtil.convertTo$exposedType$(i);
  #ENDIF
      Assertions.assertEquals(val,subList.get$TypeNameModifier$(i-25));
    }
    {
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(-1,30));
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(0,51));
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->subList.subList(30,10));
      var subsubList=subList.subList(10,30);
      Assertions.assertEquals(subsubList.size(),30-10);
      Assertions.assertFalse(subsubList.isEmpty());
      for(int i=10;i<30;++i)
      {
  #IF OfRef
        var val=TypeConversionUtil.convertToInteger(i+25);
  #ELSE
        var val=TypeConversionUtil.convertTo$exposedType$(i+25);
  #ENDIF
        Assertions.assertEquals(val,subsubList.get$TypeNameModifier$(i-10));
      }
    }
    root.add($defaultVal$);
    Assertions.assertThrows(ConcurrentModificationException.class,()->subList.subList(10,30));

    
  }


#ELSEIFSWITCH STRUCTNAME==UncheckedSubList

  var root=new UncheckedList();
  {
    var subList=root.subList(0,0);
    Assertions.assertEquals(subList.size(),0);
    Assertions.assertTrue(subList.isEmpty());
    var subsubList=subList.subList(0,0);
    Assertions.assertEquals(subsubList.size(),0);
    Assertions.assertTrue(subsubList.isEmpty());
  }
  for(int i=0;i<100;++i)
  {
    #IF OfRef
    var val=TypeConversionUtil.convertToInteger(i);
    #ELSE
    var val=TypeConversionUtil.convertTo$exposedType$(i);
    #ENDIF
    root.add(val);
  }
  {
    var subList=root.subList(25,75);
    Assertions.assertEquals(subList.size(),75-25);
    for(int i=25;i<75;++i)
    {
  #IF OfRef
      var val=TypeConversionUtil.convertToInteger(i);
  #ELSE
      var val=TypeConversionUtil.convertTo$exposedType$(i);
  #ENDIF
      Assertions.assertEquals(val,subList.get$TypeNameModifier$(i-25));
    }
    var subsubList=subList.subList(10,30);
    Assertions.assertEquals(subsubList.size(),30-10);
    Assertions.assertFalse(subsubList.isEmpty());
    for(int i=10;i<30;++i)
    {
  #IF OfRef
      var val=TypeConversionUtil.convertToInteger(i+25);
  #ELSE
      var val=TypeConversionUtil.convertTo$exposedType$(i+25);
  #ENDIF
      Assertions.assertEquals(val,subsubList.get$TypeNameModifier$(i-10));
    }
    
  }

#ELSE
  var seq=new STRUCTNAME();
  Assertions.assertEquals(seq.size(),0);
  Assertions.assertTrue(seq.isEmpty());
  Assertions.assertTrue(seq.arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR);
  seq=new STRUCTNAME(0);
  Assertions.assertEquals(seq.size(),0);
  Assertions.assertTrue(seq.isEmpty());
  Assertions.assertTrue(seq.arr==null);
  seq=new STRUCTNAME(OmniArray.DEFAULT_ARR_SEQ_CAP);
  Assertions.assertEquals(seq.size(),0);
  Assertions.assertTrue(seq.isEmpty());
  Assertions.assertTrue(seq.arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR);
  for(int i=1;i<OmniArray.DEFAULT_ARR_SEQ_CAP;++i)
  {
    seq=new STRUCTNAME(i);
    Assertions.assertEquals(seq.size(),0);
    Assertions.assertTrue(seq.isEmpty());
    Assertions.assertEquals(seq.arr.length,i);
  }
#ENDIF

 
}
#ENDDEF
#MACRODEF TestAddHelper()
for(int i=0;i<100;++i)
{
  #IF OfRef
  seq.add(Integer.valueOf(i));
  #ELSE
  seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
  #ENDIF
}
Assertions.assertEquals(seq.size(),100);
#IFSWITCH STRUCTNAME==UncheckedSubList,CheckedSubList
Assertions.assertEquals(subList.size(),100);
Assertions.assertEquals(root.size(),100);
#ENDIF
#IFSWITCH STRUCTNAME==CheckedSubList
Assertions.assertEquals(100,root.modCount);
#ELSEIFSWITCH STRUCTNAME==CheckedList,CheckedStack
Assertions.assertEquals(100,seq.modCount);
#ENDIF
var itr=seq.iterator();
#IFSWITCH STRUCTNAME==CheckedStack,UncheckedStack
for(int i=100;--i>=0;)
#ELSE
for(int i=0;i<100;++i)
#ENDIF
{
  #IF OfRef
  Assertions.assertEquals(itr.next(),Integer.valueOf(i));
  #ELSE
  Assertions.assertEquals(itr.next$TypeNameModifier$(),TypeConversionUtil.convertTo$ArrayType$(i));
  #ENDIF
}
Assertions.assertFalse(itr.hasNext());
#ENDDEF