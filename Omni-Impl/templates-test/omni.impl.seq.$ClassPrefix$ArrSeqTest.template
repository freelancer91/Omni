#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.util.TypeConversionUtil;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import java.util.function.IntFunction;
import java.util.function.Consumer;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.Arguments;
import java.util.stream.Stream;
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Consumer;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
import java.util.ConcurrentModificationException;
import omni.util.OmniArray;
import omni.api.OmniList;
import omni.api.OmniStack;
import omni.api.OmniCollection;
import omni.api.OmniListIterator;
@SuppressWarnings({"rawtypes","unchecked"}) 
public class $ClassPrefix$ArrSeqTest{
#IF OfRef
  private static void verifyRangeIsNull($ArrayType$[] arr,int offset,int bound){
    for(int i=offset;i<bound;++i){
      Assertions.assertNull(arr[i]);
    }
  }
#ENDIF
  private static enum StructType{
    STACK,
    LIST,
    SUBLIST;
  }
  private static enum InputTestArgType{
     #MACRO InputTestArgTypeImpl<ARRAY_TYPE,$ArrayType$,$ArrayType$>()
#IFNOT OfRef
    ,
    #MACRO InputTestArgTypeImpl<BOXED_TYPE,$BoxedType$,$ArrayType$>()
  #IFNOT OfBoolean
    ,
    #MACRO InputTestArgTypeImpl<PRIMITIVE_BOOLEAN,boolean,$ArrayType$boolean>()
    ,
    #MACRO InputTestArgTypeImpl<BOXED_BOOLEAN,Boolean,$ArrayType$boolean>()
    #IFNOT OfByte,OfChar
    ,
    #MACRO InputTestArgTypeImpl<PRIMITIVE_BYTE,byte,$ArrayType$>()
    ,
    #MACRO InputTestArgTypeImpl<BOXED_BYTE,Byte,$ArrayType$>()
      #IFNOT OfShort
    ,
    #MACRO InputTestArgTypeImpl<PRIMTIVE_SHORT,short,$ArrayType$>()
    ,
    #MACRO InputTestArgTypeImpl<BOXED_SHORT,Short,$ArrayType$>()
    ,
    #MACRO InputTestArgTypeImpl<PRIMITIVE_CHAR,char,$ArrayType$>()
    ,
    #MACRO InputTestArgTypeImpl<BOXED_CHAR,Character,$ArrayType$>()
        #IFNOT OfInt
    ,
    #MACRO InputTestArgTypeImpl<PRIMITIVE_INT,int,$ArrayType$>()
    ,
    #MACRO InputTestArgTypeImpl<BOXED_INT,Integer,$ArrayType$>()
          #IFNOT OfLong
    ,
    #MACRO InputTestArgTypeImpl<PRIMITIVE_LONG,long,$ArrayType$>()
    ,
    #MACRO InputTestArgTypeImpl<BOXED_LONG,Long,$ArrayType$>()
            #IFNOT OfFloat
    ,
    #MACRO InputTestArgTypeImpl<PRIMITIVE_FLOAT,float,$ArrayType$>()
    ,
    #MACRO InputTestArgTypeImpl<BOXED_FLOAT,Float,$ArrayType$>()
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
    ;
#MACRODEF InputTestArgTypeImpl<VALUE_NAME,INPUTTYPE,OUTPUTTYPE>()
VALUE_NAME{
  void callListItrAdd(OmniListIterator.Of$ClassPrefix$ itr,int valToConvert){
    itr.add(TypeConversionUtil.convertToINPUTTYPE(valToConvert));
  }
  void callListItrSet(OmniListIterator.Of$ClassPrefix$ itr,int valToConvert){
    itr.set(TypeConversionUtil.convertToINPUTTYPE(valToConvert));
  }
  void callListPut(OmniCollection.Of$ClassPrefix$ seq,int index,int valToConvert){
    ((OmniList.Of$ClassPrefix$)seq).put(index,TypeConversionUtil.convertToINPUTTYPE(valToConvert));
  }
  void callListAdd(OmniCollection.Of$ClassPrefix$ seq,int index,int valToConvert){
    ((OmniList.Of$ClassPrefix$)seq).add(index,TypeConversionUtil.convertToINPUTTYPE(valToConvert));
  }
  void callStackPush(OmniCollection.Of$ClassPrefix$ seq,int valToConvert){
    ((OmniStack.Of$ClassPrefix$)seq).push(TypeConversionUtil.convertToINPUTTYPE(valToConvert));
  }
  boolean callCollectionAdd(OmniCollection.Of$ClassPrefix$ seq,int valToConvert){
    return seq.add(TypeConversionUtil.convertToINPUTTYPE(valToConvert));
  }
  void verifyIndex(int expectedValToConvert,$ArrayType$ actualVal){
    Assertions.assertEquals(TypeConversionUtil.convertToOUTPUTTYPE(expectedValToConvert),actualVal);
  }
}
#ENDDEF
    abstract void callListItrAdd(OmniListIterator.Of$ClassPrefix$ itr,int valToConvert);
    abstract void callListItrSet(OmniListIterator.Of$ClassPrefix$ itr,int valToConvert);
    abstract void callListPut(OmniCollection.Of$ClassPrefix$ seq,int index,int valToConvert);
    abstract void callListAdd(OmniCollection.Of$ClassPrefix$ seq,int index,int valToConvert);
    abstract void callStackPush(OmniCollection.Of$ClassPrefix$ seq,int valToConvert);
    abstract boolean callCollectionAdd(OmniCollection.Of$ClassPrefix$ seq,int valToConvert);
    
    
    private int verifyAscending(ConstructionArguments constructionArgs,int offset,int length,int loVal){
      return verifyAscending(constructionArgs.root.arr,offset,length,loVal);
    }
    private int verifyDescending(ConstructionArguments constructionArgs,int offset,int length,int loVal){
      return verifyDescending(constructionArgs.root.arr,offset,length,loVal);
    }
    private int verifyMidPointInsertion(ConstructionArguments constructionArgs,int offset,int length,int loVal){
      return verifyMidPointInsertion(constructionArgs.root.arr,offset,length,loVal);
    }
    private int verifyIndex(ConstructionArguments constructionArgs,int index,int expectedValToConvert)
    {
      verifyIndex(expectedValToConvert,constructionArgs.root.arr[index]);
      return index+1; 
    }
    
    
    
    private int verifyAscending($ArrayType$[] arr,int offset,int length,int loVal){
      int bound=offset+length;
      for(int i=offset;i<bound;++i,++loVal){
        verifyIndex(loVal,arr[i]);
      }
      return bound;
    }
    private int verifyDescending($ArrayType$[] arr,int offset,int length,int loVal){
      int bound=offset+length;
      for(int i=bound;--i>=offset;++loVal){
        verifyIndex(loVal,arr[i]);
      }
      return bound;
    }
    private int verifyMidPointInsertion($ArrayType$[] arr,int offset,int length,int loVal){
      int i;
      for(int v=loVal+1,b=(i=offset)+length/2;i<b;++i,v+=2){
        verifyIndex(v,arr[i]);
      }
      for(int v=loVal+length-2,b=i+length/2;i<b;++i,v-=2){
        verifyIndex(v,arr[i]);
      }
      return offset+length;
    }
    abstract void verifyIndex(int expectedValToConvert,$ArrayType$ actualVal);
  }
  private static class ConstructionArguments{
    final int initialCapacity;
    final int rootPreAlloc;
    final int rootPostAlloc;
    final int parentPreAlloc;
    final int parentPostAlloc;
    final StructType structType;
    final int rootSize;
    final int parentSize;
    final int preAlloc;
    final int postAlloc;
    final boolean checked;
    final OmniCollection.Of$ClassPrefix$ seq;
    final OmniCollection.Of$ClassPrefix$ parent;
    final $ClassPrefix$ArrSeq root;
    ConstructionArguments(int rootPreAlloc,int parentPreAlloc,int parentPostAlloc,int rootPostAlloc,boolean checked){
      this.initialCapacity=OmniArray.DEFAULT_ARR_SEQ_CAP;
      this.rootPreAlloc=rootPreAlloc;
      this.rootPostAlloc=rootPostAlloc;
      this.parentPreAlloc=parentPreAlloc;
      this.parentPostAlloc=parentPostAlloc;
      this.parentSize=parentPreAlloc+parentPostAlloc;
      this.rootSize=parentSize+rootPreAlloc+rootPostAlloc;
      this.preAlloc=rootPreAlloc+parentPreAlloc;
      this.postAlloc=rootPostAlloc+parentPostAlloc;
      this.structType=StructType.SUBLIST;
      this.checked=checked;
      if(rootSize==0){
        this.root=checked?new $ClassPrefix$ArrSeq.CheckedList():new $ClassPrefix$ArrSeq.UncheckedList();
      }else{
        $ArrayType$[] arr=new $ArrayType$[rootSize];
        initAscendingArray(arr,0,-preAlloc,0);
        initAscendingArray(arr,preAlloc,100,100+rootPostAlloc+parentPostAlloc);
        this.root=checked?new $ClassPrefix$ArrSeq.CheckedList(rootSize,arr):new $ClassPrefix$ArrSeq.UncheckedList(rootSize,arr);
      }
      this.parent=((OmniList.Of$ClassPrefix$)root).subList(rootPreAlloc,preAlloc+parentPostAlloc);
      this.seq=((OmniList.Of$ClassPrefix$)parent).subList(parentPreAlloc,parentPreAlloc);
    }
    ConstructionArguments(int initialCapacity,boolean checked,StructType structType){
      this.initialCapacity=initialCapacity;
      this.rootPreAlloc=0;
      this.rootPostAlloc=0;
      this.parentPreAlloc=0;
      this.parentPostAlloc=0;
      this.parentSize=0;
      this.rootSize=0;
      this.preAlloc=0;
      this.postAlloc=0;
      this.structType=structType;
      this.checked=checked;
      if(structType==StructType.STACK){
        this.root=checked?new $ClassPrefix$ArrSeq.CheckedStack(initialCapacity):new $ClassPrefix$ArrSeq.UncheckedStack(initialCapacity);
      }else{
        this.root=checked?new $ClassPrefix$ArrSeq.CheckedList(initialCapacity):new $ClassPrefix$ArrSeq.UncheckedList(initialCapacity);
      }
      this.parent=root;
      this.seq=root;
    }
    public String toString(){
      StringBuilder builder=new StringBuilder(checked?"Checked":"Unchecked");
      switch(structType){
        case STACK:
          builder.append("Stack{").append(initialCapacity);
          break;
        case LIST:
          builder.append("List{").append(initialCapacity);
          break;
        default:
          builder.append("SubList{").append(rootPreAlloc).append(',').append(parentPreAlloc).append(',').append(parentPostAlloc).append(',').append(rootPostAlloc);
      }
      return builder.append('}').toString();
    }
    private OmniListIterator.Of$ClassPrefix$ constructSeqListIterator(){
      return ((OmniList.Of$ClassPrefix$)seq).listIterator();
    }
    private void verifyIteratorState(Object itr,int expectedCursor,int expectedLastRet,int expectedModCount){
      int actualCursor;
      Object actualParent;
      switch(structType){
        case LIST:
          if(checked){
             actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.cursor(itr);
             actualParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.parent(itr);
             Assertions.assertEquals(expectedModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.modCount(itr));
             Assertions.assertEquals(expectedLastRet<0?expectedLastRet:expectedLastRet+preAlloc,FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.lastRet(itr));
          }else{
            actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedList.Itr.cursor(itr);
            actualParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedList.Itr.parent(itr);
          }
          break;
        case STACK:
          if(checked){
            actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.cursor(itr);
            actualParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.parent(itr);
            Assertions.assertEquals(expectedModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.modCount(itr));
            Assertions.assertEquals(expectedLastRet<0?expectedLastRet:expectedLastRet+preAlloc,FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.lastRet(itr));
          }else{
            actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedStack.Itr.cursor(itr);
            actualParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedStack.Itr.parent(itr);
          }
          break;
        default:
          if(checked){
            actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.cursor(itr);
            actualParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.parent(itr);
            Assertions.assertEquals(expectedModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.modCount(itr));
            Assertions.assertEquals(expectedLastRet<0?expectedLastRet:expectedLastRet+preAlloc,FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.lastRet(itr));
          }else{
            actualCursor=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.Itr.cursor(itr);
            actualParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.Itr.parent(itr);
          }
      }
      Assertions.assertEquals(expectedCursor+preAlloc,actualCursor);
      Assertions.assertSame(seq,actualParent);
    }
    private void verifyStructuralIntegrity(int expectedSize,int expectedModCount){
       verifyStructuralIntegrity(expectedSize,expectedModCount,expectedSize,expectedModCount,expectedSize,expectedModCount);
    }
    private void verifyStructuralIntegrity(int expectedSeqSize,int expectedSeqModCount,int expectedParentAndRootSize,int expectedParentAndRootModCount){
       verifyStructuralIntegrity(expectedSeqSize,expectedSeqModCount,expectedParentAndRootSize,expectedParentAndRootModCount,expectedParentAndRootSize,expectedParentAndRootModCount);
    }
    
    private void verifyStructuralIntegrity(int expectedSeqSize,int expectedModCount,int expectedParentSize,int expectedParentModCount,int expectedRootSize,int expectedRootModCount)
    {
      switch(structType)
      {
        case STACK:
          if(checked)
          {
            Assertions.assertEquals(expectedRootModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(root));
          }
          break;
        case LIST:
          if(checked)
          {
             Assertions.assertEquals(expectedRootModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(root));
          }
          break;
        default:
          OmniList.Of$ClassPrefix$ actualSeqParent;
          Object actualSeqRoot;
          OmniList.Of$ClassPrefix$ actualParentParent;
          Object actualParentRoot;
          int actualParentSize;
          int actualSeqSize;
          if(checked){
            actualSeqParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.parent(seq);
            actualSeqRoot=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.root(seq);
            actualParentParent=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.parent(parent);
            actualParentRoot=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.root(parent);
            actualSeqSize=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.size(seq);
            actualParentSize=FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.size(parent);
            Assertions.assertEquals(expectedModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.modCount(seq));
            Assertions.assertEquals(expectedParentModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedSubList.modCount(parent));
            Assertions.assertEquals(expectedRootModCount,FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(root));
          }else{
            actualSeqParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.parent(seq);
            actualSeqRoot=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.root(seq);
            actualParentParent=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.parent(parent);
            actualParentRoot=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.root(parent);
            actualSeqSize=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.size(seq);
            actualParentSize=FieldAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.size(parent);
          }
          Assertions.assertSame(root,actualSeqRoot);
          Assertions.assertSame(root,actualParentRoot);
          Assertions.assertSame(parent,actualSeqParent);
          Assertions.assertNull(actualParentParent);
          Assertions.assertEquals(expectedSeqSize,actualSeqSize);
          Assertions.assertEquals(expectedParentSize+parentSize,actualParentSize);
      }
      Assertions.assertEquals(expectedRootSize+rootSize,FieldAccessor.$ClassPrefix$ArrSeq.size(root));
    }
  }
  

  
  private static void initAscendingArray($ArrayType$[] arr,int offset,int lo,int hi){
    int bound=offset+(hi-lo);
    for(int i=offset;i<bound;++i,++lo){
      arr[i]=TypeConversionUtil.convertTo$ArrayType$(lo);
    }
  }

 
 
  private static final Arguments[] NON_SUBLIST_TYPES=new Arguments[]
  {
    Arguments.of(false,StructType.LIST),
    Arguments.of(true,StructType.LIST),
    Arguments.of(false,StructType.STACK),
    Arguments.of(true,StructType.STACK)
  };
  static Stream<Arguments> getArgsForNonSubListTypes()
  {
    return Stream.of(NON_SUBLIST_TYPES);
  }
  
  @ParameterizedTest
  @MethodSource("getArgsForNonSubListTypes")
  public void testConstructor_happyPath(boolean checked,StructType structType)
  {
    $ClassPrefix$ArrSeq seq;
    if(checked){
      Assertions.assertEquals(0,structType==StructType.LIST?FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(seq=new $ClassPrefix$ArrSeq.CheckedList()):FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(seq=new $ClassPrefix$ArrSeq.CheckedStack()));
    }else{
      seq=structType==StructType.LIST?new $ClassPrefix$ArrSeq.UncheckedList():new $ClassPrefix$ArrSeq.UncheckedStack();
    }
    Assertions.assertSame(OmniArray.Of$ClassPrefix$.DEFAULT_ARR,seq.arr);
  }
  
  @ParameterizedTest
  @MethodSource("getArgsForNonSubListTypes")
  public void testConstructor_int_$ArrayType$arr_happyPath(boolean checked,StructType structType)
  {
    int size=5;
    $ArrayType$[] arr=new $ArrayType$[10];
    $ClassPrefix$ArrSeq seq;
    if(checked){
      Assertions.assertEquals(0,structType==StructType.LIST?FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(seq=new $ClassPrefix$ArrSeq.CheckedList(size,arr)):FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(seq=new $ClassPrefix$ArrSeq.CheckedStack(size,arr)));
    }else{
      seq=structType==StructType.LIST?new $ClassPrefix$ArrSeq.UncheckedList(size,arr):new $ClassPrefix$ArrSeq.UncheckedStack(size,arr);
    }
    Assertions.assertEquals(size,seq.size);
    Assertions.assertSame(arr,seq.arr);
  }
  
  static Stream<Arguments> getArgsFortestConstructor_int_happyPath()
  {
    Stream.Builder<Arguments> builder=Stream.builder();
    for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5)
    {
      builder.add(Arguments.of(initialCapacity,false,StructType.LIST));
      builder.add(Arguments.of(initialCapacity,true,StructType.LIST));
      builder.add(Arguments.of(initialCapacity,false,StructType.STACK));
      builder.add(Arguments.of(initialCapacity,true,StructType.STACK));
    }
    return builder.build();
  }
  
  @ParameterizedTest
  @MethodSource("getArgsFortestConstructor_int_happyPath")
  public void testConstructor_int_happyPath(int initialCapacity,boolean checked,StructType structType)
  {
    $ClassPrefix$ArrSeq seq;
    if(checked){
      Assertions.assertEquals(0,structType==StructType.LIST?FieldAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(seq=new $ClassPrefix$ArrSeq.CheckedList(initialCapacity)):FieldAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(seq=new $ClassPrefix$ArrSeq.CheckedStack(initialCapacity)));
    }else{
      seq=structType==StructType.LIST?new $ClassPrefix$ArrSeq.UncheckedList(initialCapacity):new $ClassPrefix$ArrSeq.UncheckedStack(initialCapacity);
    }
    Assertions.assertEquals(0,seq.size);
    switch(initialCapacity)
    {
      case 0:
        Assertions.assertNull(seq.arr);
        break;
      case OmniArray.DEFAULT_ARR_SEQ_CAP:
        Assertions.assertSame(OmniArray.Of$ClassPrefix$.DEFAULT_ARR,seq.arr);
        break;
      default:
        Assertions.assertEquals(initialCapacity,seq.arr.length);
#IF OfRef
        verifyRangeIsNull(seq.arr,0,initialCapacity);
#ENDIF
    }
  }
  static Stream<Arguments> getListInputMethodArgs()
  {
    Stream.Builder<Arguments> builder=Stream.builder();
    for(InputTestArgType inputTestArgType:InputTestArgType.values())
    {
      for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5)
      {
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,false,StructType.LIST)));
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,true,StructType.LIST)));
      }
      for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5)
      {
        for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5)
        {
          for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5)
          {
            for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5)
            {
              builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,true)));
              builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,false)));
            }
          }
        }
      }
    }
    return builder.build();
  }
  static Stream<Arguments> getCollectionInputMethodArgs()
  {
    Stream.Builder<Arguments> builder=Stream.builder();
    for(InputTestArgType inputTestArgType:InputTestArgType.values())
    {
      for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5)
      {
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,false,StructType.STACK)));
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,true,StructType.STACK)));
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,false,StructType.LIST)));
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,true,StructType.LIST)));
      }
      for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5)
      {
        for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5)
        {
          for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5)
          {
            for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5)
            {
              builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,true)));
              builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,false)));
            }
          }
        }
      }
    }
    return builder.build();
  }
  static Stream<Arguments> getStackInputMethodArgs()
  {
    Stream.Builder<Arguments> builder=Stream.builder();
    for(InputTestArgType inputTestArgType:InputTestArgType.values())
    {
      for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5)
      {
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,false,StructType.STACK)));
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,true,StructType.STACK)));
      }
    }
    return builder.build();
  }
  
  


  @ParameterizedTest
  @MethodSource("getListInputMethodArgs")
  public void testListItradd_val_happyPathInsertBegin(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      inputArgType.callListItrAdd(seqItr,i);
      constructionArgs.verifyIteratorState(seqItr,1,-1,i+1);
      seqItr.previous$TypeNameModifier$();
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyDescending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  @ParameterizedTest
  @MethodSource("getListInputMethodArgs")
  public void testadd_int_val_happyPathInsertBegin(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    for(int i=0;i<100;++i)
    {
      inputArgType.callListAdd(constructionArgs.seq,0,i);
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyDescending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  @ParameterizedTest
  @MethodSource("getListInputMethodArgs")
  public void testListItradd_val_happyPathInsertEnd(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      inputArgType.callListItrAdd(seqItr,i);
      constructionArgs.verifyIteratorState(seqItr,i+1,-1,i+1);
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyAscending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  @ParameterizedTest
  @MethodSource("getListInputMethodArgs")
  public void testadd_int_val_happyPathInsertEnd(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    for(int i=0;i<100;++i)
    {
      inputArgType.callListAdd(constructionArgs.seq,constructionArgs.seq.size(),i);
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyAscending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  @ParameterizedTest
  @MethodSource("getListInputMethodArgs")
  public void testListItradd_val_happyPathInsertMidPoint(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      inputArgType.callListItrAdd(seqItr,i);
      constructionArgs.verifyIteratorState(seqItr,(i/2)+1,-1,i+1);
      if((i&1)==0)
      {
        seqItr.previous$TypeNameModifier$();
      }
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyMidPointInsertion(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  @ParameterizedTest
  @MethodSource("getListInputMethodArgs")
  public void testadd_int_val_happyPathInsertMidPoint(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    for(int i=0;i<100;++i)
    {
      inputArgType.callListAdd(constructionArgs.seq,constructionArgs.seq.size()/2,i);
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyMidPointInsertion(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  
  @ParameterizedTest
  @MethodSource("getListInputMethodArgs")
  public void testListItrset_val_happyPath(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    for(int i=100;--i>=0;)
    {
      constructionArgs.seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      seqItr.next$TypeNameModifier$();
      inputArgType.callListItrSet(seqItr,i);
      constructionArgs.verifyIteratorState(seqItr,i+1,i,100);
    }
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyAscending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
    for(int i=0;i<100;++i)
    {
      seqItr.previous$TypeNameModifier$();
      inputArgType.callListItrSet(seqItr,i);
      constructionArgs.verifyIteratorState(seqItr,100-i-1,100-i-1,100);
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyDescending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  @ParameterizedTest
  @MethodSource("getListInputMethodArgs")
  public void testput_int_val_happyPath(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    for(int i=0;i<100;++i)
    {
      constructionArgs.seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    for(int i=0;i<100;++i)
    {
      inputArgType.callListPut(constructionArgs.seq,100-i-1,i);
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyDescending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  
 
  @ParameterizedTest
  @MethodSource("getStackInputMethodArgs")
  public void testpush_val_happyPath(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    for(int i=0;i<100;++i)
    {
      inputArgType.callStackPush(constructionArgs.seq,i);
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyAscending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  @ParameterizedTest
  @MethodSource("getCollectionInputMethodArgs")
  public void testadd_val_happyPath(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    for(int i=0;i<100;++i)
    {
      Assertions.assertTrue(inputArgType.callCollectionAdd(constructionArgs.seq,i));
    }
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      inputArgType.verifyAscending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,100,0)
    ,constructionArgs.postAlloc,100);
  }
  
  static Stream<Arguments> getCheckedListInputMethodArgs()
  {
    Stream.Builder<Arguments> builder=Stream.builder();
    for(InputTestArgType inputTestArgType:InputTestArgType.values())
    {
      for(int initialCapacity=0;initialCapacity<=15;initialCapacity+=5)
      {
        builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(initialCapacity,true,StructType.LIST)));
      }
      for(int rootPreAlloc=0;rootPreAlloc<=5;rootPreAlloc+=5)
      {
        for(int rootPostAlloc=0;rootPostAlloc<=5;rootPostAlloc+=5)
        {
          for(int parentPreAlloc=0;parentPreAlloc<=5;parentPreAlloc+=5)
          {
            for(int parentPostAlloc=0;parentPostAlloc<=5;parentPostAlloc+=5)
            {
              builder.add(Arguments.of(inputTestArgType,new ConstructionArguments(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,true)));
            }
          }
        }
      }
    }
    return builder.build();
  }
  
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testput_int_val_throwIOBE(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    for(int i=0;i<100;++i)
    {
      //too low
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->inputArgType.callListPut(constructionArgs.seq,-1,0));
      //too high
      final int finalIndex=i;
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->inputArgType.callListPut(constructionArgs.seq,finalIndex,0));
      constructionArgs.seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //when method throws, verify no changes occurred
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs.root.arr,0,constructionArgs.rootSize+100,-constructionArgs.preAlloc);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testadd_int_val_throwIOBE(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    for(int i=0;i<100;++i)
    {
      //too low
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->inputArgType.callListAdd(constructionArgs.seq,-1,0));
      //too high
      final int finalIndex=i;
      Assertions.assertThrows(IndexOutOfBoundsException.class,()->inputArgType.callListAdd(constructionArgs.seq,finalIndex+1,0));
      constructionArgs.seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //when method throws, verify no changes occurred
    constructionArgs.verifyStructuralIntegrity(100,100);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs.root.arr,0,constructionArgs.rootSize+100,-constructionArgs.preAlloc);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItrAadd_val_emptyListModRootthrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    //illegally modify the root;
    constructionArgs.root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrAdd(seqItr,0));
    constructionArgs.verifyIteratorState(seqItr,0,-1,0);
    constructionArgs.verifyStructuralIntegrity(0,0,0,0,1,1);
    InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,constructionArgs.postAlloc,100)
    ,0);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItradd_val_emptyListModParentthrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    //illegally modify the parent;
    constructionArgs.parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrAdd(seqItr,0));
    constructionArgs.verifyIteratorState(seqItr,0,-1,0);
    constructionArgs.verifyStructuralIntegrity(0,0,1,1);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
          InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
        ,constructionArgs.parentPostAlloc,100)
      ,0)
    ,constructionArgs.rootPostAlloc,100+constructionArgs.parentPostAlloc);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItradd_val_emptyListModSequencethrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    //illegally modify the sequence;
    constructionArgs.seq.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrAdd(seqItr,0));
    constructionArgs.verifyIteratorState(seqItr,0,-1,0);
    constructionArgs.verifyStructuralIntegrity(1,1);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
      ,0)
    ,constructionArgs.postAlloc,100);
  }
  
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItradd_val_nonEmptyListModRootthrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //illegally modify the root;
    constructionArgs.root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrAdd(seqItr,0));
    constructionArgs.verifyIteratorState(seqItr,100,-1,100);
    constructionArgs.verifyStructuralIntegrity(100,100,100,100,101,101);
    InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.rootSize+100,-constructionArgs.preAlloc)
    ,0);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItradd_val_nonEmptyListModParentthrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //illegally modify the parent;
    constructionArgs.parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrAdd(seqItr,0));
    constructionArgs.verifyIteratorState(seqItr,100,-1,100);
    constructionArgs.verifyStructuralIntegrity(100,100,101,101);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc+100+constructionArgs.parentPostAlloc,-constructionArgs.preAlloc)
      ,0)
    ,constructionArgs.rootPostAlloc,100+constructionArgs.parentPostAlloc);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItradd_val_nonEmptyListModSequencethrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //illegally modify the sequence;
    constructionArgs.seq.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrAdd(seqItr,0));
    constructionArgs.verifyIteratorState(seqItr,100,-1,100);
    constructionArgs.verifyStructuralIntegrity(101,101);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc+100,-constructionArgs.preAlloc)
      ,0)
    ,constructionArgs.postAlloc,100);
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItrAset_val_emptyListModRootthrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    seqItr.add(TypeConversionUtil.convertTo$ArrayType$(0));
    seqItr.previous$TypeNameModifier$();
    //illegally modify the root;
    constructionArgs.root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt to set
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrSet(seqItr,1));
    constructionArgs.verifyIteratorState(seqItr,0,0,1);
    constructionArgs.verifyStructuralIntegrity(1,1,1,1,2,2);
    InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
          InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
        ,0)
      ,constructionArgs.postAlloc,100)
    ,0);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItrset_val_emptyListModParentthrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    seqItr.add(TypeConversionUtil.convertTo$ArrayType$(0));
    seqItr.previous$TypeNameModifier$();
    //illegally modify the parent;
    constructionArgs.parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt to set
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrSet(seqItr,0));
    constructionArgs.verifyIteratorState(seqItr,0,0,1);
    constructionArgs.verifyStructuralIntegrity(1,1,2,2);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
          InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
            InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
          ,0)
        ,constructionArgs.parentPostAlloc,100)
      ,0)
    ,constructionArgs.rootPostAlloc,100+constructionArgs.parentPostAlloc);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItrset_val_emptyListModSequencethrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    seqItr.add(TypeConversionUtil.convertTo$ArrayType$(0));
    seqItr.previous$TypeNameModifier$();
    //illegally modify the sequence;
    constructionArgs.seq.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt to set
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrSet(seqItr,0));
    constructionArgs.verifyIteratorState(seqItr,0,0,1);
    constructionArgs.verifyStructuralIntegrity(2,2);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
          InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc,-constructionArgs.preAlloc)
        ,0)
      ,0)
    ,constructionArgs.postAlloc,100);
  }
  
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItrset_val_nonEmptyListModRootthrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    seqItr.add(TypeConversionUtil.convertTo$ArrayType$(0));
    seqItr.previous$TypeNameModifier$();
    //illegally modify the root;
    constructionArgs.root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt to set
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrSet(seqItr,1));
    constructionArgs.verifyIteratorState(seqItr,100,100,101);
    constructionArgs.verifyStructuralIntegrity(101,101,101,101,102,102);
    InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
          InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc+100,-constructionArgs.preAlloc)
        ,0)
      ,constructionArgs.postAlloc,100)
    ,0);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItrset_val_nonEmptyListModParentthrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    seqItr.add(TypeConversionUtil.convertTo$ArrayType$(0));
    seqItr.previous$TypeNameModifier$();
    //illegally modify the parent;
    constructionArgs.parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt to set
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrSet(seqItr,1));
    constructionArgs.verifyIteratorState(seqItr,100,100,101);
    constructionArgs.verifyStructuralIntegrity(101,101,102,102);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
          InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
            InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc+100,-constructionArgs.preAlloc)
          ,0)
        ,constructionArgs.parentPostAlloc,100)
      ,0)
    ,constructionArgs.rootPostAlloc,100+constructionArgs.parentPostAlloc);
  }
  @ParameterizedTest
  @MethodSource("getCheckedListInputMethodArgs")
  public void testListItrset_val_nonEmptyListModSequencethrowCME(InputTestArgType inputArgType,ConstructionArguments constructionArgs)
  {
    var seqItr=constructionArgs.constructSeqListIterator();
    for(int i=0;i<100;++i)
    {
      seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    seqItr.add(TypeConversionUtil.convertTo$ArrayType$(0));
    seqItr.previous$TypeNameModifier$();
    //illegally modify the sequence;
    constructionArgs.seq.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt to set
    Assertions.assertThrows(ConcurrentModificationException.class,()->inputArgType.callListItrSet(seqItr,1));
    constructionArgs.verifyIteratorState(seqItr,100,100,101);
    constructionArgs.verifyStructuralIntegrity(102,102);
    InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,
      InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
        InputTestArgType.ARRAY_TYPE.verifyIndex(constructionArgs,
          InputTestArgType.ARRAY_TYPE.verifyAscending(constructionArgs,0,constructionArgs.preAlloc+100,-constructionArgs.preAlloc)
        ,0)
      ,0)
    ,constructionArgs.postAlloc,100);
  }
  
  //TODO checked sublist CME add/put methods
  
  //TODO checked list iterator ISE add methods
  



#MACRODEF TestInputMethods(INPUTTYPE,OUTPUTTYPE)


#IFSWITCH STRUCT==List,SubList



  #IFSWITCH CHECKED==Checked
    #IFSWITCH STRUCT==SubList
@ParameterizedTest
@MethodSource("getSubListConstructionArgs")
public void testCHECKEDSTRUCTput_int_INPUTTYPE_throwCME(int rootPreAlloc,int parentPreAlloc,int parentPostAlloc,int rootPostAlloc){
  {
    //try on an empty sublist
    #MACRO InitializeForInputTest()
    //illegally modify the root
    root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //a put out of bounds should also throw a CME
    //too low
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    //too hi
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt the same tests on the parent
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.put(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.put(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.put(parentSize,TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,0,0,parent,parentSize,0,root,rootSize+1,1);
    verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
    verifyAscending$ArrayType$(root.arr,preAlloc,rootSize,100);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[rootSize]);
  }{
    //try on an empty sublist
    #MACRO InitializeForInputTest()
    //illegally modify the parent
    parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //a put out of bounds should also throw a CME
    //too low
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    //too hi
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,0,0,parent,parentSize+1,1,root,rootSize+1,1);
    verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
    verifyAscending$ArrayType$(root.arr,preAlloc,preAlloc+parentPostAlloc,100);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc+parentPostAlloc]);
    verifyAscending$ArrayType$(root.arr,preAlloc+parentPostAlloc+1,rootSize+1,100+parentPostAlloc);
  }{
    //try on an non-empty sublist
    #MACRO InitializeForInputTest()
    for(int i=0;i<100;++i){
      seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //illegally modify the root
    root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt a put at the beginning
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt a put at the midpoint
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(50,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt a put at the end
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(99,TypeConversionUtil.convertToINPUTTYPE(0)));
    //an insertion out of bounds should also throw a CME
    //too low
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    //too hi
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(10,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt the same tests on the parent
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.put(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.put(parentPreAlloc+50,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.put(parentSize+99,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.put(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.put(parentSize+100,TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,100,100,parent,parentSize+100,100,root,rootSize+101,101);
    verifyAscending$ArrayType$(root.arr,0,rootSize+100,-preAlloc);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[rootSize+100]);
  }{
    //try on an non-empty sublist
    #MACRO InitializeForInputTest()
    for(int i=0;i<100;++i){
      seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //illegally modify the parent
    parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt a put at the beginning
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt a put at the midpoint
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(50,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt a put at the end
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(99,TypeConversionUtil.convertToINPUTTYPE(0)));
    //an insertion out of bounds should also throw a CME
    //too low
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    //too hi
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.put(100,TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,100,100,parent,parentSize+101,101,root,rootSize+101,101);
    verifyAscending$ArrayType$(root.arr,0,preAlloc+100+parentPostAlloc,-preAlloc);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc+100+parentPostAlloc]);
    verifyAscending$ArrayType$(root.arr,preAlloc+101+parentPostAlloc,rootSize+101,100+parentPostAlloc);
  }
}
    #ENDIF

  
@ParameterizedTest
    #IFSWITCH STRUCT==List
@ValueSource(ints={0,5,10,15})
public void testCHECKEDSTRUCTListItrset_INPUTTYPE_throwISE(int initialCapacity){
    #ELSE
@MethodSource("getSubListConstructionArgs")
public void testCHECKEDSTRUCTListItrset_INPUTTYPE_throwISE(int rootPreAlloc,int parentPreAlloc,int parentPostAlloc,int rootPostAlloc){
    #ENDIF
  {
    //run tests on empty sequences
    {
      #MACRO InitializeForInputTest()
      var seqItr=seq.listIterator();
      Assertions.assertThrows(IllegalStateException.class,()->seqItr.set(TypeConversionUtil.convertToINPUTTYPE(0)));
      assertIteratorStateIntegrity(seqItr,preAlloc,-1,0,seq,root);
      //add to the sequence
      seqItr.add(TypeConversionUtil.convertTo$ArrayType$(0));
      //assert that it still throws
      Assertions.assertThrows(IllegalStateException.class,()->seqItr.set(TypeConversionUtil.convertToINPUTTYPE(0)));
      assertIteratorStateIntegrity(seqItr,preAlloc+1,-1,1,seq,root);
      assertStructuralIntegrity(seq,1,1,parent,parentSize+1,1,root,rootSize+1,1);
      //remove that previously added value
      seqItr.previous$TypeNameModifier$();
      seqItr.remove();
      //assert that calling it after a remove will also throw
      Assertions.assertThrows(IllegalStateException.class,()->seqItr.set(TypeConversionUtil.convertToINPUTTYPE(0)));
      assertIteratorStateIntegrity(seqItr,0,-1,2,seq,root);
      assertStructuralIntegrity(seq,0,2,parent,parentSize,2,root,rootSize,2);
      verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
      verifyAscending$ArrayType$(root.arr,preAlloc,rootSize,100);
    }
    {
      //assert that ISE supercedes CME
      {
        #MACRO InitializeForInputTest()
        var seqItr=seq.iterator();
        //illegally modify the root
        root.add(TypeConversionUtil.convertTo$ArrayType$(0));
        Assertions.assertThrows(IllegalStateException.class,()->seq.set(TypeConversionUtil.convertToINPUTTYPE(0)));
        assertIteratorStateIntegrity(seqItr,preAlloc,-1,0,seq,root);
        assertStructuralIntegrity(seq,0,0,parent,parentSize,0,root,rootSize+1,1);
        verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
        verifyAscending$ArrayType$(root.arr,preAlloc,rootSize,100);
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[rootSize]);
      }
      {
        #MACRO InitializeForInputTest()
        var seqItr=seq.iterator();
        //illegally modify the parent
        parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
        Assertions.assertThrows(IllegalStateException.class,()->seq.set(TypeConversionUtil.convertToINPUTTYPE(0)));
        assertIteratorStateIntegrity(seqItr,preAlloc,-1,0,seq,root);
        assertStructuralIntegrity(seq,0,0,parent,parentSize+1,1,root,rootSize+1,1);
        verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
        verifyAscending$ArrayType$(root.arr,preAlloc,preAlloc+parentPostAlloc,100);
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc+parentPostAlloc]);
        verifyAscending$ArrayType$(root.arr,preAlloc+parentPostAlloc+1,rootSize+1,100+parentPostAlloc);
      }
      {
        #MACRO InitializeForInputTest()
        var seqItr=seq.iterator();
        //illegally modify the sequence
        seq.add(TypeConversionUtil.convertTo$ArrayType$(0));
        Assertions.assertThrows(IllegalStateException.class,()->seq.set(TypeConversionUtil.convertToINPUTTYPE(0)));
        assertIteratorStateIntegrity(seqItr,preAlloc,-1,0,seq,root);
        assertStructuralIntegrity(seq,1,1,parent,parentSize+1,1,root,rootSize+1,1);
        verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc]);
        verifyAscending$ArrayType$(root.arr,preAlloc+1,rootSize+1,100);
      }
    }
  }
  {
    //run tests on non-empty sequences
    {
      #MACRO InitializeForInputTest()
      var seqItr=seq.listIterator();
      for(int i=0;i<100;++i)
      {
        seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
      }
      Assertions.assertThrows(IllegalStateException.class,()->seqItr.set(TypeConversionUtil.convertToINPUTTYPE(0)));
      assertIteratorStateIntegrity(seqItr,preAlloc+100,-1,100,seq,root);
      //add to the sequence
      seqItr.add(TypeConversionUtil.convertTo$ArrayType$(0));
      //assert that it still throws
      Assertions.assertThrows(IllegalStateException.class,()->seqItr.set(TypeConversionUtil.convertToINPUTTYPE(0)));
      assertIteratorStateIntegrity(seqItr,preAlloc+101,-1,101,seq,root);
      assertStructuralIntegrity(seq,101,101,parent,parentSize+101,101,root,rootSize+101,101);
      //remove that previously added value
      seqItr.previous$TypeNameModifier$();
      seqItr.remove();
      //assert that calling it after a remove will also throw
      Assertions.assertThrows(IllegalStateException.class,()->seqItr.set(TypeConversionUtil.convertToINPUTTYPE(0)));
      assertIteratorStateIntegrity(seqItr,100,-1,102,seq,root);
      assertStructuralIntegrity(seq,100,102,parent,parentSize+100,102,root,rootSize+100,102);
      verifyAscending$ArrayType$(root.arr,0,rootSize,-preAlloc);
    }
    {
      //assert that ISE supercedes CME
      {
        #MACRO InitializeForInputTest()
        var seqItr=seq.iterator();
        for(int i=0;i<100;++i)
        {
          seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
        }
        //illegally modify the root
        root.add(TypeConversionUtil.convertTo$ArrayType$(0));
        Assertions.assertThrows(IllegalStateException.class,()->seq.set(TypeConversionUtil.convertToINPUTTYPE(0)));
        assertIteratorStateIntegrity(seqItr,preAlloc+100,-1,100,seq,root);
        assertStructuralIntegrity(seq,100,100,parent,parentSize+100,100,root,rootSize+101,101);
        verifyAscending$ArrayType$(root.arr,0,rootSize+100,-preAlloc);
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[rootSize+100]);
      }
      {
        #MACRO InitializeForInputTest()
        var seqItr=seq.iterator();
        for(int i=0;i<100;++i)
        {
          seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
        }
        //illegally modify the parent
        parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
        Assertions.assertThrows(IllegalStateException.class,()->seq.set(TypeConversionUtil.convertToINPUTTYPE(0)));
        assertIteratorStateIntegrity(seqItr,preAlloc+100,-1,100,seq,root);
        assertStructuralIntegrity(seq,100,100,parent,parentSize+101,101,root,rootSize+101,101);
        verifyAscending$ArrayType$(root.arr,0,preAlloc+100+parentPostAlloc,-preAlloc);
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc+100+parentPostAlloc]);
        verifyAscending$ArrayType$(root.arr,preAlloc+101+parentPostAlloc,rootSize+100,100+parentPostAlloc);
      }
      {
        #MACRO InitializeForInputTest()
        var seqItr=seq.iterator();
        for(int i=0;i<100;++i)
        {
          seqItr.add(TypeConversionUtil.convertTo$ArrayType$(i));
        }
        //illegally modify the sequence
        seq.add(TypeConversionUtil.convertTo$ArrayType$(0));
        Assertions.assertThrows(IllegalStateException.class,()->seq.set(TypeConversionUtil.convertToINPUTTYPE(0)));
        assertIteratorStateIntegrity(seqItr,preAlloc+100,-1,100,seq,root);
        assertStructuralIntegrity(seq,101,101,parent,parentSize+101,101,root,rootSize+101,101);
        verifyAscending$ArrayType$(root.arr,0,preAlloc+100,-preAlloc);
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc+100]);
        verifyAscending$ArrayType$(root.arr,preAlloc+101,rootSize+101,100);
      }
    }
  }
}


    #IFSWITCH STRUCT==SubList
@ParameterizedTest
@MethodSource("getSubListConstructionArgs")
public void testCHECKEDSTRUCTadd_INPUTTYPE_throwCME(int rootPreAlloc,int parentPreAlloc,int parentPostAlloc,int rootPostAlloc){
  {
    //try on an empty sublist
    #MACRO InitializeForInputTest()
    //illegally modify the root
    root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt the same tests on the parent
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,0,0,parent,parentSize,0,root,rootSize+1,1);
    verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
    verifyAscending$ArrayType$(root.arr,preAlloc,rootSize,100);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[rootSize]);
  }{
    //try on an empty sublist
    #MACRO InitializeForInputTest()
    //illegally modify the parent
    parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,0,0,parent,parentSize+1,1,root,rootSize+1,1);
    verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
    verifyAscending$ArrayType$(root.arr,preAlloc,preAlloc+parentPostAlloc,100);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc+parentPostAlloc]);
    verifyAscending$ArrayType$(root.arr,preAlloc+parentPostAlloc+1,rootSize+1,100+parentPostAlloc);
  }{
    //try on an non-empty sublist
    #MACRO InitializeForInputTest()
    for(int i=0;i<100;++i){
      seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //illegally modify the root
    root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt the same tests on the parent
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,100,100,parent,parentSize+100,100,root,rootSize+101,101);
    verifyAscending$ArrayType$(root.arr,0,rootSize+100,-preAlloc);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[rootSize+100]);
  }{
    //try on an non-empty sublist
    #MACRO InitializeForInputTest()
    for(int i=0;i<100;++i){
      seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //illegally modify the parent
    parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,100,100,parent,parentSize+101,101,root,rootSize+101,101);
    verifyAscending$ArrayType$(root.arr,0,preAlloc+100+parentPostAlloc,-preAlloc);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc+100+parentPostAlloc]);
    verifyAscending$ArrayType$(root.arr,preAlloc+101+parentPostAlloc,rootSize+101,100+parentPostAlloc);
  }
}
@ParameterizedTest
@MethodSource("getSubListConstructionArgs")
public void testCHECKEDSTRUCTadd_int_INPUTTYPE_throwCME(int rootPreAlloc,int parentPreAlloc,int parentPostAlloc,int rootPostAlloc){
  {
    //try on an empty sublist
    #MACRO InitializeForInputTest()
    //illegally modify the root
    root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    //an insertion out of bounds should also throw a CME
    //too low
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    //too hi
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(1,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt the same tests on the parent
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(parentSize+1,TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,0,0,parent,parentSize,0,root,rootSize+1,1);
    verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
    verifyAscending$ArrayType$(root.arr,preAlloc,rootSize,100);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[rootSize]);
  }{
    //try on an empty sublist
    #MACRO InitializeForInputTest()
    //illegally modify the parent
    parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    //an insertion out of bounds should also throw a CME
    //too low
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    //too hi
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(1,TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,0,0,parent,parentSize+1,1,root,rootSize+1,1);
    verifyAscending$ArrayType$(root.arr,0,preAlloc,-preAlloc);
    verifyAscending$ArrayType$(root.arr,preAlloc,preAlloc+parentPostAlloc,100);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc+parentPostAlloc]);
    verifyAscending$ArrayType$(root.arr,preAlloc+parentPostAlloc+1,rootSize+1,100+parentPostAlloc);
  }{
    //try on an non-empty sublist
    #MACRO InitializeForInputTest()
    for(int i=0;i<100;++i){
      seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //illegally modify the root
    root.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion at the beginning
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt an insertion at the midpoint
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(50,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt an insertion at the end
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(100,TypeConversionUtil.convertToINPUTTYPE(0)));
    //an insertion out of bounds should also throw a CME
    //too low
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    //too hi
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(101,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt the same tests on the parent
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(parentPreAlloc+50,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(parentSize+100,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    Assertions.assertThrows(ConcurrentModificationException.class,()->parent.add(parentSize+101,TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,100,100,parent,parentSize+100,100,root,rootSize+101,101);
    verifyAscending$ArrayType$(root.arr,0,rootSize+100,-preAlloc);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[rootSize+100]);
  }{
    //try on an non-empty sublist
    #MACRO InitializeForInputTest()
    for(int i=0;i<100;++i){
      seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    }
    //illegally modify the parent
    parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
    //attempt an insertion at the beginning
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(0,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt an insertion at the midpoint
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(50,TypeConversionUtil.convertToINPUTTYPE(0)));
    //attempt an insertion at the end
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(100,TypeConversionUtil.convertToINPUTTYPE(0)));
    //an insertion out of bounds should also throw a CME
    //too low
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(-1,TypeConversionUtil.convertToINPUTTYPE(0)));
    //too hi
    Assertions.assertThrows(ConcurrentModificationException.class,()->seq.add(101,TypeConversionUtil.convertToINPUTTYPE(0)));
    assertStructuralIntegrity(seq,100,100,parent,parentSize+101,101,root,rootSize+101,101);
    verifyAscending$ArrayType$(root.arr,0,preAlloc+100+parentPostAlloc,-preAlloc);
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),root.arr[preAlloc+100+parentPostAlloc]);
    verifyAscending$ArrayType$(root.arr,preAlloc+101+parentPostAlloc,rootSize+101,100+parentPostAlloc);
  }
}
    #ENDIF
  #ENDIF
#ENDIF


#ENDDEF

#MACRODEF InitializeForInputTest()
#IFSWITCH STRUCT==List,Stack
int rootPreAlloc=0;
int parentPreAlloc=0;
int parentPostAlloc=0;
int rootPostAlloc=0;
#ENDIF
int parentSize=parentPreAlloc+parentPostAlloc;
int rootSize=rootPreAlloc+parentSize+rootPostAlloc;
int preAlloc=rootPreAlloc+parentPreAlloc;
#IFSWITCH STRUCT==SubList
$ClassPrefix$ArrSeq.CHECKEDList root;
if(rootSize==0){
  root=new $ClassPrefix$ArrSeq.CHECKEDList();
}else{
  $ArrayType$[] arr=new $ArrayType$[rootSize];
  initAscendingArray(arr,0,-preAlloc,0);
  initAscendingArray(arr,preAlloc,100,100+rootPostAlloc+parentPostAlloc);
  root=new $ClassPrefix$ArrSeq.CHECKEDList(rootSize,arr);
}
var parent=root.subList(rootPreAlloc,preAlloc+parentPostAlloc);
var seq=parent.subList(parentPreAlloc,parentPreAlloc);
#ELSE
var seq=new $ClassPrefix$ArrSeq.CHECKEDSTRUCT(initialCapacity);
var parent=seq;
var root=seq;
#ENDIF
#ENDDEF

#MACRODEF SubListImpl<CHECKED>()
@Test
public void testCHECKEDSubListsize(){
  var root=new $ClassPrefix$ArrSeq.CHECKEDList();
  var parent=root.subList(0,0);
  var seq=parent.subList(0,0);
  Assertions.assertEquals(0,seq.size());
  for(int i=0;i<100;++i){
    seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    Assertions.assertEquals(i+1,seq.size());
  }
#IFSWITCH CHECKED==Checked
  parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
  Assertions.assertThrows(ConcurrentModificationException.class,seq::size);
  root.add(TypeConversionUtil.convertTo$ArrayType$(0));
  Assertions.assertThrows(ConcurrentModificationException.class,parent::size);
#ENDIF
}
@Test
public void testCHECKEDSubListisEmpty(){
  var root=new $ClassPrefix$ArrSeq.CHECKEDList();
  var parent=root.subList(0,0);
  var seq=parent.subList(0,0);
  Assertions.assertTrue(seq.isEmpty());
  for(int i=0;i<100;++i){
    seq.add(TypeConversionUtil.convertTo$ArrayType$(i));
    Assertions.assertFalse(seq.isEmpty());
  }
  var seqItr=seq.iterator();
  for(int i=0;i<100;++i){
    Assertions.assertFalse(seq.isEmpty());
    seqItr.next();
    seqItr.remove();
  }
  Assertions.assertTrue(seq.isEmpty());
#IFSWITCH CHECKED==Checked
  parent.add(TypeConversionUtil.convertTo$ArrayType$(0));
  Assertions.assertThrows(ConcurrentModificationException.class,seq::isEmpty);
  root.add(TypeConversionUtil.convertTo$ArrayType$(0));
  Assertions.assertThrows(ConcurrentModificationException.class,parent::isEmpty);
#ENDIF
}
#ENDDEF

#MACRODEF StructImpl<STRUCTNAME>()
#MACRO TestClone<DEFAULT>()
#MACRO TestClone<NULL>()
#MACRO TestClone<50>()
#MACRO TestClone<0>()
#MACRO TestClone<10>()
#MACRO TestMiscMethods<DEFAULT>()
#MACRO TestForEachMethods<DEFAULT>(,)
#IFNOT OfRef
#MACRO TestForEachMethods<DEFAULT>($TypeNameModifier$,)
#ENDIF


#MACRO TestOutputMethods<DEFAULT>($ArrayType$,$TypeNameModifier$,$defaultVal$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
#IFNOT OfRef
#MACRO TestOutputMethods<DEFAULT>($BoxedType$,,null,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR)
  #IFNOT OfDouble
#MACRO TestOutputMethods<DEFAULT>(double,Double,Double.NaN,OmniArray.OfDouble.DEFAULT_ARR)
    #IFNOT OfFloat
#MACRO TestOutputMethods<DEFAULT>(float,Float,Float.NaN,OmniArray.OfFloat.DEFAULT_ARR)
      #IFNOT OfLong
#MACRO TestOutputMethods<DEFAULT>(long,Long,Long.MIN_VALUE,OmniArray.OfLong.DEFAULT_ARR)
        #IFNOT OfInt
#MACRO TestOutputMethods<DEFAULT>(int,Int,Integer.MIN_VALUE,OmniArray.OfInt.DEFAULT_ARR)
          #IFNOT OfShort,OfChar
#MACRO TestOutputMethods<DEFAULT>(short,Short,Short.MIN_VALUE,OmniArray.OfShort.DEFAULT_ARR)
            #IFNOT OfByte
#MACRO TestOutputMethods<DEFAULT>(char,Char,Character.MIN_VALUE,OmniArray.OfChar.DEFAULT_ARR)
#MACRO TestOutputMethods<DEFAULT>(byte,Byte,Byte.MIN_VALUE,OmniArray.OfByte.DEFAULT_ARR)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
}

#MACRODEF TestForEachMethods<INITIALCAPACITY>(OUTPUTMODIFIER,dummy)
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_NoMod(){
  #MACRO ConstructionRoutine()
  var consumer=new $ClassPrefix$MonitoredConsumer();
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_NoMod(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var consumer=new $ClassPrefix$MonitoredConsumer();
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,consumer.size());
  var seqIterator=seq.iterator();
  var consumerIterator=consumer.iterator();
  for(int i=0;i<100;++i){
#IF OfRef
    Assertions.assertSame(consumerIterator.next(),seqIterator.next());
#ELSE
    Assertions.assertEquals(consumerIterator.next(),seqIterator.next());
#ENDIF
  }
}
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_ModdingConsumer(){
  #MACRO ConstructionRoutine()
  var consumer=new $ClassPrefix$MonitoredConsumer.ModifyingArrSeqSTRUCTNAMEConsumer(seq);
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertEquals(0,seq.modCount);
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_ModdingConsumer(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var consumer=new $ClassPrefix$MonitoredConsumer.ModifyingArrSeqSTRUCTNAMEConsumer(seq);
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.forEach((OUTPUTMODIFIERConsumer)consumer));
  Assertions.assertEquals(100,seq.size());
  Assertions.assertEquals(300,seq.modCount);
  Assertions.assertEquals(100,consumer.size());
  var seqIterator=seq.iterator();
  var consumerIterator=consumer.iterator();
  for(int i=0;i<100;++i){
#IF OfRef
    Assertions.assertSame(consumerIterator.next(),seqIterator.next());
#ELSE
    Assertions.assertEquals(consumerIterator.next(),seqIterator.next());
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_ThrowingConsumer(){
  #MACRO ConstructionRoutine()
  var consumer=new $ClassPrefix$MonitoredConsumer.Throwing();
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertEquals(0,seq.modCount);
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_ThrowingConsumer(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var consumer=new $ClassPrefix$MonitoredConsumer.Throwing();
  Assertions.assertThrows(IndexOutOfBoundsException.class,()->seq.forEach((OUTPUTMODIFIERConsumer)consumer));
  Assertions.assertEquals(100,seq.size());
  Assertions.assertEquals(100,seq.modCount);
  Assertions.assertEquals(1,consumer.size());
  var seqIterator=seq.iterator();
  var consumerIterator=consumer.iterator();
  for(int i=0;i<1;++i){
#IF OfRef
    Assertions.assertSame(consumerIterator.next(),seqIterator.next());
#ELSE
    Assertions.assertEquals(consumerIterator.next(),seqIterator.next());
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsEmpty_ThrowingAndModdingConsumer(){
  #MACRO ConstructionRoutine()
  var consumer=new $ClassPrefix$MonitoredConsumer.ModifyingArrSeqSTRUCTNAMEAndThrowingConsumer(seq);
  seq.forEach((OUTPUTMODIFIERConsumer)consumer);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertEquals(0,seq.modCount);
  Assertions.assertTrue(consumer.isEmpty());
}
@Test
public void testSTRUCTNAMEforEach_OUTPUTMODIFIERConsumer_SeqIsNotEmpty_ThrowingAndModdingConsumer(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var consumer=new $ClassPrefix$MonitoredConsumer.ModifyingArrSeqSTRUCTNAMEAndThrowingConsumer(seq);
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.forEach((OUTPUTMODIFIERConsumer)consumer));
  Assertions.assertEquals(100,seq.size());
  Assertions.assertEquals(102,seq.modCount);
  Assertions.assertEquals(1,consumer.size());
}
#ENDIF
#ENDDEF
#MACRODEF TestMiscMethods<INITIALCAPACITY>()
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_zeroLengthArrayAndSequenceIsEmpty(){
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[0];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[0];
#ENDIF
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
  Assertions.assertEquals(0,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertSame(paramArr,result);
}
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_zeroLengthArrayAndSequenceNotEmpty(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
#IF OfRef
  Integer[] paramArr=new Integer[0];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[0];
#ENDIF
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertNotSame(paramArr,result);
  var itr=seq.iterator();
  for(int i=0;i<100;++i){
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_nonzeroLengthArrayAndSequenceIsEmpty(){
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[5];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[5];
#ENDIF
  for(int i=0;i<paramArr.length;++i){
    paramArr[i]=TypeConversionUtil.convertTo$ArrayType$(paramArr.length);
  }
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
  Assertions.assertEquals(5,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertSame(paramArr,result);
  Assertions.assertNull(result[0]);
  for(int i=1;i<result.length;++i){
    Assertions.assertEquals((Object)TypeConversionUtil.convertTo$ArrayType$(paramArr.length),result[i]);
  }
}
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_overSizedArray(){
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[10];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[10];
#ENDIF
  for(int i=0;i<paramArr.length;++i){
    paramArr[i]=TypeConversionUtil.convertTo$ArrayType$(paramArr.length);
  }
  #MACRO AddAscending(5,$ArrayType$)
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(5,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(5,seq.modCount);
#ENDIF
  Assertions.assertEquals(10,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertSame(paramArr,result);
  var itr=seq.iterator();
  for(int i=0;i<5;++i){
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
  Assertions.assertNull(result[5]);
  for(int i=6;i<result.length;++i){
    Assertions.assertEquals((Object)TypeConversionUtil.convertTo$ArrayType$(paramArr.length),result[i]);
  }
}
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_undersizedArray(){
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[5];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[5];
#ENDIF
  for(int i=0;i<paramArr.length;++i){
    paramArr[i]=TypeConversionUtil.convertTo$ArrayType$(10);
  }
  #MACRO AddAscending(10,$ArrayType$)
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(10,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(10,seq.modCount);
#ENDIF
  Assertions.assertEquals(10,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertNotSame(paramArr,result);
  var itr=seq.iterator();
  for(int i=0;i<10;++i){
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEtoArray_ObjectArray_exactSizeArray(){
  #MACRO ConstructionRoutine()
#IF OfRef
  Integer[] paramArr=new Integer[5];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[5];
#ENDIF
  for(int i=0;i<paramArr.length;++i){
    paramArr[i]=TypeConversionUtil.convertTo$ArrayType$(5);
  }
  #MACRO AddAscending(5,$ArrayType$)
  var result=seq.toArray(paramArr);
  Assertions.assertEquals(5,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(5,seq.modCount);
#ENDIF
  Assertions.assertEquals(5,result.length);
  Assertions.assertNotSame(seq.arr,result);
  Assertions.assertSame(paramArr,result);
  var itr=seq.iterator();
  for(int i=0;i<5;++i){
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsEmpty_nonMod(){
  #MACRO ConstructionRoutine()
#IF OfRef
  IntFunction<Integer[]> arrConstructor=Integer[]::new;
#ELSE
  IntFunction<$BoxedType$[]> arrConstructor=$BoxedType$[]::new;
#ENDIF
  var result=seq.toArray(arrConstructor);
  Assertions.assertEquals(0,seq.size());
  Assertions.assertNotSame(seq.arr,result);
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
  Assertions.assertEquals(0,result.length);
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsNotEmpty_nonMod(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
#IF OfRef
  IntFunction<Integer[]> arrConstructor=Integer[]::new;
#ELSE
  IntFunction<$BoxedType$[]> arrConstructor=$BoxedType$[]::new;
#ENDIF
  var result=seq.toArray(arrConstructor);
  Assertions.assertEquals(100,seq.size());
  Assertions.assertNotSame(seq.arr,result);
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,result.length);
  var itr=seq.iterator();
  for(int i=0;i<100;++i){
#IF OfRef
    Assertions.assertSame(itr.next(),result[i]);
#ELSE
    Assertions.assertEquals(itr.next(),result[i]);
#ENDIF
  }
}
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsEmpty_moddingArrayConstructor(){
  #MACRO ConstructionRoutine()
  #IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->{
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    return new Integer[arrSize];
  };
  #ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->{
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    return new $BoxedType$[arrSize];
  };
  #ENDIF
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(1,seq.size());
  Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),seq.arr[0]);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(1,seq.modCount);
  #ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsNotEmpty_moddingArrayConstructor(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  #IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->{
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    return new Integer[arrSize];
  };
  #ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->{
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    return new $BoxedType$[arrSize];
  };
  #ENDIF
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(101,seq.size());
  Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(100),seq.arr[100]);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(101,seq.modCount);
  #ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsEmpty_throwingArrayConstructor(){
  #MACRO ConstructionRoutine()
#IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->{
    throw new IndexOutOfBoundsException();
  };
#ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->{
    throw new IndexOutOfBoundsException();
  };
#ENDIF
  Assertions.assertThrows(IndexOutOfBoundsException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsNotEmpty_throwingArrayConstructor(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
#IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->{
    throw new IndexOutOfBoundsException();
  };
#ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->{
    throw new IndexOutOfBoundsException();
  };
#ENDIF
  Assertions.assertThrows(IndexOutOfBoundsException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsEmpty_throwingAndModdingArrConstructor(){
  #MACRO ConstructionRoutine()
  #IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->{
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    throw new IndexOutOfBoundsException();
  };
  #ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->{
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    throw new IndexOutOfBoundsException();
  };
  #ENDIF
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(1,seq.size());
  Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(0),seq.arr[0]);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(1,seq.modCount);
  #ENDIF
}
@Test
public void testSTRUCTNAMEtoArray_IntFunction_seqIsNotEmpty_throwingAndModdingArrConstructor(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  #IF OfRef
  IntFunction<Integer[]> arrConstructor=(int arrSize)->{
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    throw new IndexOutOfBoundsException();
  };
  #ELSE
  IntFunction<$BoxedType$[]> arrConstructor=(int arrSize)->{
    seq.add(TypeConversionUtil.convertTo$ArrayType$(arrSize));
    throw new IndexOutOfBoundsException();
  };
  #ENDIF
  Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toArray(arrConstructor));
  Assertions.assertEquals(101,seq.size());
  Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(100),seq.arr[100]);
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(101,seq.modCount);
  #ENDIF
}
#ENDIF
@Test
public void testSTRUCTNAMEclear_void_seqIsEmpty(){
  #MACRO ConstructionRoutine()
  seq.clear();
  Assertions.assertTrue(seq.isEmpty());
#IFSWITCH STRUCTNAME==CheckedStack,CheckedList
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEclear_void_seqIsNotEmpty(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  seq.clear();
  Assertions.assertTrue(seq.isEmpty());
  for(int i=0;i<100;++i){
#IF OfRef
    Assertions.assertNull(seq.arr[i]);
#ELSE
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(i),seq.arr[i]);
#ENDIF
  }
#IFSWITCH STRUCTNAME==CheckedStack,CheckedList
  Assertions.assertEquals(101,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEisEmpty_void_seqIsEmpty(){
  #MACRO ConstructionRoutine()
  Assertions.assertTrue(seq.isEmpty());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEisEmpty_void_seqIsNotEmpty(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  Assertions.assertFalse(seq.isEmpty());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEisEmpty_void_seqIsBeingCleared(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var itr=seq.iterator();
  for(int i=100;--i>=0;){
    Assertions.assertFalse(seq.isEmpty());
    itr.next$TypeNameModifier$();
    itr.remove();
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
    Assertions.assertEquals(100+(100-i),seq.modCount);
#ENDIF
  }
  Assertions.assertTrue(seq.isEmpty());
}
@Test
public void testSTRUCTNAMEsize_void_seqIsEmpty(){
  #MACRO ConstructionRoutine()
  Assertions.assertEquals(0,seq.size);
  Assertions.assertEquals(seq.size,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEsize_void_seqIsNotEmpty(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  Assertions.assertEquals(100,seq.size);
  Assertions.assertEquals(seq.size,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEsize_void_seqIsBeingCleared(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var itr=seq.iterator();
  for(int i=100;--i>=0;){
    itr.next$TypeNameModifier$();
    itr.remove();
    Assertions.assertEquals(i,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
    Assertions.assertEquals(100+(100-i),seq.modCount);
#ENDIF
  }
}
#ENDDEF

#MACRODEF TestClone<INITIALCAPACITY>()
@Test
public void testSTRUCTNAMEClone_initialCapacityINITIALCAPACITY_seqIsEmpty()
{
  #MACRO ConstructionRoutine()
  var clone=($ClassPrefix$ArrSeq.STRUCTNAME)seq.clone();
  Assertions.assertEquals(0,clone.size());
  Assertions.assertEquals(0,seq.size());
  Assertions.assertSame(clone.arr,OmniArray.Of$ClassPrefix$.DEFAULT_ARR);
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,clone.modCount);
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}

@Test
public void testSTRUCTNAMEClone_initialCapacityINITIALCAPACITY_seqIsNotEmpty()
{
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var clone=($ClassPrefix$ArrSeq.STRUCTNAME)seq.clone();
  Assertions.assertEquals(100,clone.size());
  Assertions.assertEquals(100,seq.size());
  Assertions.assertNotSame(seq.arr,clone.arr);
  for(int i=0;i<100;++i)
  {
    Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(i),clone.arr[i]);
#IF OfRef
    Assertions.assertSame(seq.arr[i],clone.arr[i]);
#ENDIF
  }
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,clone.modCount);
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
}
#ENDDEF


#MACRODEF TestOutputMethods<INITIALCAPACITY>(OUTPUTTYPE,OUTPUTMODIFIER,DEFAULTVAL,DEFAULTARR)
@Test
public void testSTRUCTNAMEtoOUTPUTMODIFIERArray_void_seqIsEmpty(){
  #MACRO ConstructionRoutine()
  Assertions.assertSame(DEFAULTARR,seq.toOUTPUTMODIFIERArray());
  Assertions.assertEquals(0,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(0,seq.modCount);
#ENDIF
}
@Test
public void testSTRUCTNAMEtoOUTPUTMODIFIERArray_void_seqIsNotEmpty(){
  #MACRO ConstructionRoutine()
  #MACRO AddAscending(100,$ArrayType$)
  var result=seq.toOUTPUTMODIFIERArray();
  Assertions.assertEquals(100,seq.size());
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  Assertions.assertEquals(100,seq.modCount);
#ENDIF
  Assertions.assertEquals(100,result.length);
  var itr=seq.iterator();
  for(int i=0;i<100;++i){
#IF OfRef
    Assertions.assertSame(itr.nextOUTPUTMODIFIER(),result[i]);
#ELSE
    Assertions.assertEquals(itr.nextOUTPUTMODIFIER(),result[i]);
#ENDIF
  }
  Assertions.assertNotSame(seq.arr,result);
}
#ENDDEF

#MACRODEF ConstructionRoutine()
#IFSWITCH INITIALCAPACITY==DEFAULT
var seq=new $ClassPrefix$ArrSeq.STRUCTNAME();
#ELSEIFSWITCH INITIALCAPACITY==NULL
var seq=new $ClassPrefix$ArrSeq.STRUCTNAME(0,null);
#ELSE
var seq=new $ClassPrefix$ArrSeq.STRUCTNAME(INITIALCAPACITY);
#ENDIF
#ENDDEF
#MACRODEF AddAscending(NUM_TO_ADD,INPUTTYPE)
for(int i=0;i<NUM_TO_ADD;++i){
  Assertions.assertTrue(seq.add(TypeConversionUtil.convertToINPUTTYPE(i)));
}
#ENDDEF

#MACRODEF VerifyIntegrity()
#IFSWITCH STRUCT==Stack,List
private static void verifyIntegrity($ClassPrefix$ArrSeq.CHECKEDSTRUCT seq,int expectedModCount,int expected
#ELSE
#ENDIF
#ENDDEF

#MACRODEF TestContains<INPUTTYPE>()
@ParameterizedTest
@MethoSource("getCHECKEDSTRUCTcontainsINPUTTYPETestArgs")
#IFSWITCH STRUCTNAME==Stack,List
public void testCHECKEDSTRUCTcontains($ClassPrefix$ArrSeq.CHECKEDSTRUCT seq,INPUTTYPE input,boolean expectedReturn,Class<? extends Throwable> expectedException)
{
  if(expectedException==null)
  {
    #IFSWITCH  
  }
  else
  {
  }
}
#ELSE
#ENDIF
#ENDDEF

