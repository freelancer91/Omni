#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
#IF OfRef
import omni.impl.CheckedCollectionTest;
#ENDIF
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import java.util.ConcurrentModificationException;
#IFNOT OfChar,OfDouble,OfRef
import omni.util.OmniArray;
#ENDIF
@SuppressWarnings({"rawtypes","unchecked"}) 
public class $ClassPrefix$ArrSeqToStringTest
{
#IF OfRef
  private static final $ArrayType$ MIN_LENGTH_STRING_VAL=new $ArrayType$(){@Override public String toString(){return "";}};
#ELSEIF OfBoolean
  private static final $ArrayType$ MIN_LENGTH_STRING_VAL=true;
#ELSE
  private static final $ArrayType$ MIN_LENGTH_STRING_VAL=0;
#ENDIF
  private static final int MIN_TOSTRING_LENGTH=String.valueOf(MIN_LENGTH_STRING_VAL).length();

#IF OfBoolean
  private static final int MAX_TOSTRING_LENGTH=5;
#ELSEIF OfByte
  private static final int MAX_TOSTRING_LENGTH=4;
#ELSEIF OfShort
  private static final int MAX_TOSTRING_LENGTH=6;
#ELSEIF OfInt
  private static final int MAX_TOSTRING_LENGTH=11;
#ELSEIF OfLong
  private static final int MAX_TOSTRING_LENGTH=20;
#ELSEIF OfFloat
  private static final int MAX_TOSTRING_LENGTH=15;
#ENDIF

  private static void testArrSeqToString(int length)
  {
    final var arr=new $ArrayType$[length];
    var arrayList=new ArrayList(length);
  #IF OfRef
    var val=Integer.valueOf(0);
    var boxedVal=val;
  #ELSEIF OfBoolean
    var val=true;
    var boxedVal=Boolean.TRUE;
  #ELSE
    var val=($exposedType$)0;
    var boxedVal=$BoxedType$.valueOf(val);
  #ENDIF
    for(int i=0;i<length;++i)
    {
      arr[i]=val;
      arrayList.add(boxedVal);
    }
    {
      var expected=arrayList.toString();
      {
        var checkedList=new $ClassPrefix$ArrSeq.CheckedList(length,arr);
        Assertions.assertEquals(expected,checkedList.toString());
        Assertions.assertEquals(expected,checkedList.subList(0,length).toString());
      }
      {
        var uncheckedList=new $ClassPrefix$ArrSeq.UncheckedList(length,arr);
        Assertions.assertEquals(expected,uncheckedList.toString());
        Assertions.assertEquals(expected,uncheckedList.subList(0,length).toString());
      }
    }
    {
      for(int l=0,r=length-1;l<r;++l,--r)
      {
        arrayList.set(r,arrayList.set(l,arrayList.get(r)));
      }
      var expected=arrayList.toString();
      arrayList=null;
      Assertions.assertEquals(expected,new $ClassPrefix$ArrSeq.CheckedStack(length,arr).toString());
      Assertions.assertEquals(expected,new $ClassPrefix$ArrSeq.UncheckedStack(length,arr).toString());
    }
  }

  @Test
  public void testSmallArrSeqToString()
  {
    testArrSeqToString(100);
  }
  @Test
  public void testEmptyArrSeqToString()
  {
    var expected=new ArrayList().toString();
    {
      var root=new $ClassPrefix$ArrSeq.CheckedList();
      Assertions.assertEquals(expected,root.toString());
      var subList=root.subList(0,0);
      Assertions.assertEquals(expected,subList.toString());
      root.add($defaultVal$);
      Assertions.assertThrows(ConcurrentModificationException.class,()->subList.toString());
    }
    {
      var root=new $ClassPrefix$ArrSeq.UncheckedList();
      Assertions.assertEquals(expected,root.toString());
      Assertions.assertEquals(expected,root.subList(0,0).toString());
    }
    Assertions.assertEquals(expected,new $ClassPrefix$ArrSeq.CheckedStack().toString());
    Assertions.assertEquals(expected,new $ClassPrefix$ArrSeq.UncheckedStack().toString());
  }
  //@Test
  public void testOOMArrSeqToString()
  {
#IF OfBoolean,OfByte,OfChar,OfInt,OfLong,OfShort
    int length=Integer.MAX_VALUE/(MIN_TOSTRING_LENGTH+2)-1;
#ELSEIF OfFloat
    int length=Integer.MAX_VALUE/(MIN_TOSTRING_LENGTH+2)-3;
#ELSEIF OfRef
    int length=Integer.MAX_VALUE/(MIN_TOSTRING_LENGTH+2)-1;
#ELSE
    int length=Integer.MAX_VALUE/(MIN_TOSTRING_LENGTH+2)-1;
#ENDIF
    final $ArrayType$[] arr=new $ArrayType$[length+1];
#IF OfBoolean,OfRef
    for(int i=0;i<length;++i)
    {
      arr[i]=MIN_LENGTH_STRING_VAL;
    }
#ENDIF
    {
      var root=new $ClassPrefix$ArrSeq.CheckedList(length,arr);
      Assertions.assertDoesNotThrow(()->root.toString());
      ++root.size;
      Assertions.assertThrows(OutOfMemoryError.class,()->root.toString());
      --root.size;
      var subList=root.subList(0,root.size);
      Assertions.assertDoesNotThrow(()->subList.toString());
      subList.add(MIN_LENGTH_STRING_VAL);
      Assertions.assertThrows(OutOfMemoryError.class,()->subList.toString());
    }
    {
      var root=new $ClassPrefix$ArrSeq.UncheckedList(length,arr);
      Assertions.assertDoesNotThrow(()->root.toString());
      ++root.size;
      Assertions.assertThrows(OutOfMemoryError.class,()->root.toString());
      --root.size;
      var subList=root.subList(0,root.size);
      Assertions.assertDoesNotThrow(()->subList.toString());
      subList.add(MIN_LENGTH_STRING_VAL);
      Assertions.assertThrows(OutOfMemoryError.class,()->subList.toString());
    }
    {
      var root=new $ClassPrefix$ArrSeq.CheckedStack(length,arr);
      Assertions.assertDoesNotThrow(()->root.toString());
      ++root.size;
      Assertions.assertThrows(OutOfMemoryError.class,()->root.toString());
    }
    {
      var root=new $ClassPrefix$ArrSeq.UncheckedStack(length,arr);
      Assertions.assertDoesNotThrow(()->root.toString());
      ++root.size;
      Assertions.assertThrows(OutOfMemoryError.class,()->root.toString());
    }
  }

#IF OfBoolean,OfByte,OfShort,OfInt,OfLong,OfFloat
  //TODO make this faster or place is switch to disable it as desired
  //@Test
  public void testLargeArrSeqToString()
  {
    testArrSeqToString((OmniArray.MAX_ARR_SIZE/(MAX_TOSTRING_LENGTH+2))+1);
  }
#ENDIF

#IF OfRef
  @Test
  public void testArrSeqModificationCheck()
  {
    {
      var root=new $ClassPrefix$ArrSeq.CheckedList();
      var subList=root.subList(0,0);
      var rootModifyingObject=CheckedCollectionTest.createCollectionModifyingObject(root);
      for(int i=0;i<10;++i)
      {
        subList.add(rootModifyingObject);
      }
      Assertions.assertThrows(ConcurrentModificationException.class,()->subList.toString());
    }
    {
      var root=new $ClassPrefix$ArrSeq.CheckedList();
      var subList=root.subList(0,0);
      var subListModifyingObject=CheckedCollectionTest.createCollectionModifyingObject(subList);
      for(int i=0;i<10;++i)
      {
        subList.add(subListModifyingObject);
      }
      Assertions.assertThrows(ConcurrentModificationException.class,()->subList.toString());
    }
    {
      var seq=new $ClassPrefix$ArrSeq.CheckedList();
      var seqModifyingObject=CheckedCollectionTest.createCollectionModifyingObject(seq);
      for(int i=0;i<10;++i)
      {
        seq.add(seqModifyingObject);
      }
      Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toString());
    }
    {
      var seq=new $ClassPrefix$ArrSeq.CheckedStack();
      var seqModifyingObject=CheckedCollectionTest.createCollectionModifyingObject(seq);
      for(int i=0;i<10;++i)
      {
        seq.add(seqModifyingObject);
      }
      Assertions.assertThrows(ConcurrentModificationException.class,()->seq.toString());
    }
  }
#ENDIF
}