#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
#IF OfDouble,OfLong,OfInt
import java.util.function.$TypeNameModifier$Consumer;
import java.util.function.$TypeNameModifier$Predicate;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Consumer;
import omni.function.$TypeNameModifier$Predicate;
#ENDIF
import java.util.function.Consumer;
import java.io.IOException;
import omni.util.TypeConversionUtil;
import org.junit.jupiter.api.Assertions;
import omni.impl.$ClassPrefix$InputTestArgType;
import omni.impl.$ClassPrefix$OutputTestArgType;
import org.junit.jupiter.params.provider.Arguments;
import java.util.NoSuchElementException;
import java.util.stream.Stream;
#IFNOT OfRef,OfDouble,OfChar
import omni.util.OmniArray;
#ENDIF
import omni.impl.$SNode$;
import omni.api.OmniIterator;
import java.util.function.Predicate;
import omni.impl.FunctionCallType;
import omni.impl.QueryCastType;
import java.io.File;
import omni.api.OmniStack;
import omni.util.TypeUtil;
import org.junit.jupiter.api.Tag;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.Externalizable;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;
import omni.impl.seq.$ClassPrefix$SeqMonitor.CheckedType;
import omni.impl.seq.$ClassPrefix$SeqMonitor.PreModScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.SequenceLocation;
import omni.impl.seq.$ClassPrefix$SeqMonitor.SequenceContentsScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.IterationScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.ItrRemoveScenario;
import omni.impl.seq.$ClassPrefix$SeqMonitor.MonitoredFunctionGen;
import omni.impl.seq.$ClassPrefix$SeqMonitor.MonitoredRemoveIfPredicateGen;
import java.nio.file.Files;
#IF OfRef
import omni.impl.seq.$ClassPrefix$SeqMonitor.MonitoredObjectGen;
import omni.impl.seq.$ClassPrefix$SeqMonitor.MonitoredObject;
#ENDIF
import omni.impl.seq.$ClassPrefix$SeqMonitor.SequenceVerificationItr;
import omni.api.OmniCollection;
import java.util.ArrayList;
@SuppressWarnings({"rawtypes","unchecked"})
@Tag("SnglLnkSeq")
@Execution(ExecutionMode.CONCURRENT)
public class $ClassPrefix$SnglLnkSeqTest{
  #MACRO TestMethods(true)
#MACRODEF TestMethods(PARALLEL)
#MACRO testConstructor_void<PARALLEL>()
#MACRO testItrnext_void<PARALLEL>()
#MACRO testItrremove_void<PARALLEL>()
#MACRO testItrforEachRemaining_Consumer<PARALLEL>()
#MACRO testforEach_Consumer<PARALLEL>()
#MACRO testremoveIf_Predicate<PARALLEL>()
#MACRO testclone_void<PARALLEL>()
#MACRO testsize_void<PARALLEL>()
#MACRO testisEmpty_void<PARALLEL>()
#MACRO testadd_val<PARALLEL>()
#MACRO testStackpush_val<PARALLEL>()
#MACRO testQueueoffer_val<PARALLEL>()
#MACRO testcontains_val<PARALLEL>()
#MACRO testsearch_val<PARALLEL>()
#MACRO testremoveVal_val<PARALLEL>()
#MACRO testpeek_void<PARALLEL>()
#MACRO testpoll_void<PARALLEL>()
#MACRO testpop_void<PARALLEL>()
#MACRO testreadAndwriteObject<PARALLEL>()
#MACRO testtoArray_void<PARALLEL>()
#MACRO testclear_void<PARALLEL>()
#MACRO testQueueelement_void<PARALLEL>()
#MACRO testtoArray_IntFunction<PARALLEL>()
#MACRO testtoArray_ObjectArray<PARALLEL>()
#MACRO testMASSIVEtoString_void<PARALLEL>()
#MACRO testtoString_void<PARALLEL>()
#MACRO testhashCode_void<PARALLEL>()
#ENDDEF
  @FunctionalInterface
  interface ArgBuilder{
    void buildArgs(Stream.Builder<Arguments> streamBuilder,NestedType nestedType,CheckedType checkedType);
    static Stream<Arguments> buildSeqArgs(ArgBuilder argBuilder){
      Stream.Builder<Arguments> streamBuilder=Stream.builder();
      for(var nestedType:NestedType.values()){
        for(var checkedType:CheckedType.values()){
          argBuilder.buildArgs(streamBuilder,nestedType,checkedType);
        }
      }
      return streamBuilder.build();
    }
  }
  static Stream<Arguments> getPeekPollAndPopArgs(){
    return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
      for(var outputType:$ClassPrefix$OutputTestArgType.values()){
        streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),outputType));
      }
    });
  }
  static Stream<Arguments> gettoStringAndhashCode_voidArgs(){
   return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
     for(int seqSize:new int[]{0,1,100}){
  #IF OfRef
       for(var monitoredObjectGen:MonitoredObjectGen.values()){
         if(monitoredObjectGen.expectedException==null || (checkedType.checked && monitoredObjectGen.appliesToRoot)){
           streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),seqSize,monitoredObjectGen));
         }
       }
  #ELSE
       streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),seqSize));
  #ENDIF
     }
   });
  }
  private static class $ClassPrefix$SnglLnkSeqMonitor implements $ClassPrefix$SeqMonitor{
    
    
    NestedType nestedType;
    CheckedType checkedType;
    final $ClassPrefix$SnglLnkSeq seq;
    int expectedSeqSize;
    int expectedSeqModCount;
#IFNOT OfRef,OfDouble,OfChar
    $ClassPrefix$SnglLnkSeqMonitor(NestedType nestedType,CheckedType checkedType,$SNode$ head,int seqSize,$SNode$ tail){
      this.nestedType=nestedType;
      this.checkedType=checkedType;
      this.expectedSeqSize=seqSize;
      switch(nestedType){
        case QUEUE:
          this.seq=checkedType.checked?new $ClassPrefix$SnglLnkSeq.CheckedQueue(head,seqSize,tail):new $ClassPrefix$SnglLnkSeq.UncheckedQueue(head,seqSize,tail);
          break;
        case STACK:
          this.seq=checkedType.checked?new $ClassPrefix$SnglLnkSeq.CheckedStack(head,seqSize):new $ClassPrefix$SnglLnkSeq.UncheckedStack(head,seqSize);
          break;
        default:
          throw new Error("unknown nested type "+nestedType);
      }
    }
#ENDIF
    $ClassPrefix$SnglLnkSeqMonitor(NestedType nestedType,CheckedType checkedType){
      this.nestedType=nestedType;
      this.checkedType=checkedType;
      switch(nestedType){
        case QUEUE:
          this.seq=checkedType.checked?new $ClassPrefix$SnglLnkSeq.CheckedQueue():new $ClassPrefix$SnglLnkSeq.UncheckedQueue();
          break;
        case STACK:
          this.seq=checkedType.checked?new $ClassPrefix$SnglLnkSeq.CheckedStack():new $ClassPrefix$SnglLnkSeq.UncheckedStack();
          break;
        default:
          throw new Error("unknown nested type "+nestedType);
      }
    }
    public int getExpectedSeqSize(){
      return this.expectedSeqSize;
    }
    public void illegalAdd(PreModScenario preModScenario){
      switch(preModScenario){
        case ModSeq:
          $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(seq,0);
          ++expectedSeqModCount;
          ++expectedSeqSize;
          break;
        case NoMod:
          break;
        default:
          throw new Error("Unknown preModScenario "+preModScenario);
      }
    }
  #IF OfRef
    public boolean add(Object obj){
      boolean ret=seq.add(obj);
      if(ret)
      {
        ++expectedSeqSize;
        ++expectedSeqModCount;
      }
      return ret;
    }
  #ENDIF
    public boolean add(int val,$ClassPrefix$InputTestArgType inputArgType){
      boolean ret=inputArgType.callCollectionAdd(seq,val);
      if(ret){
        ++expectedSeqSize;
        ++expectedSeqModCount;
      }
      return ret;
    }
    public boolean offer(int val,$ClassPrefix$InputTestArgType inputArgType){
      boolean ret=inputArgType.callQueueOffer(seq,val);
      if(ret){
        ++expectedSeqSize;
        ++expectedSeqModCount;
      }
      return ret;
    }
    public void push(int val,$ClassPrefix$InputTestArgType inputArgType){
      inputArgType.callStackPush(seq,val);
      ++expectedSeqSize;
      ++expectedSeqModCount;
    }
    public String toString(){
      StringBuilder builder=new StringBuilder();
      builder.append("$ClassPrefix$SnglLnkSeq.").append(checkedType.checked?"Checked":"Unchecked");
      switch(nestedType){
        case STACK:
          builder.append("Stack");
          break;
        case QUEUE:
          builder.append("Queue");
          break;
        default:
          throw new Error("Unknown nestedType "+nestedType);
      }
      return builder.toString();
    }
    public boolean isEmpty(){
      return seq.isEmpty();
    }
    public void forEach(MonitoredConsumer action,FunctionCallType functionCallType){
  #IFNOT OfRef
      if(functionCallType==FunctionCallType.Boxed){
        seq.forEach((Consumer)action);
      }else
  #ENDIF
      {
        seq.forEach(($TypeNameModifier$Consumer)action);
      }
    }
    public void clear(){
      int seqSize=expectedSeqSize;
      seq.clear();
      if(seqSize!=0){
        expectedSeqSize=0;
        ++expectedSeqModCount;
      }
    }
    public void pop(int expectedVal,$ClassPrefix$OutputTestArgType outputType){
      switch(nestedType)
      {
        case QUEUE:
          outputType.verifyQueueRemove(seq,expectedVal);
          break;
        case STACK:
          outputType.verifyStackPop(seq,expectedVal);
          break; 
        default:
          throw new Error("Unknown nested type "+nestedType);
      }
     
      --expectedSeqSize;
      ++expectedSeqModCount;
    }
    public void poll(int expectedVal,$ClassPrefix$OutputTestArgType outputType){
      outputType.verifyPoll(seq,expectedSeqSize,expectedVal);
      if(expectedSeqSize!=0){
        --expectedSeqSize;
        ++expectedSeqModCount;
      }
    }
    public void verifyRemoveIf(MonitoredRemoveIfPredicate pred,FunctionCallType functionCallType,int expectedNumRemoved,OmniCollection.Of$ClassPrefix$ clone){
  #IF OfBoolean
      int seqSize=expectedSeqSize;
  #ENDIF
      boolean retVal;
  #IFNOT OfRef
      if(functionCallType==FunctionCallType.Boxed){
        retVal=seq.removeIf((Predicate)pred);
      }
      else
  #ENDIF
      {
        retVal=seq.removeIf(($TypeNameModifier$Predicate)pred);
      }
      if(retVal){
        ++expectedSeqModCount;
        int numRemoved;
  #IF OfBoolean
        int numTrue=0,numFalse=0;
        var cloneItr=clone.iterator();
        while(cloneItr.hasNext()){
          if(cloneItr.next$TypeNameModifier$()){
            ++numTrue;
          }else{
            ++numFalse;
          }
        }
        if(pred.removedVals.contains(true)){
          if(pred.removedVals.contains(false)){
            numRemoved=seqSize;
            Assertions.assertTrue(seq.isEmpty());
          }else{
            numRemoved=numTrue;
            Assertions.assertFalse(seq.contains(true));
          }
        }else{
          numRemoved=numFalse;
          Assertions.assertFalse(seq.contains(false));
        }
  #ELSE
        numRemoved=pred.numRemoved;
        for(var removedVal:pred.removedVals){
          Assertions.assertFalse(seq.contains(removedVal));
        }
  #ENDIF
        expectedSeqSize-=numRemoved;
        if(expectedNumRemoved!=-1){
          Assertions.assertEquals(expectedNumRemoved,numRemoved);
        }
      }else{
        Assertions.assertEquals(expectedSeqSize,clone.size());
        var seqItr=seq.iterator();
        var cloneItr=clone.iterator();
        for(int i=0;i<expectedSeqSize;++i){
  #IF OfRef
          Assertions.assertSame(seqItr.next(),cloneItr.next());
  #ELSE
          Assertions.assertEquals(seqItr.next$TypeNameModifier$(),cloneItr.next$TypeNameModifier$());
  #ENDIF
        }
      }
      verifyStructuralIntegrity();
    }
    public void writeObject(ObjectOutputStream oos) throws IOException{
      ((Externalizable)seq).writeExternal(oos);
    }
    public Object readObject(ObjectInputStream ois) throws IOException,ClassNotFoundException{
      return ois.readObject();
    }
    public void verifyStructuralIntegrity(){
      Assertions.assertEquals(expectedSeqSize,seq.size);
      if(checkedType.checked){
        switch(nestedType){
          case QUEUE:
            Assertions.assertEquals(expectedSeqModCount,(($ClassPrefix$SnglLnkSeq.CheckedQueue)seq).modCount);
            break;
          case STACK:
            Assertions.assertEquals(expectedSeqModCount,(($ClassPrefix$SnglLnkSeq.CheckedStack)seq).modCount);
            break;
          default:
            throw new Error("Unknown nested type "+nestedType);
        }
      }
      if(expectedSeqSize==0){
        Assertions.assertNull(seq.head);
      }else{
        $SNode$ node;
        Assertions.assertNotNull(node=seq.head);
        int i=expectedSeqSize;
        while(--i!=0){
          Assertions.assertNotNull(node=node.next);
        }
        Assertions.assertNull(node.next);
      }
    }
    class UncheckedSnglLnkSeqItrMonitor implements ItrMonitor{
      final OmniIterator.Of$ClassPrefix$ itr;
      $SNode$ expectedPrev;
      $SNode$ expectedCurr;
      $SNode$ expectedNext;
      UncheckedSnglLnkSeqItrMonitor(){
        this.expectedNext=seq.head;
        this.itr=seq.iterator();
      }
      public void forEachRemaining(MonitoredConsumer action,FunctionCallType functionCallType){
  #IFNOT OfRef
        if(functionCallType==FunctionCallType.Boxed){
          itr.forEachRemaining((Consumer)action);
        }else
  #ENDIF
        {
          itr.forEachRemaining(($TypeNameModifier$Consumer)action);
        }
        $SNode$ expectedNext;
        if((expectedNext=this.expectedNext)!=null){
          $SNode$ expectedPrev,expectedCurr=this.expectedCurr;
          do{
            expectedPrev=expectedCurr;
          }while((expectedNext=(expectedCurr=expectedNext).next)!=null);
          this.expectedPrev=expectedPrev;
          this.expectedCurr=expectedCurr;
          this.expectedNext=null;
        }
      }
      public $ClassPrefix$SeqMonitor getSeqMonitor(){
        return $ClassPrefix$SnglLnkSeqMonitor.this;
      }
      public void verifyNext(int expectedVal,$ClassPrefix$OutputTestArgType outputType){
        outputType.verifyItrNext(itr,expectedVal);
        final $SNode$ expectedNext;
        this.expectedNext=(expectedNext=this.expectedNext).next;
        this.expectedPrev=this.expectedCurr;
        this.expectedCurr=expectedNext;
      }
      public void verifyIteratorState(){
        Assertions.assertSame(expectedPrev,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.AbstractItr.prev(itr));
        Assertions.assertSame(expectedCurr,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.AbstractItr.curr(itr));
        Assertions.assertSame(expectedNext,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.AbstractItr.next(itr));
        switch(nestedType)
        {
          case STACK:
            if(checkedType.checked)
            {
              Assertions.assertSame(seq,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.CheckedStack.Itr.parent(itr));
            }
            else
            {
              Assertions.assertSame(seq,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.UncheckedStack.Itr.parent(itr));
            }
            break;
          case QUEUE:
            if(checkedType.checked)
            {
              Assertions.assertSame(seq,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.CheckedQueue.Itr.parent(itr));
            }
            else
            {
              Assertions.assertSame(seq,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.UncheckedQueue.Itr.parent(itr));
            }
            break;
          default:
            throw new Error("Unknown nested type "+nestedType);
        }
      }
      public void iterateForward(){
        itr.next();
        final $SNode$ expectedNext;
        this.expectedNext=(expectedNext=this.expectedNext).next;
        this.expectedPrev=this.expectedCurr;
        this.expectedCurr=expectedNext;
      }
      public void remove(){
        itr.remove();
        --expectedSeqSize;
        ++expectedSeqModCount;
        this.expectedCurr=this.expectedPrev;
      }
      public boolean hasNext(){
        return itr.hasNext();
      }
    }
    class CheckedSnglLnkSeqItrMonitor extends UncheckedSnglLnkSeqItrMonitor
    {
      int expectedItrModCount;
      private CheckedSnglLnkSeqItrMonitor(){
        super();
        this.expectedItrModCount=expectedSeqModCount;
      }
      public void verifyIteratorState(){
        Assertions.assertSame(expectedPrev,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.AbstractItr.prev(itr));
        Assertions.assertSame(expectedCurr,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.AbstractItr.curr(itr));
        Assertions.assertSame(expectedNext,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.AbstractItr.next(itr));
        switch(nestedType)
        {
          case STACK:
            if(checkedType.checked)
            {
              Assertions.assertSame(seq,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.CheckedStack.Itr.parent(itr));
              Assertions.assertEquals(expectedItrModCount,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.CheckedStack.Itr.modCount(itr));
            }
            else
            {
              Assertions.assertSame(seq,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.UncheckedStack.Itr.parent(itr));
            }
            break;
          case QUEUE:
            if(checkedType.checked)
            {
              Assertions.assertSame(seq,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.CheckedQueue.Itr.parent(itr));
              Assertions.assertEquals(expectedItrModCount,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.CheckedQueue.Itr.modCount(itr));
            }
            else
            {
              Assertions.assertSame(seq,FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.UncheckedQueue.Itr.parent(itr));
            }
            break;
          default:
            throw new Error("Unknown nested type "+nestedType);
        }
        
      }
      @Override public void remove(){
        super.remove();
        ++expectedItrModCount;
      }
    }
    private static class SnglLnkSeqSequenceVerificationItr extends SequenceVerificationItr{
      $SNode$ curr;
      final $ClassPrefix$SnglLnkSeqMonitor seqMonitor;
      private SnglLnkSeqSequenceVerificationItr($ClassPrefix$SnglLnkSeqMonitor seqMonitor,$SNode$ curr){
        this.seqMonitor=seqMonitor;
        this.curr=curr;
      }
      @Override public SequenceVerificationItr verifyPostAlloc(int expectedVal){
        Assertions.assertNull(curr);
        return this;
      }
      @Override public void verifyLiteralIndexAndIterate($ArrayType$ val){
  #IF OfRef
        Assertions.assertSame(val,curr.val);
  #ELSE
        Assertions.assertEquals(val,curr.val);
  #ENDIF
        curr=curr.next;
      }
  #IF OfRef
      @Override public void verifyIndexAndIterate(MonitoredObject monitoredObject){
        Object v;
        if((v=curr.val) instanceof MonitoredObject){
          Assertions.assertEquals(monitoredObject.compareVal,((MonitoredObject)v).compareVal);
        }else{
          Assertions.assertEquals(monitoredObject.compareVal,(Object)v);
        }
        curr=curr.next;
      }
  #ENDIF
      @Override public void verifyIndexAndIterate($ClassPrefix$InputTestArgType inputArgType,int val){
        inputArgType.verifyVal(val,curr.val);
        curr=curr.next;
      }
      @Override public SequenceVerificationItr getPositiveOffset(int i){
        if(i<0){
          throw new Error("offset cannot be negative: "+i);
        }
        var currCopy=curr;
        while(i>0)
        {
          --i;
          currCopy=currCopy.next;
        }
        
        return new SnglLnkSeqSequenceVerificationItr(seqMonitor,currCopy);
      }
      @Override public SequenceVerificationItr skip(int i){
        if(i<0){
          throw new Error("offset cannot be negative: "+i);
        }
        while(i>0)
        {
          --i;
          curr=curr.next;
        }
        return this;
      }
      @Override public boolean equals(Object val){
        final SnglLnkSeqSequenceVerificationItr that;
        return val==this || (val instanceof SnglLnkSeqSequenceVerificationItr && (that=(SnglLnkSeqSequenceVerificationItr)val).seqMonitor.seq==this.seqMonitor.seq && that.curr==this.curr);
      }
      @Override public SequenceVerificationItr verifyRootPostAlloc(){
        Assertions.assertNull(curr);
        return this;
      }
      @Override public SequenceVerificationItr verifyParentPostAlloc(){
        Assertions.assertNull(curr);
        return this;
      }
      @Override public SequenceVerificationItr verifyPostAlloc(){
        Assertions.assertNull(curr);
        return this;
      
      }
      @Override public SequenceVerificationItr verifyPostAlloc(PreModScenario preModScenario){
        if(seqMonitor.nestedType.forwardIteration && preModScenario==PreModScenario.ModSeq){
          verifyIllegalAdd();
        }
        Assertions.assertNull(curr);
        return this;
      
      }
      public SequenceVerificationItr verifyNaturalAscending(int v,$ClassPrefix$InputTestArgType inputArgType,int length)
      {
        if(seqMonitor.nestedType.forwardIteration)
        {
          return verifyAscending(v,inputArgType,length);
        }
        else
        {
          return verifyDescending(v+length,inputArgType,length);
        }
      }
     
      
    }
    public UncheckedSnglLnkSeqItrMonitor getItrMonitor(){
      return checkedType.checked
        ?new CheckedSnglLnkSeqItrMonitor()
        :new UncheckedSnglLnkSeqItrMonitor();
    }
    public SequenceVerificationItr verifyPreAlloc(PreModScenario preModScenario){
      var verifyItr=new SnglLnkSeqSequenceVerificationItr(this,seq.head);
      if(!nestedType.forwardIteration && preModScenario==PreModScenario.ModSeq){
        verifyItr.verifyIllegalAdd();
      }
      return verifyItr;
    }
    
    public SequenceVerificationItr verifyPreAlloc(){
      return new SnglLnkSeqSequenceVerificationItr(this,seq.head);
    }
    public SequenceVerificationItr verifyPreAlloc(int expectedVal){
      return new SnglLnkSeqSequenceVerificationItr(this,seq.head);
    }
    
    public String callToString(){
      return seq.toString();
    }
    
  }
  static enum NestedType{
    QUEUE(true),
    STACK(false);
    final boolean forwardIteration;
    NestedType(boolean forwardIteration){
      this.forwardIteration=forwardIteration;
    }
  }
  static enum QueryTester
  {
#IF OfRef
    ObjectNonNull(true){
      @Override boolean invokecontainsObject($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokecontainsBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokecontainsUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokeremoveValObject($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokeremoveValBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokeremoveValUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokesearchObject($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokesearchBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokesearchUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override void addEqualsVal($ClassPrefix$SnglLnkSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override void addNotEqualsVal($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
        seqMonitor.seq.add(new Object());
        ++seqMonitor.expectedSeqModCount;
        ++seqMonitor.expectedSeqSize;
      }
      @Override boolean invokecontainsMonitored($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        return seqMonitor.seq.contains(monitoredObject);
      }
      @Override boolean invokeremoveValMonitored($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        boolean ret=seqMonitor.seq.remove(monitoredObject);
        if(ret){
          ++seqMonitor.expectedSeqModCount;
          --seqMonitor.expectedSeqSize;
        }
        return ret;
      }
      @Override int invokesearchMonitored($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        return ((OmniStack.Of$ClassPrefix$)seqMonitor.seq).search(monitoredObject);
      }
      @Override int initContainsEnd($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject,int seqSize){
        Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
        for(int i=0;i<seqSize-1;++i){
          seqMonitor.seq.add(new Object());
        }
        seqMonitor.seq.add(monitoredObject);
        seqMonitor.expectedSeqModCount+=seqSize;
        seqMonitor.expectedSeqSize+=seqSize;
        if(seqMonitor.nestedType.forwardIteration)
        {
          return seqMonitor.expectedSeqSize-1;
        }
        else
        {
          return 0;
        }
        
      }
      @Override int initContainsMiddle($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject,int seqSize){
        Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
        for(int i=0,bound=seqSize/2;i<bound;++i){
          seqMonitor.seq.add(new Object());
        }
        seqMonitor.seq.add(monitoredObject);
        for(int i=(seqSize/2)+1;i<seqSize;++i){
          seqMonitor.seq.add(new Object());
        }
        seqMonitor.expectedSeqModCount+=seqSize;
        seqMonitor.expectedSeqSize+=seqSize;
        if(seqMonitor.nestedType.forwardIteration)
        {
          return seqMonitor.expectedSeqSize/2;
        }
        else
        {
          return (seqMonitor.expectedSeqSize/2)-1;
        }
        
      }
      @Override int initContainsBeginning($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject,int seqSize){
        Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
        seqMonitor.seq.add(monitoredObject);
        for(int i=1;i<seqSize;++i){
          seqMonitor.seq.add(new Object());
        }
        seqMonitor.expectedSeqModCount+=seqSize;
        seqMonitor.expectedSeqSize+=seqSize;
        if(seqMonitor.nestedType.forwardIteration)
        {
          return 0;
        }
        else
        {
          return seqMonitor.expectedSeqSize-1;
        }
      }
    },
#ENDIF
  #MACRO QueryTesterImpl<null,Boolean,Boolean>(null,false)
  #MACRO QueryTesterImpl<null,Byte,Byte>(null,false)
  #MACRO QueryTesterImpl<null,Character,Character>(null,false)
  #MACRO QueryTesterImpl<null,Short,Short>(null,false)
  #MACRO QueryTesterImpl<null,Integer,Integer>(null,false)
  #MACRO QueryTesterImpl<null,Long,Long>(null,false)
  #MACRO QueryTesterImpl<null,Float,Float>(null,false)
  #MACRO QueryTesterImpl<null,Double,Double>(null,false)
  #MACRO QueryTesterImpl<null,Object,Object>(null,false)
  #MACRO QueryTesterImpl<false,Boolean,boolean>(false,true)
  #MACRO QueryTesterImpl<true,Boolean,boolean>(true,false)
  #MACRO QueryTesterImpl<0,Byte,byte>(0,true)
  #MACRO QueryTesterImpl<pos1,Byte,byte>(1,false)
  #MACRO QueryTesterImpl<pos2,Byte,byte>(2,false)
  #MACRO QueryTesterImpl<neg1,Byte,byte>(-1,false)
  #MACRO QueryTesterImpl<0,Character,char>(0,true)
  #MACRO QueryTesterImpl<pos1,Character,char>(1,false)
  #MACRO QueryTesterImpl<pos2,Character,char>(2,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Character,char>(((char)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Character,char>(((char)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<0,Short,short>(0,true)
  #MACRO QueryTesterImpl<pos1,Short,short>(1,false)
  #MACRO QueryTesterImpl<pos2,Short,short>(2,false)
  #MACRO QueryTesterImpl<neg1,Short,short>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Short,short>(((short)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Short,short>(((short)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<0,Integer,int>(0,true)
  #MACRO QueryTesterImpl<pos1,Integer,int>(1,false)
  #MACRO QueryTesterImpl<pos2,Integer,int>(2,false)
  #MACRO QueryTesterImpl<neg1,Integer,int>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Integer,int>(((int)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Integer,int>(((int)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Integer,int>(((int)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_SHORT_MINUS1,Integer,int>(((int)Short.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_CHAR_PLUS1,Integer,int>(((int)Character.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_SAFE_INT_PLUS1,Integer,int>(TypeUtil.MAX_SAFE_INT+1,false)
  #MACRO QueryTesterImpl<MIN_SAFE_INT_MINUS1,Integer,int>(TypeUtil.MIN_SAFE_INT-1,false)
  #MACRO QueryTesterImpl<0,Long,long>(0,true)
  #MACRO QueryTesterImpl<pos1,Long,long>(1,false)
  #MACRO QueryTesterImpl<pos2,Long,long>(2,false)
  #MACRO QueryTesterImpl<neg1,Long,long>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Long,long>(((long)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Long,long>(((long)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Long,long>(((long)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_SHORT_MINUS1,Long,long>(((long)Short.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_CHAR_PLUS1,Long,long>(((long)Character.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_SAFE_INT_PLUS1,Long,long>(((long)TypeUtil.MAX_SAFE_INT)+1,false)
  #MACRO QueryTesterImpl<MIN_SAFE_INT_MINUS1,Long,long>(((long)TypeUtil.MIN_SAFE_INT)-1,false)
  #MACRO QueryTesterImpl<MAX_INT_PLUS1,Long,long>(((long)Integer.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_INT_MINUS1,Long,long>(((long)Integer.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SAFE_LONG_PLUS1,Long,long>(((long)TypeUtil.MAX_SAFE_LONG)+1,false)
  #MACRO QueryTesterImpl<MIN_SAFE_LONG_MINUS1,Long,long>(((long)TypeUtil.MIN_SAFE_LONG)-1,false)
  #MACRO QueryTesterImpl<pos0,Float,float>(0.0F,true)
  #MACRO QueryTesterImpl<neg0,Float,float>(-0.0F,true)
  #MACRO QueryTesterImpl<pos1,Float,float>(1,false)
  #MACRO QueryTesterImpl<pos2,Float,float>(2,false)
  #MACRO QueryTesterImpl<neg1,Float,float>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Float,float>(((float)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Float,float>(((float)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Float,float>(((float)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_SHORT_MINUS1,Float,float>(((float)Short.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_CHAR_PLUS1,Float,float>(((float)Character.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_INT_PLUS1,Float,float>(((float)Integer.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_INT_MINUS1,Float,float>(((float)Integer.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_LONG_PLUS1,Float,float>(((float)Long.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_LONG_MINUS1,Float,float>(((float)Long.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MIN_FLOAT_VALUE,Float,float>(Float.MIN_VALUE,false)
  #MACRO QueryTesterImpl<MAX_FLOAT_VALUE,Float,float>(Float.MAX_VALUE,false)
  #MACRO QueryTesterImpl<NaN,Float,float>(Float.NaN,false)
  #MACRO QueryTesterImpl<pos0,Double,double>(0.0D,true)
  #MACRO QueryTesterImpl<neg0,Double,double>(-0.0D,true)
  #MACRO QueryTesterImpl<pos1,Double,double>(1,false)
  #MACRO QueryTesterImpl<pos2,Double,double>(2,false)
  #MACRO QueryTesterImpl<neg1,Double,double>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Double,double>(((double)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Double,double>(((double)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Double,double>(((double)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_SHORT_MINUS1,Double,double>(((double)Short.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_CHAR_PLUS1,Double,double>(((double)Character.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_SAFE_INT_PLUS1,Double,double>(((double)TypeUtil.MAX_SAFE_INT)+1,false)
  #MACRO QueryTesterImpl<MIN_SAFE_INT_MINUS1,Double,double>(((double)TypeUtil.MIN_SAFE_INT)-1,false)
  #MACRO QueryTesterImpl<MAX_INT_PLUS1,Double,double>(((double)Integer.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_INT_MINUS1,Double,double>(((double)Integer.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_LONG_PLUS1,Double,double>(((double)Long.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_LONG_MINUS1,Double,double>(((double)Long.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MIN_FLOAT_VALUE,Double,double>(Float.MIN_VALUE,false)
  #MACRO QueryTesterImpl<MAX_FLOAT_VALUE,Double,double>(Float.MAX_VALUE,false)
  #MACRO QueryTesterImpl<MIN_DOUBLE_VALUE,Double,double>(Double.MIN_VALUE,false)
  #MACRO QueryTesterImpl<MAX_DOUBLE_VALUE,Double,double>(Double.MAX_VALUE,false)
  #MACRO QueryTesterImpl<NaN,Double,double>(Double.NaN,false)
  ;

#MACRODEF QueryTesterImpl<VALUE_NAME,BOXED_TYPE,PRIMITIVE_TYPE>(PRIMITIVE_VAL,NOT_EQUALS_VAL)
BOXED_TYPEVALUE_NAME(false){
  @Override boolean invokecontainsObject($ClassPrefix$SnglLnkSeqMonitor seqMonitor){return seqMonitor.seq.contains((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override boolean invokeremoveValObject($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.remove((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      --seqMonitor.expectedSeqSize;
    }
    return ret;
  }
  @Override int invokesearchObject($ClassPrefix$SnglLnkSeqMonitor seqMonitor){return ((OmniStack.Of$ClassPrefix$)seqMonitor.seq).search((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override boolean invokecontainsBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){return seqMonitor.seq.contains((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
#IFSWITCH BOXED_TYPE==Object
  @Override boolean invokeremoveValBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.remove((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      --seqMonitor.expectedSeqSize;
    }
    return ret;
  }
#ELSE
  @Override boolean invokeremoveValBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.removeVal((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      --seqMonitor.expectedSeqSize;
    }
    return ret;
  }
#ENDIF
  @Override int invokesearchBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){return ((OmniStack.Of$ClassPrefix$)seqMonitor.seq).search((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override boolean invokecontainsUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){return seqMonitor.seq.contains((PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
#IFSWITCH PRIMITIVE_TYPE==Object
  @Override boolean invokeremoveValUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.remove((PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      --seqMonitor.expectedSeqSize;
    }
    return ret;
  }
#ELSE
  @Override boolean invokeremoveValUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.removeVal((PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      --seqMonitor.expectedSeqSize;
    }
    return ret;
  }
#ENDIF
  @Override int invokesearchUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor){return ((OmniStack.Of$ClassPrefix$)seqMonitor.seq).search((PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  void addEqualsVal($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
#IF OfRef
    seqMonitor.seq.add((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    ++seqMonitor.expectedSeqModCount;
    ++seqMonitor.expectedSeqSize;
#ELSE
  #IFSWITCH VALUE_NAME==null
    throw new UnsupportedOperationException();
  #ELSE
    #IF OfBoolean
      #IFSWITCH PRIMITIVE_TYPE==boolean
    seqMonitor.seq.add((boolean)(PRIMITIVE_VAL));
      #ELSE
        #IFSWITCH VALUE_NAME==pos1
    seqMonitor.seq.add((boolean)(true));
        #ELSE
    seqMonitor.seq.add((boolean)((PRIMITIVE_VAL)==1));
        #ENDIF
      #ENDIF
    #ELSE
      #IFSWITCH PRIMITIVE_TYPE==boolean
    seqMonitor.seq.add(($exposedType$)$queryCastBoolean$(PRIMITIVE_VAL));
      #ELSE
    seqMonitor.seq.add(($exposedType$)(PRIMITIVE_VAL));
      #ENDIF
    #ENDIF
    ++seqMonitor.expectedSeqModCount;
    ++seqMonitor.expectedSeqSize;
  #ENDIF
#ENDIF
  }
  void addNotEqualsVal($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
    #IF OfRef
    seqMonitor.seq.add((Object)(boolean)NOT_EQUALS_VAL);
    #ELSE
    seqMonitor.seq.add((boolean)NOT_EQUALS_VAL);
    #ENDIF
    ++seqMonitor.expectedSeqModCount;
    ++seqMonitor.expectedSeqSize;
  }
},
#ENDDEF
    
    final boolean isObjectNonNull;
    QueryTester(boolean isObjectNonNull){
      this.isObjectNonNull=isObjectNonNull;
    }
    boolean invokecontains($ClassPrefix$SnglLnkSeqMonitor seqMonitor,QueryCastType queryCastType){
      switch(queryCastType){
        case Unboxed:
          return invokecontainsUnboxed(seqMonitor);
        case ToBoxed:
          return invokecontainsBoxed(seqMonitor);
        case ToObject:
          return invokecontainsObject(seqMonitor);
        default:
          throw new Error("Unknown queryCastType "+queryCastType);
      }
    }
    boolean invokeremoveVal($ClassPrefix$SnglLnkSeqMonitor seqMonitor,QueryCastType queryCastType){
      switch(queryCastType){
        case Unboxed:
          return invokeremoveValUnboxed(seqMonitor);
        case ToBoxed:
          return invokeremoveValBoxed(seqMonitor);
        case ToObject:
          return invokeremoveValObject(seqMonitor);
        default:
          throw new Error("Unknown queryCastType "+queryCastType);
      }
    }
    int invokesearch($ClassPrefix$SnglLnkSeqMonitor seqMonitor,QueryCastType queryCastType){
      switch(queryCastType){
        case Unboxed:
          return invokesearchUnboxed(seqMonitor);
        case ToBoxed:
          return invokesearchBoxed(seqMonitor);
        case ToObject:
          return invokesearchObject(seqMonitor);
        default:
          throw new Error("Unknown queryCastType "+queryCastType);
      }
    }
    
    abstract boolean invokecontainsObject($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract boolean invokecontainsBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract boolean invokecontainsUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract boolean invokeremoveValObject($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract boolean invokeremoveValBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract boolean invokeremoveValUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract int invokesearchObject($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract int invokesearchBoxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract int invokesearchUnboxed($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract void addEqualsVal($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    abstract void addNotEqualsVal($ClassPrefix$SnglLnkSeqMonitor seqMonitor);
    void initDoesNotContain($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int seqSize){
      for(int i=0;i<seqSize;++i){
        addNotEqualsVal(seqMonitor);
      }
    }
    int initContainsEnd($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int seqSize){
      Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
      for(int i=0;i<seqSize-1;++i){
        addNotEqualsVal(seqMonitor);
      }
      addEqualsVal(seqMonitor);
      return seqMonitor.expectedSeqSize-1;
    }
    int initContainsMiddle($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int seqSize){
      Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
      for(int i=0,bound=seqSize/2;i<bound;++i){
        addNotEqualsVal(seqMonitor);
      }
      addEqualsVal(seqMonitor);
      for(int i=(seqSize/2)+1;i<seqSize;++i){
        addNotEqualsVal(seqMonitor);
      }
      return seqMonitor.expectedSeqSize/2;
    }
    int initContainsBeginning($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int seqSize){
      addEqualsVal(seqMonitor);
      for(int i=1;i<seqSize;++i){
        addNotEqualsVal(seqMonitor);
      }
      return 0;
    }
#IF OfRef
    boolean invokecontainsMonitored($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    boolean invokeremoveValMonitored($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    int invokesearchMonitored($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    int initContainsEnd($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject,int seqSize){throw new UnsupportedOperationException();}
    int initContainsMiddle($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject,int seqSize){throw new UnsupportedOperationException();}
    int initContainsBeginning($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredObject monitoredObject,int seqSize){throw new UnsupportedOperationException();}
#ENDIF
  };
  
  static void buildQueryArguments(Stream.Builder<Arguments> builder,NestedType nestedType){
    for(var checkedType:CheckedType.values()){
      for(var seqLocation:SequenceLocation.values()){
        if(seqLocation!=SequenceLocation.IOBLO){
          for(int seqSize:new int[]{0,1,100}){
            if(seqLocation==SequenceLocation.IOBHI || (seqSize>1 || (seqLocation==SequenceLocation.BEGINNING && seqSize>0))){
              for(var argType:QueryTester.values()){
                for(var queryCastType:QueryCastType.values()){
                  switch(argType){
#IF OfRef
                    case ObjectNonNull:
                    case Objectnull:
                      if(queryCastType!=QueryCastType.ToObject){
                        continue;
                      }
                      break;
                    case Booleannull:
                    case Bytenull:
                    case Characternull:
                    case Shortnull:
                    case Integernull:
                    case Longnull:
                    case Floatnull:
                    case Doublenull:
                      if(queryCastType!=QueryCastType.ToBoxed){
                        continue;
                      }
#ELSE
                    case Booleannull:
                    case Bytenull:
                    case Characternull:
                    case Shortnull:
                    case Integernull:
                    case Longnull:
                    case Floatnull:
                    case Doublenull:
                      if(queryCastType!=QueryCastType.ToBoxed || (seqSize>0 && seqLocation.expectedException==null)){
                        continue;
                      }
                      break;
                    case Objectnull:
                      if(queryCastType!=QueryCastType.ToObject || (seqSize>0 && seqLocation.expectedException==null)){
                        continue;
                      }
                      break;
#ENDIF
                    case Booleanfalse:
                    case Byte0:
                    case Character0:
                    case Short0:
                    case Integer0:
                    case Long0:
                    case Floatpos0:
                    case Floatneg0:
                    case Doublepos0:
                    case Doubleneg0:
                    case Booleantrue:
                    case Bytepos1:
                    case Characterpos1:
                    case Shortpos1:
                    case Integerpos1:
                    case Longpos1:
                    case Floatpos1:
                    case Doublepos1:
#IFNOT OfBoolean
                    //values beyond the range of boolean
                    case Bytepos2:
                    case Characterpos2:
                    case Shortpos2:
                    case Integerpos2:
                    case Longpos2:
                    case Floatpos2:
                    case Doublepos2:
  #IFNOT OfChar
                    //negative values beyond the range of char
                    case Byteneg1:
                    case Shortneg1:
                    case Integerneg1:
                    case Longneg1:
                    case Floatneg1:
                    case Doubleneg1:
    #IFNOT OfByte
                    //negative values beyond the range of byte
                    case ShortMIN_BYTE_MINUS1:
                    case IntegerMIN_BYTE_MINUS1:
                    case LongMIN_BYTE_MINUS1:
                    case FloatMIN_BYTE_MINUS1:
                    case DoubleMIN_BYTE_MINUS1:
      #IFNOT OfShort
                    //negative values beyond the range of short
                    case IntegerMIN_SHORT_MINUS1:
                    case LongMIN_SHORT_MINUS1:
                    case FloatMIN_SHORT_MINUS1:
                    case DoubleMIN_SHORT_MINUS1:
        #IFNOT OfInt
                    //negative values beyond the range of int
                    case FloatMIN_INT_MINUS1:
          #IFNOT OfFloat
                    //negative values beyond the range of int and beyond the precision of float
                    case LongMIN_INT_MINUS1:
                    case DoubleMIN_INT_MINUS1:
          #ENDIF
        #ENDIF
        #IFNOT OfFloat
                    //negative values beyond MIN_SAFE_INT that are beyond the precision of float
                    case IntegerMIN_SAFE_INT_MINUS1:
                    case LongMIN_SAFE_INT_MINUS1:
                    case DoubleMIN_SAFE_INT_MINUS1:
          #IFNOT OfInt,OfDouble
                    //negative values beyond the range of int that are beyond the precision of float and double
                    case LongMIN_SAFE_LONG_MINUS1:
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #IFNOT OfByte
                    //positive values out of the range of byte
                    case CharacterMAX_BYTE_PLUS1:
                    case ShortMAX_BYTE_PLUS1:
                    case IntegerMAX_BYTE_PLUS1:
                    case LongMAX_BYTE_PLUS1:
                    case FloatMAX_BYTE_PLUS1:
                    case DoubleMAX_BYTE_PLUS1:
    #IFNOT OfShort
                    //positive values out of the range of short
                    case CharacterMAX_SHORT_PLUS1:
                    case IntegerMAX_SHORT_PLUS1:
                    case LongMAX_SHORT_PLUS1:
                    case FloatMAX_SHORT_PLUS1:
                    case DoubleMAX_SHORT_PLUS1:
      #IFNOT OfChar
                    //positive values out of the range of char
                    case IntegerMAX_CHAR_PLUS1:
                    case LongMAX_CHAR_PLUS1:
                    case FloatMAX_CHAR_PLUS1:
                    case DoubleMAX_CHAR_PLUS1:
        #IFNOT OfInt
                    //positive values out of the range of int
                    case LongMAX_INT_PLUS1:
                    case FloatMAX_INT_PLUS1:
                    case DoubleMAX_INT_PLUS1:
        #ENDIF
        #IFNOT OfFloat
                    //positive values beyond MAX_SAFE_INT that are beyond the precision of float
                    case IntegerMAX_SAFE_INT_PLUS1:
                    case LongMAX_SAFE_INT_PLUS1:
                    case DoubleMAX_SAFE_INT_PLUS1:
          #IFNOT OfInt,OfDouble
                    //positive values beyond the range of int that are beyond the precision of float and double
                    case LongMAX_SAFE_LONG_PLUS1:
          #ENDIF
        #ENDIF
        #IFNOT OfInt,OfLong
                      //floating-point values beyond the range any integral type
                    case FloatMAX_LONG_PLUS1:
                    case FloatMIN_LONG_MINUS1:
                    case FloatMAX_FLOAT_VALUE:
                    case DoubleMAX_FLOAT_VALUE:
                    //fractional floating point values that cannot be matched with any integral type
                    case FloatMIN_FLOAT_VALUE:
                    case DoubleMIN_FLOAT_VALUE:
                    //NaN values that can only be matches with NaN
                    case FloatNaN:
                    case DoubleNaN:
          #IFNOT OfFloat
                    //double-precision floating-point values beyond the range of any integral type and beyond the precision of float
                    case DoubleMAX_LONG_PLUS1:
                    case DoubleMIN_LONG_MINUS1:
                    case DoubleMAX_DOUBLE_VALUE:
                    //fractional floating point values that cannot be matched with any integral type and which are beyond the precision of float
                    case DoubleMIN_DOUBLE_VALUE:
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF  
#ENDIF
                    //these input values cannot potentially return true
                    break;
                    default:
                    if(seqSize>0 && seqLocation.expectedException==null){
                      continue;
                    }
                    //these values must necessarily return false
                  }
#IF OfRef
                  if(argType==QueryTester.ObjectNonNull){
                    if(seqSize==0 || !checkedType.checked){
                      continue;
                    }
                    for(var monitoredObjectGen:MonitoredObjectGen.values()){
                      if(!monitoredObjectGen.appliesToRoot || monitoredObjectGen.expectedException==null){
                        continue;
                      }
                      builder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),argType,queryCastType,seqLocation,seqSize,monitoredObjectGen));
                    }
                  }else{
                    builder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),argType,queryCastType,seqLocation,seqSize,null));
                  }
#ELSE
                  builder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),argType,queryCastType,seqLocation,seqSize));
#ENDIF
                }
              }
            }
          }
        }
      }
    }
  }
  static Stream<Arguments> getQueryStackArguments(){
    Stream.Builder<Arguments> builder=Stream.builder();
    buildQueryArguments(builder,NestedType.STACK);
    return builder.build();
  }
  static Stream<Arguments> getQueryCollectionArguments(){
    Stream.Builder<Arguments> builder=Stream.builder();
    for(var nestedType:NestedType.values()){
      buildQueryArguments(builder,nestedType);
    }
    return builder.build();
  }
  static Stream<Arguments> getBasicCollectionTestArgs(){
    return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
      for(int seqSize:new int[]{0,1,100}){
        streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),seqSize));
      }
    });
  }
#IF OfRef
  private static int verifyThrowCondition($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int numToAdd,MonitoredObject monitoredObject,MonitoredObjectGen monitoredObjectGen){
    int numExpectedCalls=numToAdd;
    var verifyItr=seqMonitor.verifyPreAlloc();
    if(seqMonitor.nestedType.forwardIteration){
      for(int i=0;i<numToAdd;++i){
        verifyItr.verifyIndexAndIterate(monitoredObject);
      }
      switch(monitoredObjectGen){
        case ThrowModSeq:
          verifyItr.verifyIllegalAdd();
        case Throw:
          numExpectedCalls=1;
          break;
        case ModSeq:
          for(int i=0;i<numExpectedCalls;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
    }else{
      switch(monitoredObjectGen){
        case ThrowModSeq:
          verifyItr.verifyIllegalAdd();
        case Throw:
          numExpectedCalls=1;
          break;
        case ModSeq:
          for(int i=0;i<numExpectedCalls;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
      for(int i=0;i<numToAdd;++i){
        verifyItr.verifyIndexAndIterate(monitoredObject);
      }
    }
    verifyItr.verifyPostAlloc();
    return numExpectedCalls;
  }
#ENDIF
}
#MACRODEF testhashCode_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testhashCode_void(){
  gettoStringAndhashCode_voidArgs().parallel().map(Arguments::get).forEach(args->{
    testhashCode_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(int)args[1]
#IF OfRef
    ,(MonitoredObjectGen)args[2]
#ENDIF
    );
  });
}
private static void testhashCode_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoStringAndhashCode_voidArgs")
public void testhashCode_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int numToAdd
#IF OfRef
,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
#IF OfRef
  MonitoredObject monitoredObject=null;
  if(numToAdd!=0 && monitoredObjectGen.expectedException!=null){
    monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
    for(int i=0;i<numToAdd;++i){
      seqMonitor.seq.add(monitoredObject);
      ++seqMonitor.expectedSeqSize;
      ++seqMonitor.expectedSeqModCount;
    }
  }else
#ENDIF
  {
    for(int i=0;i<numToAdd;++i){
      seqMonitor.add(i);
    }
  }
#IF OfRef
  if(monitoredObject!=null){
    Assertions.assertThrows(monitoredObjectGen.expectedException,()->seqMonitor.seq.hashCode());
    Assertions.assertEquals(verifyThrowCondition(seqMonitor,numToAdd,monitoredObject,monitoredObjectGen),monitoredObject.numHashCodeCalls);
  }else
#ENDIF
  {
    int resultHash=seqMonitor.seq.hashCode();
    seqMonitor.verifyPreAlloc().verifyNaturalAscending(numToAdd).verifyPostAlloc();
    var itr=seqMonitor.seq.iterator();
    int expectedHash=1;
    for(int i=0;i<numToAdd;++i){
      expectedHash=(expectedHash*31)+itr.next().hashCode();
    }
    Assertions.assertEquals(expectedHash,resultHash);
  }
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF
#MACRODEF testMASSIVEtoString_void<PARALLEL>()
#IF OfBoolean
  private static final int MAX_TOSTRING_LENGTH=5;
#ELSEIF OfByte
  private static final int MAX_TOSTRING_LENGTH=4;
#ELSEIF OfShort
  private static final int MAX_TOSTRING_LENGTH=6;
#ELSEIF OfInt
  private static final int MAX_TOSTRING_LENGTH=11;
#ELSEIF OfLong
  private static final int MAX_TOSTRING_LENGTH=20;
#ELSEIF OfFloat
  private static final int MAX_TOSTRING_LENGTH=15;
#ENDIF
#IF OfBoolean,OfByte,OfShort,OfInt,OfLong,OfFloat
static Stream<Arguments> getMASSIVEtoString_voidArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  final int seqLength=(OmniArray.MAX_ARR_SIZE/(MAX_TOSTRING_LENGTH+2))+1;
  $SNode$ head=new $SNode$(TypeConversionUtil.convertTo$ArrayType$(1));
  $SNode$ tail=head;
  for(int i=1;i<seqLength;++i){
    tail=tail.next=new $SNode$(TypeConversionUtil.convertTo$ArrayType$(1));
  }
  for(var nestedType:NestedType.values()){
    for(var checkedType:CheckedType.values()){
      builder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType,head,seqLength,tail)));
    }
  }
  return builder.build();
}
@Tag("MASSIVEtoString")
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getMASSIVEtoString_voidArgs")
public void testMASSIVEtoString_void
($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
  seqMonitor.verifyMASSIVEString();
}
#ENDIF
#ENDDEF
#MACRODEF testtoArray_IntFunction<PARALLEL>()
static Stream<Arguments> gettoArray_IntFunctionArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(var monitoredFunctionGen:MonitoredFunctionGen.values()){
      if((checkedType.checked || monitoredFunctionGen.expectedException==null)&&monitoredFunctionGen.appliesToRoot){
        for(int seqSize:new int[]{0,1,100}){
          streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),monitoredFunctionGen,seqSize));
        }
      }
    }   
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testtoArray_IntFunction(){
  gettoArray_IntFunctionArgs().parallel().map(Arguments::get).forEach(args->{
      testtoArray_IntFunctionHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(MonitoredFunctionGen)args[1],(int)args[2]);
  });
}
private static void testtoArray_IntFunctionHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoArray_IntFunctionArgs")
public void testtoArray_IntFunction
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredFunctionGen monitoredFunctionGen,int numToAdd){
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var arrConstructor=monitoredFunctionGen.getMonitoredArrayConstructor(seqMonitor);
  if(monitoredFunctionGen.expectedException==null){
    var resultArr=seqMonitor.seq.toArray(arrConstructor);
    Assertions.assertEquals(numToAdd,resultArr.length);
    var itr=seqMonitor.seq.iterator();
    for(int i=0;i<numToAdd;++i){
#IF OfRef
      Assertions.assertSame(resultArr[i],itr.next$TypeNameModifier$());
#ELSE
      Assertions.assertEquals(resultArr[i],(Object)itr.next$TypeNameModifier$());
#ENDIF
    }
  }else{
     Assertions.assertThrows(monitoredFunctionGen.expectedException,()->seqMonitor.seq.toArray(arrConstructor));
  }
  seqMonitor.verifyStructuralIntegrity();
  var verifyItr=seqMonitor.verifyPreAlloc();
  switch(monitoredFunctionGen){
    case NoThrow:
    case Throw:
      verifyItr.verifyNaturalAscending(numToAdd);
      break;
    case ModSeq:
    case ThrowModSeq:
      if(seqMonitor.nestedType.forwardIteration){
        verifyItr.verifyAscending(numToAdd).verifyIllegalAdd();
      }else{
        verifyItr.verifyIllegalAdd().verifyDescending(numToAdd);
      }
      break;
    default:
      throw new Error("Unknown monitoredFunctionGen "+monitoredFunctionGen);
  }
  verifyItr.verifyPostAlloc();
}
#ENDDEF
#MACRODEF testtoArray_ObjectArray<PARALLEL>()
static Stream<Arguments> gettoArray_ObjectArrayArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(int seqSize=0;seqSize<=15;seqSize+=5){
      for(int arrSize=0;arrSize<=20;arrSize+=5){
        streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),seqSize,arrSize));
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testtoArray_ObjectArray(){
  gettoArray_ObjectArrayArgs().parallel().map(Arguments::get).forEach(args->{
      testtoArray_ObjectArrayHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(int)args[1],(int)args[2]);
  });
}
private static void testtoArray_ObjectArrayHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoArray_ObjectArrayArgs")
public void testtoArray_ObjectArray
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int seqSize,int arrSize){
  for(int i=0;i<seqSize;++i){
    seqMonitor.add(i);
  }
#IF OfRef
  Integer[] paramArr=new Integer[arrSize];
#ELSE
  $BoxedType$[] paramArr=new $BoxedType$[arrSize];
#ENDIF
  for(int i=seqSize,bound=seqSize+arrSize;i<bound;++i){
    #IF OfRef
    paramArr[i-seqSize]=TypeConversionUtil.convertToInteger(i);
    #ELSE
    paramArr[i-seqSize]=TypeConversionUtil.convertTo$BoxedType$(i);
    #ENDIF
  }
  var resultArr=seqMonitor.seq.toArray(paramArr);
  seqMonitor.verifyStructuralIntegrity();
  if(arrSize<seqSize){
    Assertions.assertNotSame(paramArr,resultArr);
    Assertions.assertEquals(seqSize,resultArr.length);
  }
  else if(arrSize>seqSize){
    Assertions.assertSame(paramArr,resultArr);
    Assertions.assertNull(resultArr[seqSize]);
    for(int i=seqSize+1;i<arrSize;++i){
    #IF OfRef
      Assertions.assertEquals(TypeConversionUtil.convertToInteger(i+seqSize),resultArr[i]);
    #ELSE
      Assertions.assertEquals(TypeConversionUtil.convertTo$BoxedType$(i+seqSize),resultArr[i]);
    #ENDIF
    }
  }else{
    Assertions.assertSame(paramArr,resultArr);
  }
  var itr=seqMonitor.seq.iterator();
  for(int i=0;i<seqSize;++i){
#IF OfRef
    Assertions.assertSame(itr.next$TypeNameModifier$(),resultArr[i]);
#ELSE
    Assertions.assertEquals((Object)itr.next$TypeNameModifier$(),resultArr[i]);
#ENDIF
  }
  seqMonitor.verifyPreAlloc().verifyNaturalAscending(seqSize).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testQueueelement_void<PARALLEL>()
static Stream<Arguments> getQueueelement_voidArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var outputType:$ClassPrefix$OutputTestArgType.values()){
      builder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(NestedType.QUEUE,checkedType),outputType));
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testQueueelement_void(){
  getQueueelement_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testQueueelement_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],($ClassPrefix$OutputTestArgType)args[1]);
  });
}
private static void testQueueelement_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueueelement_voidArgs")
public void testQueueelement_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,$ClassPrefix$OutputTestArgType outputArgType){
  for(int i=0;i<100;++i){
    seqMonitor.add(i);
  }
  for(int i=0;i<100;++i){
    outputArgType.verifyQueueElement(seqMonitor.seq,i);
    seqMonitor.verifyStructuralIntegrity();
    seqMonitor.pop(i,outputArgType);
  }
  if(seqMonitor.checkedType.checked){
    Assertions.assertThrows(NoSuchElementException.class,()->outputArgType.verifyQueueElement(seqMonitor.seq,0));
    seqMonitor.verifyStructuralIntegrity();
  }
}
#ENDDEF
#MACRODEF testclear_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testclear_void(){
  getBasicCollectionTestArgs().parallel().map(Arguments::get).forEach(args->{
      testclear_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(int)args[1]);
  });
}
private static void testclear_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getBasicCollectionTestArgs")
public void testclear_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int numToAdd){
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  seqMonitor.clear();
  seqMonitor.verifyStructuralIntegrity();
  Assertions.assertTrue(seqMonitor.seq.isEmpty());
  seqMonitor.verifyPreAlloc().verifyPostAlloc();
}
#ENDDEF
#MACRODEF testtoArray_void<PARALLEL>()
static Stream<Arguments> gettoArray_voidArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(int seqSize:new int[]{0,1,100}){
      for(var outputArgType:$ClassPrefix$OutputTestArgType.values()){
        streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),seqSize,outputArgType));
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testtoArray_void(){
  gettoArray_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testtoArray_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(int)args[1],($ClassPrefix$OutputTestArgType)args[2]);
  });
}
private static void testtoArray_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoArray_voidArgs")
public void testtoArray_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int numToAdd,$ClassPrefix$OutputTestArgType outputArgType){
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  outputArgType.verifyToArray(seqMonitor.seq,numToAdd);
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyNaturalAscending(numToAdd).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testreadAndwriteObject<PARALLEL>()
static Stream<Arguments> getreadAndwriteObjectArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(var monitoredFunctionGen:MonitoredFunctionGen.values()){
      if((checkedType.checked || monitoredFunctionGen.expectedException==null)&&(monitoredFunctionGen.appliesToRoot)){
        for(int seqSize:new int[]{0,1,100}){
          streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),monitoredFunctionGen,seqSize
#IF OfBoolean
            ,0
#ENDIF
          ));
#IF OfBoolean
          if(seqSize!=0){
            streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),monitoredFunctionGen,seqSize,1));
          }
#ENDIF
        }
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testreadAndwriteObject(){
  getreadAndwriteObjectArgs().parallel().map(Arguments::get).forEach(args->{
      testreadAndwriteObjectHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(MonitoredFunctionGen)args[1],(int)args[2]
#IF OfBoolean
      ,(int)args[3]
#ENDIF
      );
  });
}
private static void testreadAndwriteObjectHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getreadAndwriteObjectArgs")
public void testreadAndwriteObject
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredFunctionGen monitoredFunctionGen,int numToAdd
#IF OfBoolean
,int initVal
#ENDIF
)
{
#IF OfBoolean
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(initVal+i); 
  }
#ELSE
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
#ENDIF
  
  final File file;
  try{
    file=Files.createTempFile(null,null).toFile();
  }catch(Exception e){
    Assertions.fail(e);
    return;
  }
  if(monitoredFunctionGen.expectedException==null){
    try(var oos=new ObjectOutputStream(new FileOutputStream(file));){
      oos.writeObject(seqMonitor.seq);
    }catch(Exception e){
      Assertions.fail(e);
    }
#IF OfBoolean
    seqMonitor.verifyPreAlloc().verifyNaturalAscending(initVal,numToAdd).verifyPostAlloc();
#ELSE
    seqMonitor.verifyPreAlloc().verifyNaturalAscending(numToAdd).verifyPostAlloc();
#ENDIF
    OmniCollection.Of$ClassPrefix$ readCol=null;
    try(var ois=new ObjectInputStream(new FileInputStream(file));){
      readCol=(OmniCollection.Of$ClassPrefix$)ois.readObject();
    }catch(Exception e){
      Assertions.fail(e);
      return;
    }
    var itr=readCol.iterator();
    if(seqMonitor.nestedType.forwardIteration){
      for(int i=0;i<numToAdd;++i){
#IF OfBoolean
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(initVal+i),itr.next$TypeNameModifier$());
#ELSE
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(i),itr.next$TypeNameModifier$());
#ENDIF
      }
    }else{
      for(int i=0;i<numToAdd;++i){
#IF OfBoolean
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(numToAdd-i-1+initVal),itr.next$TypeNameModifier$());
#ELSE
        Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(numToAdd-i-1),itr.next$TypeNameModifier$());
#ENDIF
      }
    }
    Assertions.assertFalse(itr.hasNext());
  }else{
    Assertions.assertThrows(monitoredFunctionGen.expectedException,()->{
      try(var moos=monitoredFunctionGen.getMonitoredObjectOutputStream(file,seqMonitor);){
        seqMonitor.writeObject(moos);
      }
    });
  }
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF
#MACRODEF testpop_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testpop_void(){
  getPeekPollAndPopArgs().parallel().map(Arguments::get).forEach(args->{
      testpop_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],($ClassPrefix$OutputTestArgType)args[1]);
  });
}
private static void testpop_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getPeekPollAndPopArgs")
public void testpop_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,$ClassPrefix$OutputTestArgType outputArgType){
  for(int i=0;i<100;++i){
    seqMonitor.add(i);
  }
  if(seqMonitor.nestedType.forwardIteration){
    for(int i=0;i<100;++i){
      seqMonitor.pop(i,outputArgType);
      seqMonitor.verifyStructuralIntegrity();
    }
  }else{
    for(int i=100;--i>=0;){
      seqMonitor.pop(i,outputArgType);
      seqMonitor.verifyStructuralIntegrity();
    }
  }
  if(seqMonitor.checkedType.checked){
    Assertions.assertThrows(NoSuchElementException.class,()->seqMonitor.pop(0,outputArgType));
    seqMonitor.verifyStructuralIntegrity();
  }
}
#ENDDEF
#MACRODEF testpeek_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testpeek_void(){
  getPeekPollAndPopArgs().parallel().map(Arguments::get).forEach(args->{
      testpeek_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],($ClassPrefix$OutputTestArgType)args[1]);
  });
}
private static void testpeek_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getPeekPollAndPopArgs")
public void testpeek_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,$ClassPrefix$OutputTestArgType outputArgType){
  if(seqMonitor.nestedType.forwardIteration){
    for(int i=0;i<100;++i){
      seqMonitor.add(i);
    }
    for(int i=0;i<100;++i){
      outputArgType.verifyPeek(seqMonitor.seq,100-i,i);
      seqMonitor.verifyStructuralIntegrity();
      seqMonitor.pop(i,outputArgType);
    }
    outputArgType.verifyPeek(seqMonitor.seq,0,0);
    seqMonitor.verifyStructuralIntegrity();
  }else{
    for(int i=0;i<100;){
      outputArgType.verifyPeek(seqMonitor.seq,i,i);
      seqMonitor.verifyStructuralIntegrity();
      seqMonitor.add(++i);
    }
  }
}
#ENDDEF
#MACRODEF testpoll_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testpoll_void(){
  getPeekPollAndPopArgs().parallel().map(Arguments::get).forEach(args->{
      testpoll_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],($ClassPrefix$OutputTestArgType)args[1]);
  });
}
private static void testpoll_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getPeekPollAndPopArgs")
public void testpoll_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,$ClassPrefix$OutputTestArgType outputArgType){
  for(int i=0;i<100;++i){
    seqMonitor.add(i);
  }
  if(seqMonitor.nestedType.forwardIteration){
    for(int i=0;i<100;++i){
      seqMonitor.poll(i,outputArgType);
      seqMonitor.verifyStructuralIntegrity();
    }
  }else{
    for(int i=100;--i>=0;){
      seqMonitor.poll(i,outputArgType);
      seqMonitor.verifyStructuralIntegrity();
    }
  }
  seqMonitor.poll(0,outputArgType);
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF
#MACRODEF testremoveVal_val<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testremoveVal_val(){
  getQueryCollectionArguments().parallel().map(Arguments::get).forEach(args->{
      testremoveVal_valHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(QueryTester)args[1],(QueryCastType)args[2],(SequenceLocation)args[3],(int)args[4]
#IF OfRef
        ,(MonitoredObjectGen)args[5]
#ENDIF
      );
  });
}
private static void testremoveVal_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueryCollectionArguments")
public void testremoveVal_val
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,QueryTester argType,QueryCastType queryCastType,SequenceLocation seqLocation,int seqSize
#IF OfRef
  ,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  if(seqSize>0){
#IF OfRef
    if(monitoredObjectGen!=null){
      int numExpectedCalls;
      final var monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
      switch(seqLocation){
        case BEGINNING:
          numExpectedCalls=1+argType.initContainsBeginning(seqMonitor,monitoredObject,seqSize);
          //if(!seqMonitor.nestedType.forwardIteration){
          //  numExpectedCalls=seqMonitor.expectedSeqSize;
          //}
          break;
        case MIDDLE:
          numExpectedCalls=1+argType.initContainsMiddle(seqMonitor,monitoredObject,seqSize);
          //if(!seqMonitor.nestedType.forwardIteration){
          //  numExpectedCalls=seqMonitor.expectedSeqSize-numExpectedCalls+1;
          //}
          break;
        case END:
          numExpectedCalls=1+argType.initContainsEnd(seqMonitor,monitoredObject,seqSize);
          //if(!seqMonitor.nestedType.forwardIteration){
          //  numExpectedCalls=1;
          //}
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor,seqSize);
          numExpectedCalls=seqMonitor.expectedSeqSize;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
      Assertions.assertThrows(monitoredObjectGen.expectedException,()->argType.invokeremoveValMonitored(seqMonitor,monitoredObject));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc();
      switch(monitoredObjectGen){
        case ModSeq:
          if(seqMonitor.nestedType.forwardIteration){
            verifyItr.skip(seqSize);
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }else{
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
            verifyItr.skip(seqSize);
          }
          verifyItr.verifyPostAlloc();
          break;
        case Throw:
          numExpectedCalls=1;
          verifyItr.skip(seqSize).verifyPostAlloc();
          break;
        case ThrowModSeq:
          numExpectedCalls=1;
          if(seqMonitor.nestedType.forwardIteration){
            verifyItr.skip(seqSize).verifyIllegalAdd();
          }else{
            verifyItr.verifyIllegalAdd().skip(seqSize);
          }
          verifyItr.verifyPostAlloc();
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
      Assertions.assertEquals(numExpectedCalls,monitoredObject.numEqualsCalls);
      return;
    }else
#ENDIF
    {
      switch(seqLocation){
        case BEGINNING:
          argType.initContainsBeginning(seqMonitor,seqSize);
          break;
        case MIDDLE:
          argType.initContainsMiddle(seqMonitor,seqSize);
          break;
        case END:
          argType.initContainsEnd(seqMonitor,seqSize);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor,seqSize);
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
    }
  }
  boolean expectedResult;
  Assertions.assertEquals(expectedResult=seqLocation!=SequenceLocation.IOBHI,argType.invokeremoveVal(seqMonitor,queryCastType));
  if(expectedResult){
    --seqSize;
  }
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().skip(seqSize).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testsearch_val<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testsearch_val(){
  getQueryStackArguments().parallel().map(Arguments::get).forEach(args->{
      testsearch_valHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(QueryTester)args[1],(QueryCastType)args[2],(SequenceLocation)args[3],(int)args[4]
#IF OfRef
        ,(MonitoredObjectGen)args[5]
#ENDIF
      );
  });
}
private static void testsearch_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueryStackArguments")
public void testsearch_val
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,QueryTester argType,QueryCastType queryCastType,SequenceLocation seqLocation,int seqSize
#IF OfRef
  ,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  int expectedIndex;
  if(seqSize>0){
#IF OfRef
    if(monitoredObjectGen!=null){
      int numExpectedCalls;
      final var monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
      switch(seqLocation){
        case BEGINNING:
          numExpectedCalls=1+argType.initContainsBeginning(seqMonitor,monitoredObject,seqSize);
          break;
        case MIDDLE:
          numExpectedCalls=1+argType.initContainsMiddle(seqMonitor,monitoredObject,seqSize);
          break;
        case END:
          numExpectedCalls=1+argType.initContainsEnd(seqMonitor,monitoredObject,seqSize);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor,seqSize);
          numExpectedCalls=seqMonitor.expectedSeqSize;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
      Assertions.assertThrows(monitoredObjectGen.expectedException,()->argType.invokesearchMonitored(seqMonitor,monitoredObject));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc();
      switch(monitoredObjectGen){
        case ModSeq:
          Assertions.assertEquals(numExpectedCalls,monitoredObject.numEqualsCalls);
          for(int i=0;i<numExpectedCalls;++i){
            verifyItr.verifyIllegalAdd();
          }
          break;
        case ThrowModSeq:
          verifyItr.verifyIllegalAdd();
        case Throw:
          Assertions.assertEquals(1,monitoredObject.numEqualsCalls);
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
      verifyItr.skip(seqSize).verifyPostAlloc();
      return;
    }else
#ENDIF
    {
      switch(seqLocation){
        case BEGINNING:
          expectedIndex=argType.initContainsBeginning(seqMonitor,seqSize);
          expectedIndex=seqMonitor.expectedSeqSize-expectedIndex;
          break;
        case MIDDLE:
          expectedIndex=argType.initContainsMiddle(seqMonitor,seqSize);
          expectedIndex=seqMonitor.expectedSeqSize-expectedIndex;
          break;
        case END:
          expectedIndex=argType.initContainsEnd(seqMonitor,seqSize);
          expectedIndex=seqMonitor.expectedSeqSize-expectedIndex;
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor,seqSize);
          expectedIndex=-1;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
    }
  }else{
    expectedIndex=-1;
  }
  Assertions.assertEquals(expectedIndex,argType.invokesearch(seqMonitor,queryCastType));
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().skip(seqSize).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testcontains_val<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testcontains_val(){
  getQueryCollectionArguments().parallel().map(Arguments::get).forEach(args->{
      testcontains_valHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(QueryTester)args[1],(QueryCastType)args[2],(SequenceLocation)args[3],(int)args[4]
#IF OfRef
        ,(MonitoredObjectGen)args[5]
#ENDIF
      );
  });
}
private static void testcontains_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueryCollectionArguments")
public void testcontains_val
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,QueryTester argType,QueryCastType queryCastType,SequenceLocation seqLocation,int seqSize
#IF OfRef
  ,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
  if(seqSize>0){
#IF OfRef
    if(monitoredObjectGen!=null){
      int numExpectedCalls;
      final var monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
      switch(seqLocation){
        case BEGINNING:
          numExpectedCalls=1+argType.initContainsBeginning(seqMonitor,monitoredObject,seqSize);
          break;
        case MIDDLE:
          numExpectedCalls=1+argType.initContainsMiddle(seqMonitor,monitoredObject,seqSize);
          break;
        case END:
          numExpectedCalls=1+argType.initContainsEnd(seqMonitor,monitoredObject,seqSize);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor,seqSize);
          numExpectedCalls=seqMonitor.expectedSeqSize;
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
      Assertions.assertThrows(monitoredObjectGen.expectedException,()->argType.invokecontainsMonitored(seqMonitor,monitoredObject));
      seqMonitor.verifyStructuralIntegrity();
      var verifyItr=seqMonitor.verifyPreAlloc();
      switch(monitoredObjectGen){
        case ModSeq:
          Assertions.assertEquals(numExpectedCalls,monitoredObject.numEqualsCalls);
          if(seqMonitor.nestedType.forwardIteration){
            verifyItr.skip(seqSize);
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
          }else{
            for(int i=0;i<numExpectedCalls;++i){
              verifyItr.verifyIllegalAdd();
            }
            verifyItr.skip(seqSize);
          }
          verifyItr.verifyPostAlloc();
          break;
        case Throw:
          Assertions.assertEquals(1,monitoredObject.numEqualsCalls);
          verifyItr.skip(seqSize).verifyPostAlloc();
          break;
        case ThrowModSeq:
          Assertions.assertEquals(1,monitoredObject.numEqualsCalls);
          if(seqMonitor.nestedType.forwardIteration){
            verifyItr.skip(seqSize).verifyIllegalAdd();
          }else{
            verifyItr.verifyIllegalAdd().skip(seqSize);
          }
          verifyItr.verifyPostAlloc();
          break;
        default:
          throw new Error("Unknown monitoredObjectGen "+monitoredObjectGen);
      }
      return;
    }
    else
#ENDIF
    {
      switch(seqLocation){
        case BEGINNING:
          argType.initContainsBeginning(seqMonitor,seqSize);
          break;
        case MIDDLE:
          argType.initContainsMiddle(seqMonitor,seqSize);
          break;
        case END:
          argType.initContainsEnd(seqMonitor,seqSize);
          break;
        case IOBHI:
          argType.initDoesNotContain(seqMonitor,seqSize);
          break;
        default:
          throw new Error("Unknown seqLocation "+seqLocation);
      }
    }
  }
  Assertions.assertEquals(seqLocation!=SequenceLocation.IOBHI,argType.invokecontains(seqMonitor,queryCastType));
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().skip(seqSize).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testStackpush_val<PARALLEL>()
static Stream<Arguments> getStackpush_valArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
      builder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(NestedType.STACK,checkedType),inputArgType));
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testStackpush_val(){
  getStackpush_valArgs().parallel().map(Arguments::get).forEach(args->{
      testStackpush_valHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],($ClassPrefix$InputTestArgType)args[1]);
  });
}
private static void testStackpush_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getStackpush_valArgs")
public void testStackpush_val
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,$ClassPrefix$InputTestArgType inputArgType){
  for(int i=0;i<100;++i){
    seqMonitor.push(i,inputArgType);
    seqMonitor.verifyStructuralIntegrity();
  }
  seqMonitor.verifyPreAlloc().verifyNaturalAscending(inputArgType,100).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testQueueoffer_val<PARALLEL>()
static Stream<Arguments> getQueueoffer_valArgs(){
  Stream.Builder<Arguments> builder=Stream.builder();
  for(var checkedType:CheckedType.values()){
    for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
      builder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(NestedType.QUEUE,checkedType),inputArgType));
    }
  }
  return builder.build();
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testQueueoffer_val(){
  getQueueoffer_valArgs().parallel().map(Arguments::get).forEach(args->{
      testQueueoffer_valHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],($ClassPrefix$InputTestArgType)args[1]);
  });
}
private static void testQueueoffer_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getQueueoffer_valArgs")
public void testadd_val
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,$ClassPrefix$InputTestArgType inputArgType){
  for(int i=0;i<100;++i){
    Assertions.assertTrue(seqMonitor.offer(i,inputArgType));
    seqMonitor.verifyStructuralIntegrity();
  }
  seqMonitor.verifyPreAlloc().verifyNaturalAscending(inputArgType,100).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testadd_val<PARALLEL>()
static Stream<Arguments> getadd_valArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(var inputArgType:$ClassPrefix$InputTestArgType.values()){
      streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),inputArgType));
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testadd_val(){
  getadd_valArgs().parallel().map(Arguments::get).forEach(args->{
      testadd_valHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],($ClassPrefix$InputTestArgType)args[1]);
  });
}
private static void testadd_valHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getadd_valArgs")
public void testadd_val
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,$ClassPrefix$InputTestArgType inputArgType){
  for(int i=0;i<100;++i){
    Assertions.assertTrue(seqMonitor.add(i,inputArgType));
    seqMonitor.verifyStructuralIntegrity();
  }
  seqMonitor.verifyPreAlloc().verifyNaturalAscending(inputArgType,100).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testisEmpty_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testisEmpty_void(){
  getBasicCollectionTestArgs().parallel().map(Arguments::get).forEach(args->{
      testisEmpty_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(int)args[1]);
  });
}
private static void testisEmpty_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getBasicCollectionTestArgs")
public void testisEmpty_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int numToAdd){
  for(int i=0;i<numToAdd;++i){
    Assertions.assertEquals(i==0,seqMonitor.seq.isEmpty());
    seqMonitor.verifyStructuralIntegrity();
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getItrMonitor();
  while(numToAdd>0){
    Assertions.assertEquals((numToAdd--)==0,seqMonitor.seq.isEmpty());
    seqMonitor.verifyStructuralIntegrity();
    itrMonitor.iterateForward();
    itrMonitor.remove();
  }
  Assertions.assertTrue(seqMonitor.seq.isEmpty());
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyNaturalAscending(numToAdd).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testsize_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testsize_void(){
  getBasicCollectionTestArgs().parallel().map(Arguments::get).forEach(args->{
      testsize_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(int)args[1]);
  });
}
private static void testsize_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getBasicCollectionTestArgs")
public void testsize_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int numToAdd){
  for(int i=0;i<numToAdd;++i){
    Assertions.assertEquals(i,seqMonitor.seq.size());
    seqMonitor.verifyStructuralIntegrity();
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getItrMonitor();
  while(numToAdd>0){
    Assertions.assertEquals(numToAdd--,seqMonitor.seq.size());
    seqMonitor.verifyStructuralIntegrity();
    itrMonitor.iterateForward();
    itrMonitor.remove();
  }
  Assertions.assertEquals(numToAdd,seqMonitor.seq.size());
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyNaturalAscending(numToAdd).verifyPostAlloc();
}
#ENDDEF
#MACRODEF testclone_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testclone_void(){
  getBasicCollectionTestArgs().parallel().map(Arguments::get).forEach(args->{
      testclone_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(int)args[1]);
  });
}
private static void testclone_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getBasicCollectionTestArgs")
public void testclone_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int numToAdd){
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var clone=(OmniCollection.Of$ClassPrefix$)seqMonitor.seq.clone();
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc().verifyNaturalAscending(numToAdd).verifyPostAlloc();
  Assertions.assertNotSame(clone,seqMonitor.seq);
  switch(seqMonitor.nestedType){
    case STACK:
      if(seqMonitor.checkedType.checked){
        Assertions.assertTrue(clone instanceof $ClassPrefix$SnglLnkSeq.CheckedStack);
        Assertions.assertEquals(0,(($ClassPrefix$SnglLnkSeq.CheckedStack)clone).modCount);
      }else{
        Assertions.assertTrue(clone instanceof $ClassPrefix$SnglLnkSeq.UncheckedStack);
      }
      break;
    case QUEUE:
      if(seqMonitor.checkedType.checked){
        Assertions.assertTrue(clone instanceof $ClassPrefix$SnglLnkSeq.CheckedQueue);
        Assertions.assertEquals(0,(($ClassPrefix$SnglLnkSeq.CheckedQueue)clone).modCount);
      }else{
        Assertions.assertTrue(clone instanceof $ClassPrefix$SnglLnkSeq.UncheckedQueue);
      }
      break;
    default:
      throw new Error("Unknown nested type "+seqMonitor.nestedType);
  }
  var snglLnkSeqClone=($ClassPrefix$SnglLnkSeq)clone;
  var originalHead=(($ClassPrefix$SnglLnkSeq)seqMonitor.seq).head;
  var cloneHead=snglLnkSeqClone.head;
  Assertions.assertEquals(numToAdd,snglLnkSeqClone.size);
  if(snglLnkSeqClone.size==0){
    Assertions.assertNull(cloneHead);
    if(seqMonitor.nestedType==NestedType.QUEUE){
      if(seqMonitor.checkedType.checked){
        Assertions.assertNull((($ClassPrefix$SnglLnkSeq.CheckedQueue)snglLnkSeqClone).tail);
      }else{
        Assertions.assertNull((($ClassPrefix$SnglLnkSeq.UncheckedQueue)snglLnkSeqClone).tail);
      }
    }
  }else{
    for(int i=snglLnkSeqClone.size;;cloneHead=cloneHead.next,originalHead=originalHead.next){
      Assertions.assertNotNull(cloneHead);
      Assertions.assertNotSame(cloneHead,originalHead);
#IF OfRef
      Assertions.assertSame(cloneHead.val,originalHead.val);
#ELSE
      Assertions.assertEquals(cloneHead.val,originalHead.val);
#ENDIF
      if(--i==0){
        if(seqMonitor.nestedType==NestedType.QUEUE){
          if(seqMonitor.checkedType.checked){
            Assertions.assertSame(cloneHead,(($ClassPrefix$SnglLnkSeq.CheckedQueue)snglLnkSeqClone).tail);
          }else{
            Assertions.assertSame(cloneHead,(($ClassPrefix$SnglLnkSeq.UncheckedQueue)snglLnkSeqClone).tail);
          }
        }
        Assertions.assertNull(cloneHead.next);
        Assertions.assertNull(originalHead.next);
        break;
      }
    }
  }
}
#ENDDEF
#MACRODEF testremoveIf_Predicate<PARALLEL>()
static Stream<Arguments> getremoveIf_PredicateArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(var monitoredRemoveIfPredicateGen:MonitoredRemoveIfPredicateGen.values()){
      if(monitoredRemoveIfPredicateGen.expectedException==null || (checkedType.checked && monitoredRemoveIfPredicateGen.appliesToRoot)){
        for(var functionCallType:FunctionCallType.values()){
#IF OfRef
          if(functionCallType==FunctionCallType.Boxed){
            continue;
          }
#ENDIF
#IF OfBoolean
          for(int seqSize=0;seqSize<=10;++seqSize){
            long randSeedBound;
            if(seqSize==0 || !monitoredRemoveIfPredicateGen.isRandomized){
              randSeedBound=0;
            }else{
              randSeedBound=100;
            }
            for(long randSeed=0;randSeed<=randSeedBound;++randSeed){
              for(int period=1,inc=Math.max(1,seqSize/10);;period+=inc){
                for(int initVal=0;initVal<=1;++initVal){
                  streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),monitoredRemoveIfPredicateGen,0.5,randSeed,functionCallType,seqSize,initVal,period));
                }
                if(period>=seqSize){
                  break;
                }
              }
            }
          }
#ELSE
          for(int seqSize=0;seqSize<=100;seqSize+=10){
            double[] thresholdArr;
            long randSeedBound;
            if(seqSize==0 || !monitoredRemoveIfPredicateGen.isRandomized){
              thresholdArr=new double[]{0.5};
              randSeedBound=0;
            }else{
              thresholdArr=new double[]{0.01,0.05,0.10,0.25,0.50,0.75,0.90,0.95,0.99};
              randSeedBound=100;
            }
            for(long randSeed=0;randSeed<=randSeedBound;++randSeed){
              for(double threshold:thresholdArr)
              {
                streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),monitoredRemoveIfPredicateGen,threshold,randSeed,functionCallType,seqSize));
              }
            }
          }
#ENDIF
        }
      }
    }
 });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testremoveIf_Predicate(){
  getremoveIf_PredicateArgs().parallel().map(Arguments::get).forEach(args->{
    testremoveIf_PredicateHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(MonitoredRemoveIfPredicateGen)args[1],(double)args[2],(long)args[3],(FunctionCallType)args[4],(int)args[5]
#IF OfBoolean
    ,(int)args[6],(int)args[7]
#ENDIF
    );
  });
}
private static void testremoveIf_PredicateHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getremoveIf_PredicateArgs")
public void testremoveIf_Predicate
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredRemoveIfPredicateGen monitoredRemoveIfPredicateGen,double threshold,long randSeed,final FunctionCallType functionCallType,int seqSize
#IF OfBoolean
,int initVal,int period
#ENDIF
){
#IF OfBoolean
int trueCount=0;
for(int i=0;i<seqSize;){
  seqMonitor.add(initVal);
  if((initVal&1)!=0){
    ++trueCount;
  }
  if((++i)%period==0){
    ++initVal;
  }
}
#ELSE
  for(int i=0;i<seqSize;++i){
    seqMonitor.add(i);
  }
#ENDIF
  final var clone=(OmniCollection.Of$ClassPrefix$)seqMonitor.seq.clone();
#IF OfBoolean
  final int numExpectedCalls=seqMonitor.seq.contains(true)?seqMonitor.seq.contains(false)?2:1:seqMonitor.seq.contains(false)?1:0;
#ELSE
  final int numExpectedCalls=seqSize;
#ENDIF
  final int numExpectedRemoved;
  switch(monitoredRemoveIfPredicateGen){
#IF OfBoolean
    case RemoveTrue:
      numExpectedRemoved=trueCount;
      break;
    case RemoveFalse:
      numExpectedRemoved=seqSize-trueCount;
      break;
#ENDIF
    case RemoveAll:
      numExpectedRemoved=seqSize;
      break;
    case Random:
      numExpectedRemoved=-1;
      break;
    case RemoveNone:
    case Throw:
    case ModSeq:
    case ThrowModSeq:
      numExpectedRemoved=0;
      break;
    default:
      throw new Error("Unknown monitoredRemoveIfPredicateGen "+monitoredRemoveIfPredicateGen);
  }
  final var monitoredRemoveIfPredicate=monitoredRemoveIfPredicateGen.getMonitoredRemoveIfPredicate(seqMonitor,randSeed,numExpectedCalls,threshold);
  if(monitoredRemoveIfPredicateGen.expectedException==null || seqSize==0){
    seqMonitor.verifyRemoveIf(monitoredRemoveIfPredicate,functionCallType,numExpectedRemoved,clone);
    seqMonitor.verifyPreAlloc().skip(seqMonitor.expectedSeqSize).verifyPostAlloc();
    return;
  }else{
    Assertions.assertThrows(monitoredRemoveIfPredicateGen.expectedException,()->seqMonitor.verifyRemoveIf(monitoredRemoveIfPredicate,functionCallType,numExpectedRemoved,clone));
    //TODO verify contents of sequence in throw cases 
  }
}
#ENDDEF
#MACRODEF testforEach_Consumer<PARALLEL>()
static Stream<Arguments> getforEach_ConsumerArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(var monitoredFunctionGen:MonitoredFunctionGen.values()){
      if(monitoredFunctionGen.appliesToRoot&&(checkedType.checked || monitoredFunctionGen.expectedException==null)){
        for(var seqContentsScenario:SequenceContentsScenario.values()){
          streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),monitoredFunctionGen,seqContentsScenario,FunctionCallType.Unboxed));
#IFNOT OfRef
          streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),monitoredFunctionGen,seqContentsScenario,FunctionCallType.Boxed));
#ENDIF
        }
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testforEach_Consumer(){
  getforEach_ConsumerArgs().parallel().map(Arguments::get).forEach(args->{
      testforEach_ConsumerHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(MonitoredFunctionGen)args[1],(SequenceContentsScenario)args[2],(FunctionCallType)args[3]);
  });
}
private static void testforEach_ConsumerHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getforEach_ConsumerArgs")
public void testforEach_Consumer
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,MonitoredFunctionGen monitoredFunctionGen,SequenceContentsScenario seqContentsScenario,FunctionCallType functionCallType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var monitoredConsumer=monitoredFunctionGen.getMonitoredConsumer(seqMonitor);
  int numExpectedIteratedValues;
  if(monitoredFunctionGen.expectedException==null || !seqContentsScenario.nonEmpty){
    seqMonitor.forEach(monitoredConsumer,functionCallType);
    seqMonitor.verifyStructuralIntegrity();
    seqMonitor.verifyPreAlloc().verifyNaturalAscending(numToAdd).verifyPostAlloc();
    numExpectedIteratedValues=numToAdd;
  }else{
    Assertions.assertThrows(monitoredFunctionGen.expectedException,()->seqMonitor.forEach(monitoredConsumer,functionCallType));
    seqMonitor.verifyStructuralIntegrity();
    var verifyItr=seqMonitor.verifyPreAlloc();
    switch(monitoredFunctionGen){
      case Throw:
        numExpectedIteratedValues=1;
        verifyItr.verifyNaturalAscending(numToAdd);
        break;
      case ModSeq:
        numExpectedIteratedValues=numToAdd;
        if(seqMonitor.nestedType.forwardIteration){
          verifyItr.verifyAscending(numToAdd);
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
        }else{
          for(int i=0;i<numToAdd;++i){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyDescending(numToAdd);
        }
        break;
      case ThrowModSeq:
        numExpectedIteratedValues=1;
        if(seqMonitor.nestedType.forwardIteration){
          verifyItr.verifyAscending(numToAdd).verifyIllegalAdd();
        }else{
          verifyItr.verifyIllegalAdd().verifyDescending(numToAdd);
        }
        break;
      default:
        throw new Error("Unknown monitored function gen "+monitoredFunctionGen);
    }
    verifyItr.verifyPostAlloc();
  }
  Assertions.assertEquals(numExpectedIteratedValues,monitoredConsumer.encounteredValues.size());
  //TODO verify iterated values
}
#ENDDEF
#MACRODEF testItrforEachRemaining_Consumer<PARALLEL>()
static Stream<Arguments> getItrforEachRemaining_ConsumerArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(var preModScenario:PreModScenario.values()){
      if(checkedType.checked || preModScenario.expectedException==null){
        for(var monitoredFunctionGen:MonitoredFunctionGen.values()){
          if((monitoredFunctionGen.expectedException==null || checkedType.checked) && (preModScenario.appliesToRootItr&&monitoredFunctionGen.appliesToRootItr)){
            for(var seqContentsScenario:SequenceContentsScenario.values()){
              streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,seqContentsScenario,FunctionCallType.Unboxed));
#IFNOT OfRef
              streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),preModScenario,monitoredFunctionGen,seqContentsScenario,FunctionCallType.Boxed));
#ENDIF
            }
          }
        }
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testItrforEachRemaining_Consumer(){
  getItrforEachRemaining_ConsumerArgs().parallel().map(Arguments::get).forEach(args->{
      testItrforEachRemaining_ConsumerHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(PreModScenario)args[1],(MonitoredFunctionGen)args[2],(SequenceContentsScenario)args[3],(FunctionCallType)args[4]);
  });
}
private static void testItrforEachRemaining_ConsumerHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getItrforEachRemaining_ConsumerArgs")
public void testItrforEachRemaining_Consumer
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,PreModScenario preModScenario,MonitoredFunctionGen monitoredFunctionGen,SequenceContentsScenario seqContentsScenario,FunctionCallType functionCallType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getItrMonitor();
  seqMonitor.illegalAdd(preModScenario);
  var monitoredConsumer=monitoredFunctionGen.getMonitoredConsumer(itrMonitor);
  int numExpectedIteratedValues;
  if(preModScenario.expectedException==null || !seqContentsScenario.nonEmpty){
    if(monitoredFunctionGen.expectedException==null || !seqContentsScenario.nonEmpty){
      itrMonitor.forEachRemaining(monitoredConsumer,functionCallType);
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
      seqMonitor.verifyPreAlloc(preModScenario).verifyNaturalAscending(numToAdd).verifyPostAlloc(preModScenario);
      numExpectedIteratedValues=numToAdd;
    }else{
      Assertions.assertThrows(monitoredFunctionGen.expectedException,()->itrMonitor.forEachRemaining(monitoredConsumer,functionCallType));
      seqMonitor.verifyStructuralIntegrity();
      itrMonitor.verifyIteratorState();
      switch(monitoredFunctionGen){
        case ThrowModItr:
          numExpectedIteratedValues=1;
          var verifyItr=seqMonitor.verifyPreAlloc(preModScenario);
          if(seqMonitor.nestedType.forwardIteration){
            verifyItr.verifyAscending(1,numToAdd-1);
          }else{
            verifyItr.verifyDescending(numToAdd-1);
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ModItr:
          numExpectedIteratedValues=numToAdd;
          seqMonitor.verifyPreAlloc(preModScenario).verifyPostAlloc(preModScenario);
          break;
        case Throw:
          numExpectedIteratedValues=1;
          seqMonitor.verifyPreAlloc(preModScenario).verifyNaturalAscending(numToAdd).verifyPostAlloc(preModScenario);
          break;
        case ModSeq:
          numExpectedIteratedValues=numToAdd;
          verifyItr=seqMonitor.verifyPreAlloc(preModScenario);
          if(seqMonitor.nestedType.forwardIteration){
            verifyItr.verifyAscending(numToAdd);
            for(int i=0;i<numToAdd;++i){
              verifyItr.verifyIllegalAdd();
            }
          }else{
            for(int i=0;i<numToAdd;++i){
              verifyItr.verifyIllegalAdd();
            }
            verifyItr.verifyDescending(numToAdd);
          }
          verifyItr.verifyPostAlloc(preModScenario);
          break;
        case ThrowModSeq:
          numExpectedIteratedValues=1;
          seqMonitor.verifyPreAlloc(PreModScenario.ModSeq).verifyNaturalAscending(numToAdd).verifyPostAlloc(PreModScenario.ModSeq);
          break;
        default:
          throw new Error("Unknown monitored function gen "+monitoredFunctionGen);
      }
    }
  }else{
    Assertions.assertThrows(preModScenario.expectedException,()->itrMonitor.forEachRemaining(monitoredConsumer,functionCallType));
    seqMonitor.verifyStructuralIntegrity();
    itrMonitor.verifyIteratorState();
    switch(monitoredFunctionGen){
      case ThrowModItr:
        numExpectedIteratedValues=1;
        seqMonitor.verifyPreAlloc(preModScenario).verifyNaturalAscending(numToAdd).verifyPostAlloc(preModScenario);
        break;
      case ModItr:
        numExpectedIteratedValues=1;
        //verification in tis situation is tricky. Just skip it
        break;
      case NoThrow:
        numExpectedIteratedValues=numToAdd;
        if(preModScenario==PreModScenario.ModSeq && seqMonitor.nestedType.forwardIteration){
          ++numExpectedIteratedValues;
        }
        seqMonitor.verifyPreAlloc(preModScenario).verifyNaturalAscending(numToAdd).verifyPostAlloc(preModScenario);
        break;
      case Throw:
        numExpectedIteratedValues=1;
        seqMonitor.verifyPreAlloc(preModScenario).verifyNaturalAscending(numToAdd).verifyPostAlloc(preModScenario);
        break;
      case ModSeq:
        var verifyItr=seqMonitor.verifyPreAlloc(preModScenario);
        if(seqMonitor.nestedType.forwardIteration){
          verifyItr.verifyAscending(numToAdd);
          if(preModScenario==PreModScenario.ModSeq){
            numExpectedIteratedValues=numToAdd+1;
          }else{
            numExpectedIteratedValues=1;
          }
          for(int i=0;i<numExpectedIteratedValues;++i){
            verifyItr.verifyIllegalAdd();
          }
        }else{
          if(preModScenario==PreModScenario.ModSeq){
            numExpectedIteratedValues=numToAdd;
          }else{
            numExpectedIteratedValues=1;
          }
          for(int i=0;i<numExpectedIteratedValues;++i){
            verifyItr.verifyIllegalAdd();
          }
          verifyItr.verifyDescending(numToAdd);
        }
        verifyItr.verifyPostAlloc(preModScenario);
        break;
      case ThrowModSeq:
        verifyItr=seqMonitor.verifyPreAlloc(preModScenario);
        if(seqMonitor.nestedType.forwardIteration){
          verifyItr.verifyAscending(numToAdd).verifyIllegalAdd();
        }else{
          verifyItr.verifyIllegalAdd().verifyDescending(numToAdd);
        }
        verifyItr.verifyPostAlloc(preModScenario);
        numExpectedIteratedValues=1;
        break;
      default:
        throw new Error("Unknown monitored function gen "+monitoredFunctionGen);
    }
  }
  Assertions.assertEquals(numExpectedIteratedValues,monitoredConsumer.encounteredValues.size());
  //TODO verify the iterated values
}
#ENDDEF
#MACRODEF testItrremove_void<PARALLEL>()
static Stream<Arguments> getItrremove_voidArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(var removeScenario:ItrRemoveScenario.values()){
      if(removeScenario.validWithForwardItr && (checkedType.checked || removeScenario.expectedException==null)){
        for(var sequenceContentsScenario:SequenceContentsScenario.values()){
          if(sequenceContentsScenario.nonEmpty || removeScenario.validWithEmptySeq){
            for(var preModScenario:PreModScenario.values()){
              if(preModScenario.appliesToRootItr && (checkedType.checked || preModScenario.expectedException==null)){
                for(var seqLocation:SequenceLocation.values()){
                  if(seqLocation.expectedException==null && (sequenceContentsScenario.nonEmpty || seqLocation==SequenceLocation.BEGINNING) && (seqLocation!=SequenceLocation.END || removeScenario!=ItrRemoveScenario.PostInit) && (removeScenario!=ItrRemoveScenario.PostInit || seqLocation==SequenceLocation.BEGINNING)){
                    streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),removeScenario,preModScenario,sequenceContentsScenario,seqLocation));
                  }
                }
              }
            }
          }
        }
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testItrremove_void(){
  getItrremove_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testItrremove_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(ItrRemoveScenario)args[1],(PreModScenario)args[2],(SequenceContentsScenario)args[3],(SequenceLocation)args[4]);
  });
}
private static void testItrremove_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getItrremove_voidArgs")
public void testItrremove_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,ItrRemoveScenario removeScenario,PreModScenario preModScenario,SequenceContentsScenario seqContentsScenario,SequenceLocation seqLocation){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getItrMonitor();
  switch(seqLocation){
    case BEGINNING:
      break;
    case MIDDLE:
      for(int i=0,bound=numToAdd/2;i<bound;++i){
        itrMonitor.iterateForward();
      }
      break;
    case END:
      for(int i=0;i<numToAdd;++i){
        itrMonitor.iterateForward();
      }
      break;
    default:
      throw new Error("Unknown seqLocation "+seqLocation);
  }
  switch(removeScenario){
    case PostNext:
      if(seqLocation==SequenceLocation.BEGINNING){
        itrMonitor.iterateForward();
      }
      break;
    case PostRemove:
      if(seqLocation==SequenceLocation.BEGINNING){
        itrMonitor.iterateForward();
      }
      itrMonitor.remove();
    case PostInit:
      break;
    default:
       throw new Error("unknown remove scenario "+removeScenario);
  }
  seqMonitor.illegalAdd(preModScenario);
  SequenceVerificationItr verifyItr;
  if(removeScenario.expectedException==null){
    if(preModScenario.expectedException==null){
      itrMonitor.remove();
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
      while(itrMonitor.hasNext()){
        itrMonitor.iterateForward();
        itrMonitor.remove();
        itrMonitor.verifyIteratorState();
        seqMonitor.verifyStructuralIntegrity();
      }
      Assertions.assertFalse(itrMonitor.hasNext());
      if(seqLocation==SequenceLocation.BEGINNING){
        Assertions.assertTrue(seqMonitor.isEmpty());
      }
      return;
    }else{
      Assertions.assertThrows(preModScenario.expectedException,()->itrMonitor.remove());
      itrMonitor.verifyIteratorState();
      seqMonitor.verifyStructuralIntegrity();
      verifyItr=seqMonitor.verifyPreAlloc(preModScenario).verifyNaturalAscending(numToAdd);
    }
  }else{
    Assertions.assertThrows(removeScenario.expectedException,()->itrMonitor.remove());
    itrMonitor.verifyIteratorState();
    seqMonitor.verifyStructuralIntegrity();
    verifyItr=seqMonitor.verifyPreAlloc(preModScenario);
    switch(removeScenario){
      case PostInit:
        verifyItr.verifyNaturalAscending(numToAdd);
        break;
      case PostRemove:
        if(seqMonitor.nestedType.forwardIteration){
          switch(seqLocation){
            case BEGINNING:
              verifyItr.verifyAscending(1,numToAdd-1);
              break;
            case MIDDLE:
              verifyItr.verifyAscending((numToAdd/2)-1).verifyAscending(numToAdd/2,numToAdd/2);
              break;
            case END:
              verifyItr.verifyAscending(numToAdd-1);
              break;
            default:
             throw new Error("Unknown seqLocation "+seqLocation);
          }
        }else{
          switch(seqLocation){
            case BEGINNING:
              verifyItr.verifyDescending(numToAdd-1);
              break;
            case MIDDLE:
              verifyItr.verifyDescending(numToAdd,(numToAdd/2)-1).verifyDescending(numToAdd/2);
              break;
            case END:
              verifyItr.verifyDescending(numToAdd,numToAdd-1);
              break;
            default:
               throw new Error("Unknown seqLocation "+seqLocation);
          }
        }
        break;
      default:
        throw new Error("unknown remove scenario "+removeScenario);
    }
  }
  verifyItr.verifyPostAlloc(preModScenario);
}
#ENDDEF
#MACRODEF testItrnext_void<PARALLEL>()
static Stream<Arguments> getItrnext_voidArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    for(var itrScenario:IterationScenario.values()){
      if(checkedType.checked || itrScenario==IterationScenario.NoMod){
        for(var seqContentsScenario:SequenceContentsScenario.values()){
          if(seqContentsScenario.nonEmpty || itrScenario.validWithEmptySeq){
            if(itrScenario.preModScenario.appliesToRootItr){
              for(var outputType:$ClassPrefix$OutputTestArgType.values()){
                streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType),itrScenario,seqContentsScenario,outputType));
              }
            }
          }
        }
      }
    }
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testItrnext_void(){
  getItrnext_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testItrnext_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(IterationScenario)args[1],(SequenceContentsScenario)args[2],($ClassPrefix$OutputTestArgType)args[3]);
  });
}
private static void testItrnext_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getItrnext_voidArgs")
public void testItrnext_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,IterationScenario itrScenario,SequenceContentsScenario seqContentsScenario,$ClassPrefix$OutputTestArgType outputType){
  int numToAdd=seqContentsScenario.nonEmpty?100:0;
  for(int i=0;i<numToAdd;++i){
    seqMonitor.add(i);
  }
  var itrMonitor=seqMonitor.getItrMonitor();
  switch(itrScenario){
    case NoMod:
    case ModSeqSupercedesThrowNSEE:
      for(int i=0;;++i){
        if(i==numToAdd){
          Assertions.assertFalse(itrMonitor.hasNext());
          break;
        }
        Assertions.assertTrue(itrMonitor.hasNext());
        itrMonitor.verifyNext(seqMonitor.nestedType==NestedType.STACK?numToAdd-i-1:i,outputType);
        itrMonitor.verifyIteratorState();
        seqMonitor.verifyStructuralIntegrity();
      }
    case ModSeq:
      break;
    default:
      throw new Error("unknown itr scenario "+itrScenario);
  }
  if(seqMonitor.checkedType.checked){
    seqMonitor.illegalAdd(itrScenario.preModScenario);
    Assertions.assertThrows(itrScenario.expectedException,()->itrMonitor.iterateForward());
  }
  itrMonitor.verifyIteratorState();
  seqMonitor.verifyStructuralIntegrity();
  seqMonitor.verifyPreAlloc(itrScenario.preModScenario).verifyNaturalAscending(numToAdd).verifyPostAlloc(itrScenario.preModScenario);
}
#ENDDEF
#MACRODEF testConstructor_void<PARALLEL>()
static Stream<Arguments> getConstructor_voidArgs(){
  return ArgBuilder.buildSeqArgs((streamBuilder,nestedType,checkedType)->{
    streamBuilder.accept(Arguments.of(new $ClassPrefix$SnglLnkSeqMonitor(nestedType,checkedType)));
  });
}
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testConstructor_void(){
  getConstructor_voidArgs().parallel().map(Arguments::get).forEach(args->{
      testConstructor_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0]);
  });
}
private static void testConstructor_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("getConstructor_voidArgs")
public void testConstructor_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor){
  if(seqMonitor.checkedType.checked){
    Assertions.assertEquals(0,seqMonitor.nestedType==NestedType.QUEUE?FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.CheckedQueue.modCount(seqMonitor.seq):FieldAndMethodAccessor.$ClassPrefix$SnglLnkSeq.CheckedStack.modCount(seqMonitor.seq));
  }
  Assertions.assertEquals(0,seqMonitor.seq.size);
  Assertions.assertNull(seqMonitor.seq.head);
}
#ENDDEF
#MACRODEF testtoString_void<PARALLEL>()
#IFSWITCH PARALLEL==true
@org.junit.jupiter.api.Test
public void testtoString_void(){
  gettoStringAndhashCode_voidArgs().parallel().map(Arguments::get).forEach(args->{
    testtoString_voidHelper(($ClassPrefix$SnglLnkSeqMonitor)args[0],(int)args[1]
#IF OfRef
    ,(MonitoredObjectGen)args[2]
#ENDIF
    );
  });
}
private static void testtoString_voidHelper
#ELSE
@org.junit.jupiter.params.ParameterizedTest
@org.junit.jupiter.params.provider.MethodSource("gettoStringAndhashCode_voidArgs")
public void testtoString_void
#ENDIF
($ClassPrefix$SnglLnkSeqMonitor seqMonitor,int numToAdd
#IF OfRef
,MonitoredObjectGen monitoredObjectGen
#ENDIF
){
#IF OfRef
  MonitoredObject monitoredObject=null;
  if(numToAdd!=0 && monitoredObjectGen.expectedException!=null){
    monitoredObject=monitoredObjectGen.getMonitoredObject(seqMonitor);
    for(int i=0;i<numToAdd;++i){
      seqMonitor.seq.add(monitoredObject);
      ++seqMonitor.expectedSeqSize;
      ++seqMonitor.expectedSeqModCount;
    }
  }else
#ENDIF
  {
    for(int i=0;i<numToAdd;++i){
      seqMonitor.add(i);
    }
  }
#IF OfRef
  if(monitoredObject!=null){
    Assertions.assertThrows(monitoredObjectGen.expectedException,()->seqMonitor.seq.toString());
    Assertions.assertEquals(verifyThrowCondition(seqMonitor,numToAdd,monitoredObject,monitoredObjectGen),monitoredObject.numToStringCalls);
  }
  else
#ENDIF
  {
    var resultStr=seqMonitor.seq.toString();
    seqMonitor.verifyPreAlloc().verifyNaturalAscending(numToAdd).verifyPostAlloc();
    var itr=seqMonitor.seq.iterator();
    var arrList=new ArrayList<Object>();
    for(int i=0;i<numToAdd;++i){
      arrList.add(itr.next());
    }
    Assertions.assertEquals(arrList.toString(),resultStr);
  }
  seqMonitor.verifyStructuralIntegrity();
}
#ENDDEF