#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.util.TypeConversionUtil;
import omni.util.TypeUtil;
import omni.util.OmniArray;
import omni.api.OmniCollection;
import omni.api.OmniList;
import omni.api.OmniStack;
import org.junit.jupiter.api.Assertions;
import omni.impl.$ClassPrefix$InputTestArgType;
import omni.impl.$ClassPrefix$OutputTestArgType;
import omni.impl.FunctionCallType;
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Predicate;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Predicate;
#ENDIF
import java.util.function.UnaryOperator;
#IF OfInt,OfLong,OfDouble
import java.util.function.$UnaryOperator$;
#ELSEIFNOT OfRef,OfBoolean
import omni.function.$UnaryOperator$;
#ENDIF
import omni.impl.QueryCastType;
import java.util.Comparator;
#IF OfInt
import java.util.function.$Comparator$;
#ELSEIFNOT OfRef
import omni.function.$Comparator$;
#ENDIF
#IF OfDouble,OfLong,OfInt
import java.util.function.$TypeNameModifier$Consumer;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
@SuppressWarnings({"rawtypes","unchecked"})
class $ClassPrefix$ArrSeqMonitor implements $ClassPrefix$SeqMonitor{
  static final int DEFAULT_PRE_AND_POST_ALLOC=5;
#IF OfRef
  static void verifyRangeIsNull($ArrayType$[] arr,int offset,int bound){
    for(int i=offset;i<bound;++i){Assertions.assertNull(arr[i]);}
  }
#ENDIF

  static enum NestedType{
    LIST(true,true),
    STACK(true,false),
    SUBLIST(false,true);
    final boolean rootType;
    final boolean forwardIteration;
    NestedType(boolean rootType,boolean forwardIteration){
      this.rootType=rootType;
      this.forwardIteration=forwardIteration;
    }
  }

  static enum QueryTester
  {
#IF OfRef
    ObjectNonNull(true){
      @Override boolean invokecontainsObject($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokecontainsBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokecontainsUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokeremoveValObject($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokeremoveValBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override boolean invokeremoveValUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokeindexOfObject($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokeindexOfBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokeindexOfUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokelastIndexOfObject($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokelastIndexOfBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokelastIndexOfUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokesearchObject($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokesearchBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override int invokesearchUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override void addEqualsVal($ClassPrefix$ArrSeqMonitor seqMonitor){throw new UnsupportedOperationException();}
      @Override void addNotEqualsVal($ClassPrefix$ArrSeqMonitor seqMonitor){
        seqMonitor.seq.add(new Object());
        ++seqMonitor.expectedSeqModCount;
        ++seqMonitor.expectedParentModCount;
        ++seqMonitor.expectedRootModCount;
        ++seqMonitor.expectedSeqSize;
        ++seqMonitor.expectedParentSize;
        ++seqMonitor.expectedRootSize;
      }
      @Override boolean invokecontainsMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        return seqMonitor.seq.contains(monitoredObject);
      }
      @Override boolean invokeremoveValMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        boolean ret=seqMonitor.seq.remove(monitoredObject);
        if(ret){
          ++seqMonitor.expectedSeqModCount;
          ++seqMonitor.expectedParentModCount;
          ++seqMonitor.expectedRootModCount;
          --seqMonitor.expectedSeqSize;
          --seqMonitor.expectedParentSize;
          --seqMonitor.expectedRootSize;
#IF OfRef
          Assertions.assertNull((($ClassPrefix$ArrSeq)seqMonitor.root).arr[seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+seqMonitor.expectedRootSize+seqMonitor.parentPostAlloc+seqMonitor.rootPostAlloc]);
#ENDIF
        }
        return ret;
      }
      @Override int invokeindexOfMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        return ((OmniList.Of$ClassPrefix$)seqMonitor.seq).indexOf(monitoredObject);
      }
      @Override int invokelastIndexOfMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        return ((OmniList.Of$ClassPrefix$)seqMonitor.seq).lastIndexOf(monitoredObject);
      }
      @Override int invokesearchMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        return ((OmniStack.Of$ClassPrefix$)seqMonitor.seq).search(monitoredObject);
      }
      @Override int initContainsEnd($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
        for(int i=0;i<99;++i){
          seqMonitor.seq.add(new Object());
        }
        seqMonitor.seq.add(monitoredObject);
        seqMonitor.expectedSeqModCount+=100;
        seqMonitor.expectedParentModCount+=100;
        seqMonitor.expectedRootModCount+=100;
        seqMonitor.expectedSeqSize+=100;
        seqMonitor.expectedParentSize+=100;
        seqMonitor.expectedRootSize+=100;
        return seqMonitor.expectedSeqSize-1;
      }
      @Override int initContainsMiddle($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
        for(int i=0;i<50;++i){
          seqMonitor.seq.add(new Object());
        }
        seqMonitor.seq.add(monitoredObject);
        for(int i=51;i<100;++i){
          seqMonitor.seq.add(new Object());
        }
        seqMonitor.expectedSeqModCount+=100;
        seqMonitor.expectedParentModCount+=100;
        seqMonitor.expectedRootModCount+=100;
        seqMonitor.expectedSeqSize+=100;
        seqMonitor.expectedParentSize+=100;
        seqMonitor.expectedRootSize+=100;
        return seqMonitor.expectedSeqSize/2;
      }
      @Override int initContainsBeginning($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){
        Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
        seqMonitor.seq.add(monitoredObject);
        for(int i=1;i<100;++i){
          seqMonitor.seq.add(new Object());
        }
        seqMonitor.expectedSeqModCount+=100;
        seqMonitor.expectedParentModCount+=100;
        seqMonitor.expectedRootModCount+=100;
        seqMonitor.expectedSeqSize+=100;
        seqMonitor.expectedParentSize+=100;
        seqMonitor.expectedRootSize+=100;
        return 0;
      }
    },
#ENDIF
  #MACRO QueryTesterImpl<null,Boolean,Boolean>(null,false)
  #MACRO QueryTesterImpl<null,Byte,Byte>(null,false)
  #MACRO QueryTesterImpl<null,Character,Character>(null,false)
  #MACRO QueryTesterImpl<null,Short,Short>(null,false)
  #MACRO QueryTesterImpl<null,Integer,Integer>(null,false)
  #MACRO QueryTesterImpl<null,Long,Long>(null,false)
  #MACRO QueryTesterImpl<null,Float,Float>(null,false)
  #MACRO QueryTesterImpl<null,Double,Double>(null,false)
  #MACRO QueryTesterImpl<null,Object,Object>(null,false)
  #MACRO QueryTesterImpl<false,Boolean,boolean>(false,true)
  #MACRO QueryTesterImpl<true,Boolean,boolean>(true,false)
  #MACRO QueryTesterImpl<0,Byte,byte>(0,true)
  #MACRO QueryTesterImpl<pos1,Byte,byte>(1,false)
  #MACRO QueryTesterImpl<pos2,Byte,byte>(2,false)
  #MACRO QueryTesterImpl<neg1,Byte,byte>(-1,false)
  #MACRO QueryTesterImpl<0,Character,char>(0,true)
  #MACRO QueryTesterImpl<pos1,Character,char>(1,false)
  #MACRO QueryTesterImpl<pos2,Character,char>(2,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Character,char>(((char)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Character,char>(((char)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<0,Short,short>(0,true)
  #MACRO QueryTesterImpl<pos1,Short,short>(1,false)
  #MACRO QueryTesterImpl<pos2,Short,short>(2,false)
  #MACRO QueryTesterImpl<neg1,Short,short>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Short,short>(((short)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Short,short>(((short)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<0,Integer,int>(0,true)
  #MACRO QueryTesterImpl<pos1,Integer,int>(1,false)
  #MACRO QueryTesterImpl<pos2,Integer,int>(2,false)
  #MACRO QueryTesterImpl<neg1,Integer,int>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Integer,int>(((int)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Integer,int>(((int)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Integer,int>(((int)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_SHORT_MINUS1,Integer,int>(((int)Short.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_CHAR_PLUS1,Integer,int>(((int)Character.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_SAFE_INT_PLUS1,Integer,int>(TypeUtil.MAX_SAFE_INT+1,false)
  #MACRO QueryTesterImpl<MIN_SAFE_INT_MINUS1,Integer,int>(TypeUtil.MIN_SAFE_INT-1,false)
  #MACRO QueryTesterImpl<0,Long,long>(0,true)
  #MACRO QueryTesterImpl<pos1,Long,long>(1,false)
  #MACRO QueryTesterImpl<pos2,Long,long>(2,false)
  #MACRO QueryTesterImpl<neg1,Long,long>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Long,long>(((long)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Long,long>(((long)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Long,long>(((long)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_SHORT_MINUS1,Long,long>(((long)Short.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_CHAR_PLUS1,Long,long>(((long)Character.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_SAFE_INT_PLUS1,Long,long>(((long)TypeUtil.MAX_SAFE_INT)+1,false)
  #MACRO QueryTesterImpl<MIN_SAFE_INT_MINUS1,Long,long>(((long)TypeUtil.MIN_SAFE_INT)-1,false)
  #MACRO QueryTesterImpl<MAX_INT_PLUS1,Long,long>(((long)Integer.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_INT_MINUS1,Long,long>(((long)Integer.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SAFE_LONG_PLUS1,Long,long>(((long)TypeUtil.MAX_SAFE_LONG)+1,false)
  #MACRO QueryTesterImpl<MIN_SAFE_LONG_MINUS1,Long,long>(((long)TypeUtil.MIN_SAFE_LONG)-1,false)
  #MACRO QueryTesterImpl<pos0,Float,float>(0.0F,true)
  #MACRO QueryTesterImpl<neg0,Float,float>(-0.0F,true)
  #MACRO QueryTesterImpl<pos1,Float,float>(1,false)
  #MACRO QueryTesterImpl<pos2,Float,float>(2,false)
  #MACRO QueryTesterImpl<neg1,Float,float>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Float,float>(((float)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Float,float>(((float)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Float,float>(((float)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_SHORT_MINUS1,Float,float>(((float)Short.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_CHAR_PLUS1,Float,float>(((float)Character.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_INT_PLUS1,Float,float>(((float)Integer.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_INT_MINUS1,Float,float>(((float)Integer.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_LONG_PLUS1,Float,float>(((float)Long.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_LONG_MINUS1,Float,float>(((float)Long.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MIN_FLOAT_VALUE,Float,float>(Float.MIN_VALUE,false)
  #MACRO QueryTesterImpl<MAX_FLOAT_VALUE,Float,float>(Float.MAX_VALUE,false)
  #MACRO QueryTesterImpl<NaN,Float,float>(Float.NaN,false)
  #MACRO QueryTesterImpl<pos0,Double,double>(0.0D,true)
  #MACRO QueryTesterImpl<neg0,Double,double>(-0.0D,true)
  #MACRO QueryTesterImpl<pos1,Double,double>(1,false)
  #MACRO QueryTesterImpl<pos2,Double,double>(2,false)
  #MACRO QueryTesterImpl<neg1,Double,double>(-1,false)
  #MACRO QueryTesterImpl<MAX_BYTE_PLUS1,Double,double>(((double)Byte.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_BYTE_MINUS1,Double,double>(((double)Byte.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_SHORT_PLUS1,Double,double>(((double)Short.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_SHORT_MINUS1,Double,double>(((double)Short.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_CHAR_PLUS1,Double,double>(((double)Character.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MAX_SAFE_INT_PLUS1,Double,double>(((double)TypeUtil.MAX_SAFE_INT)+1,false)
  #MACRO QueryTesterImpl<MIN_SAFE_INT_MINUS1,Double,double>(((double)TypeUtil.MIN_SAFE_INT)-1,false)
  #MACRO QueryTesterImpl<MAX_INT_PLUS1,Double,double>(((double)Integer.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_INT_MINUS1,Double,double>(((double)Integer.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MAX_LONG_PLUS1,Double,double>(((double)Long.MAX_VALUE)+1,false)
  #MACRO QueryTesterImpl<MIN_LONG_MINUS1,Double,double>(((double)Long.MIN_VALUE)-1,false)
  #MACRO QueryTesterImpl<MIN_FLOAT_VALUE,Double,double>(Float.MIN_VALUE,false)
  #MACRO QueryTesterImpl<MAX_FLOAT_VALUE,Double,double>(Float.MAX_VALUE,false)
  #MACRO QueryTesterImpl<MIN_DOUBLE_VALUE,Double,double>(Double.MIN_VALUE,false)
  #MACRO QueryTesterImpl<MAX_DOUBLE_VALUE,Double,double>(Double.MAX_VALUE,false)
  #MACRO QueryTesterImpl<NaN,Double,double>(Double.NaN,false)
  ;

#MACRODEF QueryTesterImpl<VALUE_NAME,BOXED_TYPE,PRIMITIVE_TYPE>(PRIMITIVE_VAL,NOT_EQUALS_VAL)
BOXED_TYPEVALUE_NAME(false){
  @Override boolean invokecontainsObject($ClassPrefix$ArrSeqMonitor seqMonitor){return seqMonitor.seq.contains((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override boolean invokeremoveValObject($ClassPrefix$ArrSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.remove((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      ++seqMonitor.expectedParentModCount;
      ++seqMonitor.expectedRootModCount;
      --seqMonitor.expectedSeqSize;
      --seqMonitor.expectedParentSize;
      --seqMonitor.expectedRootSize;
#IF OfRef
      Assertions.assertNull((($ClassPrefix$ArrSeq)seqMonitor.root).arr[seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+seqMonitor.expectedRootSize+seqMonitor.parentPostAlloc+seqMonitor.rootPostAlloc]);
#ENDIF
    }
    return ret;
  }
  @Override int invokeindexOfObject($ClassPrefix$ArrSeqMonitor seqMonitor){return ((OmniList.Of$ClassPrefix$)seqMonitor.seq).indexOf((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override int invokelastIndexOfObject($ClassPrefix$ArrSeqMonitor seqMonitor){return ((OmniList.Of$ClassPrefix$)seqMonitor.seq).lastIndexOf((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override int invokesearchObject($ClassPrefix$ArrSeqMonitor seqMonitor){return ((OmniStack.Of$ClassPrefix$)seqMonitor.seq).search((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override boolean invokecontainsBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){return seqMonitor.seq.contains((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
#IFSWITCH BOXED_TYPE==Object
  @Override boolean invokeremoveValBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.remove((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      ++seqMonitor.expectedParentModCount;
      ++seqMonitor.expectedRootModCount;
      --seqMonitor.expectedSeqSize;
      --seqMonitor.expectedParentSize;
      --seqMonitor.expectedRootSize;
  #IF OfRef
      Assertions.assertNull((($ClassPrefix$ArrSeq)seqMonitor.root).arr[seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+seqMonitor.expectedRootSize+seqMonitor.parentPostAlloc+seqMonitor.rootPostAlloc]);
  #ENDIF
    }
    return ret;
  }
#ELSE
  @Override boolean invokeremoveValBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.removeVal((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      ++seqMonitor.expectedParentModCount;
      ++seqMonitor.expectedRootModCount;
      --seqMonitor.expectedSeqSize;
      --seqMonitor.expectedParentSize;
      --seqMonitor.expectedRootSize;
  #IF OfRef
      Assertions.assertNull((($ClassPrefix$ArrSeq)seqMonitor.root).arr[seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+seqMonitor.expectedRootSize+seqMonitor.parentPostAlloc+seqMonitor.rootPostAlloc]);
  #ENDIF
    }
    return ret;
  }
#ENDIF
  @Override int invokeindexOfBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){return ((OmniList.Of$ClassPrefix$)seqMonitor.seq).indexOf((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override int invokelastIndexOfBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){return ((OmniList.Of$ClassPrefix$)seqMonitor.seq).lastIndexOf((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override int invokesearchBoxed($ClassPrefix$ArrSeqMonitor seqMonitor){return ((OmniStack.Of$ClassPrefix$)seqMonitor.seq).search((BOXED_TYPE)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override boolean invokecontainsUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){return seqMonitor.seq.contains((PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
#IFSWITCH PRIMITIVE_TYPE==Object
  @Override boolean invokeremoveValUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.remove((PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      ++seqMonitor.expectedParentModCount;
      ++seqMonitor.expectedRootModCount;
      --seqMonitor.expectedSeqSize;
      --seqMonitor.expectedParentSize;
      --seqMonitor.expectedRootSize;
  #IF OfRef
      Assertions.assertNull((($ClassPrefix$ArrSeq)seqMonitor.root).arr[seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+seqMonitor.expectedRootSize+seqMonitor.parentPostAlloc+seqMonitor.rootPostAlloc]);
  #ENDIF
    }
    return ret;
  }
#ELSE
  @Override boolean invokeremoveValUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){
    boolean ret=seqMonitor.seq.removeVal((PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    if(ret){
      ++seqMonitor.expectedSeqModCount;
      ++seqMonitor.expectedParentModCount;
      ++seqMonitor.expectedRootModCount;
      --seqMonitor.expectedSeqSize;
      --seqMonitor.expectedParentSize;
      --seqMonitor.expectedRootSize;
  #IF OfRef
      Assertions.assertNull((($ClassPrefix$ArrSeq)seqMonitor.root).arr[seqMonitor.rootPreAlloc+seqMonitor.parentPreAlloc+seqMonitor.expectedRootSize+seqMonitor.parentPostAlloc+seqMonitor.rootPostAlloc]);
  #ENDIF
    }
    return ret;
  }
#ENDIF
  @Override int invokeindexOfUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){return ((OmniList.Of$ClassPrefix$)seqMonitor.seq).indexOf((PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override int invokelastIndexOfUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){return ((OmniList.Of$ClassPrefix$)seqMonitor.seq).lastIndexOf((PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  @Override int invokesearchUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor){return ((OmniStack.Of$ClassPrefix$)seqMonitor.seq).search((PRIMITIVE_TYPE)(PRIMITIVE_VAL));}
  void addEqualsVal($ClassPrefix$ArrSeqMonitor seqMonitor){
#IF OfRef
    seqMonitor.seq.add((Object)(PRIMITIVE_TYPE)(PRIMITIVE_VAL));
    ++seqMonitor.expectedSeqModCount;
    ++seqMonitor.expectedParentModCount;
    ++seqMonitor.expectedRootModCount;
    ++seqMonitor.expectedSeqSize;
    ++seqMonitor.expectedParentSize;
    ++seqMonitor.expectedRootSize;
#ELSE
  #IFSWITCH VALUE_NAME==null
    throw new UnsupportedOperationException();
  #ELSE
    #IF OfBoolean
      #IFSWITCH PRIMITIVE_TYPE==boolean
    seqMonitor.seq.add((boolean)(PRIMITIVE_VAL));
      #ELSE
        #IFSWITCH VALUE_NAME==pos1
    seqMonitor.seq.add((boolean)(true));
        #ELSE
    seqMonitor.seq.add((boolean)((PRIMITIVE_VAL)==1));
        #ENDIF
      #ENDIF
    #ELSE
      #IFSWITCH PRIMITIVE_TYPE==boolean
    seqMonitor.seq.add(($exposedType$)$queryCastBoolean$(PRIMITIVE_VAL));
      #ELSE
    seqMonitor.seq.add(($exposedType$)(PRIMITIVE_VAL));
      #ENDIF
    #ENDIF
    ++seqMonitor.expectedSeqModCount;
    ++seqMonitor.expectedParentModCount;
    ++seqMonitor.expectedRootModCount;
    ++seqMonitor.expectedSeqSize;
    ++seqMonitor.expectedParentSize;
    ++seqMonitor.expectedRootSize;
  #ENDIF
  
#ENDIF
    
  }
  void addNotEqualsVal($ClassPrefix$ArrSeqMonitor seqMonitor){
    #IF OfRef
    seqMonitor.seq.add((Object)(boolean)NOT_EQUALS_VAL);
    #ELSE
    seqMonitor.seq.add((boolean)NOT_EQUALS_VAL);
    #ENDIF
    ++seqMonitor.expectedSeqModCount;
    ++seqMonitor.expectedParentModCount;
    ++seqMonitor.expectedRootModCount;
    ++seqMonitor.expectedSeqSize;
    ++seqMonitor.expectedParentSize;
    ++seqMonitor.expectedRootSize;
  }
},
#ENDDEF
    
    final boolean isObjectNonNull;
    QueryTester(boolean isObjectNonNull){
      this.isObjectNonNull=isObjectNonNull;
    }
    boolean invokecontains($ClassPrefix$ArrSeqMonitor seqMonitor,QueryCastType queryCastType){
      switch(queryCastType){
        case Unboxed:
          return invokecontainsUnboxed(seqMonitor);
        case ToBoxed:
          return invokecontainsBoxed(seqMonitor);
        case ToObject:
          return invokecontainsObject(seqMonitor);
        default:
          throw new Error("Unknown queryCastType "+queryCastType);
      }
    }
    boolean invokeremoveVal($ClassPrefix$ArrSeqMonitor seqMonitor,QueryCastType queryCastType){
      switch(queryCastType){
        case Unboxed:
          return invokeremoveValUnboxed(seqMonitor);
        case ToBoxed:
          return invokeremoveValBoxed(seqMonitor);
        case ToObject:
          return invokeremoveValObject(seqMonitor);
        default:
          throw new Error("Unknown queryCastType "+queryCastType);
      }
    }
    int invokeindexOf($ClassPrefix$ArrSeqMonitor seqMonitor,QueryCastType queryCastType){
      switch(queryCastType){
        case Unboxed:
          return invokeindexOfUnboxed(seqMonitor);
        case ToBoxed:
          return invokeindexOfBoxed(seqMonitor);
        case ToObject:
          return invokeindexOfObject(seqMonitor);
        default:
          throw new Error("Unknown queryCastType "+queryCastType);
      }
    }
    int invokelastIndexOf($ClassPrefix$ArrSeqMonitor seqMonitor,QueryCastType queryCastType){
      switch(queryCastType){
        case Unboxed:
          return invokelastIndexOfUnboxed(seqMonitor);
        case ToBoxed:
          return invokelastIndexOfBoxed(seqMonitor);
        case ToObject:
          return invokelastIndexOfObject(seqMonitor);
        default:
          throw new Error("Unknown queryCastType "+queryCastType);
      }
    }
    int invokesearch($ClassPrefix$ArrSeqMonitor seqMonitor,QueryCastType queryCastType){
      switch(queryCastType){
        case Unboxed:
          return invokesearchUnboxed(seqMonitor);
        case ToBoxed:
          return invokesearchBoxed(seqMonitor);
        case ToObject:
          return invokesearchObject(seqMonitor);
        default:
          throw new Error("Unknown queryCastType "+queryCastType);
      }
    }
    
    abstract boolean invokecontainsObject($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract boolean invokecontainsBoxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract boolean invokecontainsUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract boolean invokeremoveValObject($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract boolean invokeremoveValBoxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract boolean invokeremoveValUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract int invokeindexOfObject($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract int invokeindexOfBoxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract int invokeindexOfUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract int invokelastIndexOfObject($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract int invokelastIndexOfBoxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract int invokelastIndexOfUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract int invokesearchObject($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract int invokesearchBoxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract int invokesearchUnboxed($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract void addEqualsVal($ClassPrefix$ArrSeqMonitor seqMonitor);
    abstract void addNotEqualsVal($ClassPrefix$ArrSeqMonitor seqMonitor);
    void initDoesNotContain($ClassPrefix$ArrSeqMonitor seqMonitor){
      for(int i=0;i<100;++i){
        addNotEqualsVal(seqMonitor);
      }
    }
    int initContainsEnd($ClassPrefix$ArrSeqMonitor seqMonitor){
      Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
      for(int i=0;i<99;++i){
        addNotEqualsVal(seqMonitor);
      }
      addEqualsVal(seqMonitor);
      return seqMonitor.expectedSeqSize-1;
    }
    int initContainsMiddle($ClassPrefix$ArrSeqMonitor seqMonitor){
      Assertions.assertEquals(0,seqMonitor.expectedSeqSize);
      for(int i=0;i<50;++i){
        addNotEqualsVal(seqMonitor);
      }
      addEqualsVal(seqMonitor);
      for(int i=51;i<100;++i){
        addNotEqualsVal(seqMonitor);
      }
      return seqMonitor.expectedSeqSize/2;
    }
    int initContainsBeginning($ClassPrefix$ArrSeqMonitor seqMonitor){
      addEqualsVal(seqMonitor);
      for(int i=1;i<100;++i){
        addNotEqualsVal(seqMonitor);
      }
      return 0;
    }
#IF OfRef
    boolean invokecontainsMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    boolean invokeremoveValMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    int invokeindexOfMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    int invokelastIndexOfMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    int invokesearchMonitored($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    int initContainsEnd($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    int initContainsMiddle($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
    int initContainsBeginning($ClassPrefix$ArrSeqMonitor seqMonitor,MonitoredObject monitoredObject){throw new UnsupportedOperationException();}
#ENDIF
  };

  private static void initArray(int rootPreAlloc,int parentPreAlloc,int parentPostAlloc,int rootPostAlloc,$ArrayType$[] arr){
    for(int i=0,v=Integer.MIN_VALUE,bound=rootPreAlloc;i<bound;++i,++v){
      arr[i]=TypeConversionUtil.convertTo$ArrayType$(v);
    }
    for(int i=rootPreAlloc,v=Integer.MIN_VALUE+rootPreAlloc,bound=i+parentPreAlloc;i<bound;++i,++v){
      arr[i]=TypeConversionUtil.convertTo$ArrayType$(v);
    }
    for(int i=rootPreAlloc+parentPreAlloc,v=Integer.MAX_VALUE-rootPostAlloc-parentPostAlloc,bound=i+parentPostAlloc;i<bound;++i,++v){
      arr[i]=TypeConversionUtil.convertTo$ArrayType$(v);
    }
    for(int i=rootPreAlloc+parentPreAlloc+parentPostAlloc,v=Integer.MAX_VALUE-rootPostAlloc,bound=i+rootPostAlloc;i<bound;++i,++v){
      arr[i]=TypeConversionUtil.convertTo$ArrayType$(v);
    }
  }
  final NestedType nestedType;
  final CheckedType checkedType;
  final int initialCapacity;
  final int rootPreAlloc;
  final int parentPreAlloc;
  final int parentPostAlloc;
  final int rootPostAlloc;
  final OmniCollection.Of$ClassPrefix$ root;
  final OmniCollection.Of$ClassPrefix$ parent;
  final OmniCollection.Of$ClassPrefix$ seq;
  int expectedRootSize;
  int expectedParentSize;
  int expectedSeqSize;
  int expectedRootModCount;
  int expectedParentModCount;
  int expectedSeqModCount;
  
  $ClassPrefix$ArrSeqMonitor(NestedType nestedType,CheckedType checkedType,int seqLength,$ArrayType$[] arr){
    this.nestedType=nestedType;
    this.checkedType=checkedType;
    this.expectedRootSize=seqLength;
    this.expectedParentSize=seqLength;
    this.expectedSeqSize=seqLength;
    this.initialCapacity=(arr==null)?0:(arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR?OmniArray.DEFAULT_ARR_SEQ_CAP:arr.length);
    switch(nestedType){
      case SUBLIST:
        seqLength+=(4*DEFAULT_PRE_AND_POST_ALLOC);
      case LIST:
        this.root=checkedType.checked?new $ClassPrefix$ArrSeq.CheckedList(seqLength,arr):new $ClassPrefix$ArrSeq.UncheckedList(seqLength,arr);
        break;
      case STACK:
        this.root=checkedType.checked?new $ClassPrefix$ArrSeq.CheckedStack(seqLength,arr):new $ClassPrefix$ArrSeq.UncheckedStack(seqLength,arr);
        break;
      default:
        throw new Error("Unknown nestedType "+nestedType);
    }
    if(nestedType.rootType){
      this.rootPreAlloc=0;
      this.parentPreAlloc=0;
      this.parentPostAlloc=0;
      this.rootPostAlloc=0;
      this.parent=root;
      this.seq=root;
    }else{
      Assertions.assertTrue(arr!=null && seqLength<=arr.length);
      this.rootPreAlloc=DEFAULT_PRE_AND_POST_ALLOC;
      this.parentPreAlloc=DEFAULT_PRE_AND_POST_ALLOC;
      this.parentPostAlloc=DEFAULT_PRE_AND_POST_ALLOC;
      this.rootPostAlloc=DEFAULT_PRE_AND_POST_ALLOC;
      this.parent=((OmniList.Of$ClassPrefix$)root).subList(rootPreAlloc,seqLength-rootPostAlloc);
      this.seq=((OmniList.Of$ClassPrefix$)parent).subList(parentPreAlloc,seqLength-rootPreAlloc-parentPostAlloc-rootPostAlloc);
    }
  }
  
  $ClassPrefix$ArrSeqMonitor(final NestedType nestedType,final CheckedType checkedType){
    this.nestedType=nestedType;
    this.checkedType=checkedType;
    this.initialCapacity=OmniArray.DEFAULT_ARR_SEQ_CAP;
    if(nestedType==NestedType.SUBLIST){
      this.rootPreAlloc=DEFAULT_PRE_AND_POST_ALLOC;
      this.parentPreAlloc=DEFAULT_PRE_AND_POST_ALLOC;
      this.parentPostAlloc=DEFAULT_PRE_AND_POST_ALLOC;
      this.rootPostAlloc=DEFAULT_PRE_AND_POST_ALLOC;
      int rootSize;
      $ArrayType$[] arr=new $ArrayType$[rootSize=rootPreAlloc+parentPreAlloc+parentPostAlloc+rootPostAlloc];
      initArray(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,arr);
      this.root=checkedType.checked
        ?new $ClassPrefix$ArrSeq.CheckedList(rootSize,arr)
        :new $ClassPrefix$ArrSeq.UncheckedList(rootSize,arr);
      this.parent=((OmniList.Of$ClassPrefix$)root).subList(rootPreAlloc,rootSize-rootPostAlloc);
      this.seq=((OmniList.Of$ClassPrefix$)parent).subList(parentPreAlloc,parentPreAlloc);
    }else{
      this.rootPreAlloc=0;
      this.parentPreAlloc=0;
      this.parentPostAlloc=0;
      this.rootPostAlloc=0;
      switch(nestedType){
        default:
          throw new Error("Unknown nestedType "+nestedType);
        case STACK:
          this.root=checkedType.checked
            ?new $ClassPrefix$ArrSeq.CheckedStack()
            :new $ClassPrefix$ArrSeq.UncheckedStack();
          break;
        case LIST:
          this.root=checkedType.checked
            ?new $ClassPrefix$ArrSeq.CheckedList()
            :new $ClassPrefix$ArrSeq.UncheckedList();
      }
      this.parent=root;
      this.seq=root;
    }

  }
  $ClassPrefix$ArrSeqMonitor(final NestedType nestedType,final CheckedType checkedType,final int initialCapacity){
    this(nestedType,checkedType,initialCapacity,0,0,0,0);
  }
  $ClassPrefix$ArrSeqMonitor(final CheckedType checkedType,final int rootPreAlloc,final int parentPreAlloc,final int parentPostAlloc,final int rootPostAlloc){
    this(NestedType.SUBLIST,checkedType,OmniArray.DEFAULT_ARR_SEQ_CAP,rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc);
  }
  $ClassPrefix$ArrSeqMonitor(final NestedType nestedType,final CheckedType checkedType,final int initialCapacity,final int rootPreAlloc,final int parentPreAlloc,final int parentPostAlloc,final int rootPostAlloc){
    this.nestedType=nestedType;
    this.checkedType=checkedType;
    this.initialCapacity=initialCapacity;
    this.rootPreAlloc=rootPreAlloc;
    this.parentPreAlloc=parentPreAlloc;
    this.parentPostAlloc=parentPostAlloc;
    this.rootPostAlloc=rootPostAlloc;
    int rootSize=rootPreAlloc+parentPreAlloc+parentPostAlloc+rootPostAlloc;
    $ArrayType$[] arr;
    if(rootSize==0){
      switch(initialCapacity){
        case 0:
          arr=null;
          break;
        case OmniArray.DEFAULT_ARR_SEQ_CAP:
          arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
          break;
        default:
          arr=new $ArrayType$[initialCapacity];
      }
    }else{
      arr=new $ArrayType$[Math.max(initialCapacity,rootSize)];
    }
    initArray(rootPreAlloc,parentPreAlloc,parentPostAlloc,rootPostAlloc,arr);
    this.root=nestedType==NestedType.STACK
      ?checkedType.checked
        ?new $ClassPrefix$ArrSeq.CheckedStack(rootSize,arr)
        :new $ClassPrefix$ArrSeq.UncheckedStack(rootSize,arr)
      :checkedType.checked
        ?new $ClassPrefix$ArrSeq.CheckedList(rootSize,arr)
        :new $ClassPrefix$ArrSeq.UncheckedList(rootSize,arr);
    switch(nestedType){
      case SUBLIST:
        this.parent=((OmniList.Of$ClassPrefix$)root).subList(rootPreAlloc,rootPreAlloc+parentPreAlloc+parentPostAlloc);
        this.seq=((OmniList.Of$ClassPrefix$)parent).subList(parentPreAlloc,parentPreAlloc);
        break;
      case LIST:
      case STACK:
        this.parent=root;
        this.seq=root;
        break;
      default:
        throw new Error("Unknown nestedType "+nestedType);
    }
  }




  abstract class AbstractItrMonitor implements ItrMonitor{
    final OmniIterator.Of$ClassPrefix$ itr;
    int expectedCursor;
    int expectedLastRet;
    public void forEachRemaining(MonitoredConsumer action,FunctionCallType functionCallType){
      int expectedBound=nestedType.forwardIteration?expectedSeqSize:0;
#IFNOT OfRef
      if(functionCallType==FunctionCallType.Boxed){
        itr.forEachRemaining((Consumer)action);
      }else
#ENDIF
      {
        itr.forEachRemaining(($TypeNameModifier$Consumer)action);
      }
      if(nestedType.forwardIteration){
        if(expectedCursor<expectedBound){
          expectedCursor=expectedBound;
          expectedLastRet=expectedCursor-1;
        }
      }else{
        if(expectedCursor>expectedBound){
          expectedCursor=expectedBound;
          expectedLastRet=expectedCursor;
        }
      }
    }
    AbstractItrMonitor(OmniIterator.Of$ClassPrefix$ itr,int expectedCursor){
      this.itr=itr;
      this.expectedCursor=expectedCursor;
      this.expectedLastRet=-1;
    }
    public void iterateReverse(){
      ((OmniListIterator.Of$ClassPrefix$)itr).previous$TypeNameModifier$();
      expectedLastRet=--expectedCursor;
    }
    public $ClassPrefix$SeqMonitor getSeqMonitor(){
      return $ClassPrefix$ArrSeqMonitor.this;
    }
    public abstract void verifyNext(int expectedVal,$ClassPrefix$OutputTestArgType outputType);
    
    
    public void set(int v,$ClassPrefix$InputTestArgType inputArgType){
       inputArgType.callListItrSet((OmniListIterator.Of$ClassPrefix$)itr,v);
    }
    
   
    public boolean hasNext(){
      return itr.hasNext();
    }
    public boolean hasPrevious(){
      return ((OmniListIterator.Of$ClassPrefix$)itr).hasPrevious();
    }
    public int nextIndex(){
      return ((OmniListIterator.Of$ClassPrefix$)itr).nextIndex();
    }
    public int previousIndex(){
      return ((OmniListIterator.Of$ClassPrefix$)itr).previousIndex();
    }
  }
   class UncheckedArrSeqItrMonitor extends AbstractItrMonitor{
    private UncheckedArrSeqItrMonitor(OmniIterator.Of$ClassPrefix$ itr,int expectedCursor){
      super(itr,expectedCursor);
    }
    @Override public void verifyIteratorState(){
      int actualCursor;
      Object actualParent;
      switch(nestedType){
        case LIST:
          actualCursor=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedList.Itr.cursor(itr);
          actualParent=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedList.Itr.parent(itr);
          break;
        case STACK:
          actualCursor=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedStack.Itr.cursor(itr);
          actualParent=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedStack.Itr.parent(itr);
          break;
        case SUBLIST:
          actualCursor=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.Itr.cursor(itr);
          actualParent=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.Itr.parent(itr);
          break;
        default:
          throw new Error("Unknown nestedType "+nestedType);
      }
      Assertions.assertEquals(expectedCursor+(rootPreAlloc+parentPreAlloc),actualCursor);
      Assertions.assertSame(seq,actualParent);
    }
    @Override public void add(int v,$ClassPrefix$InputTestArgType inputArgType){
      inputArgType.callListItrAdd((OmniListIterator.Of$ClassPrefix$)itr,v);
      ++expectedCursor;
      ++expectedRootModCount;
      ++expectedParentModCount;
      ++expectedSeqModCount;
      ++expectedRootSize;
      ++expectedParentSize;
      ++expectedSeqSize;
      expectedLastRet=-1;
    }
    @Override public void iterateForward(){
      itr.next$TypeNameModifier$();
      expectedLastRet=nestedType==NestedType.STACK
        ?--expectedCursor
        :expectedCursor++;
    }
    @Override public void verifyNext(int expectedVal,$ClassPrefix$OutputTestArgType outputType){
      outputType.verifyItrNext(itr,expectedVal);
      expectedLastRet=nestedType==NestedType.STACK
        ?--expectedCursor
        :expectedCursor++;
    }
    @Override public void verifyPrevious(int expectedVal,$ClassPrefix$OutputTestArgType outputType){
      outputType.verifyItrPrevious(itr,expectedVal);
      expectedLastRet=--expectedCursor;
    }
    @Override public void remove(){
      itr.remove();
      --expectedRootSize;
      ++expectedRootModCount;
      --expectedParentSize;
      ++expectedParentModCount;
      --expectedSeqSize;
      ++expectedSeqModCount;
      expectedCursor=expectedLastRet;
      expectedLastRet=-1;
#IF OfRef
      Assertions.assertNull((($ClassPrefix$ArrSeq)root).arr[rootPreAlloc+parentPreAlloc+expectedRootSize+parentPostAlloc+rootPostAlloc]);
#ENDIF
    }
  }
  class CheckedArrSeqItrMonitor extends UncheckedArrSeqItrMonitor{
    int expectedItrModCount;
    private CheckedArrSeqItrMonitor(OmniIterator.Of$ClassPrefix$ itr,int expectedCursor){
      super(itr,expectedCursor);
      this.expectedItrModCount=expectedRootModCount;
    }
    @Override public void verifyIteratorState(){
      int actualCursor;
      Object actualParent;
      switch(nestedType){
        case LIST:
          actualCursor=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.cursor(itr);
          actualParent=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.parent(itr);
          Assertions.assertEquals(expectedItrModCount,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.modCount(itr));
          Assertions.assertEquals(expectedLastRet<0?expectedLastRet:expectedLastRet+(rootPreAlloc+parentPreAlloc),FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedList.Itr.lastRet(itr));
          break;
        case STACK:
          actualCursor=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.cursor(itr);
          actualParent=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.parent(itr);
          Assertions.assertEquals(expectedItrModCount,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.modCount(itr));
          Assertions.assertEquals(expectedLastRet<0?expectedLastRet:expectedLastRet+(rootPreAlloc+parentPreAlloc),FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedStack.Itr.lastRet(itr));
          break;
        case SUBLIST:
          actualCursor=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.cursor(itr);
          actualParent=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.parent(itr);
          Assertions.assertEquals(expectedItrModCount,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.modCount(itr));
          Assertions.assertEquals(expectedLastRet<0?expectedLastRet:expectedLastRet+(rootPreAlloc+parentPreAlloc),FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.Itr.lastRet(itr));
          break;
        default:
          throw new Error("Unknown nestedType "+nestedType);
      }
      Assertions.assertEquals(expectedCursor+(rootPreAlloc+parentPreAlloc),actualCursor);
      Assertions.assertSame(seq,actualParent);
    }
    @Override public void add(int v,$ClassPrefix$InputTestArgType inputArgType){
      super.add(v,inputArgType);
      ++expectedItrModCount;
    }
    @Override public void remove(){
      super.remove();
      ++expectedItrModCount;
    }
  }
  public UncheckedArrSeqItrMonitor getItrMonitor(){
    var itr=seq.iterator();

    int expectedCursor=nestedType==NestedType.STACK?(($ClassPrefix$ArrSeq)root).size:0;
    return checkedType.checked
      ?new CheckedArrSeqItrMonitor(itr,expectedCursor)
      :new UncheckedArrSeqItrMonitor(itr,expectedCursor);
  }
  public UncheckedArrSeqItrMonitor getListItrMonitor(){
    var itr=((OmniList.Of$ClassPrefix$)seq).listIterator();
    return checkedType.checked
      ?new CheckedArrSeqItrMonitor(itr,0)
      :new UncheckedArrSeqItrMonitor(itr,0);
  }
  public UncheckedArrSeqItrMonitor getListItrMonitor(int index){
    var itr=((OmniList.Of$ClassPrefix$)seq).listIterator(index);
    return checkedType.checked
      ?new CheckedArrSeqItrMonitor(itr,index)
      :new UncheckedArrSeqItrMonitor(itr,index);

  }
  

 
  private static class ArrSeqSequenceVerificationItr extends SequenceVerificationItr{
    final $ArrayType$[] arr;
    int offset;
    final $ClassPrefix$ArrSeqMonitor seqMonitor;
    private ArrSeqSequenceVerificationItr($ClassPrefix$ArrSeqMonitor seqMonitor,int offset,$ArrayType$[] arr){
      this.seqMonitor=seqMonitor;
      this.arr=arr;
      this.offset=offset;
    }
    @Override public SequenceVerificationItr verifyPostAlloc(int expectedVal){
      for(int i=0,bound=seqMonitor.parentPostAlloc+seqMonitor.rootPostAlloc;i<bound;++i){
        verifyIndexAndIterate($ClassPrefix$InputTestArgType.ARRAY_TYPE,expectedVal);
      }
      return this;
    }
    @Override public void verifyLiteralIndexAndIterate($ArrayType$ val){
#IF OfRef
      Assertions.assertSame(val,arr[offset++]);
#ELSE
      Assertions.assertEquals(val,arr[offset++]);
#ENDIF
      
    }
#IF OfRef
    @Override public void verifyIndexAndIterate(MonitoredObject monitoredObject){
      Object v;
      if((v=arr[offset++]) instanceof MonitoredObject){
        Assertions.assertEquals(monitoredObject.compareVal,((MonitoredObject)v).compareVal);
      }else{
        Assertions.assertEquals(monitoredObject.compareVal,(Object)v);
      }
    }

#ENDIF
    @Override public void verifyIndexAndIterate($ClassPrefix$InputTestArgType inputArgType,int val){
      inputArgType.verifyVal(val,arr[offset++]);
    }
    @Override public SequenceVerificationItr getPositiveOffset(int i){
      if(i<0){
        throw new Error("offset cannot be negative: "+i);
      }
      return new ArrSeqSequenceVerificationItr(seqMonitor,i+offset,arr);
    }
    @Override public SequenceVerificationItr skip(int i){
      if(i<0){
        throw new Error("offset cannot be negative: "+i);
      }
      this.offset+=i;
      return this;
    }
    @Override public boolean equals(Object val){
      final ArrSeqSequenceVerificationItr that;
      return val==this || (val instanceof ArrSeqSequenceVerificationItr && (that=(ArrSeqSequenceVerificationItr)val).arr==this.arr && that.offset==this.offset);
    }
    @Override public SequenceVerificationItr verifyRootPostAlloc(){
      for(int i=0,v=Integer.MAX_VALUE-seqMonitor.rootPostAlloc;i<seqMonitor.rootPostAlloc;++i,++v){
        verifyIndexAndIterate($ClassPrefix$InputTestArgType.ARRAY_TYPE,v);
      }
      return this;
    }
    @Override public SequenceVerificationItr verifyParentPostAlloc(){
      for(int i=0,v=Integer.MAX_VALUE-seqMonitor.rootPostAlloc-seqMonitor.parentPostAlloc;i<seqMonitor.parentPostAlloc;++i,++v){
        verifyIndexAndIterate($ClassPrefix$InputTestArgType.ARRAY_TYPE,v);
      }
      return this;
    }
  }
  public int getExpectedSeqSize(){
    return this.expectedSeqSize;
  }
  
  public SequenceVerificationItr verifyPreAlloc(int expectedVal){
      var arr=(($ClassPrefix$ArrSeq)root).arr;
      int offset=0;
      for(int bound=offset+rootPreAlloc+parentPreAlloc;offset<bound;++offset){
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.verifyVal(expectedVal,arr[offset]);
      }
      return new ArrSeqSequenceVerificationItr(this,offset,arr);
  }
  public SequenceVerificationItr verifyPreAlloc(){
    var arr=(($ClassPrefix$ArrSeq)root).arr;
    int offset=0;
    for(int bound=offset+rootPreAlloc+parentPreAlloc,v=Integer.MIN_VALUE;offset<bound;++offset,++v){
      $ClassPrefix$InputTestArgType.ARRAY_TYPE.verifyVal(v,arr[offset]);
    }
    return new ArrSeqSequenceVerificationItr(this,offset,arr);
  }
  public void illegalAdd(PreModScenario preModScenario){
    switch(preModScenario){
      case ModSeq:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(seq,0);
        ++expectedRootModCount;
        ++expectedRootSize;
        ++expectedParentModCount;
        ++expectedParentSize;
        ++expectedSeqModCount;
        ++expectedSeqSize;
        break;
      case ModParent:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(parent,0);
        ++expectedRootModCount;
        ++expectedRootSize;
        ++expectedParentModCount;
        ++expectedParentSize;
        break;
      case ModRoot:
        $ClassPrefix$InputTestArgType.ARRAY_TYPE.callCollectionAdd(root,0);
        ++expectedRootModCount;
        ++expectedRootSize;
        break;
      case NoMod:
        break;
      default:
        throw new Error("Unknown preModScenario "+preModScenario);
    }
  }
#IF OfRef
  public boolean add(Object obj)
  {
    boolean ret=seq.add(obj);
    if(ret)
    {
      ++expectedSeqSize;
      ++expectedParentSize;
      ++expectedRootSize;
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
    }
    return ret;
  }
#ENDIF
  
  public void add(int index,int val,$ClassPrefix$InputTestArgType inputArgType){
    inputArgType.callListAdd(seq,index,val);
    ++expectedRootSize;
    ++expectedParentSize;
    ++expectedSeqSize;
    ++expectedRootModCount;
    ++expectedParentModCount;
    ++expectedSeqModCount;
  }
  
  public boolean add(int val,$ClassPrefix$InputTestArgType inputArgType){
    boolean ret=inputArgType.callCollectionAdd(seq,val);
    if(ret){
      ++expectedRootSize;
      ++expectedParentSize;
      ++expectedSeqSize;
      ++expectedRootModCount;
      ++expectedParentModCount;
      ++expectedSeqModCount;
    }
    return ret;
  }
  
  public void push(int val,$ClassPrefix$InputTestArgType inputArgType){
    inputArgType.callStackPush(seq,val);
    ++expectedRootSize;
    ++expectedParentSize;
    ++expectedSeqSize;
    ++expectedRootModCount;
    ++expectedParentModCount;
    ++expectedSeqModCount;
  }
  
  public void put(int index,int val,$ClassPrefix$InputTestArgType inputArgType){
    inputArgType.callListPut(seq,index,val);
  }
  public String toString(){
    StringBuilder builder=new StringBuilder();

    builder.append("$ClassPrefix$ArrSeq.").append(checkedType.checked?"Checked":"Unchecked");
    switch(nestedType){
      case STACK:
        builder.append("Stack{").append(initialCapacity);
        break;
      case LIST:
        builder.append("List{").append(initialCapacity);
        break;
      case SUBLIST:
        builder.append("SubList{").append(rootPreAlloc).append(',').append(parentPreAlloc).append(',').append(parentPostAlloc).append(',').append(rootPostAlloc);
        break;
      default:
        throw new Error("Unknown nestedType "+nestedType);
    }
    return builder.append('}').toString();
  }
  public void verifyStructuralIntegrity(){

      switch(nestedType){
        case STACK:
          if(checkedType.checked){
            Assertions.assertEquals(expectedRootModCount,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedStack.modCount(root));
          }
          break;
        case LIST:
          if(checkedType.checked){
            Assertions.assertEquals(expectedRootModCount,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(root));
          }
          break;
        case SUBLIST:
          OmniList.Of$ClassPrefix$ actualSeqParent;
          $ClassPrefix$ArrSeq actualSeqRoot;
          int actualSeqSize;
          OmniList.Of$ClassPrefix$ actualParentParent;
          $ClassPrefix$ArrSeq  actualParentRoot;
          int actualParentSize;
          if(checkedType.checked){
            actualSeqParent=(OmniList.Of$ClassPrefix$)FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.parent(seq);
            actualSeqRoot=($ClassPrefix$ArrSeq)FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.root(seq);
            actualSeqSize=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.size(seq);
            actualParentParent=(OmniList.Of$ClassPrefix$)FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.parent(parent);
            actualParentRoot=($ClassPrefix$ArrSeq)FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.root(parent);
            actualParentSize=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.size(parent);
            Assertions.assertEquals(expectedSeqModCount,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.modCount(seq));
            Assertions.assertEquals(expectedParentModCount,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.modCount(parent));
            Assertions.assertEquals(expectedRootModCount,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedList.modCount(root));
          }else{
            actualSeqParent=(OmniList.Of$ClassPrefix$)FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.parent(seq);
            actualSeqRoot=($ClassPrefix$ArrSeq)FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.root(seq);
            actualSeqSize=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.size(seq);
            actualParentParent=(OmniList.Of$ClassPrefix$)FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.parent(parent);
            actualParentRoot=($ClassPrefix$ArrSeq)FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.root(parent);
            actualParentSize=FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.size(parent);
          }
          Assertions.assertSame(root,actualSeqRoot);
          Assertions.assertSame(root,actualParentRoot);
          Assertions.assertSame(parent,actualSeqParent);
          Assertions.assertNull(actualParentParent);
          Assertions.assertEquals(expectedSeqSize,actualSeqSize);
          Assertions.assertEquals(expectedParentSize+parentPreAlloc+parentPostAlloc,actualParentSize);
          break;
        default:
          throw new Error("Unknown nestedType "+nestedType);
      }
      Assertions.assertEquals(expectedRootSize+parentPreAlloc+parentPostAlloc+rootPreAlloc+rootPostAlloc,FieldAndMethodAccessor.$ClassPrefix$ArrSeq.size(root));
  }
  public boolean isEmpty(){
    return seq.isEmpty();
  }
  public void forEach(MonitoredConsumer action,FunctionCallType functionCallType){
#IFNOT OfRef
    if(functionCallType==FunctionCallType.Boxed){
      seq.forEach((Consumer)action);
    }else
#ENDIF
    {
      seq.forEach(($TypeNameModifier$Consumer)action);
    }
  }
#IFNOT OfBoolean
  public void unstableSort(MonitoredComparator sorter){
    int seqSize=expectedSeqSize;
    ((OmniList.Of$ClassPrefix$)seq).unstableSort(($Comparator$)sorter);
    if(seqSize>1){
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
    }
  }
#ENDIF
  public void replaceAll(MonitoredUnaryOperator operator,FunctionCallType functionCallType){
    int seqSize=expectedSeqSize;
  #IFNOT OfRef
    if(functionCallType==FunctionCallType.Boxed){
      ((OmniList.Of$ClassPrefix$)seq).replaceAll((UnaryOperator)operator);
    }else
  #ENDIF
    {
      ((OmniList.Of$ClassPrefix$)seq).replaceAll(($UnaryOperator$)operator);
    }
    if(seqSize!=0){
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
    }
  }

  public void sort(MonitoredComparator sorter,FunctionCallType functionCallType){
    int seqSize=expectedSeqSize;
  #IFNOT OfRef
    if(functionCallType==FunctionCallType.Boxed){
      ((OmniList.Of$ClassPrefix$)seq).sort((Comparator)sorter);
    }else
  #ENDIF
    {
      ((OmniList.Of$ClassPrefix$)seq).sort(($Comparator$)sorter);
    }
    if(seqSize>1){
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
    }
  }
  public void stableAscendingSort(){
    int seqSize=expectedSeqSize;
    ((OmniList.Of$ClassPrefix$)seq).stableAscendingSort();
    if(seqSize>1){
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
    }
  }
  public void stableDescendingSort(){
    int seqSize=expectedSeqSize;
    ((OmniList.Of$ClassPrefix$)seq).stableDescendingSort();
    if(seqSize>1){
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
    }
  }
#IF OfRef
  public void unstableAscendingSort(){
    int seqSize=expectedSeqSize;
    ((OmniList.Of$ClassPrefix$)seq).unstableAscendingSort();
    if(seqSize>1){
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
    }
  }
  public void unstableDescendingSort(){
    int seqSize=expectedSeqSize;
    ((OmniList.Of$ClassPrefix$)seq).unstableDescendingSort();
    if(seqSize>1){
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
    }
  }
#ENDIF
  public void removeAt(int expectedVal,$ClassPrefix$OutputTestArgType outputType,int index){
    outputType.verifyListRemoveAt(seq,index,expectedVal);
    --expectedSeqSize;
    --expectedParentSize;
    --expectedRootSize;
    ++expectedSeqModCount;
    ++expectedParentModCount;
    ++expectedRootModCount;
#IF OfRef
    Assertions.assertNull((($ClassPrefix$ArrSeq)root).arr[rootPreAlloc+parentPreAlloc+expectedRootSize+parentPostAlloc+rootPostAlloc]);
#ENDIF
  }
  public void get(int expectedVal,$ClassPrefix$OutputTestArgType outputType,int index){
    outputType.verifyListGet(seq,index,expectedVal);
  }
  public void clear(){
    int seqSize=expectedSeqSize;
    seq.clear();
    if(seqSize!=0){
      expectedSeqSize=0;
      expectedParentSize=0;
      expectedRootSize=0;
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
#IF OfRef
      int newBound=rootPreAlloc+parentPreAlloc+parentPostAlloc+rootPostAlloc;
      int oldBound=newBound+seqSize;
      verifyRangeIsNull((($ClassPrefix$ArrSeq)root).arr,newBound,oldBound);
#ENDIF
    }
  }
  public void pop(int expectedVal,$ClassPrefix$OutputTestArgType outputType){
    outputType.verifyStackPop(seq,expectedVal);
    --expectedSeqSize;
    --expectedParentSize;
    --expectedRootSize;
    ++expectedSeqModCount;
    ++expectedParentModCount;
    ++expectedRootModCount;
#IF OfRef
    Assertions.assertNull((($ClassPrefix$ArrSeq)root).arr[rootPreAlloc+parentPreAlloc+expectedRootSize+parentPostAlloc+rootPostAlloc]);
#ENDIF
  }
  public void poll(int expectedVal,$ClassPrefix$OutputTestArgType outputType){
    outputType.verifyStackPoll(seq,expectedSeqSize,expectedVal);
    if(expectedSeqSize!=0){
      --expectedSeqSize;
      --expectedParentSize;
      --expectedRootSize;
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
  #IF OfRef
      Assertions.assertNull((($ClassPrefix$ArrSeq)root).arr[rootPreAlloc+parentPreAlloc+expectedRootSize+parentPostAlloc+rootPostAlloc]);
  #ENDIF
    }

  }
  
  public void verifySet(int index,int val,int expectedRet,FunctionCallType functionCallType){
  #IFNOT OfRef
    if(functionCallType==FunctionCallType.Boxed)
    {
      Assertions.assertEquals(TypeConversionUtil.convertTo$BoxedType$(expectedRet),((OmniList.Of$ClassPrefix$)seq).set(index,TypeConversionUtil.convertTo$BoxedType$(val)));
    }
    else
  #ENDIF
    {
      Assertions.assertEquals(TypeConversionUtil.convertTo$ArrayType$(expectedRet),((OmniList.Of$ClassPrefix$)seq).set(index,TypeConversionUtil.convertTo$ArrayType$(val)));
    }
  }
  
  public void verifyRemoveIf(MonitoredRemoveIfPredicate pred,FunctionCallType functionCallType,int expectedNumRemoved,OmniCollection.Of$ClassPrefix$ clone){
#IF OfRef,OfBoolean
    int seqSize=expectedSeqSize;
#ENDIF

    boolean retVal;
#IFNOT OfRef
    if(functionCallType==FunctionCallType.Boxed)
    {
      retVal=seq.removeIf((Predicate)pred);
    }
    else
#ENDIF
    {
      retVal=seq.removeIf(($TypeNameModifier$Predicate)pred);
    }
    if(retVal)
    {
      ++expectedSeqModCount;
      ++expectedParentModCount;
      ++expectedRootModCount;
      int numRemoved;
#IF OfBoolean
      int numTrue=0,numFalse=0;
      var cloneItr=clone.iterator();
      while(cloneItr.hasNext()){
        if(cloneItr.next$TypeNameModifier$()){
          ++numTrue;
        }else{
          ++numFalse;
        }
      }
      if(pred.removedVals.contains(true))
      {
        if(pred.removedVals.contains(false))
        {
          numRemoved=seqSize;
          Assertions.assertTrue(seq.isEmpty());
        }
        else
        {
          numRemoved=numTrue;
          Assertions.assertFalse(seq.contains(true));
        }
      }
      else
      {
        numRemoved=numFalse;
        Assertions.assertFalse(seq.contains(false));
      }
#ELSE
      numRemoved=pred.numRemoved;
  #IF OfRef
      verifyRangeIsNull((($ClassPrefix$ArrSeq)root).arr,(seqSize-numRemoved)+rootPreAlloc+parentPreAlloc+parentPostAlloc+rootPostAlloc,seqSize+rootPreAlloc+parentPreAlloc+parentPostAlloc+rootPostAlloc);
  #ENDIF
      for(var removedVal:pred.removedVals)
      {
        Assertions.assertFalse(seq.contains(removedVal));
      }
#ENDIF
      expectedSeqSize-=numRemoved;
      expectedParentSize-=numRemoved;
      expectedRootSize-=numRemoved;
      if(expectedNumRemoved!=-1){
        Assertions.assertEquals(expectedNumRemoved,numRemoved);
      }
    }else{
      Assertions.assertEquals(expectedSeqSize,clone.size());
      var seqItr=seq.iterator();
      var cloneItr=clone.iterator();
      for(int i=0;i<expectedSeqSize;++i){
#IF OfRef
        Assertions.assertSame(seqItr.next(),cloneItr.next());
#ELSE
        Assertions.assertEquals(seqItr.next$TypeNameModifier$(),cloneItr.next$TypeNameModifier$());
#ENDIF
      }
    }
    verifyStructuralIntegrity();
  }
  
  public void writeObject(ObjectOutputStream oos) throws IOException
  {

    switch(nestedType)
    {
      case LIST:
        if(checkedType.checked)
        {
          FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedList.writeObject(seq,oos);
        }
        else
        {
          FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedList.writeObject(seq,oos);
        }
        break;
      case STACK:
        if(checkedType.checked)
        {
          FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedStack.writeObject(seq,oos);
        }
        else
        {
          FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedStack.writeObject(seq,oos);
        }
        break;
      case SUBLIST:
        if(checkedType.checked)
        {
          FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.writeObject(seq,oos);
        }
        else
        {
          FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.writeObject(seq,oos);
        }
        break;
      default:
        throw new Error("unknown nested type "+nestedType);
    }

  }
  
  public Object readObject(ObjectInputStream ois) throws IOException,ClassNotFoundException
  {
    switch(nestedType)
    {
      case LIST:
        if(checkedType.checked)
        {
          
          return FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedList.readObject(seq,ois);
        }
        else
        {
          return FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedList.readObject(seq,ois);
        }
      case STACK:
        if(checkedType.checked)
        {
          return FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedStack.readObject(seq,ois);
        }
        else
        {
          return FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedStack.readObject(seq,ois);
        }
      case SUBLIST:
        if(checkedType.checked)
        {
          return FieldAndMethodAccessor.$ClassPrefix$ArrSeq.CheckedSubList.readObject(seq,ois);
        }
        else
        {
          return FieldAndMethodAccessor.$ClassPrefix$ArrSeq.UncheckedSubList.readObject(seq,ois);
        }
      default:
        throw new Error("unknown nested type "+nestedType);
    }
  }
}