#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;

#IF OfDouble,OfFloat
import omni.util.HashUtil;
#ENDIF
import omni.util.OmniArray;

import omni.util.ArrCopy;

import omni.impl.CheckedCollection;
import java.util.NoSuchElementException;
import omni.api.OmniIterator;
import java.util.function.IntFunction;
#IFNOT OfRef
import omni.util.TypeUtil;
#ENDIF
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Predicate;
import java.util.function.$TypeNameModifier$Consumer;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Predicate;
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
#IFNOT OfDouble,OfChar,OfRef
import omni.util.ToStringUtil;
#ENDIF
#IFNOT OfRef,OfBoolean
import omni.impl.Abstract$TypeNameModifier$Itr;
#ENDIF
import java.util.ConcurrentModificationException;
#IF OfRef
import omni.util.OmniPred;
import java.util.Objects;
#ENDIF

import java.io.IOException;
import java.io.ObjectOutput;
import java.io.ObjectInput;
#IF OfBoolean
public class $ClassPrefix$ArrDeq$<E>$ extends AbstractBooleanArrDeq{
#ELSE
import omni.api.OmniDeque;
import java.util.function.Predicate;
import java.util.function.Consumer;
import java.io.Externalizable;
import java.util.RandomAccess;
public class $ClassPrefix$ArrDeq$<E>$ implements OmniDeque.Of$ClassPrefix$$<E>$,Externalizable,Cloneable,RandomAccess{
#ENDIF
  private static final long serialVersionUID=1L;
  transient $ArrayType$[] arr;
#IFNOT OfBoolean
  transient int head;
  transient int tail;
#ENDIF 

  public $ClassPrefix$ArrDeq(){
    super();
    this.arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
#IFNOT OfBoolean
    this.tail=-1;
#ENDIF
  }
  public $ClassPrefix$ArrDeq(int initialCapacity){
    super();
    switch(initialCapacity){ 
    default:
      this.arr=new $ArrayType$[initialCapacity];
      break;
    case OmniArray.DEFAULT_ARR_SEQ_CAP:
      this.arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
    case 0:
    }
#IFNOT OfBoolean
    this.tail=-1;
#ENDIF
  }
  $ClassPrefix$ArrDeq(int head,$ArrayType$[] arr,int tail){
#IF OfBoolean
    super(head,tail);
#ELSE
    super();
    this.head=head;
    this.tail=tail;
#ENDIF  
    this.arr=arr;
  }
  @Override public int size(){
    int tail;
    if((tail=this.tail+1)!=0){
      if((tail-=this.head)<=0){
        tail+=arr.length;
      }
    }
    return tail;
  }
#IFNOT OfBoolean
  @Override public boolean isEmpty(){
    return this.tail==-1;
  }
  @Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
    final int tail;
    if((tail=this.tail)!=-1){
      uncheckedForEach(tail,action);
    }
  }
  @Override public boolean removeIf($TypeNameModifier$Predicate$<? super E>$ filter){
    final int tail;
    if((tail=this.tail)!=-1){
      final int head;
      if(tail<(head=this.head)){
        return fragmentedRemoveIf(head,tail,filter);
      }
      return nonfragmentedRemoveIf(head,tail,filter);
    }
    return false;
  }
  @Override public void clear(){
  #IF OfRef
    int tail;
    if((tail=this.tail)!=-1){
      final var arr=this.arr;
      final int head;
      if(tail<(head=this.head)){
        OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,0);
        tail=arr.length-1;
      }
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head);
      this.tail=-1;
    }
  #ELSE
    this.tail=-1;
  #ENDIF
  }
#ENDIF
  void uncheckedForEach(final int tail,$TypeNameModifier$Consumer$<? super E>$ action){
    final var arr=this.arr;
    int head;
    if(tail<(head=this.head)){
      OmniArray.Of$ClassPrefix$.ascendingForEach(arr,head,arr.length-1,action);
      head=0;
    }
    OmniArray.Of$ClassPrefix$.ascendingForEach(arr,head,tail,action);
  }
#IFNOT OfBoolean
  @Override public boolean add($exposedType$ val){
    addLast(val);
    return true;
  }
  #IF OfInt,OfLong
  @Override public boolean add(char val){
    addLast(($exposedType$)val);
    return true;
  }
  #ENDIF
  #IF OfInt,OfLong,OfShort
  @Override public boolean add(byte val){
    addLast(($exposedType$)val);
    return true;
  }
  #ENDIF
  @Override public void addFirst($exposedType$ val){
    push(val);
  }
  @Override public boolean offerFirst($exposedType$ val){
    push(val);
    return true;
  }
  @Override public boolean offerLast($exposedType$ val){
    addLast(val);
    return true;
  }
#ENDIF
  #MACRO SuppressUnchecked()
  @Override public $exposedType$ $elementMethod$(){
    return ($exposedType$)arr[head];
  }
  #MACRO SuppressUnchecked()
  @Override public $exposedType$ getLast$TypeNameModifier$(){
    return ($exposedType$)arr[tail];
  }
#IFNOT OfBoolean
  @Override public boolean offer($exposedType$ val){
    addLast(val);
    return true;
  }

  #MACRO QueryMethods<contains>()
  #MACRO QueryMethods<removeVal>()
  #MACRO QueryMethods<removeLastOccurrence>()
  #MACRO QueryMethods<search>()
#ENDIF
  #MACRO OutputMethods<false>(ToArrayImpl)
  #MACRO OutputMethods<false>(PeekImpl)
  #MACRO OutputMethods<false>(PollImpl)
  @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
    int tail;
    if((tail=this.tail)!=-1){
      final var arr=this.arr;
      final T[] dst;
      int size,head;
      if((size=(++tail)-(head=this.head))<=0){
        ArrCopy.uncheckedCopy(arr,0,dst=arrConstructor.apply(size+=arr.length),size-=tail,tail);
      }else{
        dst=arrConstructor.apply(size);
      }
      ArrCopy.uncheckedCopy(arr,head,dst,0,size);
      return dst;
    }
    return arrConstructor.apply(0);
  }
  @Override public <T> T[] toArray(T[] dst){
    int tail;
    if((tail=this.tail)!=-1){
      int size,head;
      if((size=(++tail)-(head=this.head))<=0){
        ArrCopy.uncheckedCopy(arr,0,dst=OmniArray.uncheckedArrResize(size+=arr.length,dst),size-=tail,tail);
      }else{
        dst=OmniArray.uncheckedArrResize(size,dst);
      }
      ArrCopy.uncheckedCopy(arr,head,dst,0,size);
    }else if(dst.length!=0){
      dst[0]=null;
    }
    return dst;
  }
#IF OfByte,OfChar,OfDouble,OfFloat,OfInt,OfLong,OfShort
  @Override public boolean add(boolean val){
    addLast(($exposedType$)$queryCastBoolean$(val));
    return true;
  }
  #IF OfDouble,OfFloat,OfLong
  @Override public boolean add(int val){
    addLast(($exposedType$)val);
    return true;
  }
    #IF OfDouble,OfFloat
  
  @Override public boolean add(long val){
    addLast(($exposedType$)val);
    return true;
  }
      #IF OfDouble
  @Override public boolean add(float val){
    addLast(($exposedType$)val);
    return true;
  }
      #ELSE
  @Override public boolean add(char val){
    addLast(($exposedType$)val);
    return true;
  }
  @Override public boolean add(short val){
    addLast(($exposedType$)val);
    return true;
  }    
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#IFNOT OfBoolean
  @Override public $BoxedType$ getFirst(){
    return $elementMethod$();
  }
  @Override public $BoxedType$ peekFirst(){
    return peek();
  }
  @Override public $BoxedType$ pollFirst(){
    return poll();
  }
  @Override public $BoxedType$ removeFirst(){
    return pop$TypeNameModifier$();
  }
  @Override public $BoxedType$ remove(){
    return pop$TypeNameModifier$();
  }
  @Override public boolean removeFirstOccurrence(Object val){
    return remove(val);
  }
#ENDIF
#IF OfRef
  #MACRO UncheckedRemoveVal<false,NonNull>(nonNull.equals)
  #MACRO UncheckedRemoveVal<false,Null>(null==)
  #MACRO UncheckedRemoveVal<false,>(pred.test)
  #MACRO UncheckedRemoveLastOccurrence<false,NonNull>(nonNull.equals)
  #MACRO UncheckedRemoveLastOccurrence<false,Null>(null==)
  #MACRO UncheckedRemoveLastOccurrence<false,>(pred.test)
  #MACRO UncheckedContains<NonNull>(\,nonNull)
  #MACRO UncheckedContains<Null>( )
  #MACRO UncheckedContains< >(\,pred)
  #MACRO UncheckedSearch<NonNull>(nonNull.equals)
  #MACRO UncheckedSearch<Null>(null==)
  #MACRO UncheckedSearch< >(pred.test)
#ELSE
  #IFNOT OfBoolean
  @Override public $BoxedType$ pop(){
    return pop$TypeNameModifier$();
  }
  @Override public $BoxedType$ removeLast(){
    return removeLast$TypeNameModifier$();
  }
  @Override public void push($BoxedType$ val){
    push(($exposedType$)val);
  }
  @Override public boolean offer($BoxedType$ val){
    addLast(($exposedType$)val);
    return true;
  }
  @Override public $BoxedType$ element(){
    return $elementMethod$();
  }
  @Override public $BoxedType$ getLast(){
    return getLast$TypeNameModifier$();
  }
  @Override public void addFirst($BoxedType$ val){
    push(($exposedType$)val);
  }
  @Override public void addLast($BoxedType$ val){
    addLast(($exposedType$)val);
  }
  @Override public boolean add($BoxedType$ val){
    addLast(($exposedType$)val);
    return true;
  }
  @Override public boolean offerFirst($BoxedType$ val){
    push(($exposedType$)val);
    return true;
  }
  @Override public boolean offerLast($BoxedType$ val){
    addLast(($exposedType$)val);
    return true;
  }
  #ENDIF
  #IF OfFloat,OfDouble
  #MACRO UncheckedRemoveVal<false,Bits>(bits==$convertToBits$)
  #MACRO UncheckedRemoveVal<false,0>(0==)
  #MACRO UncheckedRemoveVal<false,NaN>($BoxedType$.isNaN)
  #MACRO UncheckedRemoveLastOccurrence<false,Bits>(bits==$convertToBits$)
  #MACRO UncheckedRemoveLastOccurrence<false,0>(0==)
  #MACRO UncheckedRemoveLastOccurrence<false,NaN>($BoxedType$.isNaN)
  #MACRO UncheckedContains<Bits>(\,bits)
  #MACRO UncheckedContains<0>( )
  #MACRO UncheckedContains<NaN>( )
  #MACRO UncheckedSearch<Bits>(bits==$convertToBits$)
  #MACRO UncheckedSearch<0>(0==)
  #MACRO UncheckedSearch<NaN>($BoxedType$.isNaN)
  #ELSE
  #MACRO UncheckedRemoveVal<false,>(val==)
  #MACRO UncheckedRemoveLastOccurrence<false,>(val==)
  #MACRO UncheckedContains< >(\,val)
  #MACRO UncheckedSearch< >(val==)
  #ENDIF
  #IFNOT OfBoolean
  @Override public void forEach(Consumer<? super $BoxedType$> action){
    final int tail;
    if((tail=this.tail)!=-1){
      uncheckedForEach(tail,action::accept);
    }
  }
  @Override public boolean removeIf(Predicate<? super $BoxedType$> filter){
    final int tail;
    if((tail=this.tail)!=-1){
      final int head;
      if(tail<(head=this.head)){
        return fragmentedRemoveIf(head,tail,filter::test);
      }
      return nonfragmentedRemoveIf(head,tail,filter::test);
    }
    return false;
  }
  #ENDIF
#ENDIF
#IFNOT OfBoolean
  @Override public String toString(){
    final int tail;
    if((tail=this.tail)!=-1){
      return uncheckedToString(tail);
    }
    return "[]";
  }
  @Override public int hashCode(){
    final int tail;
    if((tail=this.tail)!=-1){
      return uncheckedHashCode(tail);
    }
    return 1;
  }
#ENDIF
  #MACRO SuppressUnchecked()
  @Override public $exposedType$ pop$TypeNameModifier$(){
    final $ArrayType$[] arr;
    int head;
    var ret=($exposedType$)((arr=this.arr)[head=this.head]);
#IF OfRef
    arr[head]=null;
#ENDIF
    if(head==this.tail){
      this.tail=-1;
      return ret;
    }else if(++head==arr.length){
      head=0;
    }
    this.head=head;
    return ret;
  }
  #MACRO SuppressUnchecked()
  @Override public $exposedType$ removeLast$TypeNameModifier$(){
    final $ArrayType$[] arr;
    int tail;
    var ret=($exposedType$)((arr=this.arr)[tail=this.tail]);
#IF OfRef
    arr[tail]=null;
#ENDIF
    if(this.head==tail){
      tail=-1;
    }else if(--tail==-1){
      tail=arr.length-1;
    }
    this.tail=tail;
    return ret;
  }
  @Override public Object clone(){
    int tail;
    if((tail=this.tail)!=-1){
      final var arr=this.arr;
      final $ArrayType$[] dst;
      int size,head;
      $ClassPrefix$ArrDeq$<E>$ clone;
      if((size=(++tail)-(head=this.head))<=0){
        clone=new $ClassPrefix$ArrDeq$<E>$(0,dst=new $ArrayType$[size+=arr.length],size-1);
        ArrCopy.uncheckedCopy(arr,0,dst,size-=tail,tail);
      }else{
        clone=new $ClassPrefix$ArrDeq$<E>$(0,dst=new $ArrayType$[size],size-1);
      }
      ArrCopy.uncheckedCopy(arr,head,dst,0,size);
      return clone;
    }
    return new $ClassPrefix$ArrDeq$<E>$();
  }
#IFNOT OfBoolean
  private
#ENDIF
  String uncheckedToString(int tail){
    final var arr=this.arr;
#IF OfDouble,OfRef
    final var builder=new StringBuilder("[");
    int head;
    if(tail<(head=this.head)){
      for(int bound=arr.length;;){
        builder.append(arr[head]).append(',').append(' ');
        if(++head==bound){
          head=0;
          break;
        }
      }
    }
    for(;;builder.append(',').append(' '),++head){
      builder.append(arr[head]);
      if(head==tail){
        return builder.append(']').toString();
      }
    }
#ELSEIF OfChar
    final char[] buffer;
    int size,head,bufferOffset=1;
    if((size=(++tail)-(head=this.head))<=0){
      for(buffer=new char[size+(size=arr.length)*3];;++bufferOffset){
        buffer[bufferOffset]=arr[head];
        buffer[++bufferOffset]=',';
        buffer[++bufferOffset]=' ';
        if(++head==size){
          ++bufferOffset;
          head=0;
          break;
        }
      }
    }else{
      buffer=new char[size*3];
    }
    for(;;buffer[++bufferOffset]=',',buffer[++bufferOffset]=' ',++bufferOffset){
      buffer[bufferOffset]=arr[head];
      if(++head==tail){
        buffer[0]='[';
        buffer[++bufferOffset]=']';
        return new String(buffer,0,bufferOffset+1);
      }
    }
#ELSE
    final byte[] buffer;
    int size,head,bufferOffset=1;
    if((size=(++tail)-(head=this.head))<=0){
      int bound;
  #IF OfBoolean
      if((size+=(bound=arr.length))<=(OmniArray.MAX_ARR_SIZE/7)){(buffer=new byte[size*7])
  #ELSEIF OfByte
      if((size+=(bound=arr.length))<=(OmniArray.MAX_ARR_SIZE/6)){(buffer=new byte[size*6])
  #ELSEIF OfShort
      if((size+=(bound=arr.length))<=(OmniArray.MAX_ARR_SIZE>>3)){(buffer=new byte[size<<3])
  #ELSEIF OfInt
      if((size+=(bound=arr.length))<=(OmniArray.MAX_ARR_SIZE/13)){(buffer=new byte[size*13])
  #ELSEIF OfLong
      if((size+=(bound=arr.length))<=(OmniArray.MAX_ARR_SIZE/22)){(buffer=new byte[size*22])
  #ELSEIF OfFloat
      if((size+=(bound=arr.length))<=(OmniArray.MAX_ARR_SIZE/17)){(buffer=new byte[size*17])
  #ENDIF
        [0]=(byte)'[';
        for(;;++bufferOffset){
  #IF OfByte
          buffer[bufferOffset=ToStringUtil.getStringShort(arr[head],buffer,bufferOffset)]=(byte)',';
  #ELSE
          buffer[bufferOffset=ToStringUtil.getString$ClassPrefix$(arr[head],buffer,bufferOffset)]=(byte)',';
  #ENDIF
          buffer[++bufferOffset]=(byte)' ';
          if(++head==bound){
            for(head=0;;buffer[bufferOffset]=(byte)',',buffer[++bufferOffset]=(byte)' '){
  #IF OfByte
              bufferOffset=ToStringUtil.getStringShort(arr[head],buffer,++bufferOffset);
  #ELSE
              bufferOffset=ToStringUtil.getString$ClassPrefix$(arr[head],buffer,++bufferOffset);
  #ENDIF
              if(++head==tail){
                buffer[bufferOffset]=(byte)']';
                return new String(buffer,0,bufferOffset+1,ToStringUtil.IOS8859CharSet);
              }
            }
          }
        }
      }else{
        final ToStringUtil.OmniStringBuilderByte builder=new ToStringUtil.OmniStringBuilderByte(1,new byte[OmniArray.MAX_ARR_SIZE]);
        for(;;){
  #IF OfByte
          builder.uncheckedAppendShort(arr[head]);
  #ELSE
          builder.uncheckedAppend$ClassPrefix$(arr[head]);
  #ENDIF
          builder.uncheckedAppendCommaAndSpace();
          if(++head==bound){
            for(head=0;;builder.uncheckedAppendCommaAndSpace()){
  #IF OfByte
              builder.uncheckedAppendShort(arr[head]);
  #ELSE
              builder.uncheckedAppend$ClassPrefix$(arr[head]);
  #ENDIF
              if(++head==tail){
                builder.uncheckedAppendChar((byte)']');
                (buffer=builder.buffer)[0]=(byte)'[';
                return new String(buffer,0,builder.size,ToStringUtil.IOS8859CharSet);
              }
            }
          }
        }
      }
    }else{
  #IF OfBoolean
      if(size<=(OmniArray.MAX_ARR_SIZE/7)){(buffer=new byte[size*7])
  #ELSEIF OfByte
      if(size<=(OmniArray.MAX_ARR_SIZE/6)){(buffer=new byte[size*6])
  #ELSEIF OfShort
      if(size<=(OmniArray.MAX_ARR_SIZE>>3)){(buffer=new byte[size<<3])
  #ELSEIF OfInt
      if(size<=(OmniArray.MAX_ARR_SIZE/13)){(buffer=new byte[size*13])
  #ELSEIF OfLong
      if(size<=(OmniArray.MAX_ARR_SIZE/22)){(buffer=new byte[size*22])
  #ELSEIF OfFloat
      if(size<=(OmniArray.MAX_ARR_SIZE/17)){(buffer=new byte[size*17])
  #ENDIF
        [size=OmniArray.Of$ClassPrefix$.ascendingToString(arr,head,tail-1,buffer,1)]=(byte)']';
        buffer[0]=(byte)'[';
        return new String(buffer,0,size+1,ToStringUtil.IOS8859CharSet);
      }else{
        final ToStringUtil.OmniStringBuilderByte builder;
        OmniArray.Of$ClassPrefix$.ascendingToString(arr,head,tail-1,builder=new ToStringUtil.OmniStringBuilderByte(1,new byte[OmniArray.MAX_ARR_SIZE]));
        builder.uncheckedAppendChar((byte)']');
        (buffer=builder.buffer)[0]=(byte)'[';
        return new String(buffer,0,builder.size,ToStringUtil.IOS8859CharSet);
      }
    }
#ENDIF
  }
#IFNOT OfBoolean
  private
#ENDIF
  int uncheckedHashCode(int tail){
    final $ArrayType$[] arr;
    int head;
    int hash=31+$hashCodeMethod$((arr=this.arr)[head=this.head]);
    if(tail<head){
      for(final int bound=arr.length;;){  
        if(++head==bound){
          hash=hash*31+$hashCodeMethod$(arr[head=0]);
          break;
        }
        hash=(hash*31)+$hashCodeMethod$(arr[head]);
      }
    }
    for(;head!=tail;hash=(hash*31)+$hashCodeMethod$(arr[++head])){}
    return hash;
  }
  @Override public void push($exposedType$ val){
    $ArrayType$[] arr;
    if((arr=this.arr)!=null){
      if(arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR){
        this.head=OmniArray.DEFAULT_ARR_SEQ_CAP-1;
        this.tail=OmniArray.DEFAULT_ARR_SEQ_CAP-1;
        this.arr=arr=new $ArrayType$[OmniArray.DEFAULT_ARR_SEQ_CAP];
        arr[OmniArray.DEFAULT_ARR_SEQ_CAP-1]=val;
      }else{
        int tail;
        if((tail=this.tail)==-1){
          arr[tail=arr.length-1]=val;
          this.tail=tail;
          this.head=tail;
        }else{
          int head;
          if((head=this.head-1)==tail){
            final $ArrayType$[] newArr;
            int newCap,size;
            this.tail=(newCap=OmniArray.growBy50Pct(head+(size=arr.length)))-1;
            ArrCopy.uncheckedCopy(arr,0,newArr=new $ArrayType$[newCap],newCap-=(++tail),tail);
            ArrCopy.uncheckedCopy(arr,head+1,newArr,head=newCap-(size-=tail),size);
            this.arr=arr=newArr;
            --head;
          }else if(head==-1 && tail==(head=arr.length-1)){
            int newCap;
            this.tail=(newCap=OmniArray.growBy50Pct(++tail))-1;
            ArrCopy.uncheckedCopy(arr,0,arr=new $ArrayType$[newCap],head=newCap-tail,tail);
            this.arr=arr;
            --head;
          }
          arr[head]=val;
          this.head=head;
        }
      }
    }else{
      initFromNullArr(val);
    }
  }
  private void initFromNullArr($exposedType$ val){
    this.head=0;
    this.tail=0;
    this.arr=new $ArrayType$[]{val};
  }
  @Override public void addLast($exposedType$ val){
    $ArrayType$[] arr;
    if((arr=this.arr)!=null){
      if(arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR){
        this.head=0;
        this.tail=0;
        this.arr=arr=new $ArrayType$[OmniArray.DEFAULT_ARR_SEQ_CAP];
        arr[0]=val;
      }else{
        int tail;
        if((tail=this.tail)==-1){
          arr[0]=val;
          this.tail=0;
          this.head=0;
        }else{
          int head;
          if(++tail==(head=this.head)){
            this.head=0;
            final $ArrayType$[] newArr;
            (newArr=new $ArrayType$[OmniArray.growBy50Pct(tail=arr.length)])[tail]=val;
            this.tail=tail;
            ArrCopy.uncheckedCopy(arr,head,newArr,0,tail-=head);
            ArrCopy.uncheckedCopy(arr,0,newArr,tail,head);
            this.arr=newArr;
          }else{
            if(tail==arr.length){
              if(head==0){
                ArrCopy.uncheckedCopy(arr,0,arr=new $ArrayType$[OmniArray.growBy50Pct(tail)],0,tail);
                this.arr=arr;
              }else{
                tail=0;
              }
            }
            arr[tail]=val;
            this.tail=tail;
          }
        }
      }
    }else{
      initFromNullArr(val);
    }
  }
  private void eraseHead(){
    int head;
    switch(Integer.signum(this.tail-(head=this.head))){
      case -1:
#IF OfRef
        $ArrayType$[] arr;
        (arr=this.arr)[head]=null;
#ENDIF
        this.head=head==arr.length-1?0:head+1;
        return;
      case 0:
        this.tail=-1;
        break;
      default:
        this.head=head+1;
    }
#IF OfRef
    arr[head]=null;
#ENDIF
  }
  private void eraseTail(){
    int tail;
    switch(Integer.signum((tail=this.tail)-this.head)){
      case -1:
#IF OfRef
        $ArrayType$[] arr;
        (arr=this.arr)[tail]=null;
#ENDIF
        this.tail=tail==0?arr.length-1:tail-1;
        return;
      case 0:
        this.tail=-1;
        break;
      default:
        this.tail=tail-1;
    }
#IF OfRef
    arr[tail]=null;
#ENDIF
  }
#IFNOT OfBoolean
  private static abstract class AbstractDeqItr$<E>$
#IF OfRef
    implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
    extends Abstract$ClassPrefix$Itr$<E>$
#ENDIF
  {
    transient int cursor;
    AbstractDeqItr(AbstractDeqItr$<E>$ itr){
      this.cursor=itr.cursor;
    }
    AbstractDeqItr(int cursor){
      this.cursor=cursor;
    }
    @Override public boolean hasNext(){
      return this.cursor!=-1;
    }
#IF OfRef
    @Override public abstract Object clone();    
#ENDIF
    abstract void uncheckedForEachRemaining(int cursor,$TypeNameModifier$Consumer$<? super E>$ action);
    @Override public void forEachRemaining($TypeNameModifier$Consumer$<? super E>$ action){
      int cursor;
      if((cursor=this.cursor)!=-1){
        uncheckedForEachRemaining(cursor,action);
      }
    }
#IFNOT OfRef
    @Override public void forEachRemaining(Consumer<? super $BoxedType$> action){
      int cursor;
      if((cursor=this.cursor)!=-1){
        uncheckedForEachRemaining(cursor,action::accept);
      }
    }
#ENDIF 
  }
#ENDIF
  private static int pullUp($ArrayType$[] arr,int head,int headDist){
#IF OfRef
    final int tmp;
    ArrCopy.semicheckedCopy(arr,tmp=head,arr,++head,headDist);
    arr[tmp]=null;
#ELSE
    ArrCopy.semicheckedCopy(arr,head,arr,++head,headDist);
#ENDIF
    return head;
  }
  private static int fragmentedPullUp($ArrayType$[] arr,int head,int headDist){
    if(headDist==0){
#IF OfRef
      arr[head]=null;
#ENDIF
      return 0;
    }else{
#IF OfRef
      int tmp;
      ArrCopy.uncheckedCopy(arr,tmp=head,arr,++head,headDist);
      arr[tmp]=null;
#ELSE
      ArrCopy.uncheckedCopy(arr,head,arr,++head,headDist);
#ENDIF
      return head;
    }
  }
  private static int fragmentedPullDown($ArrayType$[] arr,int arrBound,int tail){
    if(tail==0){
#IF OfRef
      arr[0]=null;
#ENDIF
      return arrBound;
    }
    ArrCopy.uncheckedSelfCopy(arr,0,1,tail);
#IF OfRef
    arr[tail]=null;
#ENDIF
    return tail-1;
  }
  private static class AscendingItr$<E>$ extends AbstractDeqItr$<E>$
  {
    transient final $ClassPrefix$ArrDeq$<E>$ root;
    private AscendingItr(AscendingItr$<E>$ itr){
      super(itr);
      this.root=itr.root;
    }
    private AscendingItr($ClassPrefix$ArrDeq$<E>$ root){
      super(root.tail!=-1?root.head:-1);
      this.root=root;
    }
    private AscendingItr($ClassPrefix$ArrDeq$<E>$ root,int cursor){
      super(cursor);
      this.root=root;
    }
    @Override public Object clone(){
      return new AscendingItr$<E>$(this);
    }
    #MACRO SuppressUnchecked()
    @Override public $exposedType$ next$TypeNameModifier$(){
      final $ArrayType$[] arr;
      int cursor;
      final $ClassPrefix$ArrDeq$<E>$ root;
      final var ret=($exposedType$)(arr=(root=this.root).arr)[cursor=this.cursor];
      if(cursor==root.tail){
        cursor=-1;
      }else if(++cursor==arr.length){
        cursor=0;
      }
      this.cursor=cursor;
      return ret;
    }
    private void eraseAtSplit(){
      final int head,tail,headDist,arrBound;
      final $ClassPrefix$ArrDeq$<E>$ root;
      final $ArrayType$[] arr;
      if((tail=(root=this.root).tail)<(headDist=(arrBound=(arr=root.arr).length-1)-(head=root.head))){
        arr[arrBound]=arr[0];
        root.tail=fragmentedPullDown(arr,arrBound,tail);
        this.cursor=arrBound;
      }else{
        root.head=fragmentedPullUp(arr,head,headDist);
      }
    }
    private void fragmentedAscendingRemove(int head,int lastRet,int tail,$ClassPrefix$ArrDeq$<E>$ root){
      $ArrayType$[] arr;
      int headDist,tailDist,arrBound=(arr=root.arr).length-1;
      if((headDist=lastRet-head)>=0){
        //index to remove is in head run
        if(headDist<=(tailDist=arrBound-lastRet)+tail+1){
          root.head=pullUp(arr,head,headDist);
        }else{
          ArrCopy.semicheckedSelfCopy(arr,lastRet,lastRet+1,tailDist);
          arr[arrBound]=arr[0];
          root.tail=fragmentedPullDown(arr,arrBound,tail);
          this.cursor=lastRet;
        }
      }else{
        if((tailDist=tail-lastRet)<=(headDist=arrBound-head)+lastRet+1){
          ArrCopy.uncheckedSelfCopy(arr,lastRet,lastRet+1,tailDist);
#IF OfRef
          arr[tail]=null;
#ENDIF
          root.tail=tail-1;
          this.cursor=lastRet;
        }else{
          ArrCopy.semicheckedCopy(arr,0,arr,1,lastRet);
          arr[0]=arr[arrBound];
          root.head=fragmentedPullUp(arr,head,headDist);
        }
      }
    }
    private void nonfragmentedAscendingRemove(int head,int lastRet,int tail,$ClassPrefix$ArrDeq$<E>$ root){
      int headDist,tailDist;
      if((headDist=lastRet-head)<=(tailDist=tail-lastRet)){
        root.head=pullUp(root.arr,head,headDist);
      }else{
#IF OfRef
        $ArrayType$[] arr;
        ArrCopy.uncheckedSelfCopy(arr=root.arr,lastRet,lastRet+1,tailDist);
        arr[tail]=null;
#ELSE
        ArrCopy.uncheckedSelfCopy(root.arr,lastRet,lastRet+1,tailDist);
#ENDIF
        root.tail=tail-1;
        this.cursor=lastRet;
      }
    }
    @Override public void remove(){
      final int cursor;
      switch(cursor=this.cursor){
        case -1:
          root.eraseTail();
          break;
        case 0:
          eraseAtSplit();
          break;
        default:
          final int head,tail;
          final $ClassPrefix$ArrDeq$<E>$ root;
          if((tail=(root=this.root).tail)<(head=root.head)){
            fragmentedAscendingRemove(head,cursor-1,tail,root);
          }else{
            nonfragmentedAscendingRemove(head,cursor-1,tail,root);
          }
      }
    }
    @Override void uncheckedForEachRemaining(int cursor,$TypeNameModifier$Consumer$<? super E>$ action){
      final $ClassPrefix$ArrDeq$<E>$ root;
      int tail;
      final var arr=(root=this.root).arr;
      if(cursor>(tail=root.tail)){
        OmniArray.Of$ClassPrefix$.ascendingForEach(arr,cursor,arr.length-1,action);
        cursor=0;
      }
      OmniArray.Of$ClassPrefix$.ascendingForEach(arr,cursor,tail,action);
      this.cursor=-1;
    }
  }
  private static class DescendingItr$<E>$ extends AscendingItr$<E>${
    private DescendingItr(DescendingItr$<E>$ itr){
      super(itr);
    }
    private DescendingItr($ClassPrefix$ArrDeq$<E>$ root){
      super(root,root.tail);
    }
    @Override public Object clone(){
      return new DescendingItr$<E>$(this);
    }
    @Override void uncheckedForEachRemaining(int cursor,$TypeNameModifier$Consumer$<? super E>$ action){
      final $ClassPrefix$ArrDeq$<E>$ root;
      final int head;
      final var arr=(root=this.root).arr;
      if(cursor<(head=root.head)){
        OmniArray.Of$ClassPrefix$.descendingForEach(arr,0,cursor,action);
        cursor=arr.length-1;
      }
      OmniArray.Of$ClassPrefix$.descendingForEach(arr,head,cursor,action);
      this.cursor=-1;
    }
    #MACRO SuppressUnchecked()
    @Override public $exposedType$ next$TypeNameModifier$(){
      int cursor;
      final $ClassPrefix$ArrDeq$<E>$ root;
      final var arr=(root=this.root).arr;
      this.cursor=(cursor=this.cursor)==root.head?-1:cursor==0?arr.length-1:cursor-1;
      return ($exposedType$)arr[cursor];
    }
    private void fragmentedDescendingRemove(int head,int cursor,int tail,$ClassPrefix$ArrDeq$<E>$ root){
      $ArrayType$[] arr;
      int arrBound;
      if((arrBound=(arr=root.arr).length-1)==cursor){
        //remove index 0
        if(tail<=(cursor=arrBound-head)+1){
          root.tail=fragmentedPullDown(arr,arrBound,tail);
        }else{
          arr[0]=arr[arrBound];
          root.head=fragmentedPullUp(arr,head,cursor);
          this.cursor=0;
        }
      }else{
        int headDist,tailDist;
        if((headDist=(++cursor)-head)>0){
          //removing from head run
          if(headDist<=(tailDist=arrBound-cursor)+tail+1){
#IF OfRef
            ArrCopy.uncheckedCopy(arr,tail=head,arr,++head,headDist);
            arr[tail]=null;
#ELSE
            ArrCopy.uncheckedCopy(arr,head,arr,++head,headDist);
#ENDIF
            root.head=head;
            this.cursor=cursor;
          }else{
            ArrCopy.semicheckedSelfCopy(arr,cursor,cursor+1,tailDist);
            arr[arrBound]=arr[0];
            root.tail=fragmentedPullDown(arr,arrBound,tail);
          }
        }else{
          //removing from tail run
          if((tailDist=tail-cursor)<=(headDist=arrBound-head)+cursor+1){
            ArrCopy.semicheckedSelfCopy(arr,cursor,cursor+1,tailDist);
#IF OfRef
            arr[tail]=null;
#ENDIF
            root.tail=tail-1;
          }else{
            ArrCopy.uncheckedCopy(arr,0,arr,1,cursor);
            arr[0]=arr[arrBound];
            root.head=fragmentedPullUp(arr,head,headDist);
            this.cursor=cursor;
          }
        }
      }
    }
    private void nonfragmentedDescendingRemove(int head,int lastRet,int tail,$ClassPrefix$ArrDeq$<E>$ root){
      int tailDist,headDist;
      if((tailDist=tail-lastRet)<=(headDist=lastRet-head)){
#IF OfRef
        $ArrayType$[] arr;
        ArrCopy.semicheckedSelfCopy(arr=root.arr,lastRet,lastRet+1,tailDist);
        arr[tail]=null;
#ELSE
        ArrCopy.semicheckedSelfCopy(root.arr,lastRet,lastRet+1,tailDist);
#ENDIF
        root.tail=tail-1;
      }else{
        $ArrayType$[] arr;
#IF OfRef
        ArrCopy.uncheckedCopy(arr=root.arr,tail=head,arr,++head,headDist);
        arr[tail]=null;
#ELSE
        ArrCopy.uncheckedCopy(arr=root.arr,head,arr,++head,headDist);
#ENDIF
        root.head=head;
        this.cursor=lastRet;
      }
    }
    @Override public void remove(){
      int cursor;
      if((cursor=this.cursor)==-1){
        root.eraseHead();
      }else{
        $ClassPrefix$ArrDeq$<E>$ root;
        int head,tail;
        if((tail=(root=this.root).tail)<(head=root.head)){
          fragmentedDescendingRemove(head,cursor,tail,root);
        }else{
          nonfragmentedDescendingRemove(head,cursor+1,tail,root);
        }
      }
    }
  } 
  @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
    return new AscendingItr$<E>$(this);
  }
  @Override public OmniIterator.Of$ClassPrefix$$<E>$ descendingIterator(){
    return new DescendingItr$<E>$(this);
  }
  #MACRO SuppressUnchecked()
  boolean fragmentedRemoveIf(int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfBoolean
    final var arr=this.arr;
    int trueCount=0;
    int size;
    for(int i=tail;;--i){
      if(arr[i])
      {
        ++trueCount;
      }
      if(i==0)
      {
        for(i=(size=arr.length)-1;;--i)
        {
          if(arr[i])
          {
            ++trueCount;
          }
          if(i==head)
          {
            break;
          }
        }
        size+=(tail+1-head);
        break;
      }
    }
    if(trueCount==size)
    {
      if(filter.test(true))
      {
        this.tail=-1;
        return true;
      }
    }else if(trueCount==0)
    {
      if(filter.test(false))
      {
        this.tail=-1;
        return true;
      }
    }else{
      if(filter.test(true)){
        if(filter.test(false)){
          this.tail=-1;
        }else{
          setRange(arr,size-=(trueCount+1),false);
          this.head=0;
          this.tail=size;         
        }
        return true;
      }else if(filter.test(false)){
        setRange(arr,--trueCount,true);
        this.head=0;
        this.tail=trueCount;
        return true;
      }
    }
    return false;
#ELSE
    $ArrayType$[] arr;
    if(filter.test(($exposedType$)(arr=this.arr)[head]))
    {
      if(filter.test(($exposedType$)arr[tail]))
      {
        fragmentedCollapseHeadAndTail(arr,head,tail,filter);
      }
      else
      {
        fragmentedCollapsehead(arr,head,tail,filter);
      }
      return true;
    }
    else if(filter.test(($exposedType$)arr[tail]))
    {
      fragmentedCollapsetail(arr,head,tail,filter);
      return true;
    }
    return fragmentedCollapseBody(arr,head,tail,filter);
#ENDIF
  }
#IF OfBoolean
  private static void setRange($ArrayType$[] arr,int tail,$ArrayType$ val){
    for(;;--tail){
      arr[tail]=val;
      if(tail==0){
        return;
      }
    }
  }
#ELSE
  #MACRO SuppressUnchecked()
  private static $<E>$ int pullDown($ArrayType$[] arr,int dstOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter){
    for(int srcOffset=dstOffset+1;srcOffset!=srcBound;++srcOffset)
    {
      final $ArrayType$ v;
      if(!filter.test(($exposedType$)(v=arr[srcOffset])))
      {
        arr[dstOffset++]=v;
      }
    }
    arr[dstOffset]=arr[srcBound];
#IF OfRef
    OmniArray.Of$ClassPrefix$.nullifyRange(arr,srcBound,dstOffset+1);
#ENDIF
    return dstOffset;
  }
  #MACRO SuppressUnchecked()
  private static $<E>$ int pullUp($ArrayType$[] arr,int dstOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter){
    for(int srcOffset=dstOffset-1;srcOffset!=srcBound;--srcOffset)
    {
      final $ArrayType$ v;
      if(!filter.test(($exposedType$)(v=arr[srcOffset])))
      {
        arr[dstOffset--]=v;
      }
    }
    arr[dstOffset]=arr[srcBound];
#IF OfRef
    OmniArray.Of$ClassPrefix$.nullifyRange(arr,dstOffset-1,srcBound);
#ENDIF
    return dstOffset;
  }
  #MACRO SuppressUnchecked()
  private void fragmentedCollapseBodyHelper($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
    for(int srcOffset=0;srcOffset!=tail;++srcOffset)
    {
      if(filter.test(($exposedType$)arr[srcOffset]))
      {
        tail=pullDown(arr,srcOffset,tail,filter);
        break;
      }
    }
    this.tail=tail;
    for(int srcOffset=arr.length-1;srcOffset!=head;--srcOffset)
    {
      if(filter.test(($exposedType$)arr[srcOffset]))
      {
        head=pullUp(arr,srcOffset,head,filter);
        break;
      }
    }
    this.head=head;
  }
  #MACRO SuppressUnchecked()
  private void collapseBodyHelper($ArrayType$[] ar,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
    int midPoint;
    for(int srcOffset=midPoint=(head+tail)>>1;srcOffset!=head;--srcOffset){
      if(filter.test(($exposedType$)arr[srcOffset])){
        this.head=pullUp(arr,srcOffset,head,filter);
        while(++midPoint!=tail){
          if(filter.test(($exposedType$)arr[midPoint])){
            tail=pullDown(arr,midPoint,tail,filter);
            break;
          }
        }
        this.tail=tail;
        return;
      }
    }
    while(++midPoint!=tail){
      if(filter.test(($exposedType$)arr[midPoint])){
        tail=pullDown(arr,midPoint,tail,filter);
        break;
      }
    }
    this.head=head;
    this.tail=tail;
  }
  #MACRO SuppressUnchecked()
  private void fragmentedCollapseHeadAndTail($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfRef
    arr[head]=null;
#ENDIF
    outer:for(;;){
      do{
#IF OfRef
        arr[tail]=null;
#ENDIF
        if(tail==0){
          for(tail=arr.length-1;tail!=head;--tail){
            if(!filter.test(($exposedType$)arr[tail])){
              break outer;
            }
#IF OfRef
            arr[tail]=null;
#ENDIF
          }  
          this.tail=-1;
          return;
        }
      }while(filter.test(($exposedType$)arr[--tail]));
      for(int bound=arr.length;++head!=bound;){
        if(!filter.test(($exposedType$)arr[head])){
          fragmentedCollapseBodyHelper(arr,head,tail,filter);
          return;
        }
#IF OfRef
        arr[head]=null;
#ENDIF
      }
      head=-1;
      break;
    }
    while(++head!=tail){
      if(!filter.test(($exposedType$)arr[head])){
        collapseBodyHelper(arr,head,tail,filter);
        return;
      }
#IF OfRef
      arr[head]=null;
#ENDIF
    }
    this.head=head;
    this.tail=tail;
  }
  #MACRO SuppressUnchecked()
  private boolean fragmentedCollapseBody($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
    for(int srcOffset=0;srcOffset!=tail;++srcOffset){
      if(filter.test(($exposedType$)arr[srcOffset])){
        this.tail=pullDown(arr,srcOffset,tail,filter);
        for(srcOffset=arr.length-1;srcOffset!=head;--srcOffset){
          if(filter.test(($exposedType$)arr[srcOffset])){
            this.head=pullUp(arr,srcOffset,head,filter);
            break;
          }
        }
        return true;
      }
    }
    for(int srcOffset=arr.length-1;srcOffset!=head;--srcOffset){
      if(filter.test(($exposedType$)arr[srcOffset]))
      {
        this.head=pullUp(arr,srcOffset,head,filter);
        return true;
      }
    }
    return false;
  }
  #MACRO CollapseEnd<false,head,tail>(++)
  #MACRO CollapseEnd<false,tail,head>(--)
  #MACRO SuppressUnchecked()
  private void collapseHeadAndTail($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfRef
    arr[tail]=null;
#ENDIF
    do{
#IF OfRef
      arr[head]=null;
#ENDIF
      if(++head==tail){
        this.tail=-1;
        return;
      }
    }while(filter.test(($exposedType$)arr[head]));
    while(--tail!=head){
      if(!filter.test(($exposedType$)arr[tail])){
        collapseBodyHelper(arr,head,tail,filter);
        return;
      }
#IF OfRef
      arr[tail]=null;
#ENDIF
    }
    this.head=head;
    this.tail=head;
  }
  #MACRO SuppressUnchecked()
  private boolean collapseBody($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
    int midPoint;
    for(int srcOffset=midPoint=(head+tail)>>1;srcOffset!=head;--srcOffset){
      if(filter.test(($exposedType$)arr[srcOffset])){
        this.head=pullUp(arr,srcOffset,head,filter);
        while(++midPoint!=tail){
          if(filter.test(($exposedType$)arr[midPoint])){
            this.tail=pullDown(arr,midPoint,tail,filter);
            break;
          }
        }
        return true;
      }
    }
    while(++midPoint!=tail){
      if(filter.test(($exposedType$)arr[midPoint])){
        this.tail=pullDown(arr,midPoint,tail,filter);
        return true;
      }
    }
    return false;
  }
#ENDIF
  #MACRO SuppressUnchecked()
  boolean nonfragmentedRemoveIf(int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfBoolean
    final var arr=this.arr;
    int trueCount=0;
    for(int i=head;;++i){
      if(arr[i]){
        ++trueCount;
      }
      if(i==tail){
        break;
      }
    }
    int size;
    if(trueCount==(size=tail-head+1)){
      if(filter.test(true)){
        this.tail=-1;
        return true;
      }
    }else if(trueCount==0){
      if(filter.test(false)){
        this.tail=-1;
        return true;
      }
    }else{
      if(filter.test(true)){
        if(filter.test(false)){
          this.tail=-1;
        }else{
          setRange(arr,size-=(trueCount+1),false);
          this.head=0;
          this.tail=size;
        }
        return true;
      }else if(filter.test(false)){
        setRange(arr,--trueCount,true);
        this.head=0;
        this.tail=trueCount;
        return true;
      }
    }
#ELSE
    final $ArrayType$[] arr;
    if(filter.test(($exposedType$)(arr=this.arr)[head])){
      if(head==tail){
#IF OfRef
        arr[tail]=null;
#ENDIF
        this.tail=-1;
      }else{
        if(filter.test(($exposedType$)arr[tail])){
          collapseHeadAndTail(arr,head,tail,filter);
        }else{
          collapsehead(arr,head,tail,filter);
        }
      }
      return true;
    }else if(head!=tail){
      if(filter.test(($exposedType$)arr[tail])){
        collapsetail(arr,head,tail,filter);
        return true;
      }
      return collapseBody(arr,head,tail,filter);
    }
#ENDIF
    return false;
  }
  @Override public void readExternal(ObjectInput input) throws IOException
#IF OfRef
    ,ClassNotFoundException
#ENDIF
  {
    int size;
    if((size=input.readInt())!=0){
      $ArrayType$[] arr;
#IF OfByte
      input.readFully(arr=new $ArrayType$[size]);
      this.tail=size-1;
#ELSE
      OmniArray.Of$ClassPrefix$.readArray(arr=new $ArrayType$[size],0,--size,input);
      this.tail=size;
#ENDIF
      this.head=0;
      this.arr=arr;
    }else{
      this.tail=-1;
    }
  }
  @Override public void writeExternal(ObjectOutput output) throws IOException{
    int tail;
    if((tail=this.tail)!=-1){
      int head,size;
      if((size=(++tail)-(head=this.head))<=0){
        $ArrayType$[] arr;
        output.writeInt(size+(size=(arr=this.arr).length));
#IF OfBoolean
        for(int word=TypeUtil.castToByte(arr[head]),marker=1;;){
          if(++head==size){
             head=0;
             do{
               if((marker<<=1)==(1<<8)){
                 output.writeByte(word);
                 word=0;
                 marker=1;
               }
               if(arr[head]){
                 word|=marker;
               }
             }while(++head!=tail);
             output.writeByte(word);
             return;
          }
          if((marker<<=1)==(1<<8)){
            output.writeByte(word);
            word=0;
            marker=1;
          }
          if(arr[head]){
            word|=marker;
          }
        }
#ELSEIF OfByte
        output.write(arr,head,size-head);
        output.write(arr,0,tail);
#ELSE
        OmniArray.Of$ClassPrefix$.writeArray(arr,head,size-1,output);
        OmniArray.Of$ClassPrefix$.writeArray(arr,0,tail-1,output);
#ENDIF
      }else{
        output.writeInt(size);
#IF OfByte
        output.write(arr,head,size);
#ELSE
        OmniArray.Of$ClassPrefix$.writeArray(arr,head,tail-1,output);
#ENDIF
      }
    }else{
      output.writeInt(0);
    }
  }
  @Override public boolean equals(Object obj){
    //TODO
    throw omni.util.NotYetImplementedException.getNYI();

  }
  public static class Checked$<E>$ extends $ClassPrefix$ArrDeq$<E>${
    private static final long serialVersionUID=1L;
    transient int modCount;
    public Checked(){
      super();
    }
    public Checked(int initialCapacity){
      super(initialCapacity);
    }
    Checked(int head,$ArrayType$[] arr,int tail){
      super(head,arr,tail);
    }
#IFNOT OfBoolean
    #MACRO CollapseEnd<true,head,tail>(++)
    #MACRO CollapseEnd<true,tail,head>(--)
    private static class BigCollapseData$<E>$ extends CollapseData$<E>${
      final long[] survivorSet;
      #MACRO SuppressUnchecked()
      BigCollapseData($ArrayType$[] arr,int srcOffset,int numLeft,$TypeNameModifier$Predicate$<? super E>$ filter,int arrBound){
        #MACRO Assert(srcOffset>0)
        #MACRO Assert(numLeft>64)
        #MACRO Assert(srcOffset+numLeft>=arrBound)
        #MACRO Assert(srcOffset<=arrBound)
        var survivorSet=new long[((numLeft-1)>>6)+1];
        numLeft+=(srcOffset-arrBound);
        int wordOffset=-1,survivorsBeforeBiggestRun=0,survivorsAfterBiggestRun=0,currentRunLength=0,currentRunBegin=0,biggestRunLength=0,biggestRunBegin=0;
        long word=0L,marker=1L;
        outer: for(;;)
        {
          if(srcOffset!=arrBound)
          {
            for(;;){
              if(filter.test(($exposedType$)arr[srcOffset])){
                currentRunLength=0;
              }else{
                word|=marker;
                if(currentRunLength==0){
                  currentRunBegin=srcOffset;
                }
                if(currentRunLength==biggestRunLength){
                  survivorsBeforeBiggestRun+=survivorsAfterBiggestRun;
                  survivorsAfterBiggestRun=0;
                  biggestRunBegin=currentRunBegin;
                  biggestRunLength=++currentRunLength;
                }else{
                  ++currentRunLength;
                  ++survivorsAfterBiggestRun;
                }
              }
              if(++srcOffset==arrBound)
              {
                if(numLeft==0)
                {
                  survivorSet[++wordOffset]=word;
                  break outer;
                }
                if((marker<<=1)==0L)
                {
                  survivorSet[++wordOffset]=word;
                  word=0L;
                  marker=1L;
                }
                break;
              }
              if((marker<<=1)==0L){
                survivorSet[++wordOffset]=word;
                word=0L;
                marker=1L;
              }
              
            }
          }
          for(srcOffset=0;;)
          {
            if(filter.test(($exposedType$)arr[srcOffset])){
              currentRunLength=0;
            }else{
              word|=marker;
              if(currentRunLength==0){
                currentRunBegin=srcOffset;
              }
              if(currentRunLength==biggestRunLength){
                survivorsBeforeBiggestRun+=survivorsAfterBiggestRun;
                survivorsAfterBiggestRun=0;
                biggestRunBegin=currentRunBegin;
                biggestRunLength=++currentRunLength;
              }else{
                ++currentRunLength;
                ++survivorsAfterBiggestRun;
              }
            }
            if(++srcOffset==numLeft)
            {
              survivorSet[++wordOffset]=word;
              break outer;
            }
            if((marker<<=1)==0L){
              survivorSet[++wordOffset]=word;
              word=0L;
              marker=1L;
            }
          }
        }
        
        this.biggestRunBegin=biggestRunBegin;
        this.biggestRunLength=biggestRunLength;
        this.survivorsBeforeBiggestRun=survivorsBeforeBiggestRun;
        this.survivorsAfterBiggestRun=survivorsAfterBiggestRun;
        this.survivorSet=survivorSet;
      }
      #MACRO SuppressUnchecked()
      BigCollapseData($ArrayType$[] arr,int srcOffset,int numLeft,$TypeNameModifier$Predicate$<? super E>$ filter){
        #MACRO Assert(srcOffset>=0)
        #MACRO Assert(numLeft>64)
        var survivorSet=new long[((numLeft-1)>>6)+1];
        numLeft+=srcOffset;
        for(int wordOffset=-1,survivorsBeforeBiggestRun=0,survivorsAfterBiggestRun=0,currentRunLength=0,currentRunBegin=0,biggestRunLength=0,biggestRunBegin=0;;){
          long word=0L,marker=1L;
          do{
            if(filter.test(($exposedType$)arr[srcOffset])){
              currentRunLength=0;
            }else{
              word|=marker;
              if(currentRunLength==0){
                currentRunBegin=srcOffset;
              }
              if(currentRunLength==biggestRunLength){
                survivorsBeforeBiggestRun+=survivorsAfterBiggestRun;
                survivorsAfterBiggestRun=0;
                biggestRunBegin=currentRunBegin;
                biggestRunLength=++currentRunLength;
              }else{
                ++currentRunLength;
                ++survivorsAfterBiggestRun;
              }
            }
            if(++srcOffset==numLeft){
              survivorSet[++wordOffset]=word;
              this.biggestRunBegin=biggestRunBegin;
              this.biggestRunLength=biggestRunLength;
              this.survivorsBeforeBiggestRun=survivorsBeforeBiggestRun;
              this.survivorsAfterBiggestRun=survivorsAfterBiggestRun;
              this.survivorSet=survivorSet;
              return;
            }
          }while((marker<<=1)!=0L);
          survivorSet[++wordOffset]=word;
        }
      }
      
      
      
      @Override void fragmentedCollapseBiggestRunInHead(int head,$ClassPrefix$ArrDeq$<E>$ deq,int tail){
        int overflow;
        int biggestRunEnd;
        int arrLength;
        int biggestRunBegin;
        $ArrayType$[] arr;
        int survivorsBeforeAndAfter=this.survivorsAfterBiggestRun;
        if((overflow=(biggestRunEnd=(biggestRunBegin=this.biggestRunBegin)+this.biggestRunLength)-(arrLength=(arr=deq.arr).length))>=0){
          if(survivorsBeforeAndAfter!=0){
            nonfragmentedPullSurvivorsDown(arr,overflow,biggestRunEnd-head,overflow+=survivorsBeforeAndAfter);
          }
#IF OfRef
          if(overflow!=tail){
            arr[overflow]=arr[tail];
            OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,overflow+1);
          }
#ELSE
          arr[overflow]=arr[tail];
#ENDIF
        }else{
          int newTail;
          switch(Integer.signum(overflow=(newTail=biggestRunEnd+survivorsBeforeAndAfter)-arrLength)){
            case -1:
              if(survivorsBeforeAndAfter!=0){
                if(tail==0){
                  nonfragmentedPullSurvivorsDown(arr,biggestRunEnd,biggestRunEnd-head,newTail);
                }else{
                  fragmentedPullSurvivorsDownToNonFragmented(arr,biggestRunEnd,biggestRunEnd-head,newTail);
                }
              }
#IF OfRef
              if(newTail!=--arrLength){
                OmniArray.Of$ClassPrefix$.nullifyRange(arr,arrLength,newTail+1);
              }
#ENDIF
              arr[newTail]=arr[tail];
              overflow=newTail;
#IF OfRef
              newTail=0;
#ENDIF
              break;
            case 0:
              fragmentedPullSurvivorsDownToNonFragmented(arr,biggestRunEnd,biggestRunEnd-head,newTail);             
              arr[0]=arr[tail];
#IF OfRef
              newTail=1;
#ENDIF
              break;
            default:
              fragmentedPullSurvivorsDown(arr,biggestRunEnd,biggestRunEnd-head,overflow);
              arr[overflow]=arr[tail];
#IF OfRef
              newTail=overflow+1;
#ENDIF
          }
#IF OfRef
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,newTail);
#ENDIF
        }
        deq.tail=overflow;
        if((survivorsBeforeAndAfter=this.survivorsBeforeBiggestRun)!=0){
          nonfragmentedPullSurvivorsUp(arr,biggestRunBegin,(biggestRunBegin-head)-3,biggestRunBegin-=survivorsBeforeAndAfter);
        }
#IF OfRef
        if(--biggestRunBegin!=head){
          arr[biggestRunBegin]=arr[head];
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,biggestRunBegin-1,head);
        }
#ELSE
        arr[--biggestRunBegin]=arr[head];
#ENDIF
        deq.head=biggestRunBegin;
      }
      @Override void fragmentedCollapseBiggestRunInTail(int head,$ClassPrefix$ArrDeq$<E>$ deq,int tail){
        int biggestRunBegin;
        int biggestRunEnd=(biggestRunBegin=this.biggestRunBegin)+this.biggestRunLength;
        $ArrayType$[] arr;
        int arrLength;
        int overflow=(arrLength=(arr=deq.arr).length)-head;
        int survivorsBeforeAndAfter;
        if((survivorsBeforeAndAfter=this.survivorsAfterBiggestRun)!=0){
          nonfragmentedPullSurvivorsDown(arr,biggestRunEnd,biggestRunEnd+overflow,biggestRunEnd+=survivorsBeforeAndAfter);
        }
#IF OfRef
        if(biggestRunEnd!=tail){
          arr[biggestRunEnd]=arr[tail];
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,biggestRunEnd+1);
        }
#ELSE
        arr[biggestRunEnd]=arr[tail];
#ENDIF
        deq.tail=biggestRunEnd;
        switch(Integer.signum(biggestRunEnd=biggestRunBegin-(survivorsBeforeAndAfter=this.survivorsBeforeBiggestRun))){
          case 1:
            //no overflow detected
            if(survivorsBeforeAndAfter!=0){
              if(overflow==1){
                nonfragmentedPullSurvivorsUp(arr,biggestRunBegin,biggestRunBegin-2,biggestRunEnd);
              }else{
                fragmentedPullSurvivorsUpToNonFragmented(arr,biggestRunBegin,biggestRunBegin+overflow-3,biggestRunEnd);
              }
            }
#IF OfRef
            if(biggestRunEnd!=1){
              OmniArray.Of$ClassPrefix$.nullifyRange(arr,biggestRunEnd-2,0);
            }
            --arrLength;
#ENDIF
            arr[--biggestRunEnd]=arr[head];
            break;  
          case 0:
            if(survivorsBeforeAndAfter!=0){
              fragmentedPullSurvivorsUpToNonFragmented(arr,biggestRunBegin,biggestRunBegin+overflow-3,0);
            }
#IF OfRef
            arr[biggestRunEnd=--arrLength]=arr[head];
            --arrLength;
#ELSE
            arr[biggestRunEnd=arrLength-1]=arr[head];
#ENDIF
            break;
          default:
            biggestRunEnd+=arrLength;
            if(biggestRunBegin==0){
              nonfragmentedPullSurvivorsUp(arr,arrLength,overflow-3,biggestRunEnd);
            }else{
               fragmentedPullSurvivorsUp(arr,biggestRunBegin,biggestRunBegin+overflow-3,biggestRunEnd);
            }
            arr[--biggestRunEnd]=arr[head];
#IF OfRef
            arrLength=biggestRunEnd-1;
#ENDIF
        }
        deq.head=biggestRunEnd;
#IF OfRef
        if(head<=arrLength)
        {
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,arrLength,head);
        }
#ENDIF
      }
      
      
      private void fragmentedPullSurvivorsUpToNonFragmented($ArrayType$[] arr,int dstOffset,int numToSkip,int dstBound){
        int wordOffset,s,numToRetain;
        long[] survivorSet;
        long word=(survivorSet=this.survivorSet)[wordOffset=numToSkip>>6]<<(-(numToSkip+1));
        int srcOffset=(s=dstOffset-1)-(((numToSkip)&63)+1);
        for(;;){
          if((numToSkip=Long.numberOfLeadingZeros(word))==64){
            //go to the next word
            s=srcOffset;
            srcOffset-=64;
            word=survivorSet[--wordOffset];
            continue;
          }else if((numToRetain=Long.numberOfLeadingZeros(~(word<<=numToSkip)))==64){
            //corner case. When all 64 elements of a word are copied, deplete the word before continuing the copy
            word=0;
          }
          if((s-=numToSkip)<=0){
            //overflow detected on a skip
            ArrCopy.uncheckedCopy(arr,s+=((numToSkip=arr.length)-numToRetain),arr,dstOffset-=numToRetain,numToRetain);
            break;
          }
          int srcBound;
          switch(Integer.signum(srcBound=s-numToRetain)){
            default:
              //no overflow detected yet
              ArrCopy.uncheckedCopy(arr,srcBound,arr,dstOffset-=numToRetain,numToRetain);
              if(dstOffset==dstBound){
                return;
              }
              s=srcBound;
              word<<=numToRetain;
              continue;
            case -1:
              //the source bound overflowed, so wrap around
              ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-s,s);
              ArrCopy.uncheckedCopy(arr,s=(numToSkip=arr.length)+srcBound,arr,dstOffset-=numToRetain,-srcBound);
              break;
            case 0:
              //the source bound goes right down to zero, so the next skip will overflow
              ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-=numToRetain,numToRetain);
              s=numToSkip=arr.length;
          }
          break;
        }
        if(dstOffset!=dstBound){
          for(srcOffset+=numToSkip,word<<=numToRetain;;){
            while((numToSkip=Long.numberOfLeadingZeros(word))!=64){
              ArrCopy.uncheckedCopy(arr,s-=(numToSkip+(numToRetain=Long.numberOfLeadingZeros(~(word<<=numToSkip)))),arr,dstOffset-=numToRetain,numToRetain);
              if(dstOffset==dstBound){
                //the end has been reached
                return;
              }else if(numToRetain==64){
                //corner case. when all 64 elements of a word have been copied, skip to the next word
                break;
              }
              word<<=numToRetain;
            }
            s=srcOffset;
            srcOffset-=64;
            word=survivorSet[--wordOffset];
          }
        }
      }
      private void fragmentedPullSurvivorsUp($ArrayType$[] arr,int dstOffset,int numToSkip,int dstBound){
        int wordOffset,s;
        long[] survivorSet;
        long word=(survivorSet=this.survivorSet)[wordOffset=numToSkip>>6]<<(-(numToSkip+1));
        int srcOffset=(s=dstOffset-1)-(((numToSkip)&63)+1);
        int arrLength=arr.length;
        headCopy: for(;;){
          tailToTailCopy: while((numToSkip=Long.numberOfLeadingZeros(word))!=64){
            if((s-=numToSkip)>0){
              int srcBound;
              headToTailCopy: switch(Integer.signum(srcBound=s-(numToSkip=Long.numberOfLeadingZeros(~(word<<=numToSkip))))){
                default:
                  //no overflow detected
                  ArrCopy.uncheckedCopy(arr,s=srcBound,arr,dstOffset-=numToSkip,numToSkip);
                  if(numToSkip==64){
                    break tailToTailCopy;
                  }
                  word<<=numToSkip;
                  continue;
                case -1:
                  //source bound overflow detected
                  //check if dst overflowed as well
                  int dBound;
                  switch(Integer.signum(dBound=dstOffset-numToSkip)){
                    default:
                      //no dst overflow detected
                      ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-s,s);
                      ArrCopy.uncheckedCopy(arr,s=arrLength+srcBound,arr,dstOffset=dBound,-srcBound);
                      break headToTailCopy;
                    case -1:
                      //dst overflow detected
                      ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-s,s);
                      ArrCopy.uncheckedCopy(arr,s=arrLength+(srcBound-=dBound),arr,0,-srcBound);
                      ArrCopy.uncheckedCopy(arr,s+=dBound,arr,dstOffset=arrLength+dBound,-dBound);
                      if(dstOffset==dstBound){
                        return;
                      }
                      break;
                    case 0:
                      //dst bound goes down to zero. The next copy will overflow
                      ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-s,s);
                      ArrCopy.uncheckedCopy(arr,s=arrLength+srcBound,arr,0,-srcBound);
                      dstOffset=arrLength;
                  }
                  srcOffset+=arrLength;
                  break headCopy;
                case 0:
                  //source bound goes right to zero. The next skip will overflow
                  ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-=numToSkip,numToSkip);
                  s=arrLength;
              }
              srcOffset+=arrLength;
              if(numToSkip==64 
              || (numToSkip=Long.numberOfLeadingZeros(word<<=numToSkip))==64){
                do{
                  s=srcOffset;
                  srcOffset-=64;
                  word=survivorSet[--wordOffset];
                }while((numToSkip=Long.numberOfLeadingZeros(word))==64);
              }
              s-=numToSkip;
            }else{
              s+=arrLength;
              srcOffset+=arrLength;
            }
            for(;;){
              int dBound;
              switch(Integer.signum(dBound=dstOffset-(numToSkip=Long.numberOfLeadingZeros(~(word<<=numToSkip))))){
                default:
                  //no dst overflow detected yet
                  ArrCopy.uncheckedCopy(arr,s-=numToSkip,arr,dstOffset=dBound,numToSkip);
                  if(numToSkip==64 ||
                  (numToSkip=Long.numberOfLeadingZeros(word<<=numToSkip))==64){
                    do{
                      s=srcOffset;
                      srcOffset-=64;
                      word=survivorSet[--wordOffset];
                    }while((numToSkip=Long.numberOfLeadingZeros(word))==64);
                  }
                  s-=numToSkip;
                  continue;
                case -1:
                  //dst overflow detected
                  ArrCopy.uncheckedCopy(arr,s-dstOffset,arr,0,dstOffset);
                  ArrCopy.uncheckedCopy(arr,s-=numToSkip,arr,dstOffset=arrLength+dBound,-dBound);
                  if(dstOffset==dstBound){
                    return;
                  }
                  break;
                case 0:
                  //dst bound goes right to zero, so the next copy will overflow
                  ArrCopy.uncheckedCopy(arr,s-=numToSkip,arr,0,numToSkip);
                  dstOffset=arrLength;
              }
              break headCopy;
            }
          }
          s=srcOffset;
          srcOffset-=64;
          word=survivorSet[--wordOffset];
        }
        do{
          if(numToSkip==64 || (numToSkip=Long.numberOfLeadingZeros(word<<=numToSkip))==64){
            do{
              s=srcOffset;
              srcOffset-=64;
              word=survivorSet[--wordOffset];
            }while((numToSkip=Long.numberOfLeadingZeros(word))==64);
          }
          ArrCopy.uncheckedCopy(arr,s-=(numToSkip+(numToSkip=Long.numberOfLeadingZeros(~(word<<=numToSkip)))),arr,dstOffset-=numToSkip,numToSkip);
        }while(dstOffset!=dstBound);
      }
      private void fragmentedPullSurvivorsDown($ArrayType$[] arr,int dstOffset,int numToSkip,int dstBound){
        int wordOffset,s;
        long[] survivorSet;
        long word=(survivorSet=this.survivorSet)[wordOffset=numToSkip>>6]>>>numToSkip;
        int srcOffset=(s=dstOffset+1)+(((-numToSkip)-1)&63)+1;
        int arrLength=arr.length;
        tailCopy: for(;;){
          headToHeadCopy: while((numToSkip=Long.numberOfTrailingZeros(word))!=64){
            int srcOverflow;
            if((srcOverflow=(s+=numToSkip)-arrLength)<0){
              int srcBound;
              tailToHeadCopy: switch(Integer.signum(srcOverflow=(srcBound=s+(numToSkip=Long.numberOfTrailingZeros(~(word>>>=numToSkip))))-arrLength)){
                default:
                  //no overflow detected
                  ArrCopy.uncheckedSelfCopy(arr,dstOffset,s,numToSkip);
                  dstOffset+=numToSkip;
                  if(numToSkip==64){
                    break headToHeadCopy;
                  }
                  s+=numToSkip;
                  word>>>=numToSkip;
                  continue;
                case 1:
                  //source bound overflow detected
                  //check if dst overflowed as well
                  int dBound,dstOverflow;
                  switch(Integer.signum(dstOverflow=(dBound=dstOffset+numToSkip)-arrLength)){
                    default:
                      //no dst overflow detected
                      ArrCopy.uncheckedSelfCopy(arr,dstOffset,s,srcBound=numToSkip-srcOverflow);
                      ArrCopy.uncheckedCopy(arr,0,arr,dstOffset+srcBound,s=srcOverflow);
                      dstOffset=dBound;
                      break tailToHeadCopy;
                    case 1:
                      //dst overflow detected
                      ArrCopy.uncheckedSelfCopy(arr,dstOffset,s,srcBound=numToSkip-srcOverflow);
                      ArrCopy.uncheckedCopy(arr,0,arr,dstOffset+srcBound,srcBound=srcOverflow-dstOverflow);
                      ArrCopy.uncheckedSelfCopy(arr,0,srcBound,dstOverflow);
                      if(dstOverflow==dstBound){
                        return;
                      }
                      s=srcBound+(dstOffset=dstOverflow);
                      break;
                    case 0:
                      //dst bound goes right up to array length. THe next copy will overflow
                      ArrCopy.uncheckedSelfCopy(arr,dstOffset,s,srcBound=numToSkip-srcOverflow);
                      ArrCopy.uncheckedCopy(arr,0,arr,dstOffset+srcBound,s=srcOverflow);
                      dstOffset=0;
                  }
                  srcOffset-=arrLength;
                  break tailCopy;
                case 0:
                  //source bound goes right up to arrLength, the next skip will overflow
                  ArrCopy.uncheckedSelfCopy(arr,dstOffset,s,numToSkip);
                  s=0;
                  dstOffset+=numToSkip;
              }
              srcOffset-=arrLength;
              if(numToSkip==64 
              || (numToSkip=Long.numberOfTrailingZeros(word>>>=numToSkip))==64){
                do{
                  s=srcOffset;
                  srcOffset+=64;
                  word=survivorSet[++wordOffset];
                }while((numToSkip=Long.numberOfTrailingZeros(word))==64);
              }
              s+=numToSkip;
            }else{
              s-=arrLength;
              srcOffset-=arrLength;
            }
            for(;;){
              int dBound,dstOverflow;
              switch(Integer.signum(dstOverflow=(dBound=dstOffset+(numToSkip=Long.numberOfTrailingZeros(~(word>>>=numToSkip))))-arrLength)){
                default:
                  //no dst overflow detected yet
                  ArrCopy.uncheckedCopy(arr,s,arr,dstOffset,numToSkip);
                  s+=numToSkip;
                  dstOffset=dBound;
                  if(numToSkip==64 ||
                   (numToSkip=Long.numberOfTrailingZeros(word>>>=numToSkip))==64){
                    do{
                      s=srcOffset;
                      srcOffset+=64;
                      word=survivorSet[++wordOffset];
                    }
                    while((numToSkip=Long.numberOfTrailingZeros(word))==64);
                  }
                  s+=numToSkip;
                  continue;
                case 1:
                  //dst overflow detected
                  ArrCopy.uncheckedCopy(arr,s,arr,dstOffset,dBound=numToSkip-dstOverflow);
                  ArrCopy.uncheckedSelfCopy(arr,0,s+dBound,dstOverflow);
                  if(dstOverflow==dstBound){
                    return;
                  }
                  dstOffset=dstOverflow;
                  break;
                case 0:
                  //dst bound goes right to the array length,so the next copy will overflow
                  ArrCopy.uncheckedCopy(arr,s,arr,dstOffset,numToSkip);
                  dstOffset=0;
              }
              s+=numToSkip;
              break tailCopy;
            }
          }
          s=srcOffset;
          srcOffset+=64;
          word=survivorSet[++wordOffset];
        }
        for(;;){
          if(numToSkip==64 || 
          (numToSkip=Long.numberOfTrailingZeros(word>>>=numToSkip))==64){
            do{
              s=srcOffset;
              srcOffset+=64;
              word=survivorSet[++wordOffset];
            }while((numToSkip=Long.numberOfTrailingZeros(word))==64);
          }
          ArrCopy.uncheckedSelfCopy(arr,dstOffset,s+=numToSkip,numToSkip=Long.numberOfTrailingZeros(~(word>>>=numToSkip)));
          if((dstOffset+=numToSkip)==dstBound){
            return;
          }
          s+=numToSkip;
        }
      }
      private void fragmentedPullSurvivorsDownToNonFragmented($ArrayType$[] arr,int dstOffset,int numToSkip,int dstBound){
        int wordOffset,s,numToRetain,srcOverflow;
        long[] survivorSet;
        long word=(survivorSet=this.survivorSet)[wordOffset=numToSkip>>6]>>>numToSkip;
        int srcOffset=(s=dstOffset+1)+(((-numToSkip)-1)&63)+1;
        int arrLength=arr.length;
        for(;;){
          if((numToSkip=Long.numberOfTrailingZeros(word))==64){
            //go to the next word
            s=srcOffset;
            srcOffset+=64;
            word=survivorSet[++wordOffset];
            continue;
          }else if((numToRetain=Long.numberOfTrailingZeros(~(word>>>=numToSkip)))==64){
            //corner case. When all 64 elements of a word are copied, deplete the word before continuing the copy
            word=0;
          }
          if((srcOverflow=(s+=numToSkip)-arrLength)>=0){
            //overflow detected on a skip
            ArrCopy.uncheckedCopy(arr,srcOverflow,arr,dstOffset,numToRetain);
            srcOverflow+=numToRetain;
            break;
          }
          int srcBound;
          switch(Integer.signum(srcOverflow=(srcBound=s+numToRetain)-arrLength)){
            default:
              //no overflow detected yet
              ArrCopy.uncheckedSelfCopy(arr,dstOffset,s,numToRetain);
              if((dstOffset+=numToRetain)==dstBound){
                //the end has been reached
                return;
              }
              s=srcBound;
              word>>>=numToRetain;
              continue;
            case 1:
              //the source bound overflowed, so wrap around
              ArrCopy.uncheckedSelfCopy(arr,dstOffset,s,srcBound=numToRetain-srcOverflow);
              ArrCopy.uncheckedCopy(arr,0,arr,dstOffset+srcBound,srcOverflow);
              break;
            case 0:
              //the source bound goes right up to arrLength, so the next skip will overflow
              ArrCopy.uncheckedSelfCopy(arr,dstOffset,s,numToRetain);
          }
          break;
        }
        if((dstOffset+=numToRetain)!=dstBound){
          for(srcOffset-=arrLength,word>>>=numToRetain;;){
            while((numToSkip=Long.numberOfTrailingZeros(word))!=64){
              ArrCopy.uncheckedCopy(arr,srcOverflow+=numToSkip,arr,dstOffset,numToRetain=Long.numberOfTrailingZeros(~(word>>>=numToSkip)));
              if((dstOffset+=numToRetain)==dstBound){
                //the end has been reached
                return;
              }else if(numToRetain==64){
                //corner case. when all 64 elements of a word have been copied, skip to the next word
                break;
              }
              srcOverflow+=numToRetain;
              word>>>=numToRetain;
            }
            //go to the next word
            srcOverflow=srcOffset;
            srcOffset+=64;
            word=survivorSet[++wordOffset];
          }
        }
      }
      private void nonfragmentedPullSurvivorsUp($ArrayType$[] arr,int dstOffset,int numToSkip,int dstBound){
        int wordOffset;
        long[] survivorSet;
        long word=(survivorSet=this.survivorSet)[wordOffset=numToSkip>>6]<<(-(numToSkip+1));
        for(int s,srcOffset=(s=dstOffset-1)-(((numToSkip)&63)+1);;){
          while((numToSkip=Long.numberOfLeadingZeros(word))!=64){
            ArrCopy.uncheckedCopy(arr,s-=(numToSkip+(numToSkip=Long.numberOfLeadingZeros(~(word<<=numToSkip)))),arr,dstOffset-=numToSkip,numToSkip);
            if(dstOffset==dstBound){
              //the end has been reached
              return;
            }else if(numToSkip==64){
              //corner case. when all 64 elements of a word have been copied, skip to the next word
              break;
            }
            word<<=numToSkip;
          }
          //go to the next word
          word=survivorSet[--wordOffset];
          s=srcOffset;
          srcOffset-=64;
        }
      }
      private void nonfragmentedPullSurvivorsDown($ArrayType$[] arr,int dstOffset,int numToSkip,int dstBound){
        int wordOffset;
        long[] survivorSet;
        long word=(survivorSet=this.survivorSet)[wordOffset=numToSkip>>6]>>>numToSkip;
        for(int s=dstOffset+1,srcOffset=s+(((-numToSkip)-1)&63)+1;;){
          while((numToSkip=Long.numberOfTrailingZeros(word))!=64){
            ArrCopy.uncheckedSelfCopy(arr,dstOffset,s+=numToSkip,numToSkip=Long.numberOfTrailingZeros(~(word>>>=numToSkip)));
            if((dstOffset+=numToSkip)==dstBound){
              //the end has been reached
              return;
            }else if(numToSkip==64){
              //corner case. when all 64 elements of a word have been copied, skip to the next word
              break;
            }
            s+=numToSkip;
            word>>>=numToSkip;
          }
          //go to the next word
          word=survivorSet[++wordOffset];
          s=srcOffset;
          srcOffset+=64;
        }
      }
      @Override void nonfragmentedCollapse(int head,$ClassPrefix$ArrDeq$<E>$ deq,int tail){
        final var arr=deq.arr;
        int biggestRunBegin;
        int biggestRunEnd=(biggestRunBegin=this.biggestRunBegin)+this.biggestRunLength;
        int survivorsBeforeAndAfter;
        if((survivorsBeforeAndAfter=this.survivorsAfterBiggestRun)!=0){
          nonfragmentedPullSurvivorsDown(arr,biggestRunEnd,biggestRunEnd-head,biggestRunEnd+=survivorsBeforeAndAfter);
        }
        arr[biggestRunEnd]=arr[tail];
#IF OfRef
        if(biggestRunEnd!=tail){
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,biggestRunEnd+1);
        }
#ENDIF
        deq.tail=biggestRunEnd;
        if((survivorsBeforeAndAfter=this.survivorsBeforeBiggestRun)!=0){
          nonfragmentedPullSurvivorsUp(arr,biggestRunBegin,(biggestRunBegin-head)-3,biggestRunBegin-=survivorsBeforeAndAfter);
        }
        arr[--biggestRunBegin]=arr[head];
#IF OfRef
        if(biggestRunBegin!=head){
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,biggestRunBegin-1,head);
        }
#ENDIF
        deq.head=biggestRunBegin;
      }
    }
    private static class SmallCollapseData$<E>$ extends CollapseData$<E>${
      private static void fragmentedPullSurvivorsDownHelper($ArrayType$[] arr,int dstOffset,int srcOffset,long word){
        for(int arrLength=arr.length;;){
          //check to see if a dst bound overflow occurred
          int dstOverflow,numToRetain,dstBound;
          switch(Integer.signum(dstOverflow=(dstBound=dstOffset+(numToRetain=Long.numberOfTrailingZeros(~(word))))-arrLength)){
            default:
              //no dst bound overflow detected yet
              ArrCopy.uncheckedCopy(arr,srcOffset,arr,dstOffset,numToRetain);
              dstOffset=dstBound;
              srcOffset+=(numToRetain+(dstBound=Long.numberOfTrailingZeros(word>>>=numToRetain)));
              word>>>=dstBound;
              continue;
            case 0:
              //the dst bound goes right up to the array bound. The next copy will wrap
              ArrCopy.uncheckedCopy(arr,srcOffset,arr,dstOffset,numToRetain);
              dstBound=Long.numberOfTrailingZeros(word>>>=numToRetain);
              break;
            case 1:
              //dst bound overflow detected
              ArrCopy.uncheckedCopy(arr,srcOffset,arr,dstOffset,dstOffset=numToRetain-dstOverflow);
              ArrCopy.uncheckedSelfCopy(arr,0,srcOffset+dstOffset,dstOverflow);
              if((dstBound=Long.numberOfTrailingZeros(word>>>=numToRetain))==64){
                return;
              }
          }
          finalizeNonfragmentedPullDown(arr,dstOverflow,srcOffset+numToRetain+dstBound,word>>>dstBound);
          return;
        }
      }
      private static void fragmentedPullSurvivorsUpHelper($ArrayType$[] arr,int dstOffset,int srcOffset,long word)
      {
        for(;;)
        {
          //check to see if dst bound overflow occurred
          int lead0s,dstBound;
          switch(Integer.signum(dstBound=dstOffset-(lead0s=Long.numberOfLeadingZeros(~word))))
          {
            default:
              //no dst bound overflow detected yet
               ArrCopy.uncheckedCopy(arr,srcOffset-=lead0s,arr,dstOffset=dstBound,lead0s);
               srcOffset-=(lead0s=Long.numberOfLeadingZeros(word<<=lead0s));
               word<<=lead0s;
               continue;
            case 0:
              //the dst bound goes right down to zero. The next copy will wrap
              ArrCopy.uncheckedCopy(arr,srcOffset-=lead0s,arr,0,lead0s);
              lead0s=Long.numberOfLeadingZeros(word<<=lead0s);
              dstOffset=arr.length;
              break;
            case -1:
              //dst bound overflow detected
              ArrCopy.uncheckedCopy(arr,srcOffset-dstOffset,arr,0,dstOffset);
              ArrCopy.uncheckedCopy(arr,srcOffset-=lead0s,arr,dstOffset=arr.length+dstBound,-dstBound);
              if((lead0s=Long.numberOfLeadingZeros(word<<=lead0s))==64)
              {
                return;
              }
          }
          finalizeNonfragmentedPullUp(arr,dstOffset,srcOffset-lead0s,word<<lead0s);
          return;
        }
      }
      private static void fragmentedPullSurvivorsDown($ArrayType$[] arr,int dstOffset,long word)
      {
        int numToSkip;
        for(int arrLength=arr.length,srcOffset=dstOffset+1+(numToSkip=Long.numberOfTrailingZeros(word));;)
        {
          int srcOverflow;
          if((srcOverflow=srcOffset-arrLength)>=0)
          {
            //the source offset overflowed on a skip
            fragmentedPullSurvivorsDownHelper(arr,dstOffset,srcOverflow,word>>>numToSkip);
            return;
          }
          int srcBound,numToRetain;
          switch(Integer.signum(srcOverflow=(srcBound=srcOffset+(numToRetain=Long.numberOfTrailingZeros(~(word>>>=numToSkip))))-arrLength))
          {
            default:
              //no overflow detected yet
              ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,numToRetain);
              dstOffset+=numToRetain;
              srcOffset=srcBound+(numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain));
              continue;
            case 1:
              //source bound overflowed, check to see if dst overflowed
              int dstOverflow;
              switch(Integer.signum(dstOverflow=(srcBound=dstOffset+numToRetain)-arrLength))
              {
                default:
                  //no dst overflow detected
                  ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,dstOverflow=numToRetain-srcOverflow);
                  ArrCopy.uncheckedCopy(arr,0,arr,dstOffset+dstOverflow,srcOverflow);
                  fragmentedPullSurvivorsDownHelper(arr,srcBound,srcOverflow+(numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain)),word>>>numToSkip);
                  return;
                case 1:
                  //dst overflow detected
                  ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,srcBound=numToRetain-srcOverflow);
                  ArrCopy.uncheckedCopy(arr,0,arr,dstOffset+srcBound,srcBound=srcOverflow-dstOverflow);
                  ArrCopy.uncheckedSelfCopy(arr,0,srcBound,dstOverflow);
                  if((numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain))==64)
                  {
                    return;
                  }
                  break;
                case 0:
                  //dst bound goes right up to the end, next copy will overflow
                  ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,srcBound=numToRetain-srcOverflow);
                  ArrCopy.uncheckedCopy(arr,0,arr,dstOffset+srcBound,srcOverflow);
                  numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain);
              }
              finalizeNonfragmentedPullDown(arr,dstOverflow,srcOverflow+numToSkip,word>>>numToSkip);
              return;
            case 0:
              //the source bound goes right up to arrLength, so the next skip will overflow
              ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,numToRetain);
              fragmentedPullSurvivorsDownHelper(arr,dstOffset+numToRetain,numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain),word>>>numToSkip);
              return;
          }
        }
      }
      private static void fragmentedPullSurvivorsUp($ArrayType$[] arr,int dstOffset,long word)
      {
        int lead0s;
        for(int srcOffset=dstOffset-1-(lead0s=Long.numberOfLeadingZeros(word));;)
        {
          if(srcOffset<=0)
          {
            //the source offset overflowed on a skip
            fragmentedPullSurvivorsUpHelper(arr,dstOffset,srcOffset+arr.length,word<<lead0s);
            return;
          }
          int srcBound;
          switch(Integer.signum(srcBound=srcOffset-(lead0s=Long.numberOfLeadingZeros(~(word<<=lead0s)))))
          {
            default:
              //no overflow detected yet
              ArrCopy.uncheckedCopy(arr,srcBound,arr,dstOffset-=lead0s,lead0s);
              srcOffset=srcBound-(lead0s=Long.numberOfLeadingZeros(word<<=lead0s));
              continue;
            case -1:
              //the source bound overflowed, check to see if dst overflowed
              int dstBound;
              switch(Integer.signum(dstBound=dstOffset-lead0s))
              {
                default:
                  //no dst overflow detected
                  ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-srcOffset,srcOffset);
                  ArrCopy.uncheckedCopy(arr,srcOffset=arr.length+srcBound,arr,dstBound,-srcBound);
                  fragmentedPullSurvivorsUpHelper(arr,dstBound,srcOffset-(lead0s=Long.numberOfLeadingZeros(word<<=lead0s)),word<<lead0s);
                  return;
                case -1:
                  //dst overflow detected
                  ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-srcOffset,srcOffset);
                  ArrCopy.uncheckedCopy(arr,srcOffset=(dstOffset=arr.length)-(srcBound=dstBound-srcBound),arr,0,srcBound);
                  ArrCopy.uncheckedCopy(arr,srcOffset+=dstBound,arr,dstOffset+=dstBound,-dstBound);
                  if((lead0s=Long.numberOfLeadingZeros(word<<=lead0s))==64)
                  {
                    return;
                  }
                  break;
                case 0:
                  //the dst bound goes right to zero, so the next copy will wrap
                  ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-srcOffset,srcOffset);
                  ArrCopy.uncheckedCopy(arr,srcOffset=(dstOffset=arr.length)+srcBound,arr,0,-srcBound);
                  lead0s=Long.numberOfLeadingZeros(word<<=lead0s);
                  break;
              }
              finalizeNonfragmentedPullUp(arr,dstOffset,srcOffset-=lead0s,word<<lead0s);
              return;
            case 0:
              //the source bound goes right to zero, so the next skip will overflow
              ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-=lead0s,lead0s);
              fragmentedPullSurvivorsUpHelper(arr,dstOffset,arr.length-(lead0s=Long.numberOfLeadingZeros(word<<=lead0s)),word<<lead0s);
              return;
          }
        }
      }
      private static void fragmentedPullSurvivorsDownToNonFragmented($ArrayType$[] arr,int dstOffset,long word){
        int numToRetain,srcOverflow,numToSkip;
        for(int arrLength=arr.length,srcOffset=dstOffset+1+(numToSkip=Long.numberOfTrailingZeros(word));;)
        {
          numToRetain=Long.numberOfTrailingZeros(~(word>>>=numToSkip));
          if((srcOverflow=srcOffset-arrLength)>=0)
          {
            //the source offset overflowed on a skip
            ArrCopy.uncheckedCopy(arr,srcOverflow,arr,dstOffset,numToRetain);
            srcOverflow+=numToRetain;
            break;
          }
          int srcBound;
          switch(Integer.signum(srcOverflow=(srcBound=srcOffset+numToRetain)-arrLength))
          {
            default:
              //no overflow detected yet
              ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,numToRetain);
              if((numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain))==64)
              {
                return;
              }
              dstOffset+=numToRetain;
              srcOffset=srcBound+numToSkip;
              continue;
            case 1:
              //the source bound overflowed, so wrap around
              ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,srcBound=numToRetain-srcOverflow);
              ArrCopy.uncheckedCopy(arr,0,arr,dstOffset+srcBound,srcOverflow);
              break;
            case 0:
              //the source bound goes right up to arrLength, so the next skip will overflow
              ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,numToRetain);
          }
          break;
        }
        if((numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain))!=64)
        {
          finalizeFragmentedPullDown(arr,dstOffset+numToRetain,srcOverflow+numToSkip,word>>>numToSkip);
        }
      }
      private static void fragmentedPullSurvivorsUpToNonFragmented($ArrayType$[] arr,int dstOffset,long word)
      {
        int lead0s,srcOffset;
        for(srcOffset=dstOffset-1-(lead0s=Long.numberOfLeadingZeros(word));;)
        {
          lead0s=Long.numberOfLeadingZeros(~(word<<=lead0s));
          if(srcOffset<=0)
          {
            //the source offset overflowed on a kip
            ArrCopy.uncheckedCopy(arr,srcOffset+=(arr.length-lead0s),arr,dstOffset-=lead0s,lead0s);
            break;
          }
          int srcBound;
          switch(Integer.signum(srcBound=srcOffset-lead0s))
          {
            default:
              //no overflow detected yet
              ArrCopy.uncheckedCopy(arr,srcBound,arr,dstOffset-=lead0s,lead0s);
              if((lead0s=Long.numberOfLeadingZeros(word<<=lead0s))==64)
              {
                return;
              }
              srcOffset=srcBound-lead0s;
              continue;
            case -1:
              //the source bound overflowed, so wrap around
              ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-srcOffset,srcOffset);
              ArrCopy.uncheckedCopy(arr,srcOffset=arr.length+srcBound,arr,dstOffset-=lead0s,-srcBound);
              break;
            case 0:
              //the source bound goes right to zero, so the next skip will overflow
              ArrCopy.uncheckedCopy(arr,0,arr,dstOffset-=lead0s,lead0s);
              srcOffset=arr.length;
          }
          break;
        }
        if((lead0s=Long.numberOfLeadingZeros(word<<=lead0s))!=64)
        {
          finalizeFragmentedPullUp(arr,dstOffset,srcOffset-lead0s,word<<lead0s);
        }
      }
      private static void finalizeNonfragmentedPullUp($ArrayType$[] arr,int dstOffset,int srcOffset,long word){
        for(;;){
          int lead0s;
          ArrCopy.uncheckedCopy(arr,srcOffset-=(lead0s=Long.numberOfLeadingZeros(~word)),arr,dstOffset-=lead0s,lead0s);
          if((lead0s=Long.numberOfLeadingZeros(word<<=lead0s))==64)
          {
            return;
          }
          srcOffset-=lead0s;
          word<<=lead0s;
        }
      }
      private static void finalizeNonfragmentedPullDown($ArrayType$[] arr,int dstOffset,int srcOffset,long word){
        for(;;){
          int numToRetain;
          ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,numToRetain=Long.numberOfTrailingZeros(~word));
          int numToSkip;
          if((numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain))==64){
            return;
          }
          srcOffset+=(numToSkip+numToRetain);
          dstOffset+=numToRetain;
          word>>>=numToSkip;
        }
      }
      private static void finalizeFragmentedPullDown($ArrayType$[] arr,int dstOffset,int srcOffset,long word){
        for(;;){
          int numToRetain;
          ArrCopy.uncheckedCopy(arr,srcOffset,arr,dstOffset,numToRetain=Long.numberOfTrailingZeros(~word));
          int numToSkip;
          if((numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain))==64){
            return;
          }
          srcOffset+=(numToSkip+numToRetain);
          dstOffset+=numToRetain;
          word>>>=numToSkip;
        }
      }
      private static void finalizeFragmentedPullUp($ArrayType$[] arr,int dstOffset,int srcOffset,long word)
      {
        for(;;)
        {
          int lead0s;
          ArrCopy.uncheckedCopy(arr,srcOffset-=(lead0s=Long.numberOfLeadingZeros(~word)),arr,dstOffset-=lead0s,lead0s);
          if((lead0s=Long.numberOfLeadingZeros(word<<=lead0s))==64)
          {
            return;
          }
          srcOffset-=lead0s;
          word<<=lead0s;
        }
      }
      private static void nonfragmentedPullSurvivorsDown($ArrayType$[] arr,int dstOffset,long word){
        int numToSkip;
        for(int srcOffset=dstOffset+1+(numToSkip=Long.numberOfTrailingZeros(word));;)
        {
          int numToRetain;
          ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset,numToRetain=Long.numberOfTrailingZeros(~(word>>>=numToSkip)));
          if((numToSkip=Long.numberOfTrailingZeros(word>>>=numToRetain))==64){
            return;
          }
          dstOffset+=numToRetain;
          srcOffset+=(numToSkip+numToRetain);
        }
      }
      private static void nonfragmentedPullSurvivorsUp($ArrayType$[] arr,int dstOffset,long word)
      {
        int lead0s;
        for(int srcOffset=dstOffset-1-(lead0s=Long.numberOfLeadingZeros(word));;)
        {
          ArrCopy.uncheckedCopy(arr,srcOffset-=(lead0s=Long.numberOfLeadingZeros(~(word<<=lead0s))),arr,dstOffset-=lead0s,lead0s);
          if((lead0s=Long.numberOfLeadingZeros(word<<=lead0s))==64)
          {
            return;
          }
          srcOffset-=lead0s;
        }
      }
      final long survivorWord;
      #MACRO SuppressUnchecked()
      SmallCollapseData($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
        #MACRO Assert(head>=0)
        #MACRO Assert(tail+1-head<=64)
        int survivorsBeforeBiggestRun=0,survivorsAfterBiggestRun=0,currentRunLength=0,currentRunBegin=0,biggestRunLength=0,biggestRunBegin=0;
        for(long word=0L,marker=1L;;++head,marker<<=1){
          if(filter.test(($exposedType$)arr[head])){
            currentRunLength=0;
          }else{
            word|=marker;
            if(currentRunLength==0){
              currentRunBegin=head;
            }
            if(currentRunLength==biggestRunLength){
              survivorsBeforeBiggestRun+=survivorsAfterBiggestRun;
              survivorsAfterBiggestRun=0;
              biggestRunBegin=currentRunBegin;
              biggestRunLength=++currentRunLength;
            }else{
              ++currentRunLength;
              ++survivorsAfterBiggestRun;
            }
          }
          if(head==tail){
            this.survivorWord=word;
            this.biggestRunBegin=biggestRunBegin;
            this.biggestRunLength=biggestRunLength;
            this.survivorsBeforeBiggestRun=survivorsBeforeBiggestRun;
            this.survivorsAfterBiggestRun=survivorsAfterBiggestRun;
            return;
          }
        }
      }
      #MACRO SuppressUnchecked()
      SmallCollapseData($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter,int arrBound){
        #MACRO Assert(tail<head)
        #MACRO Assert(tail>=0)
        #MACRO Assert(head<=arrBound)
        #MACRO Assert(tail-head+arrBound<=64)
        int survivorsBeforeBiggestRun=0,survivorsAfterBiggestRun=0,currentRunLength=0,currentRunBegin=0,biggestRunLength=0,biggestRunBegin=0;
        for(long word=0L,marker=1L;;++head,marker<<=1){
          if(head==arrBound){
            for(head=0;;++head,marker<<=1){
              if(head==tail){
                this.survivorWord=word;
                this.biggestRunBegin=biggestRunBegin;
                this.biggestRunLength=biggestRunLength;
                this.survivorsBeforeBiggestRun=survivorsBeforeBiggestRun;
                this.survivorsAfterBiggestRun=survivorsAfterBiggestRun;
                return;
              }
              if(filter.test(($exposedType$)arr[head])){
                currentRunLength=0;
              }else{
                word|=marker;
                if(currentRunLength==0){
                  currentRunBegin=head;
                }
                if(currentRunLength==biggestRunLength){
                  survivorsBeforeBiggestRun+=survivorsAfterBiggestRun;
                  survivorsAfterBiggestRun=0;
                  biggestRunBegin=currentRunBegin;
                  biggestRunLength=++currentRunLength;
                }else{
                  ++currentRunLength;
                  ++survivorsAfterBiggestRun;
                }
              }
              
            }
          }
          if(filter.test(($exposedType$)arr[head])){
            currentRunLength=0;
          }else{
            word|=marker;
            if(currentRunLength==0){
              currentRunBegin=head;
            }
            if(currentRunLength==biggestRunLength){
              survivorsBeforeBiggestRun+=survivorsAfterBiggestRun;
              survivorsAfterBiggestRun=0;
              biggestRunBegin=currentRunBegin;
              biggestRunLength=++currentRunLength;
            }else{
              ++currentRunLength;
              ++survivorsAfterBiggestRun;
            }
          }
        }
      }
      
      @Override void fragmentedCollapseBiggestRunInTail(int head,$ClassPrefix$ArrDeq$<E>$ deq,int tail){
        int biggestRunBegin;
        int biggestRunEnd=(biggestRunBegin=this.biggestRunBegin)+this.biggestRunLength;
        $ArrayType$[] arr;
        int arrLength;
        int overflow=(arrLength=(arr=deq.arr).length)-head;
        int survivorsBeforeAndAfter;
        if((survivorsBeforeAndAfter=this.survivorsAfterBiggestRun)!=0)
        {
          nonfragmentedPullSurvivorsDown(arr,biggestRunEnd,this.survivorWord>>>(biggestRunEnd+overflow));
        }
#IF OfRef
        if((biggestRunEnd+=survivorsBeforeAndAfter)!=tail)
        {
          arr[biggestRunEnd]=arr[tail];
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,biggestRunEnd+1);
        }
#ELSE
        arr[biggestRunEnd+=survivorsBeforeAndAfter]=arr[tail];
#ENDIF
        deq.tail=biggestRunEnd;
        switch(Integer.signum(biggestRunEnd=biggestRunBegin-(survivorsBeforeAndAfter=this.survivorsBeforeBiggestRun)))
        {
          case 1:
            //no overflow detected
            if(survivorsBeforeAndAfter!=0)
            {
              if(overflow==1)
              {
                nonfragmentedPullSurvivorsUp(arr,biggestRunBegin,this.survivorWord<<(1-biggestRunBegin));
              }
              else
              {
                fragmentedPullSurvivorsUpToNonFragmented(arr,biggestRunBegin,this.survivorWord<<(2-(biggestRunBegin+overflow)));
              }
            }
#IF OfRef
            if(biggestRunEnd!=1)
            {
              OmniArray.Of$ClassPrefix$.nullifyRange(arr,biggestRunEnd-2,0);
            }
#ENDIF
            arr[--biggestRunEnd]=arr[head];
            
#IF OfRef
            --arrLength;
#ENDIF
            break;
          case 0:
            if(survivorsBeforeAndAfter!=0)
            {
              fragmentedPullSurvivorsUpToNonFragmented(arr,biggestRunBegin,this.survivorWord<<(2-(biggestRunBegin+overflow)));
            }
            
#IF OfRef
            arr[biggestRunEnd=--arrLength]=arr[head];
            --arrLength;
#ELSE
            arr[biggestRunEnd=arrLength-1]=arr[head];
#ENDIF
            break;
          default:
            if(biggestRunBegin==0)
            {
              nonfragmentedPullSurvivorsUp(arr,arrLength,this.survivorWord<<(2-overflow));
            }
            else
            {
              fragmentedPullSurvivorsUp(arr,biggestRunBegin,this.survivorWord<<(2-(biggestRunBegin+overflow)));
            }
            arr[biggestRunEnd+=(arrLength-1)]=arr[head];
#IF OfRef
            arrLength=biggestRunEnd-1;      
#ENDIF
        }
        deq.head=biggestRunEnd;
#IF OfRef
        if(head<=arrLength)
        {
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,arrLength,head);
        }
#ENDIF
      }
      @Override void fragmentedCollapseBiggestRunInHead(int head,final $ClassPrefix$ArrDeq$<E>$ deq,int tail){
        int overflow;
        int biggestRunEnd;
        int arrLength;
        int biggestRunBegin;
        $ArrayType$[] arr;
        int survivorsBeforeAndAfter=this.survivorsAfterBiggestRun;
        if((overflow=(biggestRunEnd=(biggestRunBegin=this.biggestRunBegin)+this.biggestRunLength)-(arrLength=(arr=deq.arr).length))>=0){
          if(survivorsBeforeAndAfter!=0){
            nonfragmentedPullSurvivorsDown(arr,overflow,this.survivorWord>>>(biggestRunEnd-head));
          }
#IF OfRef
          if((overflow+=survivorsBeforeAndAfter)!=tail){
            arr[overflow]=arr[tail];
            OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,overflow+1);
          }
#ELSE
          arr[overflow+=survivorsBeforeAndAfter]=arr[tail];
#ENDIF
        }else{
          int newTail;
          switch(Integer.signum(overflow=(newTail=biggestRunEnd+survivorsBeforeAndAfter)-arrLength)){
            case -1:
              if(survivorsBeforeAndAfter!=0){
                if(tail==0){
                  nonfragmentedPullSurvivorsDown(arr,biggestRunEnd,this.survivorWord>>>(biggestRunEnd-head));
                }else{
                  fragmentedPullSurvivorsDownToNonFragmented(arr,biggestRunEnd,this.survivorWord>>>(biggestRunEnd-head));
                }
              }
#IF OfRef
              if(newTail!=--arrLength){
                OmniArray.Of$ClassPrefix$.nullifyRange(arr,arrLength,newTail+1);
              }
#ENDIF
              arr[newTail]=arr[tail];
              overflow=newTail;
#IF OfRef
              newTail=0;
#ENDIF
              break;
            case 0:
              fragmentedPullSurvivorsDownToNonFragmented(arr,biggestRunEnd,this.survivorWord>>>(biggestRunEnd-head));             
              arr[0]=arr[tail];
#IF OfRef
              newTail=1;
#ENDIF
              break;
            default:
              fragmentedPullSurvivorsDown(arr,biggestRunEnd,this.survivorWord>>>(biggestRunEnd-head));
              arr[overflow]=arr[tail];
#IF OfRef
              newTail=overflow+1;
#ENDIF
          }
#IF OfRef
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,newTail);
#ENDIF
        }
        deq.tail=overflow;
        if((survivorsBeforeAndAfter=this.survivorsBeforeBiggestRun)!=0){
          nonfragmentedPullSurvivorsUp(arr,biggestRunBegin,this.survivorWord<<(2-(biggestRunBegin-head)));
        }
#IF OfRef
        if((biggestRunBegin-=(survivorsBeforeAndAfter+1))!=head){
          arr[biggestRunBegin]=arr[head];
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,biggestRunBegin-1,head);
        }
#ELSE
        arr[biggestRunBegin-=(survivorsBeforeAndAfter+1)]=arr[head];
#ENDIF
        deq.head=biggestRunBegin;
      }
      @Override void nonfragmentedCollapse(int head,$ClassPrefix$ArrDeq$<E>$ deq,int tail)
      {
        final var arr=deq.arr;
        int biggestRunBegin;
        int biggestRunEnd=(biggestRunBegin=this.biggestRunBegin)+this.biggestRunLength;
        int survivorsBeforeAndAfter;
        if((survivorsBeforeAndAfter=this.survivorsAfterBiggestRun)!=0){
          nonfragmentedPullSurvivorsDown(arr,biggestRunEnd,this.survivorWord>>>(biggestRunEnd-head));
        }
        arr[biggestRunEnd+=survivorsBeforeAndAfter]=arr[tail];
#IF OfRef
        if(biggestRunEnd!=tail){
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,biggestRunEnd+1);
        }
#ENDIF
        deq.tail=biggestRunEnd;
        if((survivorsBeforeAndAfter=this.survivorsBeforeBiggestRun)!=0){
          nonfragmentedPullSurvivorsUp(arr,biggestRunBegin,this.survivorWord<<(2-(biggestRunBegin-head)));
        }
        arr[biggestRunBegin-=(survivorsBeforeAndAfter+1)]=arr[head];
#IF OfRef
        if(biggestRunBegin!=head){
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,biggestRunBegin-1,head);
        }
#ENDIF
        deq.head=biggestRunBegin;
      }
    }
    private static abstract class CollapseData$<E>${
      int survivorsBeforeBiggestRun;
      int survivorsAfterBiggestRun;
      int biggestRunBegin;
      int biggestRunLength;
      abstract void fragmentedCollapseBiggestRunInHead(int head,$ClassPrefix$ArrDeq$<E>$ deq,int tail);
      abstract void fragmentedCollapseBiggestRunInTail(int head,$ClassPrefix$ArrDeq$<E>$ deq,int tail);
      abstract void nonfragmentedCollapse(int head,$ClassPrefix$ArrDeq$<E>$ deq,int tail);
      private int getNumSurvivors(){
        return this.survivorsBeforeBiggestRun+this.biggestRunLength+this.survivorsAfterBiggestRun;
      }
    }
    private void collapseBodyHelper($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
      int numLeft,srcOffset;
      if((numLeft=tail-(srcOffset=head+1))!=0){
        CollapseData$<E>$ collapseData;
        if(numLeft>64){
          collapseData=new BigCollapseData$<E>$(arr,srcOffset,numLeft,filter);
        }else{
          collapseData=new SmallCollapseData$<E>$(arr,srcOffset,tail-1,filter);
        }
        CheckedCollection.checkModCount(modCount,this.modCount);
        int numSurvivors;
        if((numSurvivors=collapseData.getNumSurvivors())!=numLeft){
          if(numSurvivors==0){
            nonfragmentedCollapseAll(head,tail);
          }else{
            collapseData.nonfragmentedCollapse(head,this,tail);
          }
          return;
        }
      }else{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      this.head=head;
      this.tail=tail;
    }
    private void fragmentedCollapseAll(int head,int tail){
      this.tail=tail;
      final var arr=this.arr;
      if(tail==0){
        arr[tail=arr.length-1]=arr[head];
        this.head=tail;
#IF OfRef
        OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail-1,head);
#ENDIF
      }else{
        arr[--tail]=arr[head];
        this.head=tail;
#IF OfRef
        OmniArray.Of$ClassPrefix$.nullifyRange(arr,arr.length-1,head);
        if(tail!=0){
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail-1,0);
        }
#ENDIF
      }
    }
    private void nonfragmentedCollapseAll(int head,int tail){
      this.head=head;
      this.tail=++head;
      $ArrayType$[] arr;
      (arr=this.arr)[head]=arr[tail];
#IF OfRef
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head+1);
#ENDIF
    }
    private void fragmentedCollapseBodyHelper($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
      int numLeft,arrLength,srcOffset;
      if((numLeft=tail-(srcOffset=head+1)+(arrLength=arr.length))!=0){
        CollapseData$<E>$ collapseData;
        if(numLeft>64){
          collapseData=new BigCollapseData$<E>$(arr,srcOffset,numLeft,filter,arrLength);
        }else{
          collapseData=new SmallCollapseData$<E>$(arr,srcOffset,tail,filter,arrLength);
        }
        CheckedCollection.checkModCount(modCount,this.modCount);
        int numSurvivors;
        if((numSurvivors=collapseData.getNumSurvivors())!=numLeft){
          if(numSurvivors==0){
            fragmentedCollapseAll(head,tail);
          }else{
            if(collapseData.biggestRunBegin>head){
              collapseData.fragmentedCollapseBiggestRunInHead(head,this,tail);
            }else{
              collapseData.fragmentedCollapseBiggestRunInTail(head,this,tail);
            }
          }
          return;
        }
      }else{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      this.head=head;
      this.tail=tail;
    }
    private boolean collapseBody($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
      int numLeft,srcOffset;
      if((numLeft=tail-(srcOffset=head+1))!=0){
        CollapseData$<E>$ collapseData;
        if(numLeft>64){
          collapseData=new BigCollapseData$<E>$(arr,srcOffset,numLeft,filter);
        }else{
          collapseData=new SmallCollapseData$<E>$(arr,srcOffset,tail-1,filter);
        }
        CheckedCollection.checkModCount(modCount,this.modCount);
        int numSurvivors;
        if((numSurvivors=collapseData.getNumSurvivors())!=numLeft){
          if(numSurvivors==0){
            nonfragmentedCollapseAll(head,tail);
          }else{
            collapseData.nonfragmentedCollapse(head,this,tail);
          }
          this.modCount=modCount+1;
          return true;
        }
      }else{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      return false;
    }
    private boolean fragmentedCollapseBody($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
      int numLeft,arrLength,srcOffset;
      if((numLeft=tail-(srcOffset=head+1)+(arrLength=arr.length))!=0){
        CollapseData$<E>$ collapseData;
        if(numLeft>64){
          collapseData=new BigCollapseData$<E>$(arr,srcOffset,numLeft,filter,arrLength);
        }else{
          collapseData=new SmallCollapseData$<E>$(arr,srcOffset,tail,filter,arrLength);
        }
        CheckedCollection.checkModCount(modCount,this.modCount);
        int numSurvivors;
        if((numSurvivors=collapseData.getNumSurvivors())!=numLeft){
          if(numSurvivors==0){
            fragmentedCollapseAll(head,tail);
          }else{
            if(collapseData.biggestRunBegin>head){
              collapseData.fragmentedCollapseBiggestRunInHead(head,this,tail);
            }else{
              collapseData.fragmentedCollapseBiggestRunInTail(head,this,tail);
            }
          }
          this.modCount=modCount+1;
          return true;
        }
      }else{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      return false;
    }
    #MACRO SuppressUnchecked()
    private void fragmentedCollapseHeadAndTail($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
      int newTail=tail-1,newHead=head+1,bound=arr.length-1;
      for(;;--newTail){
        if(newTail==-1){
          for(;;++newHead){
            if(newHead>bound){
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.tail=-1;
              break;
            }else if(!filter.test(($exposedType$)arr[newHead])){
              collapsetailHelper(arr,newHead,filter,modCount);
              break;
            }
          }
          break;
        }else if(!filter.test(($exposedType$)arr[newTail])){
          for(;;++newHead){
            if(newHead>bound){
              collapseheadHelper(arr,newTail,filter,modCount);
              break;
            }else if(!filter.test(($exposedType$)arr[newHead])){
              fragmentedCollapseBodyHelper(arr,newHead,newTail,filter,modCount);
              break;
            }
          }
          break;
        }
      }
  #IF OfRef
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,newHead-1,head);
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,newTail+1);
  #ENDIF
    }
    #MACRO SuppressUnchecked()
    private void collapseHeadAndTail($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
      for(int headOffset=head+1;headOffset!=tail;++headOffset){
        if(!filter.test(($exposedType$)arr[headOffset])){
          for(int tailOffset=tail-1;tailOffset!=headOffset;--tailOffset){
            if(!filter.test(($exposedType$)arr[tailOffset])){
              collapseBodyHelper(arr,headOffset,tailOffset,filter,modCount);
  #IF OfRef
              OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,tailOffset+1);
              OmniArray.Of$ClassPrefix$.nullifyRange(arr,headOffset-1,head);
  #ENDIF
              return;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.head=headOffset;
          this.tail=headOffset;
  #IF OfRef
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,headOffset+1);
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,headOffset-1,head);
  #ENDIF
          return;
        }
      }
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.tail=-1;
  #IF OfRef
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head);
  #ENDIF
    }
#ENDIF
    #MACRO SuppressUnchecked()
    @Override boolean fragmentedRemoveIf(int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfBoolean
      final $ArrayType$[] arr;
      int trueCount=0,bound=(arr=this.arr).length;
      for(int i=head;;){
        if(arr[i]){
          ++trueCount;
        }
        if(++i==bound){
          for(i=0;;++i){
            if(arr[i]){
              ++trueCount;
            }
            if(i==tail){
              break;
            }
          }
          break;
        }
      }
      int modCount=this.modCount;
      try{
        if(trueCount!=0){
          if(trueCount!=(bound+=(tail-head+1))){
            head=(filter.test(true)?0b01:0b00)|(filter.test(false)?0b10:0b00);
            CheckedCollection.checkModCount(modCount,this.modCount);
            switch(head){
              case 0b00:
                return false;
              case 0b01:
                setRange(arr,bound-=(trueCount+1),false);
                this.tail=bound;
                this.head=0;
                break;
              case 0b10:
                setRange(arr,--trueCount,true);
                this.tail=trueCount;
                this.head=0;
                break;
              default:
                this.tail=-1;
            }
          }else{
            boolean removeTrue=filter.test(true);
            CheckedCollection.checkModCount(modCount,this.modCount);
            if(!removeTrue){
              return false;
            }
            this.tail=-1;
          }
        }else{
          boolean removeFalse=filter.test(false);
          CheckedCollection.checkModCount(modCount,this.modCount);
          if(!removeFalse){
             return false; 
          }
          this.tail=-1;
        }
        this.modCount=modCount+1;
        return true;
      }catch(ConcurrentModificationException e){
        throw e;
      }catch(RuntimeException e){
        throw CheckedCollection.checkModCount(modCount,this.modCount,e);
      }
      
#ELSE
      int modCount=this.modCount;
      try{
        final $ArrayType$[] arr;
        if(filter.test(($exposedType$)(arr=this.arr)[head])){
          if(filter.test(($exposedType$)arr[tail])){
            fragmentedCollapseHeadAndTail(arr,head,tail,filter,modCount);
          }else{
            fragmentedCollapsehead(arr,head,tail,filter,modCount);
          }
          this.modCount=modCount+1;
          return true;
        }else{
          if(filter.test(($exposedType$)arr[tail])){
            fragmentedCollapsetail(arr,head,tail,filter,modCount);
            this.modCount=modCount+1;
            return true;
          }
          return fragmentedCollapseBody(arr,head,tail,filter,modCount);
        }
      }catch(ConcurrentModificationException e){
        throw e;
      }catch(RuntimeException e){
        throw CheckedCollection.checkModCount(modCount,this.modCount,e);
      }
#ENDIF
    }
    #MACRO SuppressUnchecked()
    @Override boolean nonfragmentedRemoveIf(int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfBoolean
      final var arr=this.arr;
      int trueCount=0;
      for(int i=head;;++i){
        if(arr[i]){
          ++trueCount;
        }
        if(i==tail){
          break;
        }
      }
#ENDIF
      final int modCount=this.modCount;
      try{
#IF OfBoolean
        if(trueCount!=0){
          if(trueCount!=(tail-=(head-1))){
            head=(filter.test(true)?0b01:0b00)|(filter.test(false)?0b10:0b00);
            CheckedCollection.checkModCount(modCount,this.modCount);
            switch(head){
              case 0b00:
                return false;
              case 0b01:
                setRange(arr,tail-=(trueCount+1),false);
                this.tail=tail;
                this.head=0;
                break;
              case 0b10:
                setRange(arr,--trueCount,true);
                this.tail=trueCount;
                this.head=0;
                break;
              default:
                this.tail=-1;
            }
          }else{
            boolean removeTrue=filter.test(true);
            CheckedCollection.checkModCount(modCount,this.modCount);
            if(!removeTrue){
               return false; 
            }
            this.tail=-1;
          }
        }else{
          boolean removeFalse=filter.test(false);
          CheckedCollection.checkModCount(modCount,this.modCount);
          if(!removeFalse){
             return false; 
          }
          this.tail=-1;
        }
        this.modCount=modCount+1;
        return true;
#ELSE
        final $ArrayType$[] arr;
        if(filter.test(($exposedType$)(arr=this.arr)[head])){
          if(head==tail){
            CheckedCollection.checkModCount(modCount,this.modCount);
  #IF OfRef
            arr[tail]=null;
  #ENDIF
            this.tail=-1;
          }else if(filter.test(($exposedType$)arr[tail])){
            collapseHeadAndTail(arr,head,tail,filter,modCount);
          }else{
            collapsehead(arr,head,tail,filter,modCount);
          }
          this.modCount=modCount+1;
          return true;
        }else if(head!=tail){
          if(filter.test(($exposedType$)arr[tail])){
            collapsetail(arr,head,tail,filter,modCount);
            this.modCount=modCount+1;
            return true;
          }
          return collapseBody(arr,head,tail,filter,modCount);
        }
#ENDIF
      }catch(ConcurrentModificationException e){
        throw e;
      }catch(RuntimeException e){
        throw CheckedCollection.checkModCount(modCount,this.modCount,e);
      }
#IFNOT OfBoolean
      CheckedCollection.checkModCount(modCount,this.modCount);
      return false;
#ENDIF
    }
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      return new AscendingItr$<E>$(this);
    }
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ descendingIterator(){
      return new DescendingItr$<E>$(this);
    }
    private static class AscendingItr$<E>$ extends AbstractDeqItr$<E>${
      transient int modCount;
      transient int lastRet;
      transient final Checked$<E>$ root;
      private AscendingItr(AscendingItr$<E>$ itr){
        super(itr);
        this.modCount=itr.modCount;
        this.lastRet=itr.lastRet;
        this.root=itr.root;
      }
      private AscendingItr(Checked$<E>$ root){
        super(root.tail==-1?-1:root.head);
        this.root=root;
        this.modCount=root.modCount;
        this.lastRet=-1;
      }
      private AscendingItr(Checked$<E>$ root,int cursor){
        super(cursor);
        this.root=root;
        this.modCount=root.modCount;
        this.lastRet=-1;
      }
      @Override public Object clone(){
        return new AscendingItr$<E>$(this);
      }
      #MACRO SuppressUnchecked()
      @Override public $exposedType$ next$TypeNameModifier$(){
        final Checked$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        int cursor;
        if((cursor=this.cursor)!=-1){
          final $ArrayType$[] arr;
          final var ret=($exposedType$)(arr=root.arr)[cursor];
          this.lastRet=cursor;
          if(cursor==root.tail){
            cursor=-1;
          }else if(++cursor==arr.length){
            cursor=0;
          }
          this.cursor=cursor;
          return ret;
        }
        throw new NoSuchElementException();
      }
      private void fragmentedAscendingRemove(int head,int lastRet,int tail,$ClassPrefix$ArrDeq$<E>$ root){
        $ArrayType$[] arr;
        int headDist,tailDist,arrBound=(arr=root.arr).length-1;
        if((headDist=lastRet-head)>=0){
          //index to remove is in head run
          if(headDist<=(tailDist=arrBound-lastRet)+tail+1){
            if(headDist==0){
              if(tailDist==0){
                root.head=0;
              }
              else{
                root.head=head+1;
              }
#IF OfRef
              arr[head]=null;
#ENDIF
            }else{
#IF OfRef
              ArrCopy.uncheckedCopy(arr,tail=head,arr,++head,headDist);
              arr[tail]=null;
#ELSE
              ArrCopy.uncheckedCopy(arr,head,arr,++head,headDist);
#ENDIF
              root.head=head;
            }
          }else{
            ArrCopy.semicheckedSelfCopy(arr,lastRet,lastRet+1,tailDist);
            arr[arrBound]=arr[0];
            root.tail=fragmentedPullDown(arr,arrBound,tail);
            this.cursor=lastRet;
          }
        }else{
          if((tailDist=tail-lastRet)<=(headDist=arrBound-head)+lastRet+1){
            if(tailDist==0){
              if(lastRet==0){
                root.tail=arrBound;
              }else{
                root.tail=tail-1;
              }
            }else{
              ArrCopy.uncheckedSelfCopy(arr,lastRet,lastRet+1,tailDist);
              root.tail=tail-1;
              this.cursor=lastRet;
            }
#IF OfRef
            arr[tail]=null;
#ENDIF
          }else{
            ArrCopy.semicheckedCopy(arr,0,arr,1,lastRet);
            arr[0]=arr[arrBound];
            root.head=fragmentedPullUp(arr,head,headDist);
          }
        }
      }
      private void nonfragmentedAscendingRemove(int head,int lastRet,int tail,$ClassPrefix$ArrDeq$<E>$ root){
        int headDist,tailDist;
        if((headDist=lastRet-head)<=(tailDist=tail-lastRet)){
          root.head=pullUp(root.arr,head,headDist);
        }else{
#IF OfRef
          if(tailDist==0){
            root.arr[tail]=null;
          }else
#ELSE
          if(tailDist!=0)
#ENDIF
          {
#IF OfRef
            $ArrayType$[] arr;
            ArrCopy.uncheckedSelfCopy(arr=root.arr,lastRet,lastRet+1,tailDist);
            arr[tail]=null;
#ELSE
            ArrCopy.uncheckedSelfCopy(root.arr,lastRet,lastRet+1,tailDist);
#ENDIF
            this.cursor=lastRet;
          }
          root.tail=tail-1;
        }
      }
      @Override public void remove(){
        int lastRet;
        if((lastRet=this.lastRet)!=-1){
          int modCount;
          final Checked$<E>$ root;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          root.modCount=++modCount;
          this.modCount=modCount;
          final int head,tail;
          switch(Integer.signum((tail=root.tail)-(head=root.head))){
            case -1:
              fragmentedAscendingRemove(head,lastRet,tail,root);
              break;
            case 0:
              root.tail=-1;
#IF OfRef
              root.arr[tail]=null;
#ENDIF
              break;
            default:
              nonfragmentedAscendingRemove(head,lastRet,tail,root);
          }
          this.lastRet=-1;
          return;
        }
        throw new IllegalStateException();
      }
      @Override void uncheckedForEachRemaining(final int expectedCursor,$TypeNameModifier$Consumer$<? super E>$ action){
        int modCount=this.modCount;
        final Checked$<E>$ root;
        int tail=(root=this.root).tail;
        try{
          final var arr=root.arr;
          int cursor;
          if((cursor=expectedCursor)>tail){
            OmniArray.Of$ClassPrefix$.ascendingForEach(arr,cursor,arr.length-1,action);
            cursor=0;
          }
          OmniArray.Of$ClassPrefix$.ascendingForEach(arr,cursor,tail,action);
        }finally{
          CheckedCollection.checkModCount(modCount,root.modCount,expectedCursor,this.cursor);
        }
        this.lastRet=tail;
        this.cursor=-1;
      }
    }
    private static class DescendingItr$<E>$ extends AscendingItr$<E>${
      private DescendingItr(DescendingItr$<E>$ itr){
        super(itr);
      }
      private DescendingItr(Checked$<E>$ root){
        super(root,root.tail);
      }
      @Override public Object clone(){
        return new DescendingItr$<E>$(this);
      }
      #MACRO SuppressUnchecked()
      @Override public $exposedType$ next$TypeNameModifier$(){
        final Checked$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        int cursor;
        if((cursor=this.cursor)!=-1){
          final $ArrayType$[] arr;
          final var ret=($exposedType$)(arr=root.arr)[cursor];
          this.lastRet=cursor;
          if(cursor==root.head){
            cursor=-1;
          }else if(--cursor==-1){
            cursor=arr.length-1;
          }
          this.cursor=cursor;
          return ret;
        }
        throw new NoSuchElementException();
      }
      private void fragmentedDescendingRemove(int head,int lastRet,int tail,$ClassPrefix$ArrDeq$<E>$ root){
        $ArrayType$[] arr;
        int headDist,tailDist,arrBound=(arr=root.arr).length-1;
        if((headDist=lastRet-head)>=0){
          if(headDist<=(tailDist=arrBound-lastRet)+tail+1){
            if(headDist==0){
              if(tailDist==0){
                root.head=0;
              }else{
                root.head=head+1;
              }
#IF OfRef
              arr[head]=null;
#ENDIF
            }else{
#IF OfRef
              ArrCopy.uncheckedCopy(arr,tail=head,arr,++head,headDist);
              arr[tail]=null;
#ELSE
              ArrCopy.uncheckedCopy(arr,head,arr,++head,headDist);
#ENDIF
              root.head=head;
              this.cursor=lastRet;
            }
          }else{
            ArrCopy.semicheckedSelfCopy(arr,lastRet,lastRet+1,tailDist);
            arr[arrBound]=arr[0];
            root.tail=fragmentedPullDown(arr,arrBound,tail);
          }
        }else{
          if((tailDist=tail-lastRet)<=(headDist=arrBound-head)+lastRet+1){
            if(tailDist==0){
              if(lastRet==0){
                root.tail=arrBound;
              }else{
                root.tail=tail-1;
              }
            }else{
              ArrCopy.uncheckedSelfCopy(arr,lastRet,lastRet+1,tailDist);
              root.tail=tail-1;
            }
  #IF OfRef
            arr[tail]=null;
  #ENDIF
          }else{
            ArrCopy.semicheckedCopy(arr,0,arr,1,lastRet);
            arr[0]=arr[arrBound];
            root.head=fragmentedPullUp(arr,head,headDist);
            this.cursor=lastRet;
          }
        }
      }
      private void nonfragmentedDescendingRemove(int head,int lastRet,int tail,$ClassPrefix$ArrDeq$<E>$ root){
        int tailDist,headDist;
        if((tailDist=tail-lastRet)<=(headDist=lastRet-head)){
  #IF OfRef
          $ArrayType$[] arr;
          ArrCopy.semicheckedSelfCopy(arr=root.arr,lastRet,lastRet+1,tailDist);
          arr[tail]=null;
  #ELSE
          ArrCopy.semicheckedSelfCopy(root.arr,lastRet,lastRet+1,tailDist);
  #ENDIF
          root.tail=tail-1;
        }else{
          if(headDist==0){
            root.head=head+1;
#IF OfRef
            root.arr[head]=null;
#ENDIF
          }else{
            $ArrayType$[] arr;
  #IF OfRef
            ArrCopy.uncheckedCopy(arr=root.arr,tail=head,arr,++head,headDist);
            arr[tail]=null;
  #ELSE
            ArrCopy.uncheckedCopy(arr=root.arr,head,arr,++head,headDist);
  #ENDIF
            this.cursor=lastRet;
            root.head=head;
          }
          
        }
      }
      @Override public void remove(){
        int lastRet;
        if((lastRet=this.lastRet)!=-1){
          int modCount;
          final Checked$<E>$ root;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          root.modCount=++modCount;
          this.modCount=modCount;
          final int head,tail;
          switch(Integer.signum((tail=root.tail)-(head=root.head))){
            case -1:
              fragmentedDescendingRemove(head,lastRet,tail,root);
              break;
            case 0:
              root.tail=-1;
#IF OfRef
              root.arr[tail]=null;
#ENDIF
              break;
            default:
              nonfragmentedDescendingRemove(head,lastRet,tail,root);
          }
          this.lastRet=-1;
          return;
        }
        throw new IllegalStateException();
      }
      @Override void uncheckedForEachRemaining(final int expectedCursor,$TypeNameModifier$Consumer$<? super E>$ action){
        int modCount=this.modCount;
        final Checked$<E>$ root;
        int head=(root=this.root).head;
        try{
          final var arr=root.arr;
          int cursor;
          if((cursor=expectedCursor)<head){
            OmniArray.Of$ClassPrefix$.descendingForEach(arr,0,cursor,action);
            cursor=arr.length-1;
          }
          OmniArray.Of$ClassPrefix$.descendingForEach(arr,head,cursor,action);
        }finally{
          CheckedCollection.checkModCount(modCount,root.modCount,expectedCursor,this.cursor);
        }
        this.lastRet=head;
        this.cursor=-1;
      }
    }
    @Override public Object clone(){
      int tail;
      if((tail=this.tail)!=-1){
        final var arr=this.arr;
        final $ArrayType$[] dst;
        int size,head;
        Checked$<E>$ clone;
        if((size=(++tail)-(head=this.head))<=0){
          clone=new Checked$<E>$(0,dst=new $ArrayType$[size+=arr.length],size-1);
          ArrCopy.uncheckedCopy(arr,0,dst,size-=tail,tail);
        }else{
          clone=new Checked$<E>$(0,dst=new $ArrayType$[size],size-1);
        }
        ArrCopy.uncheckedCopy(arr,head,dst,0,size);
        return clone;
      }
      return new Checked$<E>$();
    }
    #MACRO SuppressUnchecked()
    @Override public $exposedType$ removeLast$TypeNameModifier$(){
      int tail;
      if((tail=this.tail)!=-1){
        ++this.modCount;
        final $ArrayType$[] arr;
        var ret=($exposedType$)((arr=this.arr)[tail]);
    #IF OfRef
        arr[tail]=null;
    #ENDIF
        if(this.head==tail){
          tail=-1;
        }else if(--tail==-1){
          tail=arr.length-1;
        }
        this.tail=tail;
        return ret;
      }
      throw new NoSuchElementException();
    }
    #MACRO SuppressUnchecked()
    @Override public $exposedType$ pop$TypeNameModifier$(){
      int tail;
      if((tail=this.tail)!=-1){
        ++this.modCount;
        final $ArrayType$[] arr;
        int head;
        var ret=($exposedType$)((arr=this.arr)[head=this.head]);
    #IF OfRef
        arr[head]=null;
    #ENDIF
        if(head==tail){
          this.tail=-1;
          return ret;
        }else if(++head==arr.length){
          head=0;
        }
        this.head=head;
        return ret;
      }
      throw new NoSuchElementException();
    }
    @Override public void writeExternal(ObjectOutput output) throws IOException{
      int modCount=this.modCount;
      try{
        super.writeExternal(output);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    }
    @Override public void clear(){
#IF OfRef
      int tail;
      if((tail=this.tail)!=-1){
        ++this.modCount;
        final var arr=this.arr;
        final int head;
        if(tail<(head=this.head)){
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,0);
          tail=arr.length-1;
        }
        OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head);
#ELSE
      if(this.tail!=-1){
        ++this.modCount;
#ENDIF
        this.tail=-1;
      }
    }
    @Override public void push($exposedType$ val){
      ++this.modCount;
      super.push(val);
    }
    @Override public void addLast($exposedType$ val){
      ++this.modCount;
      super.addLast(val);
    }
    @Override void uncheckedForEach(final int tail,$TypeNameModifier$Consumer$<? super E>$ action){
      final int modCount=this.modCount;
      try{
        super.uncheckedForEach(tail,action);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    }
    #MACRO SuppressUnchecked()
    @Override public $exposedType$ $elementMethod$(){
      if(tail!=-1){
        return ($exposedType$)arr[head];
      }
      throw new NoSuchElementException();
    }
    #MACRO SuppressUnchecked()
    @Override public $exposedType$ getLast$TypeNameModifier$(){
      final int tail;
      if((tail=this.tail)!=-1){
        return ($exposedType$)arr[tail];
      }
      throw new NoSuchElementException();
    }
    @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
      return super.toArray(arrSize->{
        int modCount=this.modCount;
        try{
          return arrConstructor.apply(arrSize);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      });
    }
    #MACRO OutputMethods<true>(PollImpl)
#IF OfRef
    @Override public String toString(){
      final int tail;
      if((tail=this.tail)!=-1){
        int modCount=this.modCount;
        try{
          return super.uncheckedToString(tail);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
      return "[]";
    }
    @Override public int hashCode(){
      final int tail;
      if((tail=this.tail)!=-1){
        int modCount=this.modCount;
        try{
          return super.uncheckedHashCode(tail);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
      return 1;
    }
    @Override public boolean contains(Object val){
      final int tail;
      if((tail=this.tail)!=-1){
        if(val!=null){
          final int modCount=this.modCount;
          try{
            return super.uncheckedcontainsNonNull(tail,val);
          }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return super.uncheckedcontainsNull(tail);
      }
      return false;
    }
    @Override public int search(Object val){
      final int tail;
      if((tail=this.tail)!=-1){
        if(val!=null){
          final int modCount=this.modCount;
          try{
            return super.uncheckedsearchNonNull(tail,val);
          }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return super.uncheckedsearchNull(tail);
      }
      return -1;
    }
    #MACRO UncheckedRemoveVal<true,NonNull>(nonNull.equals)
    #MACRO UncheckedRemoveVal<true,Null>(null==)
    #MACRO UncheckedRemoveVal<true,>(pred.test)
    #MACRO UncheckedRemoveLastOccurrence<true,NonNull>(nonNull.equals)
    #MACRO UncheckedRemoveLastOccurrence<true,Null>(null==)
    #MACRO UncheckedRemoveLastOccurrence<true,>(pred.test)
#ELSEIF OfFloat,OfDouble
    #MACRO UncheckedRemoveVal<true,Bits>(bits==$convertToBits$)
    #MACRO UncheckedRemoveVal<true,0>(0==)
    #MACRO UncheckedRemoveVal<true,NaN>($BoxedType$.isNaN)
    #MACRO UncheckedRemoveLastOccurrence<true,Bits>(bits==$convertToBits$)
    #MACRO UncheckedRemoveLastOccurrence<true,0>(0==)
    #MACRO UncheckedRemoveLastOccurrence<true,NaN>($BoxedType$.isNaN)
#ELSE
    #MACRO UncheckedRemoveVal<true,>(val==)
    #MACRO UncheckedRemoveLastOccurrence<true,>(val==)
#ENDIF
  }
}
#MACRODEF OutputMethods<CHECKED>(MACRONAME)
#MACRO MACRONAME($ArrayType$,$TypeNameModifier$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR,$exposedType$,$defaultVal$,($exposedType$))
#IFNOT OfRef
#MACRO MACRONAME($BoxedType$,,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR,$BoxedType$,null,($BoxedType$))
  #IFNOT OfDouble
#MACRO MACRONAME(double,Double,OmniArray.OfDouble.DEFAULT_ARR,double,Double.NaN,$castToDouble$)
    #IFNOT OfFloat
#MACRO MACRONAME(float,Float,OmniArray.OfFloat.DEFAULT_ARR,float,Float.NaN,$castToFloat$)
      #IFNOT OfLong
#MACRO MACRONAME(long,Long,OmniArray.OfLong.DEFAULT_ARR,long,Long.MIN_VALUE,$castToLong$)
        #IFNOT OfInt
#MACRO MACRONAME(int,Int,OmniArray.OfInt.DEFAULT_ARR,int,Integer.MIN_VALUE,$castToInt$)
          #IFNOT OfShort,OfChar
#MACRO MACRONAME(short,Short,OmniArray.OfShort.DEFAULT_ARR,short,Short.MIN_VALUE,$castToShort$)
            #IFNOT OfByte
#MACRO MACRONAME(byte,Byte,OmniArray.OfByte.DEFAULT_ARR,byte,Byte.MIN_VALUE,$castToByte$)
#MACRO MACRONAME(char,Char,OmniArray.OfChar.DEFAULT_ARR,char,Character.MIN_VALUE,$castToChar$)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF PollImpl(ARRTYPE,CLASSPREFIX,DEFAULTARR,RETTYPE,DEFAULTVAL,CAST)
#MACRO SuppressUnchecked()
@Override public RETTYPE pollCLASSPREFIX(){
  int tail;
  if((tail=this.tail)!=-1){
#IFSWITCH CHECKED==true
    ++this.modCount;
#ENDIF
    final $ArrayType$[] arr;
    int head;
    var ret=CAST((arr=this.arr)[head=this.head]);
#IF OfRef
    arr[head]=null;
#ENDIF
    if(head==tail){
      this.tail=-1;
      return ret;
    }else if(++head==arr.length){
      head=0;
    }
    this.head=head;
    return ret;
  }
  return DEFAULTVAL;
}
#MACRO SuppressUnchecked()
@Override public RETTYPE pollLastCLASSPREFIX(){
  int tail;
  if((tail=this.tail)!=-1){
#IFSWITCH CHECKED==true
    ++this.modCount;
#ENDIF
    final $ArrayType$[] arr;
    var ret=CAST((arr=this.arr)[tail]);
#IF OfRef
    arr[tail]=null;
#ENDIF
    if(this.head==tail){
      tail=-1;
    }else if(--tail==-1){
      tail=arr.length-1;
    }
    this.tail=tail;
    return ret;
  }
  return DEFAULTVAL;
}
#ENDDEF
#MACRODEF PeekImpl(ARRTYPE,CLASSPREFIX,DEFAULTARR,RETTYPE,DEFAULTVAL,CAST)
#MACRO SuppressUnchecked()
@Override public RETTYPE peekCLASSPREFIX(){
  if(tail!=-1){
    return CAST(arr[head]);
  }
  return DEFAULTVAL;
}
#MACRO SuppressUnchecked()
@Override public RETTYPE peekLastCLASSPREFIX(){
  final int tail;
  if((tail=this.tail)!=-1){
    return CAST(arr[tail]);
  }
  return DEFAULTVAL;
}
#ENDDEF
#MACRODEF ToArrayImpl(ARRTYPE,CLASSPREFIX,DEFAULTARR,RETTYPE,DEFAULTVAL,CAST)
@Override public ARRTYPE[] toCLASSPREFIXArray(){
  int tail;
  if((tail=this.tail)!=-1){
    final var arr=this.arr;
    final ARRTYPE[] dst;
    int size,head;
    if((size=(++tail)-(head=this.head))<=0){
      ArrCopy.uncheckedCopy(arr,0,dst=new ARRTYPE[size+=arr.length],size-=tail,tail);
    }else{
      dst=new ARRTYPE[size];
    }
    ArrCopy.uncheckedCopy(arr,head,dst,0,size);
    return dst;
  }
  return DEFAULTARR;
}
#ENDDEF
#MACRODEF UncheckedQueryParam()
#IFSWITCH SUFFIX==NonNull
,Object nonNull
#ELSEIFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==Null,0,NaN
#ELSE
  #IF OfRef
,Predicate<Object> pred
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF UncheckedRemoveVal<CHECKED,SUFFIX>(TEST)
#IFSWITCH CHECKED==true
@Override
#ENDIF
boolean uncheckedremoveValSUFFIX(int tail
#MACRO UncheckedQueryParam()
){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
    #IF OfRef
  int modCount=this.modCount;
  try
    #ENDIF
  #ENDIF
#ENDIF
  {
    final var arr=this.arr;
    int head,index;
    if(tail<(head=this.head)){
      final int bound;
      for(index=head,bound=arr.length-1;;++index){
        if(TEST(arr[index])){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
          CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
          this.modCount=modCount+1;
#ENDIF
#IF OfBoolean
          if(++head>bound){
            this.head=0;
          }else{
            arr[index]=!val;
            this.head=head;
          }
#ELSE
          int headDist,tailDist;
          if((headDist=index-head)<=((tailDist=bound-index)+tail)){
  #IF OfRef
            ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headDist);
            arr[head]=null;
            this.head=(tail>bound)?0:tail;
  #ELSE
            ArrCopy.semicheckedCopy(arr,head,arr,++head,headDist);
            this.head=(head>bound)?0:head;
  #ENDIF
          }else{
            ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailDist);
            arr[bound]=arr[0];
            ArrCopy.semicheckedSelfCopy(arr,0,1,tail);
  #IF OfRef
            arr[tail]=null;
  #ENDIF
            this.tail=(--tail==-1)?bound:tail;
          }
#ENDIF
          return true;
        }else if(index==bound){
          for(index=0;;++index){
            if(TEST(arr[index])){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
              CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
              this.modCount=modCount+1;
#ENDIF
#IF OfBoolean
              arr[index]=!val;
              this.head=(++head>bound)?0:head;
#ELSE
              int headDist,tailDist;
              if((headDist=bound-head)+index+1<(tailDist=tail-index)){
                ArrCopy.semicheckedCopy(arr,0,arr,1,index);
                arr[0]=arr[bound];
  #IF OfRef
                ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headDist);
                arr[head]=null;
                this.head=(tail>bound)?0:tail;
  #ELSE
                ArrCopy.semicheckedCopy(arr,head,arr,++head,headDist);
                this.head=(head>bound)?0:head;
  #ENDIF
              }else{
                ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailDist);
  #IF OfRef
                arr[tail]=null;
  #ENDIF
                this.tail=(--tail==-1)?bound:tail;
              }
#ENDIF
              return true;
            }else if(index==tail){
              break;
            }
          }
          break;
        }
      }
    }else{
      for(index=head;;++index){
        if(TEST(arr[index])){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
          CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
          this.modCount=modCount+1;
#ENDIF
#IF OfBoolean
          
          if(head==tail){
            this.tail=-1;
          }else{
            arr[index]=!val;
            this.head=head+1;
          }
#ELSE
          int headDist,tailDist;
          if((tailDist=tail-index)<=(headDist=index-head)){
            if(headDist==0){
              this.tail=-1;
            }else{
              ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailDist);
              this.tail=tail-1;
            }
    #IF OfRef
            arr[tail]=null;
    #ENDIF
          }else{
    #IF OfRef
            ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headDist);
            arr[head]=null;
            this.head=tail;
    #ELSE
            ArrCopy.semicheckedCopy(arr,head,arr,++head,headDist);
            this.head=head;
    #ENDIF
          }
#ENDIF
          return true;
        }else if(index==tail){
          break;
        }
      }
    }
  }
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
  catch(ConcurrentModificationException e){
    throw e;
  }catch(RuntimeException e){
    throw CheckedCollection.checkModCount(modCount,this.modCount,e);
  }
  CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
#ENDIF
  return false;
}
#ENDDEF
#MACRODEF UncheckedRemoveLastOccurrence<CHECKED,SUFFIX>(TEST)
#IFSWITCH CHECKED==true
@Override
#ENDIF
boolean uncheckedremoveLastOccurrenceSUFFIX(int tail
#MACRO UncheckedQueryParam()
){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
    #IF OfRef
  int modCount=this.modCount;
  try
    #ENDIF
  #ENDIF
#ENDIF
  {
    final var arr=this.arr;
    int head,index;
    if(tail<(head=this.head)){
      final int bound;
      for(bound=arr.length-1,index=tail;;--index){
        if(TEST(arr[index])){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
          CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
          this.modCount=modCount+1;
#ENDIF
#IF OfBoolean
          if(--tail==-1){
            this.tail=bound;
          }else{
            arr[index]=!val;
            this.tail=tail;
          }
#ELSE
          int headDist,tailDist;
          if((headDist=bound-head)+index+1<(tailDist=tail-index)){
            ArrCopy.semicheckedCopy(arr,0,arr,1,index);
            arr[0]=arr[bound];
  #IF OfRef
            ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headDist);
            arr[head]=null;
            this.head=(tail>bound)?0:tail;
  #ELSE
            ArrCopy.semicheckedCopy(arr,head,arr,++head,headDist);
            this.head=(head>bound)?0:head;
  #ENDIF
          }else{
            ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailDist);
  #IF OfRef
            arr[tail]=null;
  #ENDIF
            this.tail=(--tail==-1)?bound:tail;
          }
#ENDIF
          return true;
        }else if(index==0){
          for(index=bound;;--index){
            if(TEST(arr[index])){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
              CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
              this.modCount=modCount+1;
#ENDIF
#IF OfBoolean
              arr[index]=!val;
              this.tail=(--tail==-1)?bound:tail;
#ELSE
              int headDist,tailDist;
              if((headDist=index-head)<=(tailDist=bound-index)+tail+1){
  #IF OfRef
                ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headDist);
                arr[head]=null;
                this.head=(tail>bound)?0:tail;
  #ELSE
                ArrCopy.semicheckedCopy(arr,head,arr,++head,headDist);
                this.head=(head>bound)?0:head;
  #ENDIF
              }else{
                ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailDist);
                arr[bound]=arr[0];
                ArrCopy.semicheckedSelfCopy(arr,0,1,tail);
  #IF OfRef
                arr[tail]=null;
  #ENDIF
                this.tail=(--tail==-1)?bound:tail;
              }
#ENDIF
              return true;
            }else if(index==head){
              break;
            }
          }
          break;
        }
      }
    }else{
      for(index=tail;;--index){
        if(TEST(arr[index])){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
          CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
          this.modCount=modCount+1;
#ENDIF
#IF OfBoolean
          if(head==tail){
             this.tail=-1;
          }else{
             arr[index]=!val;
             this.tail=tail-1;
          }
#ELSE
          int headDist,tailDist;
          if((tailDist=tail-index)<=(headDist=index-head)){
            if(headDist==0){
              this.tail=-1;
            }else{
              ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailDist);
              this.tail=tail-1;
            }
    #IF OfRef
            arr[tail]=null;
    #ENDIF
          }else{
    #IF OfRef
            ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headDist);
            arr[head]=null;
            this.head=tail;
    #ELSE
            ArrCopy.semicheckedCopy(arr,head,arr,++head,headDist);
            this.head=head;
    #ENDIF
          }
#ENDIF
          return true;
        }else if(index==head){
          break;
        }
      }
    }
  }
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
  catch(ConcurrentModificationException e){
    throw e;
  }catch(RuntimeException e){
    throw CheckedCollection.checkModCount(modCount,this.modCount,e);
  }
  CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
#ENDIF
  return false;
}
#ENDDEF
#MACRODEF UncheckedContains<SUFFIX>(PARAM)
#IFNOT OfBoolean
private
#ENDIF
boolean uncheckedcontainsSUFFIX(int tail
#MACRO UncheckedQueryParam()
){
  final var arr=this.arr;
  final int head;
  if(tail<(head=this.head)){
    return OmniArray.Of$ClassPrefix$.uncheckedcontainsSUFFIX(arr,0,tailPARAM) || OmniArray.Of$ClassPrefix$.uncheckedcontainsSUFFIX(arr,head,arr.length-1PARAM);
  }
  return OmniArray.Of$ClassPrefix$.uncheckedcontainsSUFFIX(arr,head,tailPARAM);
}
#ENDDEF
#MACRODEF UncheckedSearch<SUFFIX>(TEST)
#IFNOT OfBoolean
private
#ENDIF
int uncheckedsearchSUFFIX(int tail
#MACRO UncheckedQueryParam()
){
  final var arr=this.arr;
  int head,prefix;
  if(tail<(head=this.head)){
    int bound;
    for(prefix=head,bound=arr.length;;)
    {
      if(TEST(arr[prefix]))
      {
        return prefix-head+1;
      }
      if(++prefix==bound){
        prefix=bound-head;
        head=0;
        break;
      }
    }
  }else{
    prefix=-head;
  }
  for(;;++head){
    if(TEST(arr[head]))
    {
      return prefix+head+1;
    }
    if(head==tail)
    {
      return -1;
    }
  }
}
#ENDDEF
#MACRODEF ReturnUncheckedQueryBits(VAL)
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQueryBits(VAL) is only valid for Float and Double
#ENDIF
return uncheckedMETHODNAMEBits(tail,VAL);
#ENDDEF
#MACRODEF ReturnUncheckedQuery0()
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQuery0() is only valid for Float and Double
#ENDIF
return uncheckedMETHODNAME0(tail);
#ENDDEF
#MACRODEF ReturnUncheckedQueryNaN()
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQueryNaN() is only valid for Float and Double
#ENDIF
return uncheckedMETHODNAMENaN(tail);
#ENDDEF
#MACRODEF ReturnUncheckedQuery(VAL)
#IF OfFloat,OfDouble
ERROR ReturnUncheckedQuery(VAL) is not valid for $ClassPrefix$
#ENDIF
return uncheckedMETHODNAME(tail,VAL);
#ENDDEF
#MACRODEF ReturnUncheckedQueryNonNull(VAL)
#IFNOT OfRef
ERROR ReturnUncheckedQueryNonNull(VAL) is not valid for $ClassPrefix$
#ENDIF
return uncheckedMETHODNAMENonNull(tail,VAL);
#ENDDEF
#MACRODEF ReturnUncheckedQueryNull()
#IFNOT OfRef
ERROR ReturnUncheckedQueryNull() is not valid for $ClassPrefix$
#ENDIF
return uncheckedMETHODNAMENull(tail);
#ENDDEF
#MACRODEF QueryMethods<METHODNAME>()
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
  #IF OfByte
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
  #ENDIF
  #IF OfInt,OfLong
    #IFSWITCH METHODNAME==contains,removeVal
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
    #ENDIF
  #ENDIF
  #IF OfRef
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
  #ENDIF
  #IF OfChar,OfShort
    #IFSWITCH METHODNAME==contains,removeVal
#MACRO QueryMethod<byte>( )
    #ENDIF
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
  #ENDIF
  #IF OfFloat
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )  
  #ENDIF
  #IF OfRef
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
  #ENDIF
#ENDDEF
#MACRODEF QueryMethod<INPUTTYPE>(CAST)
#IFSWITCH METHODNAME==search
@Override public int METHODNAME(INPUTTYPE val)
#ELSEIFSWITCH METHODNAME==removeVal
  #IFSWITCH INPUTTYPE==Object
@Override public boolean remove(INPUTTYPE val)
  #ELSE
@Override public boolean METHODNAME(INPUTTYPE val)
  #ENDIF
#ELSEIFSWITCH METHODNAME==removeFirstOccurrence,removeLastOccurrence,contains
@Override public boolean METHODNAME(INPUTTYPE val)
#ELSE
ERROR unknown method name METHODNAME in QueryMethod<INPUTTYPE>(CAST)
#ENDIF
{
#IFSWITCH INPUTTYPE==byte,short
  #IF OfChar
  if(val>=0)
  #ENDIF  
#ELSEIFSWITCH INPUTTYPE==char
  #IF OfByte,OfShort
  if(val<=$BoxedType$.MAX_VALUE)
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==int
  #IF OfByte,OfChar,OfShort
  if(val==($ArrayType$)val)
  #ENDIF
#ENDIF
  {
    int tail;
    if((tail=this.tail)!=-1){
#IFSWITCH INPUTTYPE==boolean
  #IF OfDouble,OfFloat
      if(val){
        #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
      }
      #MACRO ReturnUncheckedQuery0()
  #ELSE
      #MACRO ReturnUncheckedQuery($queryCastBoolean$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==byte,char,short
  #IF OfDouble,OfFloat
      if(val!=0){
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
      #MACRO ReturnUncheckedQuery0()
  #ELSE
      #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==int
  #IF OfBoolean
      returnFalse:for(;;){
        final $ArrayType$ v;
        switch(val){
        default:
          break returnFalse;
        case 0:
          v=false;
          break;
        case 1:
          v=true;
        }
        #MACRO ReturnUncheckedQuery(v)
      }
  #ELSEIF OfFloat,OfDouble
    #IF OfDouble
    #ENDIF
      if(val!=0){
    #IF OfFloat
        if(TypeUtil.checkCastTo$ClassPrefix$(val))
    #ENDIF
        {
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
      }else{
        #MACRO ReturnUncheckedQuery0()
      }
  #ELSE
      #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==long
  #IF OfBoolean
      returnFalse:for(;;){
        final $ArrayType$ v;
        if(val==0L){
          v=false;
        }else if(val==1L){
          v=true;
        }else{
          break returnFalse;
        }
        #MACRO ReturnUncheckedQuery(v)
      }
  #ELSEIF OfFloat,OfDouble
      if(val!=0){
        if(TypeUtil.checkCastTo$ClassPrefix$(val)){
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
      }else{
        #MACRO ReturnUncheckedQuery0()
      }
  #ELSEIF OfByte,OfChar,OfShort,OfInt
      final $ArrayType$ v;
      if((v=($ArrayType$)val)==val){
        #MACRO ReturnUncheckedQuery(v)
      }
  #ELSE
      #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==float
  #IF OfBoolean
      returnFalse:for(;;){
        final $ArrayType$ v;
        switch(Float.floatToRawIntBits(val)){
          default:
            break returnFalse;
          case 0:
          case Integer.MIN_VALUE:
            v=false;
            break;
          case TypeUtil.FLT_TRUE_BITS:
            v=true;
        }
        #MACRO ReturnUncheckedQuery(v)
      }
  #ELSEIF OfFloat,OfDouble
      if(val==val){
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
      #MACRO ReturnUncheckedQueryNaN()
  #ELSEIF OfRef
      #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ELSE
      final $ArrayType$ v;
    #IF OfLong
      if(TypeUtil.floatEquals(val,v=($ArrayType$)val))
    #ELSEIF OfInt
      if((double)val==(double)(v=($ArrayType$)val))
    #ELSE
      if(val==(v=($ArrayType$)val))
    #ENDIF
      {
        #MACRO ReturnUncheckedQuery(v)
      }
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==double
  #IF OfBoolean
      returnFalse:for(;;){
        final $ArrayType$ v;
        long bits;
        if(((bits=Double.doubleToRawLongBits(val))&(Long.MAX_VALUE))==0){
          v=false;
        }else if(bits==TypeUtil.DBL_TRUE_BITS){
          v=true;
        }else{
          break returnFalse;
        }
        #MACRO ReturnUncheckedQuery(v)
      }
  #ELSEIF OfFloat
      final $ArrayType$ v;
      if(val==(v=($ArrayType$)val)){
        #MACRO ReturnUncheckedQueryBits($convertToBits$(v))
      }else if(v!=v){
        #MACRO ReturnUncheckedQueryNaN()
      }
  #ELSEIF OfDouble
      if(val==val){
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
      #MACRO ReturnUncheckedQueryNaN()
  #ELSEIF OfRef
      #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ELSE
      final $ArrayType$ v;
    #IF OfLong
      if(TypeUtil.doubleEquals(val,v=($ArrayType$)val))
    #ELSE
      if(val==(v=($ArrayType$)val))
    #ENDIF
      {
        #MACRO ReturnUncheckedQuery(v)
      }
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==Object
  #IF OfRef
      if(val!=null){
        #MACRO ReturnUncheckedQueryNonNull(val)
      }
      #MACRO ReturnUncheckedQueryNull()
  #ELSE
      //todo: a pattern-matching switch statement would be great here
      returnFalse:for(;;){
    #IF OfBoolean
        final boolean b;
        if(val instanceof Boolean){
          b=(boolean)val;
        }else if(val instanceof Integer||val instanceof Byte||val instanceof Short){
          switch(((Number)val).intValue()){
            default:
              break returnFalse;
            case 0:
              b=false;
              break;
            case 1:
              b=true;
          }
        }else if(val instanceof Float){
          switch(Float.floatToRawIntBits((float)val)){
            default:
              break returnFalse;
            case 0:
            case Integer.MIN_VALUE:
              b=false;
              break;
            case TypeUtil.FLT_TRUE_BITS:
              b=true;
          }
        }else if(val instanceof Double){
          final long bits;
          if(((bits=Double.doubleToRawLongBits((double)val))&(Long.MAX_VALUE))==0){
            b=false;
          }else if(bits==TypeUtil.DBL_TRUE_BITS){
            b=true;
          }else{
            break returnFalse;
          }
        }else if(val instanceof Long){
          final long v;
          if((v=(long)val)==0L){
            b=false;
          }else if(v==1L){
            b=true;
          }else{
           break returnFalse;
          }
        }else if(val instanceof Character){
          switch(((Character)val).charValue()){
            default:
              break returnFalse;
            case 0:
              b=false;
              break;
            case 1:
              b=true;
          }
        }else{
          break returnFalse;
        }
        #MACRO ReturnUncheckedQuery(b)
    #ELSEIF OfByte
        final int i;
        if(val instanceof Byte){
          i=(byte)val;
        }else if(val instanceof Integer||val instanceof Short){
          if((i=((Number)val).intValue())!=(byte)i){
            break returnFalse;
          }
        }else if(val instanceof Long){
          final long l;
          if((l=(long)val)!=(i=(byte)l)){
            break returnFalse;
          }
        }else if(val instanceof Float){
          final float f;
          if((f=(float)val)!=(i=(byte)f)){
            break returnFalse;
          }
        }else if(val instanceof Double){
          final double d;
          if((d=(double)val)!=(i=(byte)d)){
            break returnFalse;
          }
        }else if(val instanceof Character){
          if((i=(char)val)>Byte.MAX_VALUE){
            break returnFalse;
          }
        }else if(val instanceof Boolean){
          i=TypeUtil.castToByte((boolean)val);
        }else{
          break returnFalse;
        }
        #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfChar
        final int i;
        if(val instanceof Character){
          i=(char)val;
        }else if(val instanceof Integer){
          if((i=(int)val)!=(char)i){
            break returnFalse;
          }
        }else if(val instanceof Byte||val instanceof Short){
          if((i=((Number)val).shortValue())<0){
            break returnFalse;
          }
        }else if(val instanceof Long){
          final long l;
          if((l=(long)val)!=(i=(char)l)){
            break returnFalse;
          }
        }else if(val instanceof Float){
          final float f;
          if((f=(float)val)!=(i=(char)f)){
            break returnFalse;
          }
        }else if(val instanceof Double){
          final double d;
          if((d=(double)val)!=(i=(char)d)){
            break returnFalse;
          }
        }else if(val instanceof Boolean){
          i=TypeUtil.castToByte((boolean)val);
        }else{
          break returnFalse;
        }
        #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfShort
        final int i;
        if(val instanceof Short||val instanceof Byte){
          i=((Number)val).shortValue();
        }else if(val instanceof Integer){
          if((i=(int)val)!=(short)i){
            break returnFalse;
          }
        }else if(val instanceof Long){
          final long l;
          if((l=(long)val)!=(i=(short)l)){
            break returnFalse;
          }
        }else if(val instanceof Float){
          final float f;
          if((f=(float)val)!=(i=(short)f)){
            break returnFalse;
          }
        }else if(val instanceof Double){
          final double d;
          if((d=(double)val)!=(i=(short)d)){
            break returnFalse;
          }
        }else if(val instanceof Character){
          if((i=(char)val)>Short.MAX_VALUE){
            break returnFalse;
          }
        }else if(val instanceof Boolean){
          i=TypeUtil.castToByte((boolean)val);
        }else{
          break returnFalse;
        }
        #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfInt
        final int i;
        if(val instanceof Integer||val instanceof Byte||val instanceof Short){
          i=((Number)val).intValue();
        }else if(val instanceof Long){
          final long l;
          if((l=(long)val)!=(i=(int)l)){
            break returnFalse;
          }
        }else if(val instanceof Float){
          final float f;
          if((double)(f=(float)val)!=(double)(i=(int)f)){
            break returnFalse;
          }
        }else if(val instanceof Double){
          final double d;
          if((d=(double)val)!=(i=(int)d)){
            break returnFalse;
          }
        }else if(val instanceof Character){
          i=(char)val;
        }else if(val instanceof Boolean){
          i=TypeUtil.castToByte((boolean)val);
        }else{
          break returnFalse;
        }
        #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfLong
        final long l;
        if(val instanceof Long||val instanceof Integer||val instanceof Byte||val instanceof Short){
          l=((Number)val).longValue();
        }else if(val instanceof Float){
          final float f;
          if(!TypeUtil.floatEquals(f=(float)val,l=(long)f)){
            break returnFalse;
          }
        }else if(val instanceof Double){
          final double d;
          if(!TypeUtil.doubleEquals(d=(double)val,l=(long)d)){
            break returnFalse;
          }
        }else if(val instanceof Character){
          l=(char)val;
        }else if(val instanceof Boolean){
          l=TypeUtil.castToLong((boolean)val);
        }else{
          break returnFalse;
        }
        #MACRO ReturnUncheckedQuery(l);
    #ELSEIF OfFloat
        if(val instanceof Float){
          final float f;
          if((f=(float)val)==f){
             #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
          }
          #MACRO ReturnUncheckedQueryNaN()
        }else if(val instanceof Double){
          final double d;
          final float f;
          if((d=(double)val)==(f=(float)d)){
            #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
          }else if(f!=f){
            #MACRO ReturnUncheckedQueryNaN()
          }else{
            break returnFalse;
          }
        }else if(val instanceof Integer){
          final int i;
          if((i=(int)val)!=0){
            if(!TypeUtil.checkCastToFloat(i)){
              break returnFalse;
            }
            #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
          }
          #MACRO ReturnUncheckedQuery0()
        }else if(val instanceof Long){
          final long l;
          if((l=(long)val)!=0){
            if(!TypeUtil.checkCastToFloat(l)){
              break returnFalse;
            }
            #MACRO ReturnUncheckedQueryBits($convertToBits$(l))
          }
          #MACRO ReturnUncheckedQuery0()
        }else if(val instanceof Short||val instanceof Byte){
          final int i;
          if((i=((Number)val).shortValue())!=0){
            #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
          }
          #MACRO ReturnUncheckedQuery0()
        }else if(val instanceof Character){
          final int i;
          if((i=(char)val)!=0){
            #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
          }
          #MACRO ReturnUncheckedQuery0()
        }else if(val instanceof Boolean){
          if((boolean)val){
            #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
          }
          #MACRO ReturnUncheckedQuery0()
        }else{
          break returnFalse;
        }
    #ELSE
        if(val instanceof Double){
          final double d;
          if((d=(double)val)==d){
             #MACRO ReturnUncheckedQueryBits($convertToBits$(d))
          }
          #MACRO ReturnUncheckedQueryNaN()
        }else if(val instanceof Float){
          final float f;
          if((f=(float)val)==f){
             #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
          }
          #MACRO ReturnUncheckedQueryNaN()
        }else if(val instanceof Integer|| val instanceof Short||val instanceof Byte){
          final int i;
          if((i=((Number)val).intValue())!=0){
            #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
          }
          #MACRO ReturnUncheckedQuery0()
        }else if(val instanceof Long){
          final long l;
          if((l=(long)val)!=0){
            if(!TypeUtil.checkCastToDouble(l)){
              break returnFalse;
            }
            #MACRO ReturnUncheckedQueryBits($convertToBits$(l))
          }
          #MACRO ReturnUncheckedQuery0()
        }else if(val instanceof Character){
          final int i;
          if((i=(char)val)!=0){
            #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
          }
          #MACRO ReturnUncheckedQuery0()
        }else if(val instanceof Boolean){
          if((boolean)val){
            #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
          }
          #MACRO ReturnUncheckedQuery0()
        }else{
          break returnFalse;
        }
    #ENDIF
      }
  #ENDIF
#ELSE
      if(val!=null){
        #MACRO ReturnUncheckedQuery($queryCastRef$(CAST(val)))
      }
      #MACRO ReturnUncheckedQueryNull()
#ENDIF
    }
  }
#IFSWITCH METHODNAME==search
  return -1;
#ELSE
  return false;
#ENDIF
}
#ENDDEF
#MACRODEF SuppressUnchecked()
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
#ENDDEF
#MACRODEF CollapseEnd<CHECKED,HEAD,TAIL>(INCREMENT)
#IFSWITCH CHECKED==true
#MACRO SuppressUnchecked()
private void collapseHEADHelper($ArrayType$[] arr,int TAIL,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
  #IFSWITCH HEAD==head
  if(tail==0){
    CheckedCollection.checkModCount(modCount,this.modCount);
    this.head=0;
    this.tail=0;
  }else{
    for(int head=0;;)
  #ELSE
    #IF OfRef
  int bound;  
  if((bound=arr.length-1)==head){
    CheckedCollection.checkModCount(modCount,this.modCount);
    this.tail=bound;
    this.head=head;
  }else{
    for(int tail=bound;;)
    #ELSE
  int tail;
  if((tail=arr.length-1)==head){
    CheckedCollection.checkModCount(modCount,this.modCount);
    this.tail=tail;
    this.head=head;
  }else{
    for(;;)
    #ENDIF
  #ENDIF
    {
      if(!filter.test(($exposedType$)arr[HEAD])){
        collapseBodyHelper(arr,head,tail,filter,modCount);
        break;
      }else if(INCREMENTHEAD==TAIL){
        CheckedCollection.checkModCount(modCount,this.modCount);
        this.tail=tail;
        this.head=head;
        break;
      }
    }
  #IF OfRef
    #IFSWITCH HEAD==head
    if(head!=0)
    {
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,head-1,0);
    }
    #ELSE
    if(tail!=bound)
    {
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,bound,tail+1);
    }
    #ENDIF
  #ENDIF
  }
}
#MACRO SuppressUnchecked()
private void fragmentedCollapseHEADHelper($ArrayType$[] arr,int TAIL,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
  #IFSWITCH HEAD==head
  if(TAIL==0){
    CheckedCollection.checkModCount(modCount,this.modCount);
    this.HEAD=0;
  }else{
    int HEAD;
    for(HEAD=0;;INCREMENTHEAD)
  #ELSE
    #IF OfRef
  int bound;
  if((bound=arr.length-1)==TAIL){
    CheckedCollection.checkModCount(modCount,this.modCount);
    this.HEAD=TAIL;
  }else{
    int HEAD;
    for(HEAD=bound;;INCREMENTHEAD)
    #ELSE
  int HEAD;
  if((HEAD=arr.length-1)==TAIL){
    CheckedCollection.checkModCount(modCount,this.modCount);
    this.HEAD=TAIL;
  }else{
    for(;;INCREMENTHEAD)
    #ENDIF
  #ENDIF
    {
      if(HEAD==TAIL){
        CheckedCollection.checkModCount(modCount,this.modCount);
        this.HEAD=HEAD;
        break;
      }else if(!filter.test(($exposedType$)arr[HEAD])){
        collapseBodyHelper(arr,head,tail,filter,modCount);
        break;
      }
    }
  #IF OfRef
    #IFSWITCH HEAD==head
    if(HEAD!=0)
    {
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,HEAD-1,0);
    }
    #ELSE
    if(HEAD!=bound)
    {
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,bound,HEAD+1);
    }
    #ENDIF
  #ENDIF
  }
}
#MACRO SuppressUnchecked()
private void fragmentedCollapseHEAD($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
  int newHEAD;
  #IFSWITCH HEAD==head
  int bound;
  for(newHEAD=HEAD+1,bound=arr.length-1;;INCREMENTnewHEAD){
    if(newHEAD>bound){
  #ELSE
  for(newHEAD=HEAD-1;;INCREMENTnewHEAD){
    if(newHEAD==-1){
  #ENDIF
      fragmentedCollapseHEADHelper(arr,TAIL,filter,modCount);
      break;
    }
    if(!filter.test(($exposedType$)arr[newHEAD])){
  #IFSWITCH HEAD==head
      fragmentedCollapseBodyHelper(arr,newHEAD,TAIL,filter,modCount);
  #ELSE
      fragmentedCollapseBodyHelper(arr,TAIL,newHEAD,filter,modCount);
  #ENDIF
      break;
    }
  }
  #IF OfRef
    #IFSWITCH HEAD==head
  OmniArray.Of$ClassPrefix$.nullifyRange(arr,newHEAD-1,HEAD);
    #ELSE
  OmniArray.Of$ClassPrefix$.nullifyRange(arr,HEAD,newHEAD+1);  
    #ENDIF
  #ENDIF
}
#MACRO SuppressUnchecked()
private void collapseHEAD($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter,int modCount){
  int srcOffset;
  for(srcOffset=HEAD;INCREMENTsrcOffset!=TAIL;){
    if(!filter.test(($exposedType$)arr[srcOffset])){
#IFSWITCH HEAD==head
      collapseBodyHelper(arr,srcOffset,TAIL,filter,modCount);
  #IF OfRef
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,srcOffset-1,HEAD);
  #ENDIF
#ELSE
      collapseBodyHelper(arr,TAIL,srcOffset,filter,modCount);
  #IF OfRef
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,HEAD,srcOffset+1);
  #ENDIF
#ENDIF
      this.modCount=modCount+1;
      return;
    }
  }
  CheckedCollection.checkModCount(modCount,this.modCount);
  this.modCount=modCount+1;
#IF OfRef
  #IFSWITCH HEAD==head
  OmniArray.Of$ClassPrefix$.nullifyRange(arr,srcOffset-1,HEAD);
  #ELSE
  OmniArray.Of$ClassPrefix$.nullifyRange(arr,HEAD,srcOffset+1);
  #ENDIF
#ENDIF
  this.HEAD=srcOffset;
}
#ELSE
#MACRO SuppressUnchecked()
private void fragmentedCollapseHEAD($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
  #IFSWITCH HEAD==head
  for(int bound=arr.length;;)
  #ELSE
  for(;;)
  #ENDIF
  {
  #IF OfRef
    arr[HEAD]=null;
  #ENDIF
  #IFSWITCH HEAD==head
    if(INCREMENTHEAD==bound){
      for(HEAD=0;;INCREMENTHEAD)
  #ELSE
    if(HEAD==0){
      for(HEAD=arr.length-1;;INCREMENTHEAD)
  #ENDIF
      {
        if(HEAD==TAIL){
          this.HEAD=head;
          return;
        }else if(!filter.test(($exposedType$)arr[HEAD])){
          collapseBodyHelper(arr,head,tail,filter);
          return;
        }
  #IF OfRef
        arr[HEAD]=null;
  #ENDIF
      }
    }
  #IFSWITCH HEAD==head
    if(!filter.test(($exposedType$)arr[HEAD]))
  #ELSE
    if(!filter.test(($exposedType$)arr[INCREMENTHEAD]))
  #ENDIF
    {
      fragmentedCollapseBodyHelper(arr,head,tail,filter);
      return;
    }
  }
}
#MACRO SuppressUnchecked()
private void collapseHEAD($ArrayType$[] arr,int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
  do{
  #IF OfRef
    arr[HEAD]=null;
  #ENDIF
    if(INCREMENTHEAD==TAIL){
      this.HEAD=HEAD;
      return;
    }
  }while(filter.test(($exposedType$)arr[HEAD]));
  collapseBodyHelper(arr,head,tail,filter);
}
#ENDIF
#ENDDEF
#MACRODEF Assert(expr)
//assert expr;
#ENDDEF