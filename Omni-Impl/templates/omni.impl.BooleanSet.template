#TYPEDEF OfBoolean
package omni.impl;

import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;
import java.util.function.Consumer;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import omni.api.OmniIterator;
import omni.api.OmniSet;
import omni.function.BooleanConsumer;
import omni.function.BooleanPredicate;
import omni.util.OmniArray;
import omni.util.TypeUtil;

public class BooleanSet implements OmniSet.OfBoolean
{
  static class Checked extends BooleanSet
  {
    Checked(int state)
    {
      super(state);
    }
    Checked()
    {
      super();
    }
    @Override
    public boolean equals(Object val)
    {
      //TODO implement equals method
      return false;
    }
    private void checkMod(int expectedState)
    {
      if(this.state!=expectedState)
      {
        throw new ConcurrentModificationException();
      }
    }
    @Override
    public Object clone(){
        return new Checked(this.state);
    }
    #MACRO ToArrayIntFunc<true>()
    #MACRO ForEachMethods<true>(ForEach)
    @Override
    public OmniIterator.OfBoolean iterator(){
        return new CheckedItr(this);
    }
    #MACRO RemoveIfMethods<true>()
    private static class CheckedItr extends AbstractBooleanItr
    {
      private transient final Checked root;
      private transient int itrState;
      private CheckedItr(Checked root){
          this.root=root;
          this.itrState=root.state;
      }
      @Override
      public boolean hasNext()
      {
        switch(this.itrState)
        {
          case 0b001:
          case 0b010:
          case 0b011:
          case 0b111:
            return true;
          default:
            return false;
        }
      }
      #MACRO ForEachMethods<true>(ForEachItr)
      @Override
      public boolean nextBoolean(){
          final var root=this.root;
          switch(itrState){
          case 0b001:
              root.checkMod(0b01);
              this.itrState=0b100;
              return false;
          case 0b010:
              root.checkMod(0b10);
              this.itrState=0b101;
              return true;
          case 0b011:
              root.checkMod(0b11);
              this.itrState=0b111;
              return false;
          case 0b111:
              root.checkMod(0b11);
              this.itrState=0b110;
              return true;
          default:
              throw new NoSuchElementException();
          }
      }
      @Override
      public void remove(){
        final var root=this.root;
        switch(this.itrState){
        case 0b100:
            root.checkMod(0b01);
            root.state=0b00;
            this.itrState=0b000;
            return;
        case 0b101:
            root.checkMod(0b10);
            root.state=0b00;
            this.itrState=0b000;
            return;
        case 0b110:
            root.checkMod(0b11);
            root.state=0b01;
            this.itrState=0b000;
            return;
        case 0b111:
            root.checkMod(0b11);
            root.state=0b10;
            this.itrState=0b010;
            return;
        default:
            throw new IllegalStateException();
        }
      }
    }
  }
  transient int state;
  BooleanSet(int state){
    super();
    this.state=state;
  }
  BooleanSet(){
    super();
  }
  @Override
  public void clear()
  {
    this.state=0;
  }
  @Override
  public Object clone(){
      return new BooleanSet(this.state);
  }
  @Override
  public boolean equals(Object val)
  {
    //TODO implement equals method
    return false;
  }
  #MACRO SwitchMethod(int,hashCode,,return 1231;,return 1237;,return 1231+1237;,return 0;)
  #MACRO SwitchMethod(String,toString,,return "[false]";,return "[true]";,return "[false\, true]";,return "[]";)
  #MACRO SwitchMethod(boolean,contains,boolean val,return !val;,return val;,return true;,return false;)
  @Override
  public boolean contains(Boolean val)
  {
    return val!=null && contains((boolean)val);
  }
  @Override
  public boolean contains(byte val){
      return contains((int)val);
  }
  @Override
  public boolean contains(Byte val){
      return val!=null&&contains((int)val);
  }
  @Override
  public boolean contains(char val){
      return contains((int)val);
  }
  @Override
  public boolean contains(Character val){
      return val!=null&&contains((int)val);
  }
  @Override
  public boolean contains(double val){
      long bits;
      if((bits=Double.doubleToRawLongBits(val))==0L||bits==Long.MIN_VALUE){
          return (state&0b01)!=0;
      }
      return bits==TypeUtil.DBL_TRUE_BITS&&(state&0b10)!=0;
  }
  @Override
  public boolean contains(Double val){
      return val!=null&&contains((double)val);
  }
  @Override
  public boolean contains(float val){
      switch(Float.floatToRawIntBits(val)){
      case 0:
      case Integer.MIN_VALUE:
          return (state&0b01)!=0;
      case TypeUtil.FLT_TRUE_BITS:
          return (state&0b10)!=0;
      default:
          return false;
      }
  }
  @Override
  public boolean contains(Float val){
      return val!=null&&contains((float)val);
  }
  @Override
  public boolean contains(int val){
      switch(val){
      case 0:
          return (state&0b01)!=0;
      case 1:
          return (state&0b10)!=0;
      default:
          return false;
      }
  }
  @Override
  public boolean contains(Integer val){
      return val!=null&&contains((int)val);
  }
  @Override
  public boolean contains(long val){
      if(val==0){
          return (state&0b01)!=0;
      }
      return val==1&&(state&0b10)!=0;
  }
  @Override
  public boolean contains(Long val){
      return val!=null&&contains((long)val);
  }
  #MACRO SwitchMethod(boolean,contains,Object val,return TypeUtil.refEqualsFalse(val);,return TypeUtil.refEqualsTrue(val);,return val instanceof Boolean;,return false;)
  @Override
  public boolean contains(short val){
      return contains((int)val);
  }
  @Override
  public boolean contains(Short val){
      return val!=null&&contains((int)val);
  }
  @Override
  public boolean isEmpty(){
      return state==0;
  }
  #MACRO RemoveMethod(remove,Object,if(TypeUtil.refEqualsFalse(val)),if(TypeUtil.refEqualsTrue(val)),if(val instanceof Boolean))
  #MACRO RemoveMethod(removeVal,boolean,if(!val),if(val),)
  @Override
  public boolean removeVal(Boolean val){
      return val!=null&&removeVal((boolean)val);
  }
  @Override
  public boolean removeVal(byte val){
      return removeVal((int)val);
  }
  @Override
  public boolean removeVal(Byte val){
      return val!=null&&removeVal((int)val);
  }
  @Override
  public boolean removeVal(char val){
      return removeVal((int)val);
  }
  @Override
  public boolean removeVal(Character val){
      return val!=null&&removeVal((int)val);
  }
  @Override
  public boolean removeVal(double val){
      long bits;
      if((bits=Double.doubleToRawLongBits(val))==0||bits==Long.MIN_VALUE){
          int state;
          if(((state=this.state)&0b01)!=0){
              this.state=state&0b10;
              return true;
          }
      }else if(bits==TypeUtil.DBL_TRUE_BITS){
          int state;
          if(((state=this.state)&0b10)!=0){
              this.state=state&0b01;
              return true;
          }
      }
      return false;
  }
  @Override
  public boolean removeVal(Double val){
      return val!=null&&removeVal((double)val);
  }
  @Override
  public boolean removeVal(float val){
      switch(Float.floatToRawIntBits(val)){
      case 0:
      case Integer.MIN_VALUE:
          int state;
          if(((state=this.state)&0b01)!=0){
              this.state=state&0b10;
              return true;
          }
          break;
      case TypeUtil.FLT_TRUE_BITS:
          if(((state=this.state)&0b10)!=0){
              this.state=state&0b10;
              return true;
          }
      default:
      }
      return false;
  }
  @Override
  public boolean removeVal(Float val){
      return val!=null&&removeVal((float)val);
  }
  @Override
  public boolean removeVal(int val){
      switch(val){
      case 0:
          int state;
          if(((state=this.state)&0b01)!=0){
              this.state=state&0b10;
              return true;
          }
          break;
      case 1:
          if(((state=this.state)&0b10)!=0){
              this.state=state&0b10;
              return true;
          }
      default:
      }
      return false;
  }
  @Override
  public boolean removeVal(Integer val){
      return val!=null&&removeVal((int)val);
  }
  @Override
  public boolean removeVal(long val){
      if(val==0){
          int state;
          if(((state=this.state)&0b01)!=0){
              this.state=state&0b10;
              return true;
          }
      }else if(val==1){
          int state;
          if(((state=this.state)&0b10)!=0){
              this.state=state&0b10;
              return true;
          }
      }
      return false;
  }
  @Override
  public boolean removeVal(Long val){
      return val!=null&&removeVal((long)val);
  }
  @Override
  public boolean removeVal(short val){
      return removeVal((int)val);
  }
  @Override
  public boolean removeVal(Short val){
      return val!=null&&removeVal((int)val);
  }
  @Override
  public int size(){
      switch(state){
      case 0b01:
      case 0b10:
          return 1;
      case 0b11:
          return 2;
      default:
          return 0;
      }
  }
  #MACRO ToArrayIntFunc<false>()
  @SuppressWarnings("unchecked")
  @Override
  public <T> T[] toArray(T[] dst){
      switch(state){
      case 0b01:
          (dst=OmniArray.uncheckedArrResize(1,dst))[0]=(T)Boolean.FALSE;
          break;
      case 0b10:
          (dst=OmniArray.uncheckedArrResize(1,dst))[0]=(T)Boolean.TRUE;
          break;
      case 0b11:
          (dst=OmniArray.uncheckedArrResize(2,dst))[0]=(T)Boolean.FALSE;
          dst[1]=(T)Boolean.TRUE;
          break;
      default:
          if(dst.length!=0){
              dst[0]=null;
          }
      }
      return dst;
  }
  @Override
  public boolean add(boolean val){
      switch(state){
      case 0b01:
          if(!val){
              return false;
          }
          break;
      case 0b10:
          if(val){
              return false;
          }
          break;
      case 0b11:
          return false;
      default:
          this.state=val?0b10:0b01;
          return true;
      }
      this.state=0b11;
      return true;
  }
  @Override
  public boolean add(Boolean val){
      return add((boolean)val);
  }
  #MACRO ForEachMethods<false>(ForEach)
  @Override
  public OmniIterator.OfBoolean iterator(){
      return new Itr(this);
  }
  
  private static class Itr extends AbstractBooleanItr
  {
    private transient final BooleanSet root;
    private transient int itrState;
    private Itr(BooleanSet root)
    {
      this.root=root;
      this.itrState=root.state;
    }
    @Override
    public void remove(){
        root.state=itrState;
    }
    #MACRO ForEachMethods<false>(ForEachItr)
    @Override
    public boolean nextBoolean(){
        switch(itrState){
        case 0b01:
            this.itrState=0b00;
            break;
        case 0b10:
            this.itrState=0b00;
            return true;
        default:
            this.itrState=0b10;
        }
        return false;
    }
    @Override
    public boolean hasNext(){
        return itrState!=0;
    }
  }
  #MACRO RemoveIfMethods<false>()
  #MACRO ToArrayMethod(Boolean,,Boolean.FALSE,Boolean.TRUE,OfBoolean.DEFAULT_BOXED_ARR)
  #MACRO ToArrayMethod(boolean,Boolean,false,true,OfBoolean.DEFAULT_ARR)
  #MACRO ToArrayMethod(byte,Byte,0,1,OfByte.DEFAULT_ARR)
  #MACRO ToArrayMethod(char,Char,0,1,OfChar.DEFAULT_ARR)
  #MACRO ToArrayMethod(short,Short,0,1,OfShort.DEFAULT_ARR)
  #MACRO ToArrayMethod(int,Int,0,1,OfInt.DEFAULT_ARR)
  #MACRO ToArrayMethod(long,Long,0,1,OfLong.DEFAULT_ARR)
  #MACRO ToArrayMethod(float,Float,0,1,OfFloat.DEFAULT_ARR)
  #MACRO ToArrayMethod(double,Double,0,1,OfDouble.DEFAULT_ARR)
}
#MACRODEF ToArrayMethod(retType,methodName,FALSEVAL,TRUEVAL,DEFAULTVAL)
@Override
public retType[] tomethodNameArray()
{
  switch(state)
  {
    case 0b01:
      return new retType[]{FALSEVAL};
    case 0b10:
      return new retType[]{TRUEVAL};
    case 0b11:
      return new retType[]{FALSEVAL,TRUEVAL};
    default:
      return OmniArray.DEFAULTVAL;
  }
}
#ENDDEF
#MACRODEF RemoveMethod(methodName,ParamType,FALSEEXPR,TRUEEXPR,FULLEXPR)
@Override
public boolean methodName(ParamType val)
{
  switch(this.state)
  {
    case 0b01:
      FALSEEXPR
      {
        break;
      }
      return false;
    case 0b10:
      TRUEEXPR
      {
        break;
      }
      return false;
    case 0b11:
      FULLEXPR
      {
        this.state=((boolean)val)?0b01:0b10;
        return true;
      }
    default:
      return false;
  }
  this.state=0b00;
  return true;
}
#ENDDEF
#MACRODEF SwitchMethod(retType,methodName,methodParam,FALSEEXPR,TRUEEXPR,FULLEXPR,EMPTYEXPR)
@Override
public retType methodName(methodParam)
{
  switch(this.state)
  {
    case 0b01:
      FALSEEXPR
    case 0b10:
      TRUEEXPR
    case 0b11:
      FULLEXPR
    default:
      EMPTYEXPR
  }
}
#ENDDEF
#MACRODEF ForEachItr(Consumer,TRUEPARAM,FALSEPARAM)
@Override
public void forEachRemaining(Consumer action)
{
  switch(this.itrState){
#IFSWITCH IsChecked==true
  case 0b001:
      action.accept(TRUEPARAM);
      root.checkMod(0b01);
      this.itrState=0b100;
      return;
  case 0b010:
      action.accept(TRUEPARAM);
      root.checkMod(0b10);
      this.itrState=0b101;
      return;
  case 0b011:
      action.accept(FALSEPARAM);
  case 0b111:
      action.accept(TRUEPARAM);
      root.checkMod(0b11);
      this.itrState=0b110;
  default:
  }
#ELSE
  case 0b11:
      action.accept(FALSEPARAM);
  case 0b10:
      action.accept(TRUEPARAM);
      break;
  case 0b01:
      action.accept(FALSEPARAM);
      break;
  case 0b00:
      return;
  }
  this.itrState=0b00;
#ENDIF
}
#ENDDEF
#MACRODEF RemoveIfMethods<IsChecked>()
#MACRO RemoveIf(BooleanPredicate,true,false)
#MACRO RemoveIf(Predicate<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
#ENDDEF
#MACRODEF RemoveIf(Predicate,TRUEPARAM,FALSEPARAM)
@Override
public boolean removeIf(Predicate filter)
{
  switch(state)
  {
    case 0b01:
      #MACRO TryCheckModCount(this,0b01,if(filter.test(FALSEPARAM)){break;}return false;)
    case 0b10:
      #MACRO TryCheckModCount(this,0b10,if(filter.test(TRUEPARAM)){break;}return false;)
    case 0b11:
      if(filter.test(TRUEPARAM))
      {
        if(filter.test(FALSEPARAM))
        {
          #MACRO CheckModCall(this,0b11)
          this.state=0b00;
          return true;
        }
        #MACRO CheckModCall(this,0b11)
        this.state=0b01;
        return true;
      }
      #MACRO TryCheckModCount(this,0b11,if(!filter.test(FALSEPARAM)){return false;})
      this.state=0b10;
      return true;
    default:
      return false;
  }
  this.state=0b00;
  return true;
}
#ENDDEF
#MACRODEF TryCheckModCount(TARGET,EXPECTEDSTATE,EXPRESSION)
#IFSWITCH IsChecked==true
try
{
  EXPRESSION
}
finally
{
  TARGET.checkMod(EXPECTEDSTATE);
}
#ELSE
EXPRESSION
#ENDIF
#ENDDEF
#MACRODEF ForEachMethods<IsChecked>(MACRONAME)
#MACRO MACRONAME(BooleanConsumer,true,false)
#MACRO MACRONAME(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
#ENDDEF
#MACRODEF ForEach(Consumer,TRUEPARAM,FALSEPARAM)
@Override
public void forEach(Consumer action)
{
  switch(state)
  {
    case 0b11:
      action.accept(FALSEPARAM);
      action.accept(TRUEPARAM);
      #MACRO CheckModCall(this,0b11);
      return;
    case 0b10:
      action.accept(TRUEPARAM);
      #MACRO CheckModCall(this,0b10);
      return;
    case 0b01:
      action.accept(FALSEPARAM);
      #MACRO CheckModCall(this,0b01);
    default:
  }
}
#ENDDEF
#MACRODEF CheckModCall(target,EXPECTEDSTATEPARAM)
#IFSWITCH IsChecked==true
target.checkMod(EXPECTEDSTATEPARAM);
#ENDIF
#ENDDEF
#MACRODEF ToArrayIntFunc<IsChecked>()
@SuppressWarnings("unchecked")
@Override
public <T> T[] toArray(IntFunction<T[]> arrConstructor)
{
  T[] dst;
  switch(state)
  {
    case 0b01:
      (dst=arrConstructor.apply(1))[0]=(T)Boolean.FALSE;
      #MACRO CheckModCall(this,0b01)
      break;
    case 0b10:
      (dst=arrConstructor.apply(1))[0]=(T)Boolean.TRUE;
      #MACRO CheckModCall(this,0b10)
      break;
    case 0b11:
      (dst=arrConstructor.apply(2))[0]=(T)Boolean.FALSE;
      #MACRO CheckModCall(this,0b11)
      dst[1]=(T)Boolean.TRUE;
      break;
    default:
      dst=arrConstructor.apply(0);
      #MACRO CheckModCall(this,0b00)
  }
  return dst;
}
#ENDDEF