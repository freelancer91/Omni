#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import java.util.function.IntFunction;
import omni.api.OmniIterator;
import omni.api.OmniCollection;
import omni.impl.CheckedCollection;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;
#IFNOT OfRef,OfDouble,OfChar
import omni.util.ToStringUtil;
#ENDIF
import omni.util.OmniArray;
import java.util.function.Consumer;
import java.util.function.Predicate;
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Consumer;
import java.util.function.$TypeNameModifier$Predicate;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Consumer;
import omni.function.$TypeNameModifier$Predicate;
#ENDIF

#IF OfRef
import omni.util.OmniPred;
#ELSE
import omni.util.TypeUtil;
import omni.impl.Abstract$TypeNameModifier$Itr;
#ENDIF
import omni.api.OmniStack;
import omni.api.OmniQueue;
import omni.impl.$SNode$;
import java.io.Externalizable;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.IOException;
public abstract class $ClassPrefix$SnglLnkSeq$<E>$ implements OmniCollection.Of$ClassPrefix$$<E>$,Cloneable,Externalizable{
  private static final long serialVersionUID=1L;
  
  
  transient int size;
  transient $SNode$$<E>$ head;
  private $ClassPrefix$SnglLnkSeq(){
  }
  private $ClassPrefix$SnglLnkSeq($SNode$$<E>$ head,int size){
    this.size=size;
    this.head=head;
  }
#IF OfBoolean
  private static $<E>$ int retainSurvivors($SNode$$<E>$ prev,final boolean retainThis){
    int numSurvivors=1;
    outer:for($SNode$$<E>$ next;(next=prev.next)!=null;++numSurvivors,prev=next){
      if(next.val^retainThis){
        do{
          if((next=next.next)==null){
            prev.next=null;
            break outer;
          }
        }while(next.val^retainThis);
        prev.next=next;
      }
    }
    return numSurvivors;
  }
  private static $<E>$ int retainTrailingSurvivors($SNode$$<E>$ prev,$SNode$$<E>$ curr,final boolean retainThis){
    int numSurvivors=0;
    outer:for(;;curr=curr.next){
      if(curr==null){
        prev.next=null;
        break;
      }
      if(curr.val==retainThis){
        prev.next=curr;
        do{
          ++numSurvivors;
          if((curr=(prev=curr).next)==null){
            break outer;
          }
        }
        while(curr.val==retainThis);
      }
    }
    return numSurvivors;
  }
#ELSE
  


  private static $<E>$ void pullSurvivorsDown($SNode$$<E>$ prev,$TypeNameModifier$Predicate$<? super E>$ filter,long[] survivorSet,int numSurvivors,int numRemoved){
    int wordOffset;
    for(long word=survivorSet[wordOffset=0],marker=1L;;){
      var curr=prev.next;
      if((marker&word)==0){
        do{
          if(--numRemoved==0){
            prev.next=null;
            return;
          }
          if((marker<<=1)==0){
            word=survivorSet[++wordOffset];
            marker=1L;
          }
          curr=curr.next;
        }while((marker&word)==0);
        prev.next=curr;
      }
      if(--numSurvivors==0){
        return;
      }
      if((marker<<=1)==0){
         word=survivorSet[++wordOffset];
         marker=1L;
      }
      prev=curr;
    }
  }
  private static $<E>$ int markSurvivors($SNode$$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter,long[] survivorSet){
    for(int numSurvivors=0,wordOffset=0;;){
      long word=0L,marker=1L;
      do{
        if(!filter.test(curr.val)){
          word|=marker;
          ++numSurvivors;
        }
        if((curr=curr.next)==null){
          survivorSet[wordOffset]=word;
          return numSurvivors;
        }
      }
      while((marker<<=1)!=0L);
      survivorSet[wordOffset++]=word;
    }
  }
  private static $<E>$ void pullSurvivorsDown($SNode$$<E>$ prev,long word,int numSurvivors,int numRemoved){
    for(long marker=1L;;marker<<=1){
      var curr=prev.next;
      if((marker&word)==0){
        do{
          if(--numRemoved==0){
            prev.next=null;
            return;
          }
          curr=curr.next;
        }while(((marker<<=1)&word)==0);
        prev.next=curr;
      }
      if(--numSurvivors==0){
        return;
      }
      prev=curr;
    }
  }
  private static $<E>$ long markSurvivors($SNode$$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter){
    for(long word=0L,marker=1L;;marker<<=1){
      if(!filter.test(curr.val)){
        word|=marker;
      }
      if((curr=curr.next)==null){
        return word;
      }
    }
  }

 
  private static $<E>$ int retainSurvivors($SNode$$<E>$ prev, final $TypeNameModifier$Predicate$<? super E>$ filter){
    int numSurvivors=1;
    outer:for($SNode$$<E>$ next;(next=prev.next)!=null;++numSurvivors,prev=next){
      if(filter.test(next.val)){
        do{
          if((next=next.next)==null){
            prev.next=null;
            break outer;
          }
        }while(filter.test(next.val));
        prev.next=next;
      }
    }
    return numSurvivors;
  }
  private static $<E>$ int retainTrailingSurvivors($SNode$$<E>$ prev,$SNode$$<E>$ curr,final $TypeNameModifier$Predicate$<? super E>$ filter){
    int numSurvivors=0;
    outer:for(;;curr=curr.next){
      if(curr==null){
        prev.next=null;
        break;
      }
      if(!filter.test(curr.val)){
        prev.next=curr;
        do{
          ++numSurvivors;
          if((curr=(prev=curr).next)==null){
            break outer;
          }
        }
        while(!filter.test(curr.val));
      }
    }
    return numSurvivors;
  }
#ENDIF

  
  @Override public void writeExternal(ObjectOutput out) throws IOException
  {
    int size;
    out.writeInt(size=this.size);
    if(size!=0)
    {
      var curr=this.head;
#IF OfBoolean
      for(int word=TypeUtil.castToByte(curr.val),marker=1;;)
      {
        if((curr=curr.next)==null)
        {
          out.writeByte(word);
          return;
        }
        if((marker<<=1)==(1<<8))
        {
          out.writeByte(word);
          word=0;
          marker=1;
        }
        if(curr.val)
        {
          word|=marker;
        }
      }
#ELSE
      do
      {
  #IF OfRef
        out.writeObject(curr.val);
  #ELSE
        out.write$TypeNameModifier$(curr.val);
  #ENDIF
      }
      while((curr=curr.next)!=null);
#ENDIF
    }
  }
  
  @Override public abstract Object clone();
  @Override public int size(){
    return this.size;
  }
  @Override public boolean isEmpty(){
    return this.size==0;
  }
  @Override public void clear(){
    this.head=null;
    this.size=0;
  }
  @Override public int hashCode(){
    final $SNode$$<E>$ head;
    if((head=this.head)!=null){
      return $SNode$.uncheckedHashCode(head);
    }
    return 1;
  }
  @Override public String toString(){
    final $SNode$$<E>$ head;
    if((head=this.head)!=null){
#IF OfDouble,OfRef
      final StringBuilder builder=new StringBuilder("[");
      $SNode$.uncheckedToString(head,builder);
      return builder.append(']').toString();
#ELSE
      int size;
  #IF OfChar
      final char[] buffer;
      $SNode$.uncheckedToString(head,buffer=new char[size=this.size*3]);
      buffer[0]='[';
      buffer[size-1]=']';
      return new String(buffer,0,size);
  #ELSE
      final byte[] buffer;
    #IF OfBoolean
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/7)){(buffer=new byte[size*7])
    #ELSEIF OfByte
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/6)){(buffer=new byte[size*6])
    #ELSEIF OfShort
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE>>3)){(buffer=new byte[size<<3])
    #ELSEIF OfInt
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/13)){(buffer=new byte[size*13])
    #ELSEIF OfLong
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/22)){(buffer=new byte[size*22])
    #ELSEIF OfFloat
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/17)){(buffer=new byte[size*17])
    #ENDIF
        [size=$SNode$.uncheckedToString(head,buffer)]=(byte)']';
        buffer[0]=(byte)'[';
        return new String(buffer,0,size+1,ToStringUtil.IOS8859CharSet);
      }else{
        final ToStringUtil.OmniStringBuilderByte builder;
        $SNode$.uncheckedToString(head,builder=new ToStringUtil.OmniStringBuilderByte(1,new byte[OmniArray.MAX_ARR_SIZE]));
        builder.uncheckedAppendChar((byte)']');
        buffer=builder.buffer;
        buffer[0]=(byte)'[';
        return new String(buffer,0,builder.size,ToStringUtil.IOS8859CharSet);
      }
  #ENDIF 
#ENDIF
    }
    return "[]";
  }
  @Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
    final $SNode$$<E>$ head;
    if((head=this.head)!=null){
      $SNode$.uncheckedForEach(head,action);
    }
  }
#IFNOT OfRef
  @Override public void forEach(Consumer<? super $BoxedType$> action){
    final $SNode$$<E>$ head;
    if((head=this.head)!=null){
      $SNode$.uncheckedForEach(head,action::accept);
    }
  }
#ENDIF
  @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
    final int size;
    T[] arr=arrConstructor.apply(size=this.size);
    if(size!=0){
      $SNode$.uncheckedCopyInto(head,arr);
    }
    return arr;
  }
  abstract void push($exposedType$ val);
  #MACRO add($exposedType$,)
#IFNOT OfRef
  public void push($BoxedType$ val){
    push(($exposedType$)val);
  }
  #MACRO add($BoxedType$,($exposedType$))
  #IFNOT OfBoolean
  #MACRO add(boolean,($exposedType$)$queryCastBoolean$)
  #ENDIF
#ENDIF
#IF OfDouble,OfFloat,OfLong
  #MACRO add(int,($exposedType$))
  #IFNOT OfLong
  #MACRO add(char,($exposedType$))
  #MACRO add(short,($exposedType$))
  #MACRO add(long,($exposedType$))
    #IFNOT OfFloat
  #MACRO add(float,($exposedType$))
    #ENDIF
  #ENDIF
#ENDIF
  @Override public <T> T[] toArray(T[] arr){
    final $SNode$$<E>$ head;
    if((head=this.head)!=null){
      $SNode$.uncheckedCopyInto(head,arr=OmniArray.uncheckedArrResize(size,arr));
    }else{
      arr[0]=null;
    }
    return arr;
  }
  #MACRO ToArrayImpl($ArrayType$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR,$TypeNameModifier$)
#IFNOT OfRef
  #MACRO ToArrayImpl($BoxedType$,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR,)
  #IFNOT OfDouble
  #MACRO ToArrayImpl(double,OmniArray.OfDouble.DEFAULT_ARR,Double)
    #IFNOT OfFloat
  #MACRO ToArrayImpl(float,OmniArray.OfFloat.DEFAULT_ARR,Float)
      #IFNOT OfLong
  #MACRO ToArrayImpl(long,OmniArray.OfLong.DEFAULT_ARR,Long)
        #IFNOT OfInt
  #MACRO ToArrayImpl(int,OmniArray.OfInt.DEFAULT_ARR,Int)
          #IFNOT OfShort,OfChar
  #MACRO ToArrayImpl(short,OmniArray.OfShort.DEFAULT_ARR,Short)
            #IFNOT OfByte
  #MACRO ToArrayImpl(byte,OmniArray.OfByte.DEFAULT_ARR,Byte)
  #MACRO ToArrayImpl(char,OmniArray.OfChar.DEFAULT_ARR,Char)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  #MACRO QueryMethods<Root,contains>()
  #MACRO QueryMethods<Root,removeVal>()
#IF OfRef
  abstract boolean uncheckedremoveValNonNull($SNode$$<E>$ head,Object nonNull);
  abstract boolean uncheckedremoveValNull($SNode$$<E>$ head);
  abstract boolean uncheckedremoveVal($SNode$$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ pred);
#ELSEIF OfFloat,OfDouble
  abstract boolean uncheckedremoveValBits($SNode$$<E>$ head,$queryParameterType$ bits);
  abstract boolean uncheckedremoveVal0($SNode$$<E>$ head);
  abstract boolean uncheckedremoveValNaN($SNode$$<E>$ head);
#ELSE
  abstract boolean uncheckedremoveVal($SNode$$<E>$ head,$queryParameterType$ val);
#ENDIF
  @Override public boolean removeIf($TypeNameModifier$Predicate$<? super E>$ filter){
    final $SNode$$<E>$ head;
    if((head=this.head)!=null){
      return uncheckedremoveIf(head,filter);
    }
    return false;
  }
#IFNOT OfRef
  @Override public boolean removeIf(Predicate<? super $BoxedType$> filter){
    final $SNode$$<E>$ head;
    if((head=this.head)!=null){
      return uncheckedremoveIf(head,filter::test);
    }
    return false;
  }
#ENDIF

  #MACRO peek($exposedType$,$TypeNameModifier$,$defaultVal$,($exposedType$))
#IFNOT OfRef
  #MACRO peek($BoxedType$,,null,($BoxedType$))
  #IFNOT OfDouble
  #MACRO peek(double,Double,Double.NaN,$castToDouble$)
    #IFNOT OfFloat
  #MACRO peek(float,Float,Float.NaN,$castToFloat$)
      #IFNOT OfLong
  #MACRO peek(long,Long,Long.MIN_VALUE,$castToLong$)
        #IFNOT OfInt
  #MACRO peek(int,Int,Integer.MIN_VALUE,$castToInt$)
          #IFNOT OfShort,OfChar
  #MACRO peek(short,Short,Short.MIN_VALUE,$castToShort$)
            #IFNOT OfByte
  #MACRO peek(byte,Byte,Byte.MIN_VALUE,$castToByte$)
  #MACRO peek(char,Char,Character.MIN_VALUE,$castToChar$)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  abstract boolean uncheckedremoveIf($SNode$$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter);
  public static class CheckedStack$<E>$ extends UncheckedStack$<E>${
    private static final long serialVersionUID=1L;
    transient int modCount;
    public CheckedStack(){
    }
    CheckedStack($SNode$$<E>$ head,int size){
      super(head,size);
    }
    
    @Override public void writeExternal(ObjectOutput out) throws IOException{
      int modCount=this.modCount;
      try{
        super.writeExternal(out);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    }
    
    
    
    
    @Override public void push($exposedType$ val){
      ++this.modCount;
      super.push(val);
    }
    @Override public boolean equals(Object val){
      //TODO
      return false;
    }
    @Override public void clear(){
     if(size!=0){
       ++this.modCount;
       this.size=0;
       this.head=null;
     }
    }
    @Override public Object clone(){
      $SNode$$<E>$ head;
      if((head=this.head)!=null){
        final CheckedStack$<E>$ clone;
        $SNode$$<E>$ newHead;
        for(clone=new CheckedStack$<E>$(newHead=new $SNode$$<E>$(head.val),this.size);(head=head.next)!=null;newHead=newHead.next=new $SNode$$<E>$(head.val)){}
        return clone;
      }
      return new CheckedStack$<E>$();
    }
    @Override public $exposedType$ pop$TypeNameModifier$(){
      $SNode$$<E>$ head;
      if((head=this.head)!=null){
        ++this.modCount;
        this.head=head.next;
        --this.size;
        return head.val;
      }
      throw new NoSuchElementException();
    }
#IF OfRef
  @Override public int hashCode(){
    final $SNode$$<E>$ head;
    if((head=this.head)!=null){
      final int modCount=this.modCount;
      try{
        return $SNode$.uncheckedHashCode(head);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    }
    return 1;
  }
  @Override public String toString(){
    final $SNode$$<E>$ head;
    if((head=this.head)!=null){
      final StringBuilder builder=new StringBuilder("[");
      final int modCount=this.modCount;
      try{
        $SNode$.uncheckedToString(head,builder);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      return builder.append(']').toString();
    }
    return "[]";
  }
#ENDIF    
    @Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          $SNode$.uncheckedForEach(head,action);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
    }
#IFNOT OfRef
    @Override public void forEach(Consumer<? super $BoxedType$> action){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          $SNode$.uncheckedForEach(head,action::accept);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
    }
#ENDIF
    @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
      return super.toArray((arrSize)->{
        final int modCount=this.modCount;
        try{
          return arrConstructor.apply(arrSize);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      });
    }
#IFNOT OfBoolean
    private int removeIfHelper($SNode$$<E>$ prev,$TypeNameModifier$Predicate$<? super E>$ filter,int numLeft,int modCount)
    {
      if(numLeft!=0)
      {
        int numSurvivors;
        if(numLeft>64)
        {
          long[] survivorSet;
          numSurvivors=markSurvivors(prev.next,filter,survivorSet=new long[(numLeft-1>>6)+1]);
          CheckedCollection.checkModCount(modCount,this.modCount);
          if((numLeft-=numSurvivors)!=0)
          {
            pullSurvivorsDown(prev,filter,survivorSet,numSurvivors,numLeft);
          }
        }
        else
        {
          long survivorWord=markSurvivors(prev.next,filter);
          CheckedCollection.checkModCount(modCount,this.modCount);
          if((numLeft-=(numSurvivors=Long.bitCount(survivorWord)))!=0)
          {
            pullSurvivorsDown(prev,survivorWord,numSurvivors,numLeft);
          }
        }
        return numSurvivors;
      }
      CheckedCollection.checkModCount(modCount,this.modCount);
      return 0;
    }
#ENDIF
    @Override boolean uncheckedremoveIf($SNode$$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter){
      final int modCount=this.modCount;
      try{
#IF OfBoolean
        boolean firstVal;
        if(filter.test(firstVal=head.val)){
          while((head=head.next)!=null){
            if(head.val^firstVal){
              if(filter.test(firstVal=!firstVal)){
                break;
              }
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.modCount=modCount+1;
              this.head=head;
              this.size=retainSurvivors(head,firstVal);
              return true;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
          this.head=null;
          this.size=0;
          return true;
        }else{
          $SNode$$<E>$ prev;
          for(int numSurvivors=1;(head=(prev=head).next)!=null;++numSurvivors){
            if(head.val^firstVal){
              if(filter.test(!firstVal)){
                CheckedCollection.checkModCount(modCount,this.modCount);
                this.modCount=modCount+1;
                this.size=numSurvivors+retainTrailingSurvivors(prev,head.next,firstVal);
                return true;
              }
              break;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
#ELSE
        int numLeft=this.size;
        if(filter.test(head.val)){
          while(--numLeft!=0){
            if(!filter.test((head=head.next).val)){
              this.size=1+removeIfHelper(head,filter,--numLeft,modCount);
              this.modCount=modCount+1;
              this.head=head;
              return true;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
          this.head=null;
          this.size=0;
          return true;
        }else{
          int numSurvivors;
          if(--numLeft!=(numSurvivors=removeIfHelper(head,filter,numLeft,modCount))){
            this.modCount=modCount+1;
            this.size=1+numSurvivors;
            return true;
          }
        }
#ENDIF
      }catch(ConcurrentModificationException e){
        throw e;
      }catch(RuntimeException e){
        throw CheckedCollection.checkModCount(modCount,this.modCount,e);
      }
      return false;
    }
    #MACRO StackPoll<true>($exposedType$,$TypeNameModifier$,$defaultVal$,)
#IFNOT OfRef
    #MACRO StackPoll<true>($BoxedType$,,null,($BoxedType$))
  #IFNOT OfDouble
    #MACRO StackPoll<true>(double,Double,Double.NaN,$castToDouble$)
    #IFNOT OfFloat
    #MACRO StackPoll<true>(float,Float,Float.NaN,$castToFloat$)
      #IFNOT OfLong
    #MACRO StackPoll<true>(long,Long,Long.MIN_VALUE,$castToLong$)
        #IFNOT OfInt
    #MACRO StackPoll<true>(int,Int,Integer.MIN_VALUE,$castToInt$)
          #IFNOT OfShort,OfChar
    #MACRO StackPoll<true>(short,Short,Short.MIN_VALUE,$castToShort$)
            #IFNOT OfByte
    #MACRO StackPoll<true>(byte,Byte,Byte.MIN_VALUE,$castToByte$)
    #MACRO StackPoll<true>(char,Char,Character.MIN_VALUE,$castToChar$)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#IF OfRef
    #MACRO StackUncheckedRemoveVal<true,NonNull>(nonNull.equals,!nonNull.equals)
    #MACRO StackUncheckedRemoveVal<true,Null>(null==,null!=)
    #MACRO StackUncheckedRemoveVal<true,>(pred.test,!pred.test)
#ELSEIF OfDouble,OfFloat
    #MACRO StackUncheckedRemoveVal<true,Bits>(bits==$convertToBits$,bits!=$convertToBits$)
    #MACRO StackUncheckedRemoveVal<true,0>(0==,0!=)
    #MACRO StackUncheckedRemoveVal<true,NaN>($BoxedType$.isNaN,!$BoxedType$.isNaN)
#ELSE
    #MACRO StackUncheckedRemoveVal<true,>(val==,val!=)
#ENDIF
#IF OfRef
    @Override
    public int search(Object val){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        if(val!=null){
          final int modCount=this.modCount;
          try{
            return $SNode$.uncheckedsearchNonNull(head,val);
          }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return $SNode$.uncheckedsearchNull(head);
      }
      return -1;
    }
    @Override
    public boolean contains(Object val){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        if(val!=null){
          final int modCount=this.modCount;
          try{
            return $SNode$.uncheckedcontainsNonNull(head,val);
          }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return $SNode$.uncheckedcontainsNull(head);
      }
      return false;
    }
#ENDIF
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      return new Itr$<E>$(this);
    }
    private static class Itr$<E>$ extends AbstractItr$<E>${
      final CheckedStack$<E>$ parent;
      transient int modCount;
      Itr(CheckedStack$<E>$ parent){
        super(parent.head);
        this.parent=parent;
        this.modCount=parent.modCount;
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        CheckedCollection.checkModCount(modCount,parent.modCount);
        final $SNode$$<E>$ next;
        if((next=this.next)!=null){
          this.next=next.next;
          this.prev=this.curr;
          this.curr=next;
          return next.val;
        }
        throw new NoSuchElementException();
      }
      @Override void uncheckedForEachRemaining($SNode$$<E>$ next,$TypeNameModifier$Consumer$<? super E>$ action){
        final int modCount=this.modCount;
        $SNode$$<E>$ prev,curr;
        try{
          curr=this.curr;
          do{
            action.accept(next.val);
            prev=curr;
          }while((next=(curr=next).next)!=null);
        }finally{
          CheckedCollection.checkModCount(modCount,this.parent.modCount);
        }
        this.prev=prev;
        this.curr=curr;
        this.next=null;
      }
      @Override public void remove(){
        final $SNode$$<E>$ prev;
        if(this.curr!=(prev=this.prev)){
          final CheckedStack$<E>$ parent;
          int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(parent=this.parent).modCount);
          parent.modCount=++modCount;
          this.modCount=modCount;
          --parent.size;
          if(prev==null){
            parent.head=next;
          }else{
            prev.next=next;
          }
          this.curr=prev;
          return;
        }
        throw new IllegalStateException();
      }
    }
  }
  public static class UncheckedStack$<E>$ extends $ClassPrefix$SnglLnkSeq$<E>$ implements OmniStack.Of$ClassPrefix$$<E>${
    private static final long serialVersionUID=1L;
    public UncheckedStack(){
    }
    UncheckedStack($SNode$$<E>$ head,int size){
      super(head,size);
    }
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    @Override public void readExternal(ObjectInput in) throws IOException
#IF OfRef
      ,ClassNotFoundException
#ENDIF
    {
      int size;
      this.size=size=in.readInt();
      if(size!=0)
      {
        $SNode$$<E>$ curr;
#IF OfBoolean
        int word,marker;
        for(this.head=curr=new $SNode$(((marker=1)&(word=in.readUnsignedByte()))!=0);--size!=0;curr=curr.next=new $SNode$$<E>$((word&marker)!=0))
        {
          if((marker<<=1)==(1<<8))
          {
            word=in.readUnsignedByte();
            marker=1;
          }
        }
#ELSEIF OfRef
        for(this.head=curr=new $SNode$$<E>$(($exposedType$)in.readObject());--size!=0;curr=curr.next=new $SNode$$<E>$(($exposedType$)in.readObject())){}
#ELSE
        for(this.head=curr=new $SNode$$<E>$(($exposedType$)in.read$TypeNameModifier$());--size!=0;curr=curr.next=new $SNode$$<E>$(($exposedType$)in.read$TypeNameModifier$())){}
#ENDIF
      }
    }
    
    
    @Override public void push($exposedType$ val){
      this.head=new $SNode$$<E>$(val,this.head);
      ++this.size;
    }
    @Override public boolean equals(Object val){
      //TODO
      return false;
    }
    @Override public Object clone(){
      $SNode$$<E>$ head;
      if((head=this.head)!=null){
        final UncheckedStack$<E>$ clone;
        $SNode$$<E>$ newHead;
        for(clone=new UncheckedStack$<E>$(newHead=new $SNode$$<E>$(head.val),this.size);(head=head.next)!=null;newHead=newHead.next=new $SNode$$<E>$(head.val)){}
        return clone;
      }
      return new UncheckedStack$<E>$();
    }
    @Override public $exposedType$ pop$TypeNameModifier$(){
      $SNode$$<E>$ head;
      this.head=(head=this.head).next;
      --this.size;
      return head.val;
    }
    #MACRO QueryMethods<UncheckedStack,search>()
    #MACRO StackPoll<false>($exposedType$,$TypeNameModifier$,$defaultVal$,)
#IFNOT OfRef
    @Override public $BoxedType$ pop(){
      return pop$TypeNameModifier$();
    }
    #MACRO StackPoll<false>($BoxedType$,,null,($BoxedType$))
  #IFNOT OfDouble
    #MACRO StackPoll<false>(double,Double,Double.NaN,$castToDouble$)
    #IFNOT OfFloat
    #MACRO StackPoll<false>(float,Float,Float.NaN,$castToFloat$)
      #IFNOT OfLong
    #MACRO StackPoll<false>(long,Long,Long.MIN_VALUE,$castToLong$)
        #IFNOT OfInt
    #MACRO StackPoll<false>(int,Int,Integer.MIN_VALUE,$castToInt$)
          #IFNOT OfShort,OfChar
    #MACRO StackPoll<false>(short,Short,Short.MIN_VALUE,$castToShort$)
            #IFNOT OfByte
    #MACRO StackPoll<false>(byte,Byte,Byte.MIN_VALUE,$castToByte$)
    #MACRO StackPoll<false>(char,Char,Character.MIN_VALUE,$castToChar$)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
    @Override boolean uncheckedremoveIf($SNode$$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfBoolean
      boolean firstVal;
      if(filter.test(firstVal=head.val)){
        while((head=head.next)!=null){
          if(head.val^firstVal){
            if(filter.test(firstVal=!firstVal)){
              break;
            }
            this.head=head;
            this.size=retainSurvivors(head,firstVal);
            return true;
          }
        }
        this.head=null;
        this.size=0;
        return true;
      }else{
        $SNode$$<E>$ prev;
        for(int numSurvivors=1;(head=(prev=head).next)!=null;++numSurvivors){
          if(head.val^firstVal){
            if(filter.test(!firstVal)){
              this.size=numSurvivors+retainTrailingSurvivors(prev,head.next,firstVal);
              return true;
            }
            break;
          }
        }
        return false;
      }
#ELSE
      if(filter.test(head.val)){
        while((head=head.next)!=null){
          if(!filter.test(head.val)){
            this.size=retainSurvivors(head,filter);
            this.head=head;
            return true;
          }
        }
        this.head=null;
        this.size=0;
        return true;
      }else{
        $SNode$$<E>$ prev;
        for(int numSurvivors=1;(head=(prev=head).next)!=null;++numSurvivors){
          if(filter.test(head.val)){
            this.size=numSurvivors+retainTrailingSurvivors(prev,head.next,filter);
            return true;
          }
        }
        return false;
      }
#ENDIF
    }
#IF OfRef
    #MACRO StackUncheckedRemoveVal<false,NonNull>(nonNull.equals,!nonNull.equals)
    #MACRO StackUncheckedRemoveVal<false,Null>(null==,null!=)
    #MACRO StackUncheckedRemoveVal<false,>(pred.test,!pred.test)
#ELSEIF OfDouble,OfFloat
    #MACRO StackUncheckedRemoveVal<false,Bits>(bits==$convertToBits$,bits!=$convertToBits$)
    #MACRO StackUncheckedRemoveVal<false,0>(0==,0!=)
    #MACRO StackUncheckedRemoveVal<false,NaN>($BoxedType$.isNaN,!$BoxedType$.isNaN)
#ELSE
    #MACRO StackUncheckedRemoveVal<false,>(val==,val!=)
#ENDIF
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      return new Itr();
    }
    private class Itr extends AbstractItr$<E>$
    {
      Itr(){
        super(UncheckedStack.this.head);
      }
      @Override public void remove(){
        final UncheckedStack$<E>$ parent;
        --(parent=UncheckedStack.this).size;
        final $SNode$$<E>$ prev;
        if((prev=this.prev)==null){
          parent.head=next;
        }else{
          prev.next=next;
        }
        this.curr=prev;
      }
    }
  }
  public static class CheckedQueue$<E>$ extends UncheckedQueue$<E>$
  {
    private static final long serialVersionUID=1L;
    transient int modCount;
    public CheckedQueue(){
      super();
    }
    CheckedQueue($SNode$$<E>$ head,int size,$SNode$$<E>$ tail){
      super(head,size,tail);
    }
    @Override public boolean equals(Object val){
      //TODO
      return false;
    }
    @Override public void writeExternal(ObjectOutput out) throws IOException{
      int modCount=this.modCount;
      try{
        super.writeExternal(out);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    }
    
    
#IF OfRef
    @Override public int hashCode(){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          return $SNode$.uncheckedHashCode(head,tail);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
      return 1;
    }
    @Override public String toString(){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        final StringBuilder builder=new StringBuilder("[");
        final int modCount=this.modCount;
        try{
          $SNode$.uncheckedToString(head,tail,builder);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
        return builder.append(']').toString();
      }
      return "[]";
    }
#ENDIF    
    @Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          $SNode$.uncheckedForEach(head,tail,action);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
    }
  #IFNOT OfRef
    @Override public void forEach(Consumer<? super $BoxedType$> action){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          $SNode$.uncheckedForEach(head,tail,action::accept);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
    }
  #ENDIF
    @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
      return super.toArray((arrSize)->{
        final int modCount=this.modCount;
        try{
          return arrConstructor.apply(arrSize);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      });
    }
    

    @Override public void clear(){
      if(size!=0)
      {
        ++this.modCount;
        this.head=null;
        this.tail=null;
      }
    }
    @Override public Object clone(){
      $SNode$$<E>$ head;
      if((head=this.head)!=null){
        $SNode$$<E>$ newHead=new $SNode$$<E>$(head.val),newTail=newHead;
        for(final var tail=this.tail;head!=tail;newTail=newTail.next=new $SNode$$<E>$((head=head.next).val)){}
        return new CheckedQueue$<E>$(newHead,this.size,newTail);
      }
      return new CheckedQueue$<E>$();
    }
    @Override void push($exposedType$ val){
      ++this.modCount;
      super.push(val);
    }
    @Override public $exposedType$ remove$TypeNameModifier$(){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        ++this.modCount;
        if(head==tail){
          this.tail=null;
        }
        this.head=head.next;
        --this.size;
        return head.val;
      }
      throw new NoSuchElementException();
    }
    #MACRO QueuePoll<true>($exposedType$,$TypeNameModifier$,$defaultVal$,)
#IFNOT OfRef
    #MACRO QueuePoll<true>($BoxedType$,,null,($BoxedType$))
  #IFNOT OfDouble
    #MACRO QueuePoll<true>(double,Double,Double.NaN,$castToDouble$)
    #IFNOT OfFloat
    #MACRO QueuePoll<true>(float,Float,Float.NaN,$castToFloat$)
      #IFNOT OfLong
    #MACRO QueuePoll<true>(long,Long,Long.MIN_VALUE,$castToLong$)
        #IFNOT OfInt
    #MACRO QueuePoll<true>(int,Int,Integer.MIN_VALUE,$castToInt$)
          #IFNOT OfShort,OfChar
    #MACRO QueuePoll<true>(short,Short,Short.MIN_VALUE,$castToShort$)
            #IFNOT OfByte
    #MACRO QueuePoll<true>(byte,Byte,Byte.MIN_VALUE,$castToByte$)
    #MACRO QueuePoll<true>(char,Char,Character.MIN_VALUE,$castToChar$)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF




#IF OfBoolean
    private int removeIfHelper($SNode$$<E>$ prev,$SNode$$<E>$ tail,boolean retainThis){
      int numSurvivors=1;
      outer:for($SNode$$<E>$ next;prev!=tail;prev=next,++numSurvivors){
        if((next=prev.next).val^retainThis){
          do{
            if(next==tail){
              prev.next=null;
              this.tail=prev;
              break outer;
            }
          }while((next=next.next).val^retainThis);
          prev.next=next;
        }
      }
      return numSurvivors;
    }
    private int removeIfHelper($SNode$$<E>$ prev,$SNode$$<E>$ head,$SNode$$<E>$ tail,boolean retainThis){
      int numSurvivors=0;
      outer:for(;;){
        if(head==tail){
          prev.next=null;
          this.tail=prev;
          break;
        }
        if((head=head.next).val==retainThis){
          prev.next=head;
          do{
            ++numSurvivors;
            if(head==tail){
              break outer;
            }
          }
          while((head=(prev=head).next).val==retainThis);
        }
      }
      return numSurvivors;
    }
#ELSE
    private void pullSurvivorsDown($SNode$$<E>$ prev,$TypeNameModifier$Predicate$<? super E>$ filter,long[] survivorSet,int numSurvivors,int numRemoved)
    {
      int wordOffset;
      for(long word=survivorSet[wordOffset=0],marker=1L;;){
        var curr=prev.next;
        if((marker&word)==0){
          do{
            if(--numRemoved==0){
              prev.next=null;
              if(curr==tail)
              {
                this.tail=prev;
              }
              return;
            }
            if((marker<<=1)==0){
              word=survivorSet[++wordOffset];
              marker=1L;
            }
            curr=curr.next;
          }while((marker&word)==0);
          prev.next=curr;
        }
        if(--numSurvivors==0){
          return;
        }
        if((marker<<=1)==0){
           word=survivorSet[++wordOffset];
           marker=1L;
        }
        prev=curr;
      }
    }
    private void pullSurvivorsDown($SNode$$<E>$ prev,long word,int numSurvivors,int numRemoved){
      for(long marker=1L;;marker<<=1){
        var curr=prev.next;
        if((marker&word)==0){
          do{
            if(--numRemoved==0){
              prev.next=null;
              if(curr==tail)
              {
                this.tail=prev;
              }
              return;
            }
            curr=curr.next;
          }while(((marker<<=1)&word)==0);
          prev.next=curr;
        }
        if(--numSurvivors==0){
          return;
        }
        prev=curr;
      }
    }
    private int removeIfHelper($SNode$$<E>$ prev,$TypeNameModifier$Predicate$<? super E>$ filter,int numLeft,int modCount){
      if(numLeft!=0){
        int numSurvivors;
        if(numLeft>64)
        {
          long[] survivorSet;
          numSurvivors=markSurvivors(prev.next,filter,survivorSet=new long[(numLeft-1>>6)+1]);
          CheckedCollection.checkModCount(modCount,this.modCount);
          if((numLeft-=numSurvivors)!=0)
          {
            pullSurvivorsDown(prev,filter,survivorSet,numSurvivors,numLeft);
          }
        }
        else
        {
          long survivorWord=markSurvivors(prev.next,filter);
          CheckedCollection.checkModCount(modCount,this.modCount);
          if((numLeft-=(numSurvivors=Long.bitCount(survivorWord)))!=0)
          {
            pullSurvivorsDown(prev,survivorWord,numSurvivors,numLeft);
          }
        }
        return numSurvivors;
      }
      CheckedCollection.checkModCount(modCount,this.modCount);
      return 0;
    }
#ENDIF
    @Override boolean uncheckedremoveIf($SNode$$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter){
      final int modCount=this.modCount;
      try{
#IF OfBoolean
        final var tail=this.tail;
        boolean firstVal;
        if(filter.test(firstVal=head.val)){
          while(head!=tail){
            if((head=head.next).val^firstVal){
              if(filter.test(firstVal=!firstVal)){
                break;
              }
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.modCount=modCount+1;
              this.head=head;
              this.size=removeIfHelper(head,tail,firstVal);
              return true;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
          this.head=null;
          this.tail=null;
          this.size=0;
          return true;
        }else{
          
          for(int numSurvivors=1;head!=tail;++numSurvivors){
            $SNode$$<E>$ prev;
            if((head=(prev=head).next).val^firstVal){
              if(filter.test(!firstVal)){
                CheckedCollection.checkModCount(modCount,this.modCount);
                this.modCount=modCount+1;
                this.size=numSurvivors+removeIfHelper(prev,head,tail,firstVal);
                return true;
              }
              break;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
#ELSE
        int numLeft=this.size;
        if(filter.test(head.val)){
          while(--numLeft!=0){
            if(!filter.test((head=head.next).val)){
              this.size=1+removeIfHelper(head,filter,--numLeft,modCount);
              this.modCount=modCount+1;
              this.head=head;
              return true;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
          this.head=null;
          this.tail=null;
          this.size=0;
          return true;
        }else{
          int numSurvivors;
          if(--numLeft!=(numSurvivors=removeIfHelper(head,filter,numLeft,modCount))){
            this.modCount=modCount+1;
            this.size=1+numSurvivors;
            return true;
          }
        }
#ENDIF
      }catch(ConcurrentModificationException e){
        throw e;
      }catch(RuntimeException e){
        throw CheckedCollection.checkModCount(modCount,this.modCount,e);
      }
      return false;
    }
#IF OfRef
    #MACRO QueueUncheckedRemoveVal<true,NonNull>(nonNull.equals,!nonNull.equals)
    #MACRO QueueUncheckedRemoveVal<true,Null>(null==,null!=)
    #MACRO QueueUncheckedRemoveVal<true,>(pred.test,!pred.test)
#ELSEIF OfDouble,OfFloat
    #MACRO QueueUncheckedRemoveVal<true,Bits>(bits==$convertToBits$,bits!=$convertToBits$)
    #MACRO QueueUncheckedRemoveVal<true,0>(0==,0!=)
    #MACRO QueueUncheckedRemoveVal<true,NaN>($BoxedType$.isNaN,!$BoxedType$.isNaN)
#ELSE
    #MACRO QueueUncheckedRemoveVal<true,>(val==,val!=)
#ENDIF
#IF OfRef
    @Override
    public boolean contains(Object val){
      final $SNode$$<E>$ head;
      if((head=this.head)!=null){
        if(val!=null){
          final int modCount=this.modCount;
          try{
            return $SNode$.uncheckedcontainsNonNull(head,tail,val);
          }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return $SNode$.uncheckedcontainsNull(head);
      }
      return false;
    }
#ENDIF
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      return new Itr$<E>$(this);
    }
    private static class Itr$<E>$ extends AbstractItr$<E>$
    {
      transient final CheckedQueue$<E>$ parent;
      transient int modCount;
      Itr(CheckedQueue$<E>$ parent){
        super(parent.head);
        this.parent=parent;
        this.modCount=parent.modCount;
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        CheckedCollection.checkModCount(modCount,parent.modCount);
        final $SNode$$<E>$ next;
        if((next=this.next)!=null){
          this.next=next.next;
          this.prev=this.curr;
          this.curr=next;
          return next.val;
        }
        throw new NoSuchElementException();
      }
      @Override void uncheckedForEachRemaining($SNode$$<E>$ next,$TypeNameModifier$Consumer$<? super E>$ action){
        final int modCount=this.modCount;
        $SNode$$<E>$ prev,curr;
        final CheckedQueue$<E>$ parent;
        final var tail=(parent=this.parent).tail;
        try{
          for(curr=this.curr;;next=curr.next)
          {
            action.accept(next.val);
            prev=curr;
            if((curr=next)==tail)
            {
              break;
            }
          }
        }finally{
          CheckedCollection.checkModCount(modCount,parent.modCount);
        }
        this.prev=prev;
        this.curr=curr;
        this.next=null;
      }
      @Override public void remove(){
        final $SNode$$<E>$ prev;
        if(this.curr!=(prev=this.prev)){
          final CheckedQueue$<E>$ parent;
          int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(parent=this.parent).modCount);
          parent.modCount=++modCount;
          this.modCount=modCount;
          --parent.size;
          if(prev==null){
            parent.head=next;
          }else{
            prev.next=next;
          }
          if(curr==parent.tail)
          {
            parent.tail=prev;
          }
          this.curr=prev;
          return;
        }
        throw new IllegalStateException();
      }
    }

  }
  public static class UncheckedQueue$<E>$ extends $ClassPrefix$SnglLnkSeq$<E>$ implements OmniQueue.Of$ClassPrefix$$<E>${
    private static final long serialVersionUID=1L;
    transient $SNode$$<E>$ tail;
    public UncheckedQueue(){
      super();
    }
    UncheckedQueue($SNode$$<E>$ head,int size,$SNode$$<E>$ tail){
      super(head,size);
      this.tail=tail;
    }
    @Override public boolean equals(Object val){
      //TODO
      return false;
    }
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    @Override public void readExternal(ObjectInput in) throws IOException
#IF OfRef
      ,ClassNotFoundException
#ENDIF
    {
      int size;
      this.size=size=in.readInt();
      if(size!=0)
      {
        $SNode$$<E>$ curr;
#IF OfBoolean
        int word,marker;
        for(this.head=curr=new $SNode$(((marker=1)&(word=in.readUnsignedByte()))!=0);--size!=0;curr=curr.next=new $SNode$$<E>$((word&marker)!=0))
        {
          if((marker<<=1)==(1<<8))
          {
            word=in.readUnsignedByte();
            marker=1;
          }
        }
#ELSEIF OfRef
        for(this.head=curr=new $SNode$$<E>$(($exposedType$)in.readObject());--size!=0;curr=curr.next=new $SNode$$<E>$(($exposedType$)in.readObject())){}
#ELSE
        for(this.head=curr=new $SNode$$<E>$(($exposedType$)in.read$TypeNameModifier$());--size!=0;curr=curr.next=new $SNode$$<E>$(($exposedType$)in.read$TypeNameModifier$())){}
#ENDIF
        this.tail=curr;
      }
    }
    @Override public void clear(){
      this.head=null;
      this.tail=null;
      this.size=0;
    }
    @Override public Object clone(){
      $SNode$$<E>$ head;
      if((head=this.head)!=null){
        $SNode$$<E>$ newHead=new $SNode$$<E>$(head.val),newTail=newHead;
        for(final var tail=this.tail;head!=tail;newTail=newTail.next=new $SNode$$<E>$((head=head.next).val)){}
        return new UncheckedQueue$<E>$(newHead,this.size,newTail);
      }
      return new UncheckedQueue$<E>$();
    }
    @Override void push($exposedType$ val){
      final var newNode=new $SNode$$<E>$(val);
      final $SNode$$<E>$ tail;
      if((tail=this.tail)!=null){
        tail.next=newNode;
      }else{
        this.head=newNode;
      }
      this.tail=newNode;
      ++this.size;
    }
    @Override public $exposedType$ $elementMethod$(){
      return head.val;
    }
    @Override public boolean offer($exposedType$ val){
      push(val);
      return true;
    }
    @Override public $exposedType$ remove$TypeNameModifier$(){
      final $SNode$$<E>$ head;
      if((head=this.head)==tail){
        this.tail=null;
      }
      this.head=head.next;
      --this.size;
      return head.val;
    }
    #MACRO QueuePoll<false>($exposedType$,$TypeNameModifier$,$defaultVal$,)
#IFNOT OfRef
    @Override public $BoxedType$ remove(){
      return remove$TypeNameModifier$();
    }
    @Override public $BoxedType$ element(){
      return $elementMethod$();
    }
    @Override public boolean offer($BoxedType$ val){
      push(($exposedType$)val);
      return true;
    }
    #MACRO QueuePoll<false>($BoxedType$,,null,($BoxedType$))
  #IFNOT OfDouble
    #MACRO QueuePoll<false>(double,Double,Double.NaN,$castToDouble$)
    #IFNOT OfFloat
    #MACRO QueuePoll<false>(float,Float,Float.NaN,$castToFloat$)
      #IFNOT OfLong
    #MACRO QueuePoll<false>(long,Long,Long.MIN_VALUE,$castToLong$)
        #IFNOT OfInt
    #MACRO QueuePoll<false>(int,Int,Integer.MIN_VALUE,$castToInt$)
          #IFNOT OfShort,OfChar
    #MACRO QueuePoll<false>(short,Short,Short.MIN_VALUE,$castToShort$)
            #IFNOT OfByte
    #MACRO QueuePoll<false>(byte,Byte,Byte.MIN_VALUE,$castToByte$)
    #MACRO QueuePoll<false>(char,Char,Character.MIN_VALUE,$castToChar$)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#IF OfBoolean
    private int removeIfHelper($SNode$$<E>$ prev,$SNode$$<E>$ tail,boolean retainThis)
    {
      int numSurvivors=1;
      outer:for($SNode$$<E>$ next;prev!=tail;++numSurvivors,prev=next){
        if((next=prev.next).val^retainThis){
          do{
            if(next==tail){
              this.tail=prev;
              prev.next=null;
              break outer;
            }
          }
          while((next=next.next).val^retainThis);
          prev.next=next;
        }
      }
      return numSurvivors;
    }
    private int removeIfHelper($SNode$$<E>$ prev,$SNode$$<E>$ curr,$SNode$$<E>$ tail,boolean retainThis){
      int numSurvivors=0;
      while(curr!=tail) {
        if((curr=curr.next).val==retainThis){
          prev.next=curr;
          do{
            ++numSurvivors;
            if(curr==tail){
              return numSurvivors;
            }
          }while((curr=(prev=curr).next).val==retainThis);
        }
      }
      prev.next=null;
      this.tail=prev;
      return numSurvivors;
    }
#ELSE
    private int removeIfHelper($SNode$$<E>$ prev,$SNode$$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
    {
      int numSurvivors=1;
      outer:for($SNode$$<E>$ next;prev!=tail;++numSurvivors,prev=next){
        if(filter.test((next=prev.next).val)){
          do{
            if(next==tail){
              this.tail=prev;
              prev.next=null;
              break outer;
            }
          }
          while(filter.test((next=next.next).val));
          prev.next=next;
        }
      }
      return numSurvivors;
    }
    private int removeIfHelper($SNode$$<E>$ prev,$SNode$$<E>$ curr,$SNode$$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
    {
      int numSurvivors=0;
      while(curr!=tail) {
        if(!filter.test((curr=curr.next).val)){
          prev.next=curr;
          do{
            ++numSurvivors;
            if(curr==tail){
              return numSurvivors;
            }
          }while(!filter.test((curr=(prev=curr).next).val));
        }
      }
      prev.next=null;
      this.tail=prev;
      return numSurvivors;
    }
#ENDIF
    @Override boolean uncheckedremoveIf($SNode$$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfBoolean
      boolean firstVal;
      if(filter.test(firstVal=head.val)){
        for(var tail=this.tail;head!=tail;)
        {
          if((head=head.next).val^firstVal){
            if(filter.test(firstVal=!firstVal)){
              break;
            }
            this.head=head;
            this.size=removeIfHelper(head,tail,firstVal);
            return true;
          }
        }
        this.head=null;
        this.tail=null;
        this.size=0;
        return true;
      }else{
        int numSurvivors=1;
        for(final var tail=this.tail;head!=tail;++numSurvivors)
        {
          final $SNode$$<E>$ prev;
          if((head=(prev=head).next).val^firstVal)
          {
            if(filter.test(!firstVal))
            {
              this.size=numSurvivors+removeIfHelper(prev,head,tail,firstVal);
              return true;
            }
            break;
          }
        }
        return false;
      }
#ELSE
      if(filter.test(head.val)){
        for(var tail=this.tail;head!=tail;)
        {
          if(!filter.test((head=head.next).val))
          {
            this.size=removeIfHelper(head,tail,filter);
            this.head=head;
            return true;  
          }
        }
        this.head=null;
        this.tail=null;
        this.size=0;
        return true;
      }else{
        int numSurvivors=1;
        for(final var tail=this.tail;head!=tail;++numSurvivors)
        {
          final $SNode$$<E>$ prev;
          if(filter.test((head=(prev=head).next).val))
          {
            this.size=numSurvivors+removeIfHelper(prev,head,tail,filter);
            return true;
          }
        }
        return false;
      }
#ENDIF
    }
#IF OfRef
    #MACRO QueueUncheckedRemoveVal<false,NonNull>(nonNull.equals,!nonNull.equals)
    #MACRO QueueUncheckedRemoveVal<false,Null>(null==,null!=)
    #MACRO QueueUncheckedRemoveVal<false,>(pred.test,!pred.test)
#ELSEIF OfDouble,OfFloat
    #MACRO QueueUncheckedRemoveVal<false,Bits>(bits==$convertToBits$,bits!=$convertToBits$)
    #MACRO QueueUncheckedRemoveVal<false,0>(0==,0!=)
    #MACRO QueueUncheckedRemoveVal<false,NaN>($BoxedType$.isNaN,!$BoxedType$.isNaN)
#ELSE
    #MACRO QueueUncheckedRemoveVal<false,>(val==,val!=)
#ENDIF

    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      return new Itr();
    }
    private class Itr extends AbstractItr$<E>$
    {
      Itr(){
        super(UncheckedQueue.this.head);
      }
      @Override public void remove(){
        final UncheckedQueue$<E>$ parent;
        --(parent=UncheckedQueue.this).size;
        final $SNode$$<E>$ prev;
        if((prev=this.prev)==null)
        {
          parent.head=next;
        }else{
          prev.next=next;
        }
        if(this.curr==parent.tail)
        {
          parent.tail=prev;
        }
        this.curr=prev;
      }
    }
  }
  
  private static class AbstractItr$<E>$
#IF OfRef
      implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
      extends Abstract$TypeNameModifier$Itr$<E>$
#ENDIF
  {
    transient $SNode$$<E>$ prev;
    transient $SNode$$<E>$ curr;
    transient $SNode$$<E>$ next;
    
    AbstractItr($SNode$$<E>$ next)
    {
      this.next=next; 
    }
    
    @Override public $exposedType$ next$TypeNameModifier$(){
      final $SNode$$<E>$ next;
      this.next=(next=this.next).next;
      this.prev=this.curr;
      this.curr=next;
      return next.val;
    }
    
    @Override public boolean hasNext(){
      return next!=null;
    }
    void uncheckedForEachRemaining($SNode$$<E>$ next,$TypeNameModifier$Consumer$<? super E>$ action){
      $SNode$$<E>$ prev,curr=this.curr;
      do{
        action.accept(next.val);
        prev=curr;
      }while((next=(curr=next).next)!=null);
      this.prev=prev;
      this.curr=curr;
      this.next=null;
    }
    @Override public void forEachRemaining($TypeNameModifier$Consumer$<? super E>$ action){
      final $SNode$$<E>$ next;
      if((next=this.next)!=null){
        uncheckedForEachRemaining(next,action);
      }
    }
#IFNOT OfRef
    @Override public void forEachRemaining(Consumer<? super $BoxedType$> action){
      final $SNode$$<E>$ next;
      if((next=this.next)!=null){
        uncheckedForEachRemaining(next,action::accept);
      }
    }
#ENDIF
    
  }
}




#MACRODEF add(INPUTTYPE,CAST)
@Override public boolean add(INPUTTYPE val)
{
  push(CAST(val));
  return true;
}
#ENDDEF
#MACRODEF peek(RETTYPE,SUFFIX,DEFAULTVAL,CAST)
public RETTYPE peekSUFFIX(){
  final $SNode$$<E>$ head;
  if((head=this.head)!=null){
    return CAST(head.val);
  }
  return DEFAULTVAL;
}
#ENDDEF
#MACRODEF QueuePoll<CHECKED>(RETTYPE,SUFFIX,DEFAULTVAL,CAST)
@Override public RETTYPE pollSUFFIX(){
  final $SNode$$<E>$ head;
  if((head=this.head)!=null){
    final var ret=CAST(head.val);
    if(head==this.tail)
    {
      this.tail=null;
    }
    this.head=head.next;
    --this.size;
#IFSWITCH CHECKED==true
    ++this.modCount;
#ENDIF
    return ret;
  }
  return DEFAULTVAL;
}
#ENDDEF
#MACRODEF StackPoll<CHECKED>(RETTYPE,SUFFIX,DEFAULTVAL,CAST)
@Override public RETTYPE pollSUFFIX(){
  final $SNode$$<E>$ head;
  if((head=this.head)!=null){
    final var ret=CAST(head.val);
    this.head=head.next;
    --this.size;
#IFSWITCH CHECKED==true
    ++this.modCount;
#ENDIF
    return ret;
  }
  return DEFAULTVAL;
}
#ENDDEF
#MACRODEF UncheckedQueryParam()
#IFSWITCH SUFFIX==NonNull
,Object nonNull
#ELSEIFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==Null,0,NaN
#ELSE
  #IF OfRef
,$TypeNameModifier$Predicate$<? super E>$ pred
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
#ENDDEF


#MACRODEF QueueUncheckedRemoveVal<CHECKED,SUFFIX>(POSTEST,NEGTEST)
@Override boolean uncheckedremoveValSUFFIX($SNode$$<E>$ head
#MACRO UncheckedQueryParam()
){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
  final int modCount=this.modCount;
  #ENDIF
#ENDIF
  if(POSTEST(head.val))
  {
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
    CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
#ENDIF
    
    if(head==tail)
    {
      this.tail=null;
    }
    this.head=head.next;
  }else{
    $SNode$$<E>$ prev;
    #IFSWITCH CHECKED==true
      #IFSWITCH SUFFIX==NonNull
    try
      #ENDIF
    #ENDIF
    {
      do{
        if(head==tail)
        {
          return false;
        }
        //if((head=(prev=head).next)==null){
        //  return false;
        //}
      }while(NEGTEST((head=(prev=head).next).val));
    }
    #IFSWITCH CHECKED==true
      #IFSWITCH SUFFIX==NonNull
    finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
      #ENDIF
    #ENDIF
    if(head==tail)
    {
      this.tail=prev;
    }
    prev.next=head.next;
  }
#IFSWITCH CHECKED==true
  this.modCount=modCount+1;
#ENDIF
  --this.size;
  return true;
}
#ENDDEF
#MACRODEF StackUncheckedRemoveVal<CHECKED,SUFFIX>(POSTEST,NEGTEST)
@Override boolean uncheckedremoveValSUFFIX($SNode$$<E>$ head
  #MACRO UncheckedQueryParam()
)
{
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
  final int modCount=this.modCount;
  #ENDIF
#ENDIF
  if(POSTEST(head.val)){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
    CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
#ENDIF
    this.head=head.next;
  }else{
    $SNode$$<E>$ prev;
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
    try
  #ENDIF
#ENDIF
    {
      do{
        if((head=(prev=head).next)==null){
          return false;
        }
      }while(NEGTEST(head.val));
    }
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
    finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
  #ENDIF
#ENDIF
    prev.next=head.next;
  }
#IFSWITCH CHECKED==true
  this.modCount=modCount+1;
#ENDIF
  --this.size;
  return true;
}
#ENDDEF
#MACRODEF ToArrayImpl(DSTARR,DEFAULTARR,CLASSPREFIX)
@Override public DSTARR[] toCLASSPREFIXArray(){
  final $SNode$$<E>$ head;
  if((head=this.head)!=null){
    final DSTARR[] dst;
    $SNode$.uncheckedCopyInto(head,dst=new DSTARR[this.size]);
    return dst;
  }
  return DEFAULTARR;
}
#ENDDEF


#MACRODEF QueryMethods<STRUCTNAME,METHODNAME>()
#IFSWITCH STRUCTNAME==Root
  #MACRO QueryMethod<boolean>( )
  #MACRO QueryMethod<int>( )
  #MACRO QueryMethod<long>( )
  #MACRO QueryMethod<float>( )
  #MACRO QueryMethod<double>( )
  #MACRO QueryMethod<Object>( )
  #IF OfByte,OfInt,OfLong
    #IFSWITCH METHODNAME==removeVal,contains
  #MACRO QueryMethod<byte>( )
  #MACRO QueryMethod<char>( )
    #ENDIF
  #ENDIF
  #IF OfChar,OfDouble,OfFloat,OfRef,OfShort
    #IFSWITCH METHODNAME==removeVal,contains
  #MACRO QueryMethod<byte>( )
  #MACRO QueryMethod<char>( )
  #MACRO QueryMethod<short>( )
    #ENDIF
  #ENDIF
  #IF OfRef
  #MACRO QueryMethod<Boolean>((boolean))
  #MACRO QueryMethod<Byte>((byte))
  #MACRO QueryMethod<Character>((char))
  #MACRO QueryMethod<Short>((short))
  #MACRO QueryMethod<Integer>((int))
  #MACRO QueryMethod<Long>((long))
  #MACRO QueryMethod<Float>((float))
  #MACRO QueryMethod<Double>((double))
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedStack
  #IFSWITCH METHODNAME==search
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
    #IF OfByte
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
    #ENDIF
    #IF OfChar,OfFloat,OfShort
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
    #ENDIF
    #IF OfRef
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
    #ENDIF
  #ELSE
ERROR unknown method name METHODNAME
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF SizeCheck()
final $SNode$$<E>$ head;
if((head=this.head)!=null)
#ENDDEF
#MACRODEF ReturnUncheckedQueryBits(VAL)
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQueryBits(VAL) is only valid for Float and Double
#ENDIF
#IFSWITCH METHODNAME==contains,search
return $SNode$.uncheckedMETHODNAMEBits(head,VAL);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAMEBits(head,VAL);
#ELSE
ERROR unknown method name METHODNAME
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQuery0()
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQuery0() is only valid for Float and Double
#ENDIF
#IFSWITCH METHODNAME==contains,search
return $SNode$.uncheckedMETHODNAME0(head);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAME0(head);
#ELSE
ERROR unknown method name METHODNAME
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryNaN()
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQueryNaN() is only valid for Float and Double
#ENDIF
#IFSWITCH METHODNAME==contains,search
return $SNode$.uncheckedMETHODNAMENaN(head);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAMENaN(head);
#ELSE
ERROR unknown method name METHODNAME
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQuery(VAL)
#IF OfFloat,OfDouble
ERROR ReturnUncheckedQuery(VAL) is not valid for $ClassPrefix$
#ENDIF
#IFSWITCH METHODNAME==contains,search
return $SNode$.uncheckedMETHODNAME(head,VAL);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAME(head,VAL);
#ELSE
ERROR unknown method name METHODNAME
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryNonNull(VAL)
#IFNOT OfRef
ERROR ReturnUncheckedQueryNonNull(VAL) is not valid for $ClassPrefix$
#ENDIF
#IFSWITCH METHODNAME==contains,search
return $SNode$.uncheckedMETHODNAMENonNull(head,VAL);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAMENonNull(head,VAL);
#ELSE
ERROR unknown method name METHODNAME
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryNull()
#IFNOT OfRef
ERROR ReturnUncheckedQueryNull() is not valid for $ClassPrefix$
#ENDIF
#IFSWITCH METHODNAME==contains,search
return $SNode$.uncheckedMETHODNAMENull(head);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAMENull(head);
#ELSE
ERROR unknown method name METHODNAME
#ENDIF
#ENDDEF
#MACRODEF CheckedSubListQueryModCountDecl()
#ENDDEF
#MACRODEF CheckedSubListQueryFinallyModCount()
#ENDDEF
#MACRODEF CheckedSubListRemoveValModCountCheck()
#ENDDEF
#MACRODEF QueryMethod<INPUTTYPE>(CAST)
#IFSWITCH METHODNAME==removeVal
  #IFSWITCH INPUTTYPE==Object
@Override public boolean remove(INPUTTYPE val){
  #ELSE
@Override public boolean METHODNAME(INPUTTYPE val){
  #ENDIF
#ELSEIFSWITCH METHODNAME==contains
@Override public boolean METHODNAME(INPUTTYPE val){
#ELSEIFSWITCH METHODNAME==search,indexOf,lastIndexOf
@Override public int METHODNAME(INPUTTYPE val){
#ELSE
ERROR unknown method name METHODNAME
#ENDIF
#IFSWITCH INPUTTYPE==byte,short
  #IF OfChar
  if(val>=0)
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==char
  #IF OfByte,OfShort
  if(val<=$BoxedType$.MAX_VALUE)
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==int
  #IF OfByte,OfChar,OfShort
  if(val==($ArrayType$)val)
  #ENDIF
#ENDIF
  {
    #MACRO CheckedSubListQueryModCountDecl()
    {
      #MACRO SizeCheck()
      {
#IFSWITCH INPUTTYPE==boolean
  #IF OfDouble,OfFloat
        if(val)
        {
          #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
        }
        #MACRO ReturnUncheckedQuery0()
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastBoolean$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==byte,char,short
  #IF OfDouble,OfFloat
        if(val!=0)
        {
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
        #MACRO ReturnUncheckedQuery0()
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==int
  #IF OfBoolean
        returnFalse:for(;;)
        {
          final $ArrayType$ v;
          switch(val)
          {
          default:
            break returnFalse;
          case 0:
            v=false;
            break;
          case 1:
            v=true;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat,OfDouble
    #IF OfDouble
    #ENDIF
        if(val!=0)
        {
    #IF OfFloat
          if(TypeUtil.checkCastTo$ClassPrefix$(val))
    #ENDIF
          {
            #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
          }
        }
        else
        {
          #MACRO ReturnUncheckedQuery0()
        }
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==long
  #IF OfBoolean
        returnFalse:for(;;)
        {
          final $ArrayType$ v;
          if(val==0L)
          {
            v=false;
          }else if(val==1L)
          {
            v=true;
          }
          else
          {
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat,OfDouble
        if(val!=0)
        {
          if(TypeUtil.checkCastTo$ClassPrefix$(val))
          {
            #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
          }
        }
        else
        {
          #MACRO ReturnUncheckedQuery0()
        }
  #ELSEIF OfByte,OfChar,OfShort,OfInt
        final $ArrayType$ v;
        if((v=($ArrayType$)val)==val)
        {
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==float
  #IF OfBoolean
        returnFalse:for(;;)
        {
          final $ArrayType$ v;
          switch(Float.floatToRawIntBits(val))
          {
            default:
              break returnFalse;
            case 0:
            case Integer.MIN_VALUE:
              v=false;
              break;
            case TypeUtil.FLT_TRUE_BITS:
              v=true;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat,OfDouble
        if(val==val)
        {
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
        #MACRO ReturnUncheckedQueryNaN()
  #ELSEIF OfRef
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ELSE
        final $ArrayType$ v;
    #IF OfLong
        if(TypeUtil.floatEquals(val,v=($ArrayType$)val))
    #ELSEIF OfInt
        if((double)val==(double)(v=($ArrayType$)val))
    #ELSE
        if(val==(v=($ArrayType$)val))
    #ENDIF
        {
          #MACRO ReturnUncheckedQuery(v)
        }
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==double
  #IF OfBoolean
        returnFalse:for(;;)
        {
          final $ArrayType$ v;
          long bits;
          if((bits=Double.doubleToRawLongBits(val))==0 || bits==Long.MIN_VALUE)
          {
            v=false;
          }
          else if(bits==TypeUtil.DBL_TRUE_BITS)
          {
            v=true;
          }
          else
          {
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat
        final $ArrayType$ v;
        if(val==(v=($ArrayType$)val))
        {
          #MACRO ReturnUncheckedQueryBits($convertToBits$(v))
        }
        else if(v!=v)
        {
          #MACRO ReturnUncheckedQueryNaN()
        }
  #ELSEIF OfDouble
        if(val==val)
        {
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
        #MACRO ReturnUncheckedQueryNaN()
  #ELSEIF OfRef
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ELSE
        final $ArrayType$ v;
    #IF OfLong
        if(TypeUtil.doubleEquals(val,v=($ArrayType$)val))
    #ELSE
        if(val==(v=($ArrayType$)val))
    #ENDIF
        {
          #MACRO ReturnUncheckedQuery(v)
        }
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==Object
  #IF OfRef
        if(val!=null)
        {
          #MACRO ReturnUncheckedQueryNonNull(val)
        }
        #MACRO ReturnUncheckedQueryNull()
  #ELSE
        //TODO a pattern-matching switch statement would be great here
        returnFalse:for(;;){
    #IF OfBoolean
          final boolean b;
          if(val instanceof Boolean){
            b=(boolean)val;
          }else if(val instanceof Integer||val instanceof Byte||val instanceof Short){
            switch(((Number)val).intValue()){
              default:
                break returnFalse;
              case 0:
                b=false;
                break;
              case 1:
                b=true;
            }
          }else if(val instanceof Float){
            switch(Float.floatToRawIntBits((float)val)){
              default:
                break returnFalse;
              case 0:
              case Integer.MIN_VALUE:
                b=false;
                break;
              case TypeUtil.FLT_TRUE_BITS:
                b=true;
            }
          }else if(val instanceof Double){
            final long bits;
            if((bits=Double.doubleToRawLongBits((double)val))==0L || bits==Long.MIN_VALUE){
              b=false;
            }else if(bits==TypeUtil.DBL_TRUE_BITS){
              b=true;
            }else{
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long v;
            if((v=(long)val)==0L){
              b=false;
            }else if(v==1L){
              b=true;
            }else{
             break returnFalse;
            }
          }else if(val instanceof Character){
            switch(((Character)val).charValue()){
              default:
                break returnFalse;
              case 0:
                b=false;
                break;
              case 1:
                b=true;
            }
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(b)
    #ELSEIF OfByte
          final int i;
          if(val instanceof Byte){
            i=(byte)val;
          }else if(val instanceof Integer||val instanceof Short){
            if((i=((Number)val).intValue())!=(byte)i){
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(byte)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)!=(i=(byte)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(byte)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            if((i=(char)val)>Byte.MAX_VALUE){
              break returnFalse;
            }
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfChar
          final int i;
          if(val instanceof Character){
            i=(char)val;
          }else if(val instanceof Integer){
            if((i=(int)val)!=(char)i){
              break returnFalse;
            }
          }else if(val instanceof Byte||val instanceof Short){
            if((i=((Number)val).shortValue())<0){
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(char)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)!=(i=(char)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(char)d)){
              break returnFalse;
            }
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfShort
          final int i;
          if(val instanceof Short||val instanceof Byte){
            i=((Number)val).shortValue();
          }else if(val instanceof Integer){
            if((i=(int)val)!=(short)i){
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(short)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)!=(i=(short)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(short)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            if((i=(char)val)>Short.MAX_VALUE){
              break returnFalse;
            }
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfInt
          final int i;
          if(val instanceof Integer||val instanceof Byte||val instanceof Short){
            i=((Number)val).intValue();
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(int)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((double)(f=(float)val)!=(double)(i=(int)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(int)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            i=(char)val;
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfLong
          final long l;
          if(val instanceof Long||val instanceof Integer||val instanceof Byte||val instanceof Short){
            l=((Number)val).longValue();
          }else if(val instanceof Float){
            final float f;
            if(!TypeUtil.floatEquals(f=(float)val,l=(long)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if(!TypeUtil.doubleEquals(d=(double)val,l=(long)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            l=(char)val;
          }else if(val instanceof Boolean){
            l=TypeUtil.castToLong((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(l);
    #ELSEIF OfFloat
          if(val instanceof Float){
            final float f;
            if((f=(float)val)==f){
               #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
            }
            #MACRO ReturnUncheckedQueryNaN()
          }else if(val instanceof Double){
            final double d;
            final float f;
            if((d=(double)val)==(f=(float)d)){
              #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
            }else if(f!=f){
              #MACRO ReturnUncheckedQueryNaN()
            }else{
              break returnFalse;
            }
          }else if(val instanceof Integer){
            final int i;
            if((i=(int)val)!=0){
              if(!TypeUtil.checkCastToFloat(i)){
                break returnFalse;
              }
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=0){
              if(!TypeUtil.checkCastToFloat(l)){
                break returnFalse;
              }
              #MACRO ReturnUncheckedQueryBits($convertToBits$(l))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Short||val instanceof Byte){
            final int i;
            if((i=((Number)val).shortValue())!=0){
     
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Character){
            final int i;
            if((i=(char)val)!=0){
     
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Boolean){
            if((boolean)val){
              #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
            }
            #MACRO ReturnUncheckedQuery0()
          }else{
            break returnFalse;
          }
    #ELSE
          if(val instanceof Double){
            final double d;
            if((d=(double)val)==d){
               #MACRO ReturnUncheckedQueryBits($convertToBits$(d))
            }
            #MACRO ReturnUncheckedQueryNaN()
          }else if(val instanceof Float){
            
            final float f;
            if((f=(float)val)==f){
               #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
            }
            #MACRO ReturnUncheckedQueryNaN()
          }else if(val instanceof Integer|| val instanceof Short||val instanceof Byte){
            final int i;
            if((i=((Number)val).intValue())!=0){
     
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=0){
              if(!TypeUtil.checkCastToDouble(l)){
                break returnFalse;
              }
              #MACRO ReturnUncheckedQueryBits($convertToBits$(l))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Character){
            final int i;
            if((i=(char)val)!=0){
     
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Boolean){
            if((boolean)val){
              #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
            }
            #MACRO ReturnUncheckedQuery0()
          }else{
            break returnFalse;
          }
    #ENDIF
        }
  #ENDIF
#ELSE
        if(val!=null)
        {
          #MACRO ReturnUncheckedQuery($queryCastRef$(CAST(val)))
        }
        #MACRO ReturnUncheckedQueryNull()
#ENDIF
      } //end size check
    } //end checked sublist try modcount
    #MACRO CheckedSubListQueryFinallyModCount()
  }//end val check
#IFSWITCH METHODNAME==search,indexOf,lastIndexOf
  return -1;
#ELSE
  #MACRO CheckedSubListRemoveValModCountCheck()
  return false;
#ENDIF
}
#ENDDEF
