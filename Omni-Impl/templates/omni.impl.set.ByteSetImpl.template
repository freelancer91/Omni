#TYPEDEF OfByte
package omni.impl.set;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.NoSuchElementException;
import java.util.function.Consumer;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import omni.api.OmniSet;
import omni.api.OmniIterator;
import omni.function.ByteConsumer;
import omni.function.BytePredicate;
import omni.impl.AbstractByteItr;
import omni.impl.CheckedCollection;
import omni.util.OmniArray;
import omni.util.ToStringUtil;
public class ByteSetImpl implements OmniSet.OfByte,Cloneable,Externalizable{
  private static final long serialVersionUID=1L;
  transient long word0;
  transient long word1;
  transient long word2;
  transient long word3;
  public ByteSetImpl(){
    super();
  }
  ByteSetImpl(long word0,long word1,long word2,long word3){
    this.word0=word0;
    this.word1=word1;
    this.word2=word2;
    this.word3=word3;
  }
  public ByteSetImpl(ByteSetImpl that){
    this.word0=that.word0;
    this.word1=that.word1;
    this.word2=that.word2;
    this.word3=that.word3;
  }
  @Override public Object clone(){
      return new ByteSetImpl(this);
  }
  private static int size(long word0,long word1,long word2,long word3){
    return Long.bitCount(word0) + Long.bitCount(word1) + Long.bitCount(word2) + Long.bitCount(word3);
  }
  private static long processWordToString(long word,int valOffset,int valBound,byte[] buffer,long magicWord){
    int bufferOffset=(int)(magicWord >>> 32);
    int numLeft=(int)magicWord;
    do{
      if((word & 1L << valOffset) != 0L){
        bufferOffset=ToStringUtil.getStringShort(valOffset,buffer,++bufferOffset);
        if(--numLeft == 0){
          break;
        }
        buffer[++bufferOffset]=',';
        buffer[++bufferOffset]=' ';
      }
    }while(++valOffset != valBound);
    return numLeft | (long)bufferOffset << 32;
  }
  private static long processWordHashCode(long word,int valOffset,int valBound,long magicWord){
    int hash=(int)(magicWord >>> 32);
    int numLeft=(int)magicWord;
    do{
      if((word & 1L << valOffset) != 0L){
        hash+=valOffset;
        if(--numLeft == 0){
          break;
        }
      }
    }while(++valOffset != valBound);
    return numLeft | (long)hash << 32;
  }
  private static String toStringHelper(long word0,long word1,long word2,long word3,int size) {
    final byte[] buffer;
    (buffer=new byte[size * 6])[0]='[';
    long magicWord;
    if((int)(magicWord=processWordToString(word0,Byte.MIN_VALUE,-64,buffer,size)) != 0){
      if((int)(magicWord=processWordToString(word1,-64,0,buffer,magicWord)) != 0){
        if((int)(magicWord=processWordToString(word2,0,64,buffer,magicWord)) != 0){
          magicWord=processWordToString(word3,64,128,buffer,magicWord);
        }
      }
    }
    buffer[size=(int)(magicWord >>> 32) + 1]=']';
    return new String(buffer,0,size + 1,ToStringUtil.IOS8859CharSet);
  }
  private static int hashCodeHelper(long word0,long word1,long word2,long word3,int size) {
    long magicWord;
    if((int)(magicWord=processWordHashCode(word0,Byte.MIN_VALUE,-64,size)) != 0){
      if((int)(magicWord=processWordHashCode(word1,-64,0,magicWord)) != 0){
        if((int)(magicWord=processWordHashCode(word2,0,64,magicWord)) != 0){
          magicWord=processWordHashCode(word3,64,128,magicWord);
        }
      }
    }
    return (int)(magicWord >>> 32);
  }
  @Override public String toString(){
    int size;
    long word0,word1,word2,word3;
    if((size=size(word0=this.word0,word1=this.word1,word2=this.word2,word3=this.word3)) != 0){
      return toStringHelper(word0,word1,word2,word3,size);
    }
    return "[]";
  }
  @Override public int hashCode(){
    int size;
    long word0,word1,word2,word3;
    if((size=size(word0=this.word0,word1=this.word1,word2=this.word2,word3=this.word3)) != 0){
      return hashCodeHelper(word0,word1,word2,word3,size);
    }
    return 0;
  }
  @Override public boolean equals(Object val){
    // TODO
    return false;
  }
  @Override public void writeExternal(ObjectOutput out) throws IOException{
    out.writeLong(word0);
    out.writeLong(word1);
    out.writeLong(word2);
    out.writeLong(word3);
  }
  @Override public void readExternal(ObjectInput in) throws IOException{
    word0=in.readLong();
    word1=in.readLong();
    word2=in.readLong();
    word3=in.readLong();
  }
  @Override public void clear(){
    word0=0;
    word1=0;
    word2=0;
    word3=0;
  }
  private boolean uncheckedRemoveByte(int val){
    long word,mask=~(1L << val);
    switch(val >> 6){
    case -2:
      return (word=this.word0) != (this.word0=word & mask);
    case -1:
      return (word=this.word1) != (this.word1=word & mask);
    case 0:
      return (word=this.word2) != (this.word2=word & mask);
    default:
      return (word=this.word3) != (this.word3=word & mask);
    }
  }
  @Override public boolean contains(Object val){
    if(val instanceof Byte){
      return contains((byte)val);
    }else if(val instanceof Integer || val instanceof Short){
      return contains(((Number)val).intValue());
    }else if(val instanceof Long){
      return contains((long)val);
    }else if(val instanceof Float){
      return contains((float)val);
    }else if(val instanceof Double){
      return contains((double)val);
    }else if(val instanceof Character){
      return contains((char)val);
    }else if(val instanceof Boolean){
      return contains((boolean)val);
    }
    return false;
  }
#MACRODEF WordContains(WORDNUM,MASK)
return (this.wordWORDNUM&(MASK))!=0;
#ENDDEF
  @Override public boolean contains(boolean val){
    #MACRO WordContains(2,val?2L:1L)
  }
  @Override public boolean contains(byte val){
    long mask=1L << val;
    switch(val >> 6){
    case -2:
      #MACRO WordContains(0,mask)
    case -1:
      #MACRO WordContains(1,mask)
    case 0:
      #MACRO WordContains(2,mask)
    default:
      #MACRO WordContains(3,mask)
    }
  }
  @Override public boolean contains(char val){
    switch(val){
    case 0:
      #MACRO WordContains(2,1L<<val)
    case 1:
      #MACRO WordContains(3,1L<<val)
    default:
      return false;
    }
  }
  @Override public boolean contains(int val){
    switch(val >> 6){
    case -2:
      #MACRO WordContains(0,1L<<val)
    case -1:
      #MACRO WordContains(1,1L<<val)
    case 0:
      #MACRO WordContains(2,1L<<val)
    case 1:
      #MACRO WordContains(3,1L<<val)
    default:
      return false;
    }
  }
  @Override public boolean contains(long val){
      int v;
      return (v=(int)val) == val && contains(v);
  }
  @Override public boolean contains(float val){
      int v;
      return (v=(int)val) == val && contains(v);
  }
  @Override public boolean contains(double val){
      int v;
      return (v=(int)val) == val && contains(v);
  }
  @Override public boolean remove(Object val){
    for(;;) {
      int v;
      if(val instanceof Byte){
        return uncheckedRemoveByte((byte)val);
      }else if(val instanceof Integer || val instanceof Short){
        v=((Number)val).intValue();
      }else if(val instanceof Long){
        long l;
        if((v=(int)(l=(long)val)) != l) {
          break;
        }
      }else if(val instanceof Float){
        float f;
        if((v=(int)(f=(float)val)) != f) {
          break;
        }
      }else if(val instanceof Double){
        double d;
        if((v=(int)(d=(double)val)) != d) {
          break;
        }
      }else if(val instanceof Character){
        return uncheckedRemoveChar((char)val);
      }else if(val instanceof Boolean){
        return uncheckedRemoveBoolean((boolean)val);
      }else {
        break;
      }
      return uncheckedRemoveInt(v);
    }
    return false;
  }
  @Override public boolean removeVal(boolean val){
    return uncheckedRemoveBoolean(val);
  }
  @Override public boolean removeVal(byte val){
    return uncheckedRemoveByte(val);
  }
  @Override public boolean removeVal(char val){
    return uncheckedRemoveChar(val);
  }
#MACRODEF RemoveFromWord(WORDNUM,MASK)
return (word=this.wordWORDNUM) != (this.wordWORDNUM=word & (MASK));
#ENDDEF
  private boolean uncheckedRemoveBoolean(boolean val) {
    long word;
    #MACRO RemoveFromWord(2,val?~2L:~1L)
  }
  private boolean uncheckedRemoveInt(int val){
    long word;
    switch(val >> 6){
    case -2:
      #MACRO RemoveFromWord(0,~(1L<<val))
    case -1:
      #MACRO RemoveFromWord(1,~(1L<<val))
    case 0:
      #MACRO RemoveFromWord(2,~(1L<<val))
    case 1:
      #MACRO RemoveFromWord(3,~(1L<<val))
    default:
      return false;
    }
  }
  private boolean uncheckedRemoveChar(int val) {
    long word;
    switch(val){
    case 0:
      #MACRO RemoveFromWord(2,~(1L<<val))
    case 1:
      #MACRO RemoveFromWord(3,~(1L<<val))
    default:
      return false;
    }
  }
  @Override public boolean removeVal(int val){
    return uncheckedRemoveInt(val);
  }
  @Override public boolean removeVal(long val){
    int v;
    return (v=(int)val) == val && uncheckedRemoveInt(v);
  }
  @Override public boolean removeVal(float val){
    int v;
    return (v=(int)val) == val && uncheckedRemoveInt(v);
  }
  @Override public boolean removeVal(double val){
    int v;
    return (v=(int)val) == val && uncheckedRemoveInt(v);
  }
  @Override public boolean isEmpty(){
    return word0 == 0 && word1 == 0 && word2 == 0 && word3 == 0;
  }
  @Override public int size(){
    return size(word0,word1,word2,word3);
  }
#MACRODEF ToArrayHelper<ARRTYPE>(CAST,BOUND1,BOUND2,BOUND3,BOUND4,BOUND5,DEFAULTARR,MODIFIER)
private static int processWordCopyToArray(long word,int valOffset,int valBound,ARRTYPE[] dst,int dstOffset){
  do{
    if((word & 1L << --valBound) != 0L){
      dst[--dstOffset]=CAST(valBound);
      if(dstOffset == 0){
        break;
      }
    }
  }while(valBound != valOffset);
  return dstOffset;
}
private static void toArrayHelper(long word0,long word1,long word2,long word3,int size,ARRTYPE[] arr) {
  if((size=processWordCopyToArray(word3,BOUND4,BOUND5,arr,size)) != 0){
    if((size=processWordCopyToArray(word2,BOUND3,BOUND4,arr,size)) != 0){
      if((size=processWordCopyToArray(word1,BOUND2,BOUND3,arr,size)) != 0){
        int valBound=BOUND2;
        do{
          if((word0 & 1L << --valBound) != 0L){
            arr[--size]=CAST(valBound);
            if(size == 0){
                break;
            }
          }
        }while(valBound != BOUND1);
      }
    }
  }
}
#IFNOTSWITCH ARRTYPE==Object
@Override public ARRTYPE[] toMODIFIERArray(){
  long word0,word1,word2,word3;
  int size;
  if((size=size(word0=this.word0,word1=this.word1,word2=this.word2,word3=this.word3)) != 0){
      ARRTYPE[] dst;
      toArrayHelper(word0,word1,word2,word3,size,dst=new ARRTYPE[size]);
      return dst;
  }
  return DEFAULTARR;
}
#ENDIF
#ENDDEF
  #MACRO ToArrayHelper<Object>((byte),Byte.MIN_VALUE,-64,0,64,128,OmniArray.OfByte.DEFAULT_BOXED_ARR,)
  #MACRO ToArrayHelper<Byte>((byte),Byte.MIN_VALUE,-64,0,64,128,OmniArray.OfByte.DEFAULT_BOXED_ARR,)
  #MACRO ToArrayHelper<byte>((byte),Byte.MIN_VALUE,-64,0,64,128,OmniArray.OfByte.DEFAULT_ARR,Byte)
  #MACRO ToArrayHelper<short>((short),Byte.MIN_VALUE,-64,0,64,128,OmniArray.OfShort.DEFAULT_ARR,Short)
  #MACRO ToArrayHelper<int>(,Byte.MIN_VALUE,-64,0,64,128,OmniArray.OfInt.DEFAULT_ARR,Int)
  #MACRO ToArrayHelper<long>(,Byte.MIN_VALUE,-64,0,64,128,OmniArray.OfLong.DEFAULT_ARR,Long)
  #MACRO ToArrayHelper<float>(,Byte.MIN_VALUE,-64,0,64,128,OmniArray.OfFloat.DEFAULT_ARR,Float)
  #MACRO ToArrayHelper<double>(,Byte.MIN_VALUE,-64,0,64,128,OmniArray.OfDouble.DEFAULT_ARR,Double)
  @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
    long word0,word1,word2,word3;
    int size;
    T[] arr=arrConstructor.apply(size=size(word0=this.word0,word1=this.word1,word2=this.word2,word3=this.word3));
    if(size != 0){
      toArrayHelper(word0,word1,word2,word3,size,arr);
    }
    return arr;
  }
  @Override public <T> T[] toArray(T[] dst){
    long word0,word1,word2,word3;
    int size;
    if((size=size(word0=this.word0,word1=this.word1,word2=this.word2,word3=this.word3)) != 0){
      toArrayHelper(word0,word1,word2,word3,size,dst=OmniArray.uncheckedArrResize(size,dst));
    }else if(dst.length != 0){
      dst[0]=null;
    }
    return dst;
  }
#MACRODEF AddToWord(WORDNUM,MASK)
return (word=this.wordWORDNUM) != (this.wordWORDNUM=word | (MASK));
#ENDDEF
  @Override public boolean add(boolean val){
    long word;
    #MACRO AddToWord(2,val?2L:1L)
  }
  @Override public boolean add(byte val){
    long word,mask=1L << val;
    switch(val >> 6){
    case -2:
      #MACRO AddToWord(0,mask)
    case -1:
      #MACRO AddToWord(1,mask)
    case 0:
      #MACRO AddToWord(2,mask)
    default:
      #MACRO AddToWord(3,mask)
    }
  }
  @Override public boolean add(Byte val){
    return add((byte)val);
  }
  private static int processWordForEach(long word,int valOffset,int valBound,ByteConsumer action,int numLeft){
    do{
      if((word & 1L << valOffset) != 0L){
        action.accept((byte)valOffset);
        if(--numLeft == 0){
          break;
        }
      }
    }while(++valOffset != valBound);
    return numLeft;
  }
  private static void forEachHelper(long word0,long word1,long word2,long word3,int size,ByteConsumer action) {
    if((size=processWordForEach(word0,Byte.MIN_VALUE,-64,action,size)) != 0){
      if((size=processWordForEach(word1,-64,0,action,size)) != 0){
        if((size=processWordForEach(word2,0,64,action,size)) != 0){
          int valOffset=64;
          do{
            if((word3 & 1L << valOffset) != 0L){
              action.accept((byte)valOffset);
              if(--size == 0){
                break;
              }
            }
          }while(++valOffset != 128);
        }
      }
    }
  }
  #MACRO forEach(ByteConsumer,action)
  #MACRO forEach(Consumer<? super Byte>,action::accept)
#MACRODEF forEach(CONSUMER,ACTION)
@Override public void forEach(CONSUMER action){
  long word0,word1,word2,word3;
  int size;
  if((size=size(word0=this.word0,word1=this.word1,word2=this.word2,word3=this.word3)) != 0){
    forEachHelper(word0,word1,word2,word3,size,ACTION);
  }
}
#ENDDEF
  #MACRO removeIf(BytePredicate)
  #MACRO removeIf(Predicate<? super Byte>)
#MACRODEF removeIf(PREDICATE)
private static long processWordRemoveIf(long word,int valOffset,PREDICATE filter){
  long marker=1L;
  for(;;){
    if((word & marker) != 0){
      if(filter.test((byte)valOffset)){
        word&=~marker;
      }
    }
    if((marker<<=1) == 0){
      return word;
    }
    ++valOffset;
  }
}
@Override public boolean removeIf(PREDICATE filter){
  long word;
  return (word=this.word0) != (this.word0=processWordRemoveIf(word,Byte.MIN_VALUE,filter))
    | (word=this.word1) != (this.word1=processWordRemoveIf(word,-64,filter))
    | (word=this.word2) != (this.word2=processWordRemoveIf(word,0,filter))
    | (word=this.word3) != (this.word3=processWordRemoveIf(word,64,filter));
}
#ENDDEF
  private static class Itr extends AbstractByteItr{
    private final ByteSetImpl root;
    private int valOffset;
    private Itr(ByteSetImpl root){
        this.root=root;
        int tail0s;
        if((tail0s=Long.numberOfTrailingZeros(root.word0)) != 64){
            this.valOffset=tail0s - 128;
        }else if((tail0s=Long.numberOfTrailingZeros(root.word1)) != 64){
            this.valOffset=tail0s - 64;
        }else if((tail0s=Long.numberOfTrailingZeros(root.word2)) != 64){
            this.valOffset=tail0s;
        }else{
            this.valOffset=Long.numberOfTrailingZeros(root.word3) + 64;
        }
    }
    @Override public boolean hasNext(){
        return this.valOffset != 128;
    }
    @Override public byte nextByte(){
        int valOffset;
        var ret=(byte)(valOffset=this.valOffset);
        var root=this.root;
        switch(++valOffset >> 6){
        case -2:
            if((valOffset=Long.numberOfTrailingZeros(root.word0 >>> valOffset)) != 64){
                this.valOffset=valOffset - 128;
                break;
            }
            valOffset=0;
        case -1:
            if((valOffset=Long.numberOfTrailingZeros(root.word1 >>> valOffset)) != 64){
                this.valOffset=valOffset - 64;
                break;
            }
            valOffset=0;
        case 0:
            if((valOffset=Long.numberOfTrailingZeros(root.word2 >>> valOffset)) != 64){
                this.valOffset=valOffset;
                break;
            }
            valOffset=0;
        case 1:
            this.valOffset=Long.numberOfTrailingZeros(root.word3 >>> valOffset) + 64;
            break;
        default:
            this.valOffset=128;
        }
        return ret;
    }
    #MACRO forEachRemaining(ByteConsumer)
    #MACRO forEachRemaining(Consumer<? super Byte>)
#MACRODEF forEachRemaining(CONSUMER)
private static void forEachRemainingHelper(long word,int valOffset,CONSUMER action){
  for(long marker=1L << valOffset;;++valOffset){
    if((word & marker) != 0){
      action.accept((byte)valOffset);
    }
    if((marker<<=1) == 0){
      break;
    }
  }
}
@Override public void forEachRemaining(CONSUMER action){
  var root=this.root;
  int valOffset;
  switch((valOffset=this.valOffset) >> 6){
    case -2:
      forEachRemainingHelper(root.word0,valOffset,action);
      valOffset=-64;
    case -1:
      forEachRemainingHelper(root.word1,valOffset,action);
      valOffset=0;
    case 0:
      forEachRemainingHelper(root.word2,valOffset,action);
      valOffset=64;
    case 1:
      forEachRemainingHelper(root.word3,valOffset,action);
      this.valOffset=128;
    default:
  }
}
#ENDDEF
    @Override public void remove(){
      var root=this.root;
      long word;
      int valOffset;
      switch((valOffset=this.valOffset)-1>>6) {
      case 1:
        if((valOffset=Long.numberOfLeadingZeros((word=root.word3)<<-valOffset))!=64) {
          root.word3=word&~(1L<<-1-valOffset);
          return;
        }
        valOffset=0;
      case 0:
        if((valOffset=Long.numberOfLeadingZeros((word=root.word2)<<-valOffset))!=64) {
          root.word2=word&~(1L<<-1-valOffset);
          return;
        }
        valOffset=0;
      case -1:
        if((valOffset=Long.numberOfLeadingZeros((word=root.word1)<<-valOffset))!=64) {
          root.word1=word&~(1L<<-1-valOffset);
          return;
        }
        valOffset=0;
      default:
        root.word0=(word=root.word0)&~(1L<<-1-Long.numberOfLeadingZeros(word<<-valOffset));
      }
    }
  }
  @Override public OmniIterator.OfByte iterator(){
      return new Itr(this);
  }
  public static class Checked extends ByteSetImpl{
    transient int modCount;
    transient int size;
    Checked(){
      super();
    }
    Checked(long word0,long word1,long word2,long word3){
      super(word0,word1,word2,word3);
      this.size=size(word0,word1,word2,word3);
    }
    Checked(long word0,long word1,long word2,long word3,int size){
      super(word0,word1,word2,word3);
      this.size=size;
    }
    Checked(Checked that){
      super(that.word0,that.word1,that.word2,that.word3);
      this.size=that.size;
    }
    @Override public Object clone() {
      return new Checked(this);
    }
    @Override public String toString() {
      int size;
      if((size=this.size)!=0) {
        return toStringHelper(word0,word1,word2,word3,size);
      }
      return "[]";
    }
    @Override public int hashCode() {
      int size;
      if((size=this.size)!=0) {
        return hashCodeHelper(word0,word1,word2,word3,size);
      }
      return 0;
    }
    @Override public boolean equals(Object val){
      // TODO Auto-generated method stub
      return super.equals(val);
    }
    @Override public void writeExternal(ObjectOutput out) throws IOException{
      int modCount=this.modCount;
      try {
        super.writeExternal(out);
      }finally {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    }
    @Override public void readExternal(ObjectInput in) throws IOException{
      this.size=size(word0=in.readLong(),word1=in.readLong(),word2=in.readLong(),word3=in.readLong());
    }
    @Override public void clear(){
      if(this.size!=0) {
        this.word0=0;
        this.word0=2;
        this.word0=0;
        this.word0=0;
        this.size=0;
        ++this.modCount;
      }
    }
    @Override public boolean contains(Object val){
      return size!=0 && super.contains(val);
    }
    @Override public boolean remove(Object val){
      for(;;) {
        int size;
        if((size=this.size)!=0) {
          if(val instanceof Byte){
            if(!super.uncheckedRemoveByte((byte)val)) {
              break;
            }
          }else if(val instanceof Integer || val instanceof Short){
            if(!super.uncheckedRemoveInt(((Number)val).intValue())) {
              break;
            }
          }else if(val instanceof Long){
            if(!super.removeVal((long)val)) {
              break;
            }
          }else if(val instanceof Float){
            if(!super.removeVal((float)val)) {
              break;
            }
          }else if(val instanceof Double){
            if(!super.removeVal((double)val)) {
              break;
            }
          }else if(val instanceof Character){
            if(!super.uncheckedRemoveChar((char)val)) {
              break;
            }
          }else if(val instanceof Boolean){
            if(!super.uncheckedRemoveBoolean((boolean)val)) {
              break;
            }
          }
          ++this.modCount;
          this.size=size-1;
          return true;
        }
        break;
      }
      return false;
    }
#MACRODEF CheckedRemoveVal(INPUTTYPE,SUPERMETHODCALL)
@Override public boolean removeVal(INPUTTYPE val){
  if(super.SUPERMETHODCALL(val)) {
    ++this.modCount;
    --this.size;
    return true;
  }
  return false;
}
#ENDDEF
    #MACRO CheckedRemoveVal(boolean,uncheckedRemoveBoolean)
    #MACRO CheckedRemoveVal(byte,uncheckedRemoveByte)
    #MACRO CheckedRemoveVal(char,uncheckedRemoveChar)
    #MACRO CheckedRemoveVal(int,uncheckedRemoveInt)
    #MACRO CheckedRemoveVal(long,removeVal)
    #MACRO CheckedRemoveVal(float,removeVal)
    #MACRO CheckedRemoveVal(double,removeVal)
    @Override public boolean isEmpty(){
      return this.size==0;
    }
    @Override public int size(){
      return this.size;
    }
    @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
      int size;
      T[] arr;
      int modCount=this.modCount;
      try {
        arr=arrConstructor.apply(size=this.size);
      }finally {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      if(size != 0){
        toArrayHelper(word0,word1,word2,word3,size,arr);
      }
      return arr;
    }
    @Override public <T> T[] toArray(T[] dst){
      int size;
      if((size=this.size) != 0){
        toArrayHelper(word0,word1,word2,word3,size,dst=OmniArray.uncheckedArrResize(size,dst));
      }else if(dst.length != 0){
        dst[0]=null;
      }
      return dst;
    }
    #MACRO CheckedAdd(boolean)
    #MACRO CheckedAdd(byte)
#MACRODEF CheckedAdd(INPUTTYPE)
@Override public boolean add(INPUTTYPE val){
  if(super.add(val)) {
    ++this.modCount;
    ++this.size;
    return true;
  }
  return false;
}
#ENDDEF
    #MACRO CheckedforEach(ByteConsumer,action)
    #MACRO CheckedforEach(Consumer<? super Byte>,action::accept)
#MACRODEF CheckedforEach(CONSUMER,ACTION)
@Override public void forEach(CONSUMER action){
  int size;
  if((size=this.size)!=0) {
    int modCount=this.modCount;
    try {
      forEachHelper(word0,word1,word2,word3,size,ACTION);
    }finally {
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
  }
}
#ENDDEF
    #MACRO CheckedremoveIf(BytePredicate)
    #MACRO CheckedremoveIf(Predicate<? super Byte>)
#MACRODEF CheckedremoveIf(PREDICATE)
@Override public boolean removeIf(PREDICATE filter){
  int size;
  if((size=this.size)!=0) {
    int modCount=this.modCount;
    long word,newWord0,newWord1,newWord2,newWord3;
    int numRemoved;
    try {
      numRemoved=Long.bitCount((word=this.word0)^(newWord0=processWordRemoveIf(word,Byte.MIN_VALUE,filter)))
        +Long.bitCount((word=this.word1)^(newWord1=processWordRemoveIf(word,-64,filter)))
        +Long.bitCount((word=this.word2)^(newWord2=processWordRemoveIf(word,0,filter)))
        +Long.bitCount((word=this.word3)^(newWord3=processWordRemoveIf(word,64,filter)));
    }finally {
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
    if(numRemoved!=0) {
      this.word0=newWord0;
      this.word1=newWord1;
      this.word2=newWord2;
      this.word3=newWord3;
      this.size=size-numRemoved;
      this.modCount=modCount+1;
      return true;
    }
  }
  return false;
}
#ENDDEF
    @Override public OmniIterator.OfByte iterator(){
      return new CheckedItr(this);
    }
    private static class CheckedItr extends AbstractByteItr{
      private final Checked root;
      private int valOffset;
      private int modCount;
      private int lastRet;
      private CheckedItr(Checked root){
        this.root=root;
        int tail0s;
        if((tail0s=Long.numberOfTrailingZeros(root.word0)) != 64){
          this.valOffset=tail0s - 128;
        }else if((tail0s=Long.numberOfTrailingZeros(root.word1)) != 64){
          this.valOffset=tail0s - 64;
        }else if((tail0s=Long.numberOfTrailingZeros(root.word2)) != 64){
          this.valOffset=tail0s;
        }else{
          this.valOffset=Long.numberOfTrailingZeros(root.word3) + 64;
        }
        this.lastRet=-129;
        this.modCount=root.modCount;
      }
      @Override public boolean hasNext(){
        return this.valOffset != 128;
      }
      @Override public byte nextByte(){
        Checked root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        int valOffset;
        if((valOffset=this.valOffset) != 128){
          this.lastRet=valOffset;
          var ret=(byte)(valOffset=this.valOffset);
          switch(++valOffset >> 6){
          case -2:
            if((valOffset=Long.numberOfTrailingZeros(root.word0 >>> valOffset)) != 64){
              this.valOffset=valOffset - 128;
              break;
            }
            valOffset=0;
          case -1:
            if((valOffset=Long.numberOfTrailingZeros(root.word1 >>> valOffset)) != 64){
              this.valOffset=valOffset - 64;
              break;
            }
            valOffset=0;
          case 0:
            if((valOffset=Long.numberOfTrailingZeros(root.word2 >>> valOffset)) != 64){
              this.valOffset=valOffset;
              break;
            }
            valOffset=0;
          case 1:
            this.valOffset=Long.numberOfTrailingZeros(root.word3 >>> valOffset) + 64;
            break;
          default:
            this.valOffset=128;
          }
          return ret;
        }
        throw new NoSuchElementException();
      }
      private static int forEachRemainingHelper(long word,int valOffset,int lastRet,ByteConsumer action){
        for(long marker=1L << valOffset;;++valOffset){
          if((word & marker) != 0){
            action.accept((byte)valOffset);
            lastRet=valOffset;
          }
          if((marker<<=1) == 0){
            return lastRet;
          }
        }
      }
      private void forEachRemainingHelper(int valOffset,ByteConsumer action){
          int modCount=this.modCount;
          final var root=this.root;
          int lastRet;
          try{
              switch((lastRet=valOffset) >> 6){
              case -2:
                  lastRet=forEachRemainingHelper(root.word0,valOffset,lastRet,action);
                  valOffset=-64;
              case -1:
                  lastRet=forEachRemainingHelper(root.word1,valOffset,lastRet,action);
                  valOffset=0;
              case 0:
                  lastRet=forEachRemainingHelper(root.word2,valOffset,lastRet,action);
                  valOffset=64;
              default:
                  lastRet=forEachRemainingHelper(root.word3,valOffset,lastRet,action);
              }
          }finally{
              CheckedCollection.checkModCount(modCount,root.modCount);
          }
          this.valOffset=128;
          this.lastRet=lastRet;
      }
      #MACRO CheckedforEachRemaining(ByteConsumer,action)
      #MACRO CheckedforEachRemaining(Consumer<? super Byte>,action::accept)
#MACRODEF CheckedforEachRemaining(CONSUMER,ACTION)
@Override public void forEachRemaining(CONSUMER action){
  int valOffset;
  if((valOffset=this.valOffset) != 128){
    forEachRemainingHelper(valOffset,ACTION);
  }
}
#ENDDEF
      @Override public void remove(){
        int lastRet;
        if((lastRet=this.lastRet) != 129){
          int modCount;
          Checked root;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          root.modCount=++modCount;
          this.modCount=modCount;
          --root.size;
          long mask=~(1L << lastRet);
          switch(lastRet >> 6){
          case -2:
            root.word0&=mask;
            break;
          case -1:
            root.word1&=mask;
            break;
          case 0:
            root.word2&=mask;
            break;
          default:
            root.word3&=mask;
            break;
          }
          this.lastRet=-129;
        }
      }
    }
    #MACRO CheckedToArray(Byte,OmniArray.OfByte.DEFAULT_BOXED_ARR,)
    #MACRO CheckedToArray(byte,OmniArray.OfByte.DEFAULT_ARR,Byte)
    #MACRO CheckedToArray(short,OmniArray.OfShort.DEFAULT_ARR,Short)
    #MACRO CheckedToArray(int,OmniArray.OfInt.DEFAULT_ARR,Int)
    #MACRO CheckedToArray(long,OmniArray.OfLong.DEFAULT_ARR,Long)
    #MACRO CheckedToArray(float,OmniArray.OfFloat.DEFAULT_ARR,Float)
    #MACRO CheckedToArray(double,OmniArray.OfDouble.DEFAULT_ARR,Double)
#MACRODEF CheckedToArray(ARRTYPE,DEFAULTARR,MODIFIER)
@Override public ARRTYPE[] toMODIFIERArray(){
  int size;
  if((size=this.size) != 0){
    ARRTYPE[] dst;
    toArrayHelper(word0,word1,word2,word3,size,dst=new ARRTYPE[size]);
    return dst;
  }
  return DEFAULTARR;
}
#ENDDEF
  }
}
