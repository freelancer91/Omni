#TYPEDEF OfBoolean
  packagename = ofboolean
  PackageName = OfBoolean
  <E> = 
  ArrayType = boolean
  Consumer = BooleanConsumer
  BoxedType = Boolean
  exposedType = boolean
  queryParameterType = boolean
  Comparator = BooleanComparator
  UnaryOperator = BooleanPredicate
  DEFAULT_BOXED_ARR = OmniArray.OfBoolean.DEFAULT_BOXED_ARR
  removeAtIndexMethod = removeBooleanAt
  getMethod = getBoolean
  queryCastBoolean = 
  queryCastRef = (boolean)
#ENDDEF
#TYPEDEF OfByte
  packagename = ofbyte
  PackageName = OfByte
  <E> = 
  ArrayType = byte
  Consumer = ByteConsumer
  BoxedType = Byte
  exposedType = byte
  queryParameterType = int
  Comparator = ByteComparator
  UnaryOperator = ByteUnaryOperator
  DEFAULT_BOXED_ARR = OmniArray.OfByte.DEFAULT_BOXED_ARR
  removeAtIndexMethod = removeByteAt
  getMethod = getByte
  queryCastBoolean = TypeUtil.castToByte
  queryCastPrimitive = 
  queryCastRef = (byte)
#ENDDEF
#TYPEDEF OfChar
  packagename = ofchar
  PackageName = OfChar
  <E> = 
  ArrayType = char
  Consumer = CharConsumer
  BoxedType = Character
  exposedType = char
  queryParameterType = int
  Comparator = CharComparator
  UnaryOperator = CharUnaryOperator
  DEFAULT_BOXED_ARR = OmniArray.OfChar.DEFAULT_BOXED_ARR
  removeAtIndexMethod = removeCharAt
  getMethod = getChar
  queryCastBoolean = TypeUtil.castToChar
  queryCastPrimitive = 
  queryCastRef = (char)
#ENDDEF
#TYPEDEF OfShort
  packagename = ofshort
  PackageName = OfShort
  <E> = 
  ArrayType = short
  Consumer = ShortConsumer
  BoxedType = Short
  exposedType = short
  queryParameterType = int
  Comparator = ShortComparator
  UnaryOperator = ShortUnaryOperator
  DEFAULT_BOXED_ARR = OmniArray.OfShort.DEFAULT_BOXED_ARR
  removeAtIndexMethod = removeShortAt
  getMethod = getShort
  queryCastBoolean = (short)TypeUtil.castToByte
  queryCastPrimitive = 
  queryCastRef = (short)
#ENDDEF
#TYPEDEF OfInt
  packagename = ofint
  PackageName = OfInt
  <E> = 
  ArrayType = int
  Consumer = IntConsumer
  BoxedType = Integer
  exposedType = int
  queryParameterType = int
  Comparator = IntBinaryOperator
  UnaryOperator = IntUnaryOperator
  DEFAULT_BOXED_ARR = OmniArray.OfInt.DEFAULT_BOXED_ARR
  removeAtIndexMethod = removeIntAt
  getMethod = getInt
  queryCastBoolean = (int)TypeUtil.castToByte
  queryCastPrimitive = 
  queryCastRef = (int)
#ENDDEF
#TYPEDEF OfLong
  packagename = oflong
  PackageName = OfLong
  <E> = 
  ArrayType = long
  Consumer = LongConsumer
  BoxedType = Long
  exposedType = long
  queryParameterType = long
  Comparator = LongComparator
  UnaryOperator = LongUnaryOperator
  DEFAULT_BOXED_ARR = OmniArray.OfLong.DEFAULT_BOXED_ARR
  removeAtIndexMethod = removeLongAt
  getMethod = getLong
  queryCastBoolean = TypeUtil.castToLong
  queryCastPrimitive = 
  queryCastRef = (long)
#ENDDEF
#TYPEDEF OfFloat
  packagename = offloat
  PackageName = OfFloat
  <E> = 
  ArrayType = float
  Consumer = FloatConsumer
  BoxedType = Float
  exposedType = float
  queryParameterType = int
  convertToBits = Float.floatToRawIntBits
  Comparator = FloatComparator
  UnaryOperator = FloatUnaryOperator
  DEFAULT_BOXED_ARR = OmniArray.OfFloat.DEFAULT_BOXED_ARR
  removeAtIndexMethod = removeFloatAt
  getMethod = getFloat
  TRUE_BITS = TypeUtil.FLT_TRUE_BITS
  queryCastPrimitive = 
  queryCastRef = (float)
#ENDDEF
#TYPEDEF OfDouble
  packagename = ofdouble
  PackageName = OfDouble
  <E> = 
  ArrayType = double
  Consumer = DoubleConsumer
  BoxedType = Double
  exposedType = double
  queryParameterType = long
  convertToBits = Double.doubleToRawLongBits
  Comparator = DoubleComparator
  UnaryOperator = DoubleUnaryOperator
  DEFAULT_BOXED_ARR = OmniArray.OfDouble.DEFAULT_BOXED_ARR
  removeAtIndexMethod = removeDoubleAt
  getMethod = getDouble
  TRUE_BITS = TypeUtil.DBL_TRUE_BITS
  queryCastPrimitive = 
  queryCastRef = (double)
#ENDDEF
#TYPEDEF OfRef
  packagename = ofref
  PackageName = OfRef
  <E> = <E>
  ArrayType = Object
  Consumer = Consumer<? super E>
  BoxedType = Object
  exposedType = E
  Comparator = Comparator<? super E>
  UnaryOperator = UnaryOperator<E>
  DEFAULT_BOXED_ARR = OmniArray.OfRef.DEFAULT_ARR
  queryCastBoolean = OmniPred.OfRef.getEqualsPred
  removeAtIndexMethod = remove
  getMethod = get
  queryCastPrimitive = OmniPred.OfRef.getEqualsPred
  queryCastRef = OmniPred.OfRef.getEqualsPred
#ENDDEF
package omni.impl.seq.arr.$packagename$;
import omni.api.OmniList;
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import omni.util.ArrCopy;
import omni.util.SortUtil;
import omni.util.OmniArray;
import omni.impl.seq.arr.ArrSeqUtil;
#IF OfDouble,OfLong,OfInt
import java.util.function.$Consumer$;
import java.util.function.$UnaryOperator$;
#ELSEIF OfRef
import java.util.function.Predicate;
#ELSE
import omni.function.$Consumer$;
import omni.function.$UnaryOperator$;
#ENDIF
import java.util.function.Consumer;
import java.util.Comparator;
import java.util.function.UnaryOperator;
import java.util.function.IntFunction;
#IF OfInt
import java.util.function.IntBinaryOperator;
#ELSEIFNOT OfRef
import omni.function.$Comparator$;
#ENDIF
#IF OfRef
import omni.util.OmniPred;
#ELSE
import omni.util.TypeUtil;
#ENDIF
class UncheckedSubList$<E>$ extends AbstractSeq.Unchecked.AbstractSubList$<E>$ implements OmniList.$PackageName$$<E>$
{
  UncheckedSubList(AbstractSeq.Unchecked$<E>$ root,AbstractSeq.Unchecked.AbstractSubList$<E>$ parent,int rootOffset,int size)
  {
    super(root,parent,rootOffset,size);
  }
  UncheckedSubList(AbstractSeq.Unchecked$<E>$ root,int rootOffset,int size)
  {
    super(root,rootOffset,size);
  }
  @Override
  public Object clone()
  {
    final $ArrayType$[] arr;
    final int size;
    if((size=this.size)!=0)
    {
      ArrCopy.uncheckedCopy(root.arr,rootOffset,arr=new $ArrayType$[size],0,size);
    }
    else
    {
      arr=null;
    }
    return new UncheckedList$<E>$(size,arr);
  }
  @Override
  public boolean equals(Object val)
  {
    //TODO
    return false;
  }
  @Override
  public OmniIterator.$PackageName$$<E>$ iterator()
  {
    //TODO
    return null;
  }
  @Override
  public OmniListIterator.$PackageName$$<E>$ listIterator()
  {
    //TODO
    return null;
  }
  @Override
  public OmniListIterator.$PackageName$$<E>$ listIterator(int index)
  {
    //TODO
    return null;
  }
  @Override
  public OmniList.$PackageName$$<E>$ subList(int fromIndex,int toIndex)
  {
    return new UncheckedSubList$<E>$(root,this,this.rootOffset+fromIndex,toIndex-fromIndex);
  }
  @Override
  public void sort($Comparator$ sorter)
  {
    final int size;
    if((size=this.size)>1)
    {
      final int rootOffset;
      SortUtil.uncheckedsort(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,sorter);
    }
  }
  @Override
  public void replaceAll($UnaryOperator$ operator)
  {
    final int size;
    if((size=this.size)!=0)
    {
      final int rootOffset;
      ArrSeqUtil.uncheckedReplaceAll(root.arr,rootOffset=this.rootOffset,rootOffset+size,operator);
    }
  }
  @Override
  public void put(int index,$exposedType$ val)
  {
    root.arr[index+rootOffset]=val;
  }
  @Override
  public $exposedType$ set(int index,$exposedType$ val)
  {
    final $ArrayType$[] arr;
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    final var oldVal=($exposedType$)(arr=root.arr)[index+=rootOffset];
    arr[index]=val;
    return oldVal;
  }
#IF OfRef
  @SuppressWarnings("unchecked")
#ENDIF
  @Override
  public $exposedType$ $getMethod$(int index)
  {
    return ($exposedType$)root.arr[index+rootOffset];
  }
#MACRODEF SortNoComparator(sortMethod)
  @Override
  public void sortMethod()
  {
    final int size;
    if((size=this.size)>1)
    {
      final int rootOffset;
      SortUtil.uncheckedsortMethod(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
    }
  }
#ENDDEF
#MACRO SortNoComparator(sort)
#MACRO SortNoComparator(reverseSort)
  @Override
  public $exposedType$ $removeAtIndexMethod$(int index)
  {
    final AbstractSeq.Unchecked$<E>$ root;
    final $ArrayType$[] arr;
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    final var removed=($exposedType$)(arr=(root=this.root).arr)[index+=rootOffset];
    ArrSeqUtil.eraseIndexHelper(arr,index,--root.size);
    bubbleUpDecrementSize(parent);
    --size;
    return removed;
  }
  @Override
  public String toString()
  {
    final int size;
    if((size=this.size)!=0)
    {
      final StringBuilder builder;
      final int rootOffset;
      ArrSeqUtil.forwardToString(root.arr,rootOffset=this.rootOffset,rootOffset+size,builder=new StringBuilder("["));
      return builder.append(']').toString();
    }
    return "[]";
  }
  @Override
  public int hashCode()
  {
    final int size;
    if((size=this.size)!=0)
    {
      final int rootOffset;
      return ArrSeqUtil.forwardHashCode(root.arr,rootOffset=this.rootOffset,rootOffset+size);
    }
    return 1;
  }
  @Override
  public void forEach($Consumer$ action)
  {
    final int size;
    if((size=this.size)!=0)
    {
      final int rootOffset;
      ArrSeqUtil.uncheckedForwardForEach(root.arr,rootOffset=this.rootOffset,rootOffset+size,action);
    }
  }
#MACRODEF ToArray(retType,Name,defaultArr)
  @Override
  public retType[] toNameArray()
  {
    final int size;
    if((size=this.size)!=0)
    {
      final retType[] dst;
      ArrCopy.uncheckedCopy(root.arr,rootOffset,dst=new retType[size],0,size);
      return dst;
    }
    return defaultArr;
  }
#ENDDEF
#MACRO ToArray(\$BoxedType\$,,\$DEFAULT_BOXED_ARR\$)
  @Override
  public <T> T[] toArray(IntFunction<T[]> arrConstructor)
  {
    final int size;
    final T[] dst=arrConstructor.apply(size=this.size);
    if(size!=0)
    {
      ArrCopy.uncheckedCopy(root.arr,rootOffset,dst,0,size);
    }
    return dst;
  }
  @Override
  public <T> T[] toArray(T[] arr)
  {
    final int size;
    if((size=this.size)!=0)
    {
      ArrCopy.uncheckedCopy(root.arr,rootOffset,arr=OmniArray.uncheckedArrResize(size,arr),0,size);
    }
    else if(arr.length!=0)
    {
      arr[0]=null;
    }
    return arr;
  }
#MACRODEF UncheckedQuery(retType,methodName,methodParams,uncheckedMethodParams)
  private retType uncheckedmethodName(methodParams)
  {
    final int rootOffset;
    return ArrSeqUtil.uncheckedmethodName(uncheckedMethodParams);
  }
#ENDDEF
#MACRODEF UncheckedRemoveVal(indexTest,Suffix,methodParams)
  private boolean uncheckedremoveValSuffix(methodParams)
  {
    final AbstractSeq.Unchecked$<E>$ root;
    final var arr=(root=this.root).arr;
    int index;
    final int bound=(index=this.rootOffset)+(--size);
    while(indexTest(arr[index]))
    {
      if(++index==bound)
      {
        return false;
      }
    }
    ArrSeqUtil.eraseIndexHelper(arr,index,--root.size);
    bubbleUpDecrementSize(parent);
    this.size=size;
    return true;
  }
#ENDDEF
#IF OfRef
  #MACRO UncheckedQuery(boolean,contains,int size\,Predicate<Object> pred,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,pred)
  #MACRO UncheckedQuery(int,indexOf,int size\,Predicate<Object> pred,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,pred)
  #MACRO UncheckedRemoveVal(!pred.test,,int size\,Predicate<Object> pred)
#ELSEIF OfDouble,OfFloat
  #MACRO UncheckedQuery(boolean,containsBits,int size\,\$queryParameterType\$ bits,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,bits)
  #MACRO UncheckedQuery(int,indexOfBits,int size\,\$queryParameterType\$ bits,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,bits)
  #MACRO UncheckedQuery(boolean,containsNaN,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
  #MACRO UncheckedQuery(int,indexOfNaN,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
  #MACRO UncheckedQuery(boolean,contains0,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
  #MACRO UncheckedQuery(int,indexOf0,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
#MACRODEF UncheckedDoubleFloatQuery(retType,methodName)
  private retType uncheckedmethodName(int size,$exposedType$ val)
  {
    if(val==val)
    {
      return uncheckedmethodNameBits(size,$convertToBits$(val));
    }
    return uncheckedmethodNameNaN(size);
  }
#ENDDEF
  #MACRO UncheckedDoubleFloatQuery(boolean,contains)
  #MACRO UncheckedDoubleFloatQuery(boolean,removeVal)
  #MACRO UncheckedDoubleFloatQuery(int,indexOf)
  #IF OfFloat
#MACRODEF UncheckedRawIntQuery(retType,methodName)
  private retType uncheckedmethodNameRawInt(int size,int val)
  {
    if(val!=0)
    {
      return uncheckedmethodNameBits(size,$convertToBits$(val));
    }
    return uncheckedmethodNameNaN(size);
  }
#ENDDEF
    #MACRO UncheckedRawIntQuery(boolean,removeVal)
    #MACRO UncheckedRawIntQuery(int,indexOf)
  #ENDIF
  #MACRO UncheckedRemoveVal(bits!=\$convertToBits\$,Bits,int size\,\$queryParameterType\$ bits)
  #MACRO UncheckedRemoveVal(0!=,0,int size)
  #MACRO UncheckedRemoveVal(!\$BoxedType\$.isNaN,NaN,int size)
#ELSE
  #IF OfBoolean
    #MACRO UncheckedRemoveVal(val^,,int size\,\$queryParameterType\$ val)
  #ELSE
    #MACRO UncheckedRemoveVal(val!=,,int size\,\$queryParameterType\$ val)
  #ENDIF
  #MACRO UncheckedQuery(boolean,contains,int size\,\$queryParameterType\$ val,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,val)
  #MACRO UncheckedQuery(int,indexOf,int size\,\$queryParameterType\$ val,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,val)
#ENDIF
#MACRODEF BasicQuery(retType,methodName,paramType,negRet,methodParams)
  @Override
  public retType methodName(paramType val)
  {
    final int size;
    if((size=this.size)!=0)
    {
      return uncheckedmethodName(methodParams);
    }
    return negRet;
  }
#ENDDEF
#MACRODEF QueryObject(retType,methodName,negRet)
  @Override
  public retType methodName(Object val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IFNOT OfRef
      if(val instanceof $BoxedType$)
#ENDIF
      {
        return uncheckedmethodName(size,$queryCastRef$(val));
      }
    }
    return negRet;
  }
#ENDDEF
  @Override
  public boolean remove(Object val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IFNOT OfRef
      if(val instanceof $BoxedType$)
#ENDIF
      {
        return uncheckedremoveVal(size,$queryCastRef$(val));
      }
    }
    return false;
  }
#MACRO QueryObject(boolean,contains,false)
#MACRO QueryObject(int,indexOf,-1)
#MACRODEF QueryBoolean(retType,methodName,negRet)
  @Override
  public retType methodName(boolean val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfDouble,OfFloat
      if(val)
      {
        return uncheckedmethodNameBits(size,$TRUE_BITS$);
      }
      return uncheckedmethodName0(size);
#ELSE
      return uncheckedmethodName(size,$queryCastBoolean$(val));
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryBoolean(boolean,contains,false)
#MACRO QueryBoolean(boolean,removeVal,false)
#MACRO QueryBoolean(int,indexOf,-1)
#IF OfRef,OfByte
  #MACRO BasicQuery(boolean,contains,byte,false,size\,\$queryCastPrimitive\$(val))
  #MACRO BasicQuery(boolean,removeVal,byte,false,size\,\$queryCastPrimitive\$(val))
  #MACRO BasicQuery(int,indexOf,byte,-1,size\,\$queryCastPrimitive\$(val))
#ENDIF
#IFNOT OfDouble,OfLong,OfInt,OfBoolean
#MACRODEF QueryChar(retType,methodName,negRet)
  public retType methodName(char val)
  {
#IF OfByte,OfShort
    if(val<=$BoxedType$.MAX_VALUE)
#ENDIF
    {
      final int size;
      if((size=this.size)!=0)
      {
#IF OfFloat
        return uncheckedmethodNameRawInt(size,val);
#ELSE
        return uncheckedmethodName(size,$queryCastPrimitive$(val));
#ENDIF
      }
    }
    return negRet;
  }
#ENDDEF
  #IFNOT OfFloat
    #MACRO QueryChar(boolean,contains,false)
    #MACRO QueryChar(boolean,removeVal,false)
  #ENDIF
  #MACRO QueryChar(int,indexOf,-1)
#ENDIF
#IF OfRef,OfFloat,OfShort,OfChar
#MACRODEF QueryShort(retType,methodName,negRet)
  @Override
  public retType methodName(short val)
  {
#IF OfChar
    if(val>=0)
#ENDIF
    {
      final int size;
      if((size=this.size)!=0)
      {
#IF OfFloat
        return uncheckedmethodNameRawInt(size,val);
#ELSE
        return uncheckedmethodName(size,$queryCastPrimitive$(val));
#ENDIF
      }
    }
    return negRet;
  }
#ENDDEF
  #IFNOT OfFloat
    #MACRO QueryShort(boolean,contains,false)
    #MACRO QueryShort(boolean,removeVal,false)
  #ENDIF
  #MACRO QueryShort(int,indexOf,-1)
#ENDIF
#MACRODEF QueryInt(retType,methodName,negRet)
  @Override
  public retType methodName(int val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfDouble,OfFloat
      if(val!=0)
      {
  #IF OfFloat
        if(TypeUtil.checkCastToFloat(val))
        {
          return uncheckedmethodNameBits(size,$convertToBits$(val));
        }
  #ENDIF
      }
      else
      {
        return uncheckedmethodName0(size);
      }
#ELSEIF OfBoolean
      final boolean v;
      switch(val){
        default:
          return negRet;
        case 0:
          v=false;
          break;
        case 1:
          v=true;
      }
      return uncheckedmethodName(size,v);
#ELSE
  #IF OfShort,OfChar,OfByte
      if(val==($exposedType$)val)
  #ENDIF
      {
        return uncheckedmethodName(size,$queryCastPrimitive$(val));
      }
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryInt(boolean,contains,false)
#MACRO QueryInt(boolean,removeVal,false)
#MACRO QueryInt(int,indexOf,-1)
#MACRODEF QueryLong(retType,methodName,negRet)
  public retType methodName(long val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfRef,OfLong
      return uncheckedmethodName(size,$queryCastPrimitive$(val));
#ELSEIF OfDouble,OfFloat
      if(val!=0)
      {
        if(TypeUtil.checkCastTo$BoxedType$(val))
        {
          return uncheckedmethodNameBits(size,$convertToBits$(val));
        }
      }
      else
      {
         return uncheckedmethodName0(size);
      }
#ELSE
      final $exposedType$ v;
  #IF OfBoolean
      if(val==0){
        v=false;
      }else if(val==1){
        v=true;
      }else{
        return negRet;
      }
  #ELSE
      if(val==(v=($exposedType$)val))
  #ENDIF
      {
        return uncheckedmethodName(size,v);
      }
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryLong(boolean,contains,false)
#MACRO QueryLong(boolean,removeVal,false)
#MACRO QueryLong(int,indexOf,-1)
#MACRODEF QueryFloat(retType,methodName,negRet)
  public retType methodName(float val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfRef,OfFloat
      return uncheckedmethodName(size,$queryCastPrimitive$(val));
#ELSEIF OfDouble
      if(val==val)
      {
        return uncheckedmethodNameBits(size,$convertToBits$(val));
      }
      return uncheckedmethodNameNaN(size);  
#ELSE
      final $exposedType$ v;
  #IF OfLong
      if(TypeUtil.floatEquals(val,v=(long)val))
  #ELSEIF OfInt
      if((double)val==(double)(v=(int)val))
  #ELSEIF OfBoolean
      switch(Float.floatToRawIntBits(val)){
        default:
          return negRet;
        case 0:
        case Integer.MIN_VALUE:
          v=false;
          break;
        case TypeUtil.FLT_TRUE_BITS:
          v=true;
      }
  #ELSE
      if(val==(v=($exposedType$)val))
  #ENDIF 
      {
        return uncheckedmethodName(size,v);
      }
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryFloat(boolean,contains,false)
#MACRO QueryFloat(boolean,removeVal,false)
#MACRO QueryFloat(int,indexOf,-1)
#MACRODEF QueryDouble(retType,methodName,negRet)
  public retType methodName(double val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfRef,OfDouble
      return uncheckedmethodName(size,$queryCastPrimitive$(val));
#ELSE
      final $exposedType$ v;
  #IF OfFloat
      if(val==(v=($exposedType$)val))
      {
        return uncheckedmethodNameBits(size,$convertToBits$(v));
      }
      else if(v!=v)
      {
        return uncheckedmethodNameNaN(size);
      }
  #ELSE
    #IF OfBoolean
      final long bits;
      if((bits=Double.doubleToRawLongBits(val))==0||bits==Long.MIN_VALUE){
        v=false;
      }else if(bits==TypeUtil.DBL_TRUE_BITS){
        v=true;
      }else{
        return negRet;
      }
    #ELSE
      if(val==(v=($exposedType$)val))
    #ENDIF
      {
        return uncheckedmethodName(size,v);
      }
  #ENDIF
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryDouble(boolean,contains,false)
#MACRO QueryDouble(boolean,removeVal,false)
#MACRO QueryDouble(int,indexOf,-1)

#IF OfFloat
  @Override
  protected boolean containsRawInt(int val)
  {
    final int size;
    if((size=this.size)!=0)
    {
      final int rootOffset;
      return ArrSeqUtil.uncheckedcontainsRawInt(root.arr,rootOffset=this.rootOffset,rootOffset+size,val);
    }
    return false;
  }
  @Override
  protected boolean removeRawInt(int val)
  {
    final int size;
    if((size=this.size)!=0)
    {
      return uncheckedremoveValRawInt(size,val);
    }
    return false;
  }
#ENDIF
#IF OfRef
#MACRO BasicQuery(boolean,contains,Boolean,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,contains,Byte,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,contains,Character,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,contains,Short,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,contains,Integer,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,contains,Long,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,contains,Float,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,contains,Double,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,removeVal,Boolean,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,removeVal,Byte,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,removeVal,Character,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,removeVal,Short,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,removeVal,Integer,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,removeVal,Long,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,removeVal,Float,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(boolean,removeVal,Double,false,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(int,indexOf,Boolean,-1,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(int,indexOf,Byte,-1,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(int,indexOf,Character,-1,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(int,indexOf,Short,-1,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(int,indexOf,Integer,-1,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(int,indexOf,Long,-1,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(int,indexOf,Float,-1,size\,OmniPred.OfRef.getEqualsPred(val))
#MACRO BasicQuery(int,indexOf,Double,-1,size\,OmniPred.OfRef.getEqualsPred(val))
  @Override
  protected int uncheckedlastIndexOf(int size,Predicate<Object> pred)
  {
    final int rootOffset;
    return ArrSeqUtil.uncheckedlastIndexOf(root.arr,rootOffset=this.rootOffset,rootOffset+size,pred);
  }
  @Override
  protected int uncheckedlastIndexOfNonNull(int size,Object nonNull)
  {
    final int rootOffset;
    return ArrSeqUtil.uncheckedlastIndexOf(root.arr,rootOffset=this.rootOffset,rootOffset+size,nonNull::equals);
  }
#ELSEIF OfDouble,OfFloat
  @Override
  protected int uncheckedlastIndexOf0(int size)
  {
    final int rootOffset;
    return ArrSeqUtil.uncheckedlastIndexOf0(root.arr,rootOffset=this.rootOffset,rootOffset+size);
  }
  @Override
  protected int uncheckedlastIndexOfBits(int size,$queryParameterType$ bits)
  {
    final int rootOffset;
    return ArrSeqUtil.uncheckedlastIndexOfBits(root.arr,rootOffset=this.rootOffset,rootOffset+size,bits);
  }
  @Override
  protected int uncheckedlastIndexOfNaN(int size)
  {
    final int rootOffset;
    return ArrSeqUtil.uncheckedlastIndexOfNaN(root.arr,rootOffset=this.rootOffset,rootOffset+size);
  }
#ELSE
  @Override
  protected int uncheckedlastIndexOf(int size,$queryParameterType$ val)
  {
    final int rootOffset;
    return ArrSeqUtil.uncheckedlastIndexOf(root.arr,rootOffset=this.rootOffset,rootOffset+size,val);
  }
#ENDIF
#IFNOT OfRef
  @Override
  public void forEach(Consumer<? super $BoxedType$> action)
  {
    final int size;
    if((size=this.size)!=0)
    {
      final int rootOffset;
      ArrSeqUtil.uncheckedForwardForEach(root.arr,rootOffset=this.rootOffset,rootOffset+size,action::accept);
    }
  }
  @Override
  public void sort(Comparator<? super $BoxedType$> sorter)
  {
    final int size;
    if((size=this.size)>1)
    {
      final int rootOffset;
      SortUtil.uncheckedsort(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,sorter::compare);
    }
  }
  @Override
  public void replaceAll(UnaryOperator<$BoxedType$> operator)
  {
    final int size;
    if((size=this.size)!=0)
    {
      final int rootOffset;
      ArrSeqUtil.uncheckedReplaceAll(root.arr,rootOffset=this.rootOffset,rootOffset+size,operator::apply);
    }
  }
  #MACRO ToArray(double,Double,OmniArray.OfDouble.DEFAULT_ARR)
  #IF OfFloat,OfLong,OfInt,OfShort,OfChar,OfByte,OfBoolean
    #MACRO ToArray(float,Float,OmniArray.OfFloat.DEFAULT_ARR)
    #IF OfLong,OfInt,OfShort,OfChar,OfByte,OfBoolean
      #MACRO ToArray(long,Long,OmniArray.OfLong.DEFAULT_ARR)
      #IF OfInt,OfShort,OfChar,OfByte,OfBoolean
        #MACRO ToArray(int,Int,OmniArray.OfInt.DEFAULT_ARR)
        #IF OfShort,OfByte,OfBoolean
          #MACRO ToArray(short,Short,OmniArray.OfShort.DEFAULT_ARR)
          #IF OfByte,OfBoolean
            #MACRO ToArray(byte,Byte,OmniArray.OfByte.DEFAULT_ARR)
            #IF OfBoolean
              #MACRO ToArray(boolean,Boolean,OmniArray.OfBoolean.DEFAULT_ARR)
            #ENDIF     
          #ENDIF
        #ENDIF
        #IF OfChar,OfBoolean
          #MACRO ToArray(char,Char,OmniArray.OfChar.DEFAULT_ARR)
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
}