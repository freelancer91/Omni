#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.set;
import java.util.Collection;
import omni.api.OmniCollection;
import java.util.Set;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.NoSuchElementException;
import java.util.function.Consumer;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import omni.api.OmniIterator;
import omni.api.OmniSet;
#IF OfChar,OfShort,OfFloat
import omni.function.$TypeNameModifier$Consumer;
import omni.function.$TypeNameModifier$Predicate;
#ELSEIF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Consumer;
import java.util.function.$TypeNameModifier$Predicate;
#ENDIF
#IFNOT OfRef
import omni.impl.Abstract$TypeNameModifier$Itr;
#ENDIF
import omni.impl.CheckedCollection;
import omni.util.OmniArray;
#IF OfLong,OfFloat,OfDouble
import omni.util.TypeUtil;
#ENDIF
#IF OfRef
import java.util.ConcurrentModificationException;
#ENDIF
#IFNOT OfChar,OfDouble,OfRef
import omni.util.ToStringUtil;
#ENDIF
public class $ClassPrefix$OpenAddressHashSet$<E>$
#IF OfChar,OfShort,OfInt,OfLong
extends AbstractIntegralTypeOpenAddressHashSet<$BoxedType$>
#ELSEIF OfRef
extends AbstractOpenAddressHashSet$<E>$
#ELSE
extends AbstractOpenAddressHashSet<$BoxedType$>
#ENDIF
implements OmniSet.Of$ClassPrefix$$<E>${
#IF OfRef
  static final Object NULL=new Object();
  static final int NULLHASH=SetCommonImpl.tableHash(NULL);
  static final Object DELETED=new Object();
  
  
#ENDIF
  

#IF OfLong,OfInt,OfShort,OfChar
  private  static long processWordHashCode(long word,int valOffset,int valBound,long magicWord){
    int hash=(int)(magicWord >>> 32);
    int numLeft=(int)magicWord;
    do{
      if((word & 1L << valOffset) != 0L){
  #IF OfLong
        long v;
        hash+=(int)((v=valOffset)^(v>>>32));
  #ELSE
        hash+=valOffset;
  #ENDIF
        if(--numLeft == 0){
          break;
        }
      }
    }while(++valOffset != valBound);
    return numLeft | (long)hash << 32;
  }
#ENDIF
#IF OfLong,OfInt,OfShort,OfChar
  private static $<E>$ long wordRemoveIf(long word,
  #IF OfLong
  long
  #ELSE
  int
  #ENDIF
  valOffset,$TypeNameModifier$Predicate$<? super E>$ filter){
    long newWord=0L;
    for(int tail0s;(tail0s=Long.numberOfTrailingZeros(word))!=64;++valOffset,word>>>=1){
      word>>>=tail0s;
      if(!filter.test(($exposedType$)(valOffset+=tail0s))){
        newWord|=(1L<<valOffset);
      }
    }
    return newWord;
  }
#ENDIF
#IF OfDouble,OfFloat,OfRef
  transient $queryParameterType$[] table;
#ELSE
  transient $ArrayType$[] table;
#ENDIF
  public $ClassPrefix$OpenAddressHashSet(Collection<? extends $BoxedExposed$> that){
    super();
    //TODO optimize
    this.addAll(that);
  }
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.OfRef<? extends $BoxedExposed$> that){
    super();
    //TODO optimize
    this.addAll(that);
  }
#IFNOT OfRef
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.OfBoolean that){
    super();
    //TODO optimize
    this.addAll(that);
  }
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.$ClassPrefix$Output<?> that){
    super();
    //TODO optimize;
    this.addAll(that);
  }
  #IFNOT OfChar
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.OfByte that){
    super();
    //TODO optimize
    this.addAll(that);
  }
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.OfShort that){
    super();
    //TODO optimize
    this.addAll(that);
  }  
    #IFNOT OfShort
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.OfInt that){
    super();
    //TODO optimize
    this.addAll(that);
  }
      #IFNOT OfInt
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.OfLong that){
    super();
    //TODO optimize
    this.addAll(that);
  }
        #IFNOT OfLong
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.OfFloat that){
    super();
    //TODO optimize
    this.addAll(that);
  }
          #IFNOT OfFloat
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.OfDouble that){
    super();
    //TODO optimize
    this.addAll(that);
  }
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #IFNOT OfShort
  public $ClassPrefix$OpenAddressHashSet(OmniCollection.OfChar that){
    super();
    //TODO optimize
    this.addAll(that);
  }
  #ENDIF
#ENDIF

  public $ClassPrefix$OpenAddressHashSet(float loadFactor,Collection<? extends $BoxedExposed$> that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.OfRef<? extends $BoxedExposed$> that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }
#IFNOT OfRef
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.OfBoolean that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.$ClassPrefix$Output<?> that){
    super(loadFactor);
    //TODO optimize;
    this.addAll(that);
  }
  #IFNOT OfChar
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.OfByte that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.OfShort that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }  
    #IFNOT OfShort
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.OfInt that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }
      #IFNOT OfInt
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.OfLong that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }
        #IFNOT OfLong
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.OfFloat that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }
          #IFNOT OfFloat
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.OfDouble that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #IFNOT OfShort
  public $ClassPrefix$OpenAddressHashSet(float loadFactor,OmniCollection.OfChar that){
    super(loadFactor);
    //TODO optimize
    this.addAll(that);
  }
  #ENDIF
#ENDIF

  public $ClassPrefix$OpenAddressHashSet(){
    super();
  }
  public $ClassPrefix$OpenAddressHashSet($ClassPrefix$OpenAddressHashSet$<E>$ that){
    super(that);
#IF OfFloat,OfDouble,OfRef
    int size;
    if((size=that.size)!=0){
      $queryParameterType$[] thisTable;
      int thisTableLength;
      this.table=thisTable=new $queryParameterType$[thisTableLength=tableSizeFor(size)];
      this.maxTableSize=(int)(thisTableLength*loadFactor);
      final $queryParameterType$[] thatTable;
      --thisTableLength;
      for(int thatTableLength=(thatTable=that.table).length;;){
        $queryParameterType$ tableVal;
  #IF OfFloat
        switch(tableVal=thatTable[--thatTableLength]) {
        case $DELETED_TABLE_VAL$:
        case $EMPTY_TABLE_VAL$:
          continue;
        default:
        }
  #ELSE
        if((tableVal=thatTable[--thatTableLength]) == $EMPTY_TABLE_VAL$ || tableVal == $DELETED_TABLE_VAL$){
          continue;
        }
  #ENDIF
        SetCommonImpl.quickInsert(tableVal,thisTable,thisTableLength,SetCommonImpl.tableHash(tableVal)&thisTableLength);
        if(--size==0) {
          return;
        }
#ELSE
    int tableSize;
    if((tableSize=that.tableSize)!=0){
      $ArrayType$[] thisTable;
      int thisTableLength;
      this.table=thisTable=new $ArrayType$[thisTableLength=tableSizeFor(tableSize)];
      this.maxTableSize=(int)(thisTableLength*loadFactor);
      --thisTableLength;
      $ArrayType$[] thatTable;
      for(int thatTableLength=(thatTable=that.table).length;;){
        $ArrayType$ tableVal;
        #MACRO IfIsPresentValue(tableVal=thatTable[--thatTableLength])
        {
  #IF OfLong
          SetCommonImpl.quickInsert(tableVal,thisTable,thisTableLength,Long.hashCode(tableVal)&thisTableLength);
  #ELSE
          SetCommonImpl.quickInsert(tableVal,thisTable,thisTableLength,tableVal&thisTableLength);
  #ENDIF
          if(--tableSize==0){
            break;
          }
        }
#ENDIF
      }
    }
  }
  public $ClassPrefix$OpenAddressHashSet(int initialCapacity){
    super(initialCapacity);
  }
  public $ClassPrefix$OpenAddressHashSet(float loadFactor){
    super(loadFactor);
  }
  public $ClassPrefix$OpenAddressHashSet(int initialCapacity,float loadFactor){
    super(initialCapacity,loadFactor);
  }
#IFNOT OfRef
  @Override public boolean add(boolean val){
  #IF OfDouble,OfFloat
  if(val){
    #IF OfFloat
    return addToTable($TRUE_BITS$,$TRUE_BITS$^ $TRUE_BITS$ >>> 16);
    #ELSE
    return addToTable($TRUE_BITS$,(int)($TRUE_BITS$ ^ $TRUE_BITS$ >>> 32) ^ (int)($TRUE_BITS$ ^ $TRUE_BITS$ >>> 32) >>> 16);
    #ENDIF
  }
    #IF OfFloat
  return addToTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
    #ELSE
  return addToTable($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
    #ENDIF
  #ELSE
    long word;
    #IF OfChar
    if((word=this.word0)!=(this.word0=word|(val?2L:1L))){
    #ELSE
    if((word=this.word2)!=(this.word2=word|(val?2L:1L))){
    #ENDIF
      ++this.size;
      return true;
    }
    return false;
  #ENDIF
  }
  #IFNOT OfChar,OfFloat,OfDouble
  @Override public boolean add(byte val){
    returnFalse:for(;;){
      long word,mask=1L<<val;
      switch(val>>6){
      case -2:
        #MACRO AddToWord(0,mask)
      case -1:
        #MACRO AddToWord(1,mask)
      case 0:
        #MACRO AddToWord(2,mask)
      default:
        #MACRO AddToWord(3,mask)
      }
      ++this.size;
      return true;
    }
    return false;
  }
  #ENDIF
  #IFNOT OfShort,OfDouble
  @Override public boolean add(char val){
    #IF OfFloat
    if(val==0){
      return addToTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
    }
    int intBits;
    return addToTable(intBits=Float.floatToRawIntBits(val),SetCommonImpl.tableHash(intBits));
    #ELSE
    returnFalse:for(;;){
      long word;
      switch(val >> 6){
      case 0:
      #IF OfChar
        #MACRO AddToWord(0,1L << val)
      case 1:
        #MACRO AddToWord(1,1L << val)
      case 2:
        #MACRO AddToWord(2,1L << val)
      case 3:
      #ELSE
        #MACRO AddToWord(2,1L << val)
      case 1:
      #ENDIF
        #MACRO AddToWord(3,1L << val)
      default:
        if(!addToTable(val)){
          break returnFalse;
        }
      }
      ++size;
      return true;
    }
    return false; 
    #ENDIF
  }
  #ENDIF
  #IF OfShort,OfFloat
  @Override public boolean add(short val){
    #IF OfFloat
    if(val==0){
      return addToTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
    }
    int intBits;
    return addToTable(intBits=Float.floatToRawIntBits(val),SetCommonImpl.tableHash(intBits));
    #ELSE
    returnFalse:for(;;){
      long word;
      switch(val >> 6){
      case -2:
        #MACRO AddToWord(0,1L << val)
      case -1:
        #MACRO AddToWord(1,1L << val)
      case 0:
        #MACRO AddToWord(2,1L << val)
      case 1:
        #MACRO AddToWord(3,1L << val)
      default:
        if(!addToTable(val)){
            break returnFalse;
        }
      }
      ++size;
      return true;
    }
    return false;
    #ENDIF
  }
  #ENDIF
  #IF OfInt,OfLong,OfFloat,OfDouble
  @Override public boolean add(int val){
    #IF OfFloat,OfDouble
    if(val == 0){
      #IF OfFloat
      return addToTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
      #ELSE
      return addToTable($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
      #ENDIF
    }
      #IF OfFloat
    return addToTable(val=$convertToBits$(val),SetCommonImpl.tableHash(val));
      #ELSE
    long bits;
    return addToTable(bits=$convertToBits$(val),SetCommonImpl.tableHash(bits));
      #ENDIF
    #ELSE
    returnFalse:for(;;){
      long word;
      switch(val >> 6){
      case -2:
        #MACRO AddToWord(0,1L << val)
      case -1:
        #MACRO AddToWord(1,1L << val)
      case 0:
        #MACRO AddToWord(2,1L << val)
      case 1:
        #MACRO AddToWord(3,1L << val)
      default:
        if(!addToTable(val)){
            break returnFalse;
        }
      }
      ++size;
      return true;
    }
    return false;
    #ENDIF
  }
  #ENDIF
  #IF OfLong,OfFloat,OfDouble
  @Override public boolean add(long val){
    #IF OfFloat,OfDouble
    if(val == 0){
      #IF OfFloat
      return addToTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
      #ELSE
      return addToTable($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
      #ENDIF
    }
    
      #IF OfFloat
    int bits;
    return addToTable(bits=$convertToBits$(val),SetCommonImpl.tableHash(bits));
      #ELSE
    return addToTable(val=$convertToBits$(val),SetCommonImpl.tableHash(val));
      #ENDIF
    #ELSE
    returnFalse:for(;;){
      returnTrue:for(;;){
        addToTable:for(;;){
          int v;
          if((v=(int)val)==val){
            long word;
            switch(v>>6){
              case -2:
                #MACRO AddToWord(0,1L<<v)
              case -1:
                #MACRO AddToWord(1,1L<<v)
              case 0:
                #MACRO AddToWord(2,1L<<v)
              case 1:
                #MACRO AddToWord(3,1L<<v)
              default:
                break addToTable;
            }
            break returnTrue;
          }
          break addToTable;
        }
        if(!addToTable(val)){
          break returnFalse;
        }
        break returnTrue;
      }
      ++this.size;
      return true;
    }
    return false;
    #ENDIF
  }
  #ENDIF
  #IF OfFloat,OfDouble
  @Override public boolean add(float val){
    if(val == val){
      $queryParameterType$ bits;
      if((bits=$convertToBits$(val)) == 0){
    #IF OfFloat
        return addToTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
    #ELSE
        return addToTable($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
    #ENDIF
      }
    #IF OfFloat
      return addToTable(bits,SetCommonImpl.tableHash(bits));
    }
    return addToTable(0x7fc00000,0x7fc00000 ^ 0x7fc00000 >>> 16);
    #ELSE
      return addToTable(bits,SetCommonImpl.tableHash(bits));
    }
    return addToTable(0x7ff8000000000000L,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16);
    #ENDIF
  }
  #ENDIF
  #IF OfDouble
  @Override
  public boolean add(double val){
    if(val == val){
      long longBits;
      if((longBits=Double.doubleToRawLongBits(val)) == 0){
        return addToTable($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
      }
      return addToTable(longBits,SetCommonImpl.tableHash(longBits));
    }
    return addToTable(0x7ff8000000000000L,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32)
            ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16);
  }
  #ENDIF
  @Override public boolean add($BoxedType$ val){
    return add(($exposedType$)val);
  }
#ENDIF
#IF OfRef
  @Override public boolean add($exposedType$ val){
    if(val==null){
      return addToTable(NULL,NULLHASH);
    }
    return addToTable(val,SetCommonImpl.tableHash(val));
  }
#ENDIF
#IF OfFloat,OfDouble,OfRef
  @Override public void clear() {
    if(size!=0) {
      $queryParameterType$[] table;
      for(int i=(table=this.table).length;--i>=0;) {
        table[i]=$EMPTY_TABLE_VAL$;
      }
      size=0;
    }
  }
#ENDIF
  @Override public Object clone(){
    return new $ClassPrefix$OpenAddressHashSet$<E>$(this);
  }
  @Override public boolean contains(boolean val){
#IF OfRef
    return size!=0 && tableContains(val,val?1231:1237);
#ELSEIF OfFloat,OfDouble
    if(size!=0) {
      if(val) {
  #IF OfFloat
        return tableContains($TRUE_BITS$,$TRUE_BITS$^ $TRUE_BITS$ >>> 16);
  #ELSE
        return tableContains($TRUE_BITS$,(int)($TRUE_BITS$ ^ $TRUE_BITS$ >>> 32) ^ (int)($TRUE_BITS$ ^ $TRUE_BITS$ >>> 32) >>> 16);
  #ENDIF
      }
#IF OfFloat
      return tableContains($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
  #ELSE
      return tableContains($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
  #ENDIF
    }
    return false;
#ELSEIF OfChar
    #MACRO WordContains(0,val?2L:1L)
#ELSEIF OfShort,OfInt,OfLong
    #MACRO WordContains(2,val?2L:1L)
#ELSE
ERROR unknown type $ClassPrefix$
#ENDIF
  }
#IFNOT OfFloat,OfDouble
  @Override public boolean contains(byte val){
  #IF OfRef
    return size!=0 && tableContains(val,SetCommonImpl.tableHash(val));
  #ELSE
    return uncheckedContainsByte(val);
  #ENDIF
  }
#ENDIF
#IFNOT OfDouble
  @Override public boolean contains(char val){
  #IF OfRef
    return size!=0 && tableContains(val,val);
  #ELSEIF OfFloat
    if(size!=0) {
      if(val==0) {
        return tableContains($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
      }
      int bits;
      return tableContains(bits=Float.floatToRawIntBits(val),SetCommonImpl.tableHash(bits));
    }
    return false;
  #ELSE
    return uncheckedContainsChar(val);
  #ENDIF
  }
  #IF OfChar,OfShort,OfFloat,OfRef
  @Override public boolean contains(short val){
    #IF OfRef
    return size!=0 && tableContains(val,SetCommonImpl.tableHash(val));
    #ELSEIF OfFloat
    if(size!=0) {
      if(val==0) {
        return tableContains($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
      }
      int bits;
      return tableContains(bits=Float.floatToRawIntBits(val),SetCommonImpl.tableHash(bits));
    }
    return false;
    #ELSEIF OfChar
    return val>=0 && uncheckedContainsChar(val);
    #ELSE
    return uncheckedContainsInt(val);
    #ENDIF
  }
  #ENDIF
#ENDIF
  @Override public boolean contains(int val){
#IF OfRef
    return size!=0 && tableContains(val,SetCommonImpl.tableHash(val));
#ELSEIF OfFloat,OfDouble
    if(size!=0) {
      if(val==0) {
  #IF OfFloat
        return tableContains($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
  #ELSE
        return tableContains($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
  #ENDIF
      }
  #IF OfFloat
      else if(TypeUtil.checkCastToFloat(val))
  #ENDIF
      {
  #IF OfFloat
        return tableContains(val=$convertToBits$(val),SetCommonImpl.tableHash(val));
  #ELSE
        long bits;
        return tableContains(bits=$convertToBits$(val),SetCommonImpl.tableHash(bits));
  #ENDIF
      }
    }
    return false;
#ELSEIF OfChar
    return val==(char)val && uncheckedContainsChar(val);
#ELSEIF OfShort
    return val==(short)val && uncheckedContainsInt(val);
#ELSEIF OfInt,OfLong
    return uncheckedContainsInt(val);
#ELSE
ERROR unknown type $ClassPrefix$    
#ENDIF
  }
  @Override public boolean contains(long val){
#IF OfRef
    return size!=0 && tableContains(val,SetCommonImpl.tableHash(val));
#ELSEIF OfFloat,OfDouble
    if(size!=0) {
      if(val==0) {
        #IF OfFloat
        return tableContains($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
  #ELSE
        return tableContains($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
  #ENDIF
      }else if(TypeUtil.checkCastTo$ClassPrefix$(val)) {
  #IF OfFloat
        int bits;
        return tableContains(bits=$convertToBits$(val),SetCommonImpl.tableHash(bits));
  #ELSE
        return tableContains(val=$convertToBits$(val),SetCommonImpl.tableHash(val));
  #ENDIF
      }
    }
    return false;
#ELSEIF OfChar
    int v;
    return size!=0 && (v=(char)val)==val && uncheckedContainsChar(v);
#ELSEIF OfShort
    int v;
    return size!=0 && (v=(short)val)==val && uncheckedContainsInt(v);
#ELSEIF OfInt
    int v;
    return size!=0 && (v=(int)val)==val && uncheckedContainsInt(v);
#ELSEIF OfLong
    if(size==0){
      return false;
    }
    int v;
    if((v=(int)val)==val){
      return uncheckedContainsInt(v);
    }
    return tableContains(val);
#ELSE
ERROR unknown type $ClassPrefix$
#ENDIF
  }
  @Override public boolean contains(float val){
#IF OfRef
    if(size!=0){
      if(val==val){
        return tableContains(val,SetCommonImpl.tableHash(Float.floatToRawIntBits(val)));
      }
      return tableContains(Float.NaN,0x7fc00000 ^ 0x7fc00000 >>> 16);
    }
    return false;
#ELSEIF OfFloat,OfDouble
    if(size!=0) {
      if(val==val) {
        $queryParameterType$ bits;
        if((bits=$convertToBits$(val))!=0) {
          return tableContains(bits,SetCommonImpl.tableHash(bits));
        }
  #IF OfFloat
        return tableContains($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
  #ELSE
        return tableContains($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
  #ENDIF
      }
  #IF OfFloat
      return tableContains(0x7fc00000,0x7fc00000 ^ 0x7fc00000 >>> 16);
  #ELSE
      return tableContains(0x7ff8000000000000L,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16);
  #ENDIF
    }
    return false;
#ELSEIF OfChar
    int v;
    return size!=0 && (v=(char)val)==val && uncheckedContainsChar(v);
#ELSEIF OfShort
    int v;
    return size!=0 && (v=(short)val)==val && uncheckedContainsInt(v);
#ELSEIF OfInt
    int v;
    return size!=0 && (double)(v=(int)val)==(double)val && uncheckedContainsInt(v);
#ELSEIF OfLong
    long l;
    if(size==0 || !TypeUtil.floatEquals(val,l=(long)val)){
      return false;
    }
    int v;
    if((v=(int)l)!=l){
      return tableContains(l);
    }
    return uncheckedContainsInt(v);
#ELSE
ERROR unknown type $ClassPrefix$
#ENDIF
  }
  @Override public boolean contains(double val){
#IF OfRef
    if(size!=0){
      if(val==val){
        return tableContains(val,SetCommonImpl.tableHash(Double.doubleToRawLongBits(val)));
      }
      return tableContains(Double.NaN,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16);
    }
    return false;
#ELSEIF OfFloat,OfDouble
    if(size!=0) {
  #IF OfFloat
      double d;
      float f;
      if((d=val)==(f=(float)d))
      {
        $queryParameterType$ bits;
        if((bits=$convertToBits$(f))==0)
  #ELSE
      if(val==val){
        $queryParameterType$ bits;
        if((bits=$convertToBits$(val))==0)
  #ENDIF
        {
          #IF OfFloat
        return tableContains($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
  #ELSE
        return tableContains($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
  #ENDIF
        }
        return tableContains(bits,SetCommonImpl.tableHash(bits));
      }
      else
  #IF OfFloat
      if(d!=d)
  #ENDIF
      {
  #IF OfFloat
        return tableContains(0x7fc00000,0x7fc00000 ^ 0x7fc00000 >>> 16);
  #ELSE
        return tableContains(0x7ff8000000000000L,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16);
  #ENDIF
      }
    }
    return false;
#ELSEIF OfChar
    int v;
    return size!=0 && (v=(char)val)==val && uncheckedContainsChar(v);
#ELSEIF OfShort
    int v;
    return size!=0 && (v=(short)val)==val && uncheckedContainsInt(v);
#ELSEIF OfInt
    int v;
    return size!=0 && (double)(v=(int)val)==val && uncheckedContainsInt(v);
#ELSEIF OfLong
    long l;
    if(size==0 || !TypeUtil.doubleEquals(val,l=(long)val)){
      return false;
    }
    int v;
    if((v=(int)l)!=l){
      return tableContains(l);
    }
    return uncheckedContainsInt(v);
#ELSE
ERROR unknown type $ClassPrefix$
#ENDIF
  }
#MACRODEF FloatAndDoubleQueryBody<REMOVE>()
checkNaN:for(;;) {
  checkPos0:for(;;) {
    $queryParameterType$ bits;
    if(val instanceof $BoxedType$) {
      $exposedType$ v;
      if((v=($exposedType$)val)==v) {
        if((bits=$convertToBits$(v))==0) {
          break checkPos0;
        }
      }else{
        break checkNaN;
      }
#IF OfFloat
    }else if(val instanceof Integer) {
      if((bits=(int)val)==0) {
        break checkPos0;
      }else if(!TypeUtil.checkCastToFloat(bits)) {
        break returnFalse;
      }
      bits=Float.floatToRawIntBits(bits);
    }else if(val instanceof Long) {
      long l;
      if((l=(long)val)==0) {
        break checkPos0;
      }else if(!TypeUtil.checkCastToFloat(l)) {
        break returnFalse;
      }
      bits=Float.floatToRawIntBits(l);
    }else if(val instanceof Double) {
      double d;
      float f;
      if((d=(double)val)==(f=(float)d)) {
        if((bits=Float.floatToRawIntBits(f))==0) {
          break checkPos0;
        }
      }else if(d!=d) {
        break checkNaN;
      }else {
        break returnFalse;
      }
    }else if(val instanceof Short || val instanceof Byte) {
      if((bits=((Number)val).shortValue())==0) {
        break checkPos0;
      }
      bits=Float.floatToRawIntBits(bits);
    }else if(val instanceof Character) {
      if((bits=(char)val)==0) {
        break checkPos0;
      }
      bits=Float.floatToRawIntBits(bits);
#ELSE
    }else if(val instanceof Integer || val instanceof Byte || val instanceof Short){
      int v;
      if((v=((Number)val).intValue()) == 0){
          break checkPos0;
      }
      bits=Double.doubleToRawLongBits(v);
    }else if(val instanceof Long){
      if((bits=(long)val) == 0){
          break checkPos0;
      }else if(!TypeUtil.checkCastToDouble(bits)){
          break returnFalse;
      }
      bits=Double.doubleToRawLongBits(bits);
    }else if(val instanceof Float){
      float f;
      if((f=(float)val) == f){
          if((bits=Double.doubleToRawLongBits(f)) == 0){
              break checkPos0;
          }
      }else{
          break checkNaN;
      }
    }else if(val instanceof Character){
      int v;
      if((v=(char)val) == 0){
          break checkPos0;
      }
      bits=Double.doubleToRawLongBits(v);
#ENDIF
    }else if(val instanceof Boolean) {
      if((boolean)val) {
#IFSWITCH REMOVE==true
  #IF OfFloat
        if(removeFromTable($TRUE_BITS$,$TRUE_BITS$^ $TRUE_BITS$ >>> 16)) {
  #ELSE
        if(removeFromTable($TRUE_BITS$,(int)($TRUE_BITS$ ^ $TRUE_BITS$ >>> 32) ^ (int)($TRUE_BITS$ ^ $TRUE_BITS$ >>> 32) >>> 16)) {
  #ENDIF
          break returnTrue;
        }
        break returnFalse;
#ELSE
  #IF OfFloat
        return tableContains($TRUE_BITS$,$TRUE_BITS$^ $TRUE_BITS$ >>> 16);
  #ELSE
        return tableContains($TRUE_BITS$,(int)($TRUE_BITS$ ^ $TRUE_BITS$ >>> 32) ^ (int)($TRUE_BITS$ ^ $TRUE_BITS$ >>> 32) >>> 16);
  #ENDIF
#ENDIF
      }else {
        break checkPos0;
      }
    }else {
      break returnFalse;
    }
#IFSWITCH REMOVE==true
    if(removeFromTable(bits,SetCommonImpl.tableHash(bits))) {
      break returnTrue;
    }
    break returnFalse;
  }
  #IF OfFloat
  if(removeFromTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16)) {
  #ELSE
  if(removeFromTable($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16)) {
  #ENDIF
      break returnTrue;
  }
  break returnFalse;
}
  #IF OfFloat
if(removeFromTable(0x7fc00000,0x7fc00000 ^ 0x7fc00000 >>> 16)){
  #ELSE
if(removeFromTable(0x7ff8000000000000L,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16)){
  #ENDIF
#ELSE
    return tableContains(bits,SetCommonImpl.tableHash(bits));
  }
  #IF OfFloat
  return tableContains($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^ $POS0_TABLE_VAL$ >>> 16);
  #ELSE
  return tableContains($POS0_TABLE_VAL$,(int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) ^ (int)($POS0_TABLE_VAL$ ^ $POS0_TABLE_VAL$ >>> 32) >>> 16);
  #ENDIF
}
  #IF OfFloat
return tableContains(0x7fc00000,0x7fc00000 ^ 0x7fc00000 >>> 16);
  #ELSE
return tableContains(0x7ff8000000000000L,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16);
  #ENDIF
#ENDIF
#ENDDEF
  
  @Override public boolean contains(Object val){
    if(size!=0){
#IF OfRef
      if(val==null){
        return tableContains(NULL,NULLHASH);
      }
      return tableContains(val,SetCommonImpl.tableHash(val));
#ELSE
      returnFalse:for(;;){
  #IF OfFloat,OfDouble
        #MACRO FloatAndDoubleQueryBody<false>()
  #ELSEIF OfChar
        int v;
        if(val instanceof Character){
          v=(char)val;
        }else if(val instanceof Integer){
          if((v=(int)val)!=(char)v){
            break returnFalse;
          }
        }else if(val instanceof Long){
          long l;
          if((l=(long)val)!=(v=(char)l)){
            break returnFalse;
          }
        }else if(val instanceof Float){
          float f;
          if((f=(float)val)!=(v=(char)f)){
            break returnFalse;
          }
        }else if(val instanceof Double){
          double d;
          if((d=(double)val)!=(v=(char)d)){
            break returnFalse;
          }
        }else if(val instanceof Byte){
          return uncheckedContainsByte((byte)val);
        }else if(val instanceof Short){
          if((v=(short)val)<0){
            break returnFalse;
          }
        }else if(val instanceof Boolean){
          #MACRO WordContains(0,((boolean)val)?2L:1L)
        }else{
          break returnFalse;
        }
        return uncheckedContainsChar(v);
  #ELSEIF OfShort
        int v;
        if(val instanceof Short){
          v=(short)val;
        }else if(val instanceof Integer){
          if((v=(int)val)!=(short)v){
            break returnFalse;
          }
        }else if(val instanceof Long){
          long l;
          if((l=(long)val)!=(v=(short)l)){
            break returnFalse;
          }
        }else if(val instanceof Float){
          float f;
          if((f=(float)val)!=(v=(short)f)){
            break returnFalse;
          }
        }else if(val instanceof Double){
          double d;
          if((d=(double)val)!=(v=(short)d)){
            break returnFalse;
          }
        }else if(val instanceof Byte){
          return uncheckedContainsByte((byte)val);
        }else if(val instanceof Character){
          return uncheckedContainsChar((char)val);
        }else if(val instanceof Boolean){
          #MACRO WordContains(2,((boolean)val)?2L:1L)
        }else{
          break returnFalse;
        }
        return uncheckedContainsInt(v);
  #ELSEIF OfInt
        int v;
        if(val instanceof Integer || val instanceof Short){
          v=((Number)val).intValue();
        }else if(val instanceof Long){
          long l;
          if((l=(long)val)!=(v=(int)l)){
            break returnFalse;
          }
        }else if(val instanceof Float){
          float f;
          if((double)(f=(float)val)!=(double)(v=(int)f)){
            break returnFalse;
          }
        }else if(val instanceof Double){
          double d;
          if((d=(double)val)!=(v=(int)d)){
            break returnFalse;
          }
        }else if(val instanceof Byte){
          return uncheckedContainsByte((byte)val);
        }else if(val instanceof Character){
          return uncheckedContainsChar((char)val);
        }else if(val instanceof Boolean){
          #MACRO WordContains(2,((boolean)val)?2L:1L)
        }else{
          break returnFalse;
        }
        return uncheckedContainsInt(v);
  #ELSEIF OfLong
        int v;
        containsInt:for(;;){
          long l;
          if(val instanceof Long){
            if((l=(long)val)==(v=(int)l)){
              break containsInt;
            }
          }else if(val instanceof Integer || val instanceof Short){
            v=((Number)val).intValue();
            break containsInt;
          }else if(val instanceof Float){
            float f;
            if(!TypeUtil.floatEquals(f=(float)val,l=(long)f)){
              break returnFalse;
            }
            if((v=(int)l)==l){
              break containsInt;
            }
          }else if(val instanceof Double){
            double d;
            if(!TypeUtil.doubleEquals(d=(double)val,l=(long)d)){
              break returnFalse;
            }
            if((v=(int)l)==l){
              break containsInt;
            }
          }else if(val instanceof Byte){
            return uncheckedContainsByte((byte)val);
          }else if(val instanceof Character){
            return uncheckedContainsChar((char)val);
          }else if(val instanceof Boolean){
            #MACRO WordContains(2,((boolean)val)?2L:1L)
          }else{
            break returnFalse;
          }
          return tableContains(l);
        }
        return uncheckedContainsInt(v);
  #ELSE
ERROR unknown type $ClassPrefix$
  #ENDIF
      }
#ENDIF
    }
    return false;
  }
#IF OfRef
  @Override public boolean contains(Boolean val){
    if(size!=0){
      if(val==null){
        return tableContains(NULL,NULLHASH);
      }else{
        return tableContains(val,val?1231:1237);
      }
      
    }
    return false;
  }
  @Override public boolean contains(Byte val){
    if(size!=0){
      if(val==null){
        return tableContains(NULL,NULLHASH);
      }
      return tableContains(val,SetCommonImpl.tableHash(val.byteValue()));
    }
    return false;
  }
  @Override public boolean contains(Character val){
    if(size!=0){
      if(val==null){
        return tableContains(NULL,NULLHASH);
      }
      return tableContains(val,val.charValue());
    }
    return false;
  }
  @Override public boolean contains(Short val){
    if(size!=0){
      if(val==null){
        return tableContains(NULL,NULLHASH);
      }
      return tableContains(val,SetCommonImpl.tableHash(val.shortValue()));
    }
    return false;
  }
  @Override public boolean contains(Integer val){
    if(size!=0){
      if(val==null){
        return tableContains(NULL,NULLHASH);
      }
      return tableContains(val,SetCommonImpl.tableHash(val.intValue()));
    }
    return false;
  }
  @Override public boolean contains(Long val){
    if(size!=0){
      if(val==null){
        return tableContains(NULL,NULLHASH);
      }
      return tableContains(val,SetCommonImpl.tableHash(val.longValue()));
    }
    return false;
  }
  @Override public boolean contains(Float val){
    if(size!=0){
      if(val==null){
        return tableContains(NULL,NULLHASH);
      }else{
        int hash;
        float f;
        if((f=(float)val)==f){
          hash=SetCommonImpl.tableHash(Float.floatToRawIntBits(f));
        }else{
          val=Float.NaN;
          hash=0x7fc00000 ^ 0x7fc00000 >>> 16;
        }
        return tableContains(val,hash);
      }
    }
    return false;
  }
  @Override public boolean contains(Double val){
    if(size!=0){
      if(val==null){
        return tableContains(NULL,NULLHASH);
      }else{
        int hash;
        double d;
        if((d=(double)val)==d){
          hash=SetCommonImpl.tableHash(Double.doubleToRawLongBits(d));
        }else{
          val=Double.NaN;
          hash=(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16;
        }
        return tableContains(val,hash);
      } 
    }
    return false;
  }
#ENDIF

  @Override public boolean equals(Object val){
    if(val==this){
      return true;
    }
    if(val instanceof Set){
      
      //TODO optimize
      Set<?> that;
      if(size==(that=(Set<?>)val).size()){
        for(final var thatVal:that){
#IF OfRef
          if(!this.contains(thatVal)){
            return false;
          }
#ELSE
          if(!(thatVal instanceof $BoxedType$) || !this.contains(($exposedType$)thatVal)){
            return false;
          }
#ENDIF
        }
        return true;
      }
    }
    return false;
  }
  /*
#IF OfChar,OfShort,OfInt,OfLong,OfRef
  private static boolean isEqualToHelper($ArrayType$[] smallTable,$ArrayType$[] bigTable,int bigTableLength,int numInTable){
#ELSE
  private static boolean isEqualToHelper($queryParameterType$[] smallTable,$queryParameterType$[] bigTable,int bigTableLength,int numInTable){
#ENDIF
    for(int tableIndex=0;;++tableIndex){
#IF OfChar,OfShort,OfInt,OfLong,OfRef
      final $ArrayType$ smallTableVal;
#ELSE
      final $queryParameterType$ smallTableVal;
#ENDIF
#IF OfRef
      if((smallTableVal=smallTable[tableIndex])!=null && smallTableVal!=RefOpenAddressHashSet.DELETED){
        if(!SetCommonImpl.tableContains(smallTableVal,bigTable,bigTableLength,SetCommonImpl.tableHash(smallTableVal)&bigTableLength)){
          return false;
        }
        if(--numInTable==0){
          return true;
        }
      }
#ELSEIF OfDouble
      if((smallTableVal=smallTable[tableIndex])!=0L && smallTableVal!=0x7ffc000000000000L){
        if(!SetCommonImpl.tableContains(smallTableVal,bigTable,bigTableLength,SetCommonImpl.tableHash(smallTableVal)&bigTableLength)){
          return false;
        }
        if(--numInTable==0){
          return true;
        }
      }
#ELSEIF OfFloat
      switch(smallTableVal=smallTable[tableIndex]){
        default:
          if(!SetCommonImpl.tableContains(smallTableVal,bigTable,bigTableLength,SetCommonImpl.tableHash(smallTableVal)&bigTableLength)){
            return false;
          }
          if(--numInTable==0){
            return true;
          }
        case 0:
        case 0x7fe00000:
      }
#ELSEIF OfLong
      if(((smallTableVal=smallTable[tableIndex])&-2L)!=0L){
        if(!SetCommonImpl.tableContains(smallTableVal,bigTable,bigTableLength,Long.hashCode(smallTableVal)&bigTableLength)){
          return false;
        }
        if(--numInTable==0){
          return true;
        }
      }
#ELSE
      if(((smallTableVal=smallTable[tableIndex])&-2)!=0){
        if(!SetCommonImpl.tableContains(smallTableVal,bigTable,bigTableLength,smallTableVal&bigTableLength)){
          return false;
        }
        if(--numInTable==0){
          return true;
        }
      }
#ENDIF   
    }
  }
#IF OfRef
  private boolean isEqualTo(int size,$ClassPrefix$OpenAddressHashSet<?> that){
#ELSE
  private boolean isEqualTo(int size,$ClassPrefix$OpenAddressHashSet that){
    if(size==that.size){
#ENDIF
#IF OfChar,OfShort,OfInt,OfLong
      if(this.word0==that.word0 && this.word1==that.word1 && this.word2==that.word2 && this.word3==that.word3){
        if(size!=(size=tableSize)){
          final $ArrayType$[] thisTable,thatTable;
#ELSE
          final $queryParameterType$[] thisTable,thatTable;
#ENDIF
          final int thisTableLength,thatTableLength;
          if((thisTableLength=(thisTable=this.table).length)<=(thatTableLength=(thatTable=that.table).length)){
            return isEqualToHelper(thisTable,thatTable,thatTableLength-1,size);
          }else{
            return isEqualToHelper(thatTable,thisTable,thisTableLength-1,size);
          }
#IF OfChar,OfShort,OfInt,OfLong
        }
        return true;
      }
#ENDIF
#IFNOT OfRef
    }
    return false;
#ENDIF   
  }
  */
  #MACRO ForEach($TypeNameModifier$Consumer$<? super E>$,action)
#IFNOT OfRef
  #MACRO ForEach(Consumer<? super $BoxedType$>,action::accept)
#ENDIF
#MACRODEF ForEach(CONSUMER,ACTION)
@Override public void forEach(CONSUMER action){
  int size;
  if((size=this.size)!=0){
    forEachHelper(size,ACTION);
  }
}
#ENDDEF
  @Override
  public int hashCode(){
    int size;
    if((size=this.size) != 0){
#IF OfRef
      return uncheckedHashCode(size);
#ELSEIF OfFloat,OfDouble
      int hash=0;
      $queryParameterType$[] table;
      for(int i=(table=this.table).length;;){
        $queryParameterType$ tableVal;
  #IF OfFloat
        switch(tableVal=table[--i]){
          case $EMPTY_TABLE_VAL$:
          case $DELETED_TABLE_VAL$:
            continue;
          default:
            hash+=tableVal;
          case $POS0_TABLE_VAL$:
        }
  #ELSE
        if((tableVal=table[--i]) == $EMPTY_TABLE_VAL$ || tableVal == $DELETED_TABLE_VAL$){
            continue;
        }else if(tableVal != $POS0_TABLE_VAL$){
            hash+=(int)(tableVal ^ tableVal >>> 32);
        }
  #ENDIF
        if(--size == 0){
          return hash;
        }
      }
#ELSE
      long magicWord;
  #IF OfChar
      if((int)(magicWord=processWordHashCode(word0,0,64,size)) != 0){
        if((int)(magicWord=processWordHashCode(word1,64,128,magicWord)) != 0){
          if((int)(magicWord=processWordHashCode(word2,128,192,magicWord)) != 0){
            if((size=(int)(magicWord=processWordHashCode(word3,192,256,magicWord))) != 0){
  #ELSE
      if((int)(magicWord=processWordHashCode(word0,-128,-64,size)) != 0){
        if((int)(magicWord=processWordHashCode(word1,-64,0,magicWord)) != 0){
          if((int)(magicWord=processWordHashCode(word2,0,64,magicWord)) != 0){
            if((size=(int)(magicWord=processWordHashCode(word3,64,128,magicWord))) != 0){
  #ENDIF
              int hash=(int)(magicWord >>> 32);
              $ArrayType$[] table;
              for(int i=(table=this.table).length;;){
                $ArrayType$ tableVal;
                #MACRO IfIsPresentValue(tableVal=table[--i])
                {
  #IF OfLong
                  hash+=((int)(tableVal^(tableVal>>>32)));
  #ELSE
                  hash+=tableVal;
  #ENDIF
                  if(--size == 0){
                    return hash;
                  }
                }
              }
            }
          }
        }
      }
      return (int)(magicWord >>> 32);
#ENDIF
    }
    return 0;
  }
  @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
    return new Itr$<E>$(this);
  }
  @Override
  public void readExternal(ObjectInput in) throws IOException
#IF OfRef
    ,ClassNotFoundException
#ENDIF
  {
      int size;
      this.size=size=in.readInt();
      float loadFactor;
      this.loadFactor=loadFactor=in.readFloat();
      if(size != 0){
#IF OfFloat,OfDouble,OfRef
        int tableSize;
        maxTableSize=(int)((tableSize=tableSizeFor(size)) * loadFactor);
        $queryParameterType$[] table;
        this.table=table=new $queryParameterType$[tableSize];
        --tableSize;
        do {
  #IF OfRef
          Object obj;
          final int hash;
          if((obj=in.readObject())==null){
            obj=NULL;
            hash=NULLHASH&tableSize;;
          }else{
            hash=SetCommonImpl.tableHash(obj)&tableSize;
          }
          SetCommonImpl.quickInsert(obj,table,tableSize,hash);
  #ELSE
    #IF OfFloat
          final int val;
          SetCommonImpl.quickInsert(val=in.readInt(),table,tableSize,SetCommonImpl.tableHash(val)&tableSize);
    #ELSE
          final long val;
          SetCommonImpl.quickInsert(val=in.readLong(),table,tableSize,SetCommonImpl.tableHash(val)&tableSize);
    #ENDIF
  #ENDIF
        }while(--size != 0);
#ELSE
          word0=in.readLong();
          word1=in.readLong();
          word2=in.readLong();
          word3=in.readLong();
          tableSize=size=in.readInt();
          if(size != 0){

              int tableSize;
              maxTableSize=(int)((tableSize=tableSizeFor(size)) * loadFactor);
              $ArrayType$[] table;
              this.table=table=new $ArrayType$[tableSize];
              --tableSize;
              do{
                  final $ArrayType$ val;
  #IF OfLong
                  SetCommonImpl.quickInsert(val=in.read$ClassPrefix$(),table,tableSize,tableSize&Long.hashCode(val));
  #ELSE
                  SetCommonImpl.quickInsert(val=in.read$ClassPrefix$(),table,tableSize,tableSize&val);
  #ENDIF
              }while(--size != 0);
          }else{
              maxTableSize=1;
          }
#ENDIF
      }else{
        maxTableSize=1;
      }
  }
  @Override public boolean remove(Object val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
#IF OfRef
          if(val!=null){
            if(removeFromTable(val,SetCommonImpl.tableHash(val))){
              break returnTrue;
            }
          }else if(removeFromTable(NULL,NULLHASH)){
#ELSEIF OfFloat,OfDouble
          #MACRO FloatAndDoubleQueryBody<true>()
#ELSE
          int v;
          long word;
          checkTableInt:for(;;){
  #IF OfChar
            if(val instanceof Character){
              v=(char)val;
            }else if(val instanceof Integer){
              if((v=(int)val)!=(char)v){
                break returnFalse;
              }
            }else if(val instanceof Long){
              long l;
              if((l=(long)val)!=(v=(char)l)){
                break returnFalse;
              }
            }else if(val instanceof Float){
              float f;
              if((f=(float)val)!=(v=(char)f)){
                break returnFalse;
              }
            }else if(val instanceof Double){
              double d;
              if((d=(double)val)!=(v=(char)d)){
                break returnFalse;
              }
            }else if(val instanceof Byte){
              switch((v=(byte)val)>>6){
                case 0:
                  #MACRO RemoveFromWord(0,~(1L<<v))
                case 1:
                  #MACRO RemoveFromWord(1,~(1L<<v))
                default:
                  break returnFalse;
              }
            }else if(val instanceof Short){
              if((v=(short)val)<0){
                break returnFalse;
              }
            }else if(val instanceof Boolean){
              #MACRO RemoveFromWord(0,((boolean)val)?~2L:~1L)
            }else{
              break returnFalse;
            }
            switch(v>>6){
              case 0:
                #MACRO RemoveFromWord(0,~(1L<<v))
              case 1:
                #MACRO RemoveFromWord(1,~(1L<<v))
              case 2:
                #MACRO RemoveFromWord(2,~(1L<<v))
              case 3:
                #MACRO RemoveFromWord(3,~(1L<<v))
              default:
                break checkTableInt;
            }
  #ELSE
            checkInt:for(;;){
              checkByte:for(;;){
                checkChar:for(;;){
                  checkBoolean:for(;;){
    #IF OfLong
                    long l;
                    checkTableLong:for(;;){
                      if(val instanceof Long){
                        if((l=(long)val)!=(v=(int)l)){
                          break checkTableLong;
                        }
                      }else if(val instanceof Integer || val instanceof Short){
                        v=((Number)val).intValue();
                      }else if(val instanceof Float){
                        float f;
                        if(!TypeUtil.floatEquals(f=(float)val,l=(long)f)){
                          break returnFalse;
                        }
                        if((v=(int)l)!=l){
                          break checkTableLong;
                        }
                      }else if(val instanceof Double){
                        double d;
                        if(!TypeUtil.doubleEquals(d=(double)val,l=(long)d)){
                          break returnFalse;
                        }
                        if((v=(int)l)!=l){
                          break checkTableLong;
                        }
                      }else if(val instanceof Byte){
                        break checkByte;
                      }else if(val instanceof Character){
                        break checkChar;
                      }else if(val instanceof Boolean){
                        break checkBoolean;
                      }else{
                        break returnFalse;
                      }
                      break checkInt;
                    }//checkTableLong
                    if(!removeFromTable(l)){
                      break returnFalse;
                    }
                    break returnTrue;
    #ELSEIF OfInt
                    if(val instanceof Integer || val instanceof Short){
                      v=((Number)val).intValue();
                    }else if(val instanceof Long){
                      long l;
                      if((l=(long)val)!=(v=(int)l)){
                        break returnFalse;
                      }
                    }else if(val instanceof Float){
                      float f;
                      if((double)(f=(float)val)!=(double)(v=(int)f)){
                        break returnFalse;
                      }
                    }else if(val instanceof Double){
                      double d;
                      if((d=(double)val)!=(v=(int)d)){
                        break returnFalse;
                      }
                    }else if(val instanceof Byte){
                      break checkByte;
                    }else if(val instanceof Character){
                      break checkChar;
                    }else if(val instanceof Boolean){
                      break checkBoolean;
                    }else{
                      break returnFalse;
                    }
                    break checkInt;
    #ELSE
                    if(val instanceof Short){
                      v=(short)val;
                    }else if(val instanceof Integer){
                      if((v=(int)val)!=(short)v){
                        break returnFalse;
                      }
                    }else if(val instanceof Long){
                      long l;
                      if((l=(long)val)!=(v=(short)l)){
                        break returnFalse;
                      }
                    }else if(val instanceof Float){
                      float f;
                      if((f=(float)val)!=(v=(short)f)){
                        break returnFalse;
                      }
                    }else if(val instanceof Double){
                      double d;
                      if((d=(double)val)!=(v=(short)d)){
                        break returnFalse;
                      }
                    }else if(val instanceof Byte){
                      break checkByte;
                    }else if(val instanceof Character){
                      break checkChar;
                    }else if(val instanceof Boolean){
                      break checkBoolean;
                    }else{
                      break returnFalse;
                    }
                    break checkInt;
    #ENDIF
                  }//checkBoolean
                  #MACRO RemoveFromWord(2,((boolean)val)?~2L:~1L)
                }//checkChar
                switch((v=(char)val)>>6){
                  case 0:
                    #MACRO RemoveFromWord(2,~(1L<<v))
                  case 1:
                    #MACRO RemoveFromWord(3,~(1L<<v))
                  default:
    #IF OfShort
                    if(v>Short.MAX_VALUE){
                      break returnFalse;
                    }
    #ENDIF
                    break checkTableInt;
                }
              }//checkByte
              long mask=~(1L<<(v=(byte)val));
              switch(v>>6){
                case -2:
                  #MACRO RemoveFromWord(0,mask)
                case -1:
                  #MACRO RemoveFromWord(1,mask)
                case 0:
                  #MACRO RemoveFromWord(2,mask)
                default:
                  #MACRO RemoveFromWord(3,mask)
              }
            }//checkInt
            switch(v>>6){
              case -2:
                #MACRO RemoveFromWord(0,~(1L<<v))
              case -1:
                #MACRO RemoveFromWord(1,~(1L<<v))
              case 0:
                #MACRO RemoveFromWord(2,~(1L<<v))
              case 1:
                #MACRO RemoveFromWord(3,~(1L<<v))
              default:
                break checkTableInt;
            }
  #ENDIF
          }//checkTableInt
          if(removeFromTable(v)){
#ENDIF
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  #MACRO removeIf($TypeNameModifier$Predicate$<? super E>$,filter)
#IFNOT OfRef
  #MACRO removeIf(Predicate<? super $BoxedType$>,filter::test)
#ENDIF
#MACRODEF removeIf(PREDICATE,TEST)
@Override
public boolean removeIf(PREDICATE filter){
  int size;
  return (size=this.size) != 0 && uncheckedRemoveIf(size,TEST);
}  
#ENDDEF
  @Override public boolean removeVal(boolean val){
#IF OfFloat,OfDouble,OfRef
    int size;
    if((size=this.size)!=0) {
      returnFalse:for(;;) {
        returnTrue:for(;;) {
  #IF OfRef
          if(removeFromTable(val,val?1231:1237)){
  #ELSE
          if(val) {
    #IF OfFloat
            if(removeFromTable($TRUE_BITS$,$TRUE_BITS$^($TRUE_BITS$>>>16))) {
    #ELSE
            if(removeFromTable($TRUE_BITS$,((int)($TRUE_BITS$^($TRUE_BITS$>>>32)))^(((int)($TRUE_BITS$^($TRUE_BITS$>>>32)))>>>16))) {
    #ENDIF
              break returnTrue;
            }
    #IF OfFloat
          }else if(removeFromTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>16))) {
    #ELSE
          }else if(removeFromTable($POS0_TABLE_VAL$,((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))^(((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))>>>16))) {
    #ENDIF
  #ENDIF
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
#ELSE
    returnFalse:for(;;){
      returnTrue:for(;;){
        long word;
    #IF OfChar
        #MACRO RemoveFromWord(0,((boolean)val)?~2L:~1L)
    #ELSE
        #MACRO RemoveFromWord(2,((boolean)val)?~2L:~1L)
    #ENDIF
      }
      --this.size;
      return true;
    }
#ENDIF
    return false;
  }
#IFNOT OfFloat,OfDouble
  @Override public boolean removeVal(byte val){
#IF OfRef
    int size;
    if((size=this.size)!=0 && removeFromTable(val,SetCommonImpl.tableHash(val))){
      this.size=size-1;
      return true;
    }
    return false;
#ELSE
    returnFalse:for(;;){
      returnTrue:for(;;){
        long word;
  #IF OfChar
        switch(val>>6){
          case 0:
            #MACRO RemoveFromWord(0,~(1L<<val))
          case 1:
            #MACRO RemoveFromWord(1,~(1L<<val))
          default:
            break returnFalse;
        }
  #ELSE
        long mask=~(1L<<val);
        switch(val>>6){
          case -2:
            #MACRO RemoveFromWord(0,mask)
          case -1:
            #MACRO RemoveFromWord(1,mask)
          case 0:
            #MACRO RemoveFromWord(2,mask)
          default:
            #MACRO RemoveFromWord(3,mask)
        }
  #ENDIF
      }
      --this.size;
      return true;
    }
    return false;
#ENDIF
  }
#ENDIF
#IFNOT OfDouble
  @Override public boolean removeVal(char val){
  #IF OfFloat,OfRef
    int size;
    if((size=this.size)!=0) {
    #IF OfRef
       if(removeFromTable(val,val)){
         this.size=size-1;
         return true;
       }
    #ELSE
      returnFalse:for(;;) {
        returnTrue:for(;;) {
          if(val==0) {
            if(removeFromTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>16))) {
              break returnTrue;
            }
          }else{
            int bits;
            if(removeFromTable(bits=Float.floatToRawIntBits(val),SetCommonImpl.tableHash(bits))) {
              break returnTrue;
            }
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    #ENDIF
  #ELSE
    returnFalse:for(;;){
      returnTrue:for(;;){
        long word;
    #IF OfChar
        switch(val>>6){
          case 0:
            #MACRO RemoveFromWord(0,~(1L<<val))
          case 1:
            #MACRO RemoveFromWord(1,~(1L<<val))
          case 2:
            #MACRO RemoveFromWord(2,~(1L<<val))
          case 3:
            #MACRO RemoveFromWord(3,~(1L<<val))
          default:
            if(!removeFromTable(val)){
              break returnFalse;
            }
            break returnTrue;
        }
    #ELSEIF OfShort
        switch(val>>6){
          case 0:
            #MACRO RemoveFromWord(2,~(1L<<val))
          case 1:
            #MACRO RemoveFromWord(3,~(1L<<val))
          default:
            if(val>Short.MAX_VALUE || !removeFromTable(val)){
              break returnFalse;
            }
            break returnTrue;
        }
    #ELSEIF OfInt,OfLong
        switch(val>>6){
          case 0:
            #MACRO RemoveFromWord(2,~(1L<<val))
          case 1:
            #MACRO RemoveFromWord(3,~(1L<<val))
          default:
            if(!removeFromTable(val)){
              break returnFalse;
            }
            break returnTrue;
        }
    #ELSE
ERROR unknown type $ClassPrefix$
    #ENDIF
      }
      --this.size;
      return true;
  #ENDIF
    }
    return false;
  }
  #IF OfShort,OfChar,OfFloat,OfRef
  @Override public boolean removeVal(short val){
    int size;
    if((size=this.size)!=0){
    #IF OfRef
      if(removeFromTable(val,SetCommonImpl.tableHash(val))){
    #ELSE
      returnFalse:for(;;){
        returnTrue:for(;;){
      #IF OfFloat
          if(val==0) {
            if(removeFromTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>16))) {
              break returnTrue;
            }
          }else{
            int bits;
            if(removeFromTable(bits=Float.floatToRawIntBits(val),SetCommonImpl.tableHash(bits))) {
              break returnTrue;
            }
          }
          break returnFalse;
      #ELSE
          long word;
          switch(val>>6){
        #IF OfShort
            case -2:
              #MACRO RemoveFromWord(0,~(1L<<val))
            case -1:
              #MACRO RemoveFromWord(1,~(1L<<val))
            case 0:
              #MACRO RemoveFromWord(2,~(1L<<val))
            case 1:
              #MACRO RemoveFromWord(3,~(1L<<val))
            default:
              if(removeFromTable(val)){
        #ELSE
            case 0:
              #MACRO RemoveFromWord(0,~(1L<<val))
            case 1:
              #MACRO RemoveFromWord(1,~(1L<<val))
            case 2:
              #MACRO RemoveFromWord(2,~(1L<<val))
            case 3:
              #MACRO RemoveFromWord(3,~(1L<<val))
            default:
              if(val>=0 && removeFromTable(val)){
        #ENDIF
                break returnTrue;
              }
              break returnFalse;
          }
      #ENDIF
        }
    #ENDIF
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  #ENDIF
#ENDIF
  @Override public boolean removeVal(int val){
    int size;
    if((size=this.size)!=0){
#IF OfRef
      if(removeFromTable(val,SetCommonImpl.tableHash(val))){
#ELSE
      returnFalse:for(;;){
        returnTrue:for(;;){
  #IF OfFloat,OfDouble
          if(val==0) {
    #IF OfFloat
             if(removeFromTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>16))) {
    #ELSE
             if(removeFromTable($POS0_TABLE_VAL$,((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))^(((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))>>>16))) {
    #ENDIF
              break returnTrue;
            }
          }
    #IF OfFloat
          else if(TypeUtil.checkCastToFloat(val))
    #ENDIF
          {
            $queryParameterType$ bits;
            if(removeFromTable(bits=$convertToBits$(val),SetCommonImpl.tableHash(bits))) {
              break returnTrue;
            }
          }
          break returnFalse;
  #ELSE
          long word;
          switch(val>>6){
    #IF OfChar
            case 0:
              #MACRO RemoveFromWord(0,~(1L<<val))
            case 1:
              #MACRO RemoveFromWord(1,~(1L<<val))
            case 2:
              #MACRO RemoveFromWord(2,~(1L<<val))
            case 3:
              #MACRO RemoveFromWord(3,~(1L<<val))
            default:
              if(val>=0 && removeFromTable(val)){    
    #ELSE
            case -2:
              #MACRO RemoveFromWord(0,~(1L<<val))
            case -1:
              #MACRO RemoveFromWord(1,~(1L<<val))
            case 0:
              #MACRO RemoveFromWord(2,~(1L<<val))
            case 1:
              #MACRO RemoveFromWord(3,~(1L<<val))
            default:
      #IF OfShort
              if(val==(short)val && removeFromTable(val)){
      #ELSEIF OfInt,OfLong
              if(removeFromTable(val)){
      #ELSE
ERROR unknown type $ClassPrefix$    
      #ENDIF
    #ENDIF
                break returnTrue;
              }
              break returnFalse;
          }
  #ENDIF
        }
#ENDIF
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(long val){
    int size;
    if((size=this.size)!=0)
    {
#IF OfRef
      if(removeFromTable(val,SetCommonImpl.tableHash(val)))
      {
#ELSE
      returnFalse:for(;;)
      {
        returnTrue:for(;;)
        {
  #IF OfFloat,OfDouble
          if(val==0)
          {
    #IF OfFloat
            if(removeFromTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>16)))
    #ELSE
            if(removeFromTable($POS0_TABLE_VAL$,((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))^(((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))>>>16)))
    #ENDIF
            {
              break returnTrue;
            }
          }
          else if(TypeUtil.checkCastTo$BoxedType$(val))
          {
            $queryParameterType$ bits;
            if(removeFromTable(bits=$convertToBits$(val),SetCommonImpl.tableHash(bits)))
            {
              break returnTrue;
            }
          }
          break returnFalse;
  #ELSE
    #IF OfChar
          int v;
          if((v=(char)val)==val)
          {
            long word;
            switch(v>>6)
            {
              case 0:
                #MACRO RemoveFromWord(0,~(1L<<v))
              case 1:
                #MACRO RemoveFromWord(1,~(1L<<v))
              case 2:
                #MACRO RemoveFromWord(2,~(1L<<v))
              case 3:
    #ELSE
      #IF OfShort
          int v;
          if((v=(short)val)==val)
          {
      #ELSEIF OfInt,OfLong
          int v;
          if((v=(int)val)==val)
          {
      #ELSE
Error unknown type $ClassPrefix$      
      #ENDIF
            long word;
            switch(v>>6)
            {
              case -2:
                #MACRO RemoveFromWord(0,~(1L<<v))
              case -1:
                #MACRO RemoveFromWord(1,~(1L<<v))
              case 0:
                #MACRO RemoveFromWord(2,~(1L<<v))
              case 1:             
    #ENDIF
                #MACRO RemoveFromWord(3,~(1L<<v))
              default:
    #IFNOT OfLong
                if(removeFromTable(v)){
                  break returnTrue;
                }
    #ENDIF
            }
          }
    #IF OfLong
          if(removeFromTable(val)){
            break returnTrue;
          }
    #ENDIF
          break returnFalse;
  #ENDIF
        }
#ENDIF
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(float val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
  #IF OfRef
          if(val==val){
            if(removeFromTable(val,SetCommonImpl.tableHash(Float.floatToRawIntBits(val)))){
              break returnTrue;
            }
          }else if(removeFromTable(Float.NaN,0x7fc00000 ^ 0x7fc00000 >>> 16)){
            break returnTrue;
  #ELSEIF OfFloat,OfDouble
          if(val==val) {
            $queryParameterType$ bits;
            if((bits=$convertToBits$(val))!=0) {
              if(removeFromTable(bits,SetCommonImpl.tableHash(bits))) {
                break returnTrue;
              }
    #IF OfFloat
            }else if(removeFromTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>16))) {
              break returnTrue;
            }
          }else if(removeFromTable(0x7fc00000,0x7fc00000 ^ 0x7fc00000 >>> 16)) {
            break returnTrue;
    #ELSE
            }else if(removeFromTable($POS0_TABLE_VAL$,((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))^(((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))>>>16))) {
              break returnTrue;
            }
          }else if(removeFromTable(0x7ff8000000000000L,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16)) {
            break returnTrue;
    #ENDIF
  #ELSE
    #IF OfChar
          int v;
          if((v=(char)val)==val){
            long word;
            switch(v>>6){
              case 0:
                #MACRO RemoveFromWord(0,~(1L<<v))
              case 1:
                #MACRO RemoveFromWord(1,~(1L<<v))
              case 2:
                #MACRO RemoveFromWord(2,~(1L<<v))
              case 3:
              
    #ELSE
      #IF OfShort
          int v;
          if((v=(short)val)==val){
      #ELSEIF OfInt
          int v;
          if((double)(v=(int)val)==(double)val){
      #ELSEIF OfLong
          long l;
          if(TypeUtil.floatEquals(val,l=(long)val)){
            int v;
            if((v=(int)l)!=l){
              if(removeFromTable(l)){
                break returnTrue;
              }
              break returnFalse;
            }
            
      #ELSE
Error unknown type $ClassPrefix$
      #ENDIF
            long word;
            switch(v>>6){
              case -2:
                #MACRO RemoveFromWord(0,~(1L<<v))
              case -1:
                #MACRO RemoveFromWord(1,~(1L<<v))
              case 0:
                #MACRO RemoveFromWord(2,~(1L<<v))
              case 1:              
    #ENDIF
                #MACRO RemoveFromWord(3,~(1L<<v))
              default:
            }
            if(removeFromTable(v)){
              break returnTrue;
            }
  #ENDIF
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(double val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
#IF OfRef
          if(val==val){
            if(removeFromTable(val,SetCommonImpl.tableHash(Double.doubleToRawLongBits(val)))){
              break returnTrue;
            }
          }else if(removeFromTable(Double.NaN,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16)){
            break returnTrue;
#ELSEIF OfFloat,OfDouble
  #IF OfFloat
          double d;
          float f;
          if((d=val)==(f=(float)d)){
            $queryParameterType$ bits;
            if((bits=$convertToBits$(f))==0) {
              if(removeFromTable($POS0_TABLE_VAL$,$POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>16))) {
  #ELSE
          if(val==val){
            $queryParameterType$ bits;
            if((bits=$convertToBits$(val))==0) {
              if(removeFromTable($POS0_TABLE_VAL$,((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))^(((int)($POS0_TABLE_VAL$^($POS0_TABLE_VAL$>>>32)))>>>16))) {
  #ENDIF
                break returnTrue;
              }
            }else if(removeFromTable(bits,SetCommonImpl.tableHash(bits))) {
              break returnTrue;
            }
          }
          else
  #IF OfFloat
          if(d!=d)
  #ENDIF
          {
  #IF OfFloat
            if(removeFromTable(0x7fc00000,0x7fc00000 ^ 0x7fc00000 >>> 16)) {
  #ELSE
            if(removeFromTable(0x7ff8000000000000L,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16)) {
  #ENDIF
              break returnTrue;
            }
#ELSE
  #IF OfChar
          int v;
          if((v=(char)val)==val){
            long word;
            switch(v>>6){
              case 0:
                #MACRO RemoveFromWord(0,~(1L<<v))
              case 1:
                #MACRO RemoveFromWord(1,~(1L<<v))
              case 2:
                #MACRO RemoveFromWord(2,~(1L<<v))
              case 3:
              
  #ELSE
    #IF OfShort
          int v;
          if((v=(short)val)==val){
    #ELSEIF OfInt
          int v;
          if((v=(int)val)==val){
    #ELSEIF OfLong
          long l;
          if(TypeUtil.doubleEquals(val,l=(long)val)){
            int v;
            if((v=(int)l)!=l){
              if(!removeFromTable(l)){
                break returnFalse;
              }
              break returnTrue;
            }
    #ELSE
Error unknown type $ClassPrefix$
    #ENDIF
            long word;
            switch(v>>6){
              case -2:
                #MACRO RemoveFromWord(0,~(1L<<v))
              case -1:
                #MACRO RemoveFromWord(1,~(1L<<v))
              case 0:
                #MACRO RemoveFromWord(2,~(1L<<v))
              case 1:              
  #ENDIF
                #MACRO RemoveFromWord(3,~(1L<<v))
              default:
                if(removeFromTable(v)){
                  break returnTrue;
                }
            }
#ENDIF
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
#IF OfRef
  @Override public boolean removeVal(Boolean val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
          if(val!=null){
            if(removeFromTable(val,val?1231:1237)){
              break returnTrue;
            }
          }else if(removeFromTable(NULL,NULLHASH)){
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(Byte val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
          if(val!=null){
            if(removeFromTable(val,SetCommonImpl.tableHash(val.byteValue()))){
              break returnTrue;
            }
          }else if(removeFromTable(NULL,NULLHASH)){
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(Character val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
          if(val!=null){
            if(removeFromTable(val,val.charValue())){
              break returnTrue;
            }
          }else if(removeFromTable(NULL,NULLHASH)){
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(Short val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
          if(val!=null){
            if(removeFromTable(val,SetCommonImpl.tableHash(val.shortValue()))){
              break returnTrue;
            }
          }else if(removeFromTable(NULL,NULLHASH)){
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(Integer val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
          if(val!=null){
            if(removeFromTable(val,SetCommonImpl.tableHash(val.intValue()))){
              break returnTrue;
            }
          }else if(removeFromTable(NULL,NULLHASH)){
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(Long val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
          if(val!=null){
            if(removeFromTable(val,SetCommonImpl.tableHash(val.longValue()))){
              break returnTrue;
            }
          }else if(removeFromTable(NULL,NULLHASH)){
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(Float val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
          if(val!=null){
            float f;
            if((f=(float)val)==f){
              if(removeFromTable(val,SetCommonImpl.tableHash(Float.floatToRawIntBits(f)))){
                break returnTrue;
              }
            }else if(removeFromTable(Float.NaN,0x7fc00000 ^ 0x7fc00000 >>> 16)){
              break returnTrue;
            }
          }else if(removeFromTable(NULL,NULLHASH)){
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
  @Override public boolean removeVal(Double val){
    int size;
    if((size=this.size)!=0){
      returnFalse:for(;;){
        returnTrue:for(;;){
          if(val!=null){
            double d;
            if((d=(double)val)==d){
              if(removeFromTable(val,SetCommonImpl.tableHash(Double.doubleToRawLongBits(d)))){
                break returnTrue;
              }
            }else if(removeFromTable(Double.NaN,(int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) ^ (int)(0x7ff8000000000000L ^ 0x7ff8000000000000L >>> 32) >>> 16)){
              break returnTrue;
            }
          }else if(removeFromTable(NULL,NULLHASH)){
            break returnTrue;
          }
          break returnFalse;
        }
        this.size=size-1;
        return true;
      }
    }
    return false;
  }
#ENDIF
#MACRODEF ToArray(RETTYPE,DEFAULTARR,MODIFIER)
@Override public RETTYPE[] toMODIFIERArray(){
  int size;
  if((size=this.size) != 0){
    RETTYPE[] dst;
    uncheckedCopyIntoArray(size,dst=new RETTYPE[size]);
    return dst;
  }
  return DEFAULTARR;
}
#ENDDEF
  #MACRO ToArray($ArrayType$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR,$TypeNameModifier$)
#IFNOT OfRef
  #MACRO ToArray($BoxedType$,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR,)
  #IFNOT OfDouble
  #MACRO ToArray(double,OmniArray.OfDouble.DEFAULT_ARR,Double)
    #IFNOT OfFloat
  #MACRO ToArray(float,OmniArray.OfFloat.DEFAULT_ARR,Float)
      #IFNOT OfLong
  #MACRO ToArray(long,OmniArray.OfLong.DEFAULT_ARR,Long)
        #IFNOT OfInt
  #MACRO ToArray(int,OmniArray.OfInt.DEFAULT_ARR,Int)  
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#MACRODEF ToArrayHelper(ARRTYPE,CAST)
#IFNOT OfFloat,OfDouble,OfRef
private static int wordCopy(long word,int valOffset,int valBound,ARRTYPE[] dst,int dstOffset,int dstBound){
  do{
      if((word & 1L << valOffset) != 0L){
          dst[dstOffset]=CAST(valOffset);
          if(++dstOffset == dstBound){
              break;
          }
      }
  }while(++valOffset != valBound);
  return dstOffset;  
}
#ENDIF
private void uncheckedCopyIntoArray(int size,ARRTYPE[] dst){
#IF OfFloat,OfDouble,OfRef
  var table=this.table;
  for(int i=0;;++i) {
      $queryParameterType$ tableVal;
  #IF OfFloat
      switch(tableVal=table[i]) {
      case $EMPTY_TABLE_VAL$:
      case $DELETED_TABLE_VAL$:
        continue;
      case $POS0_TABLE_VAL$:
        dst[--size]=0.0f;
        break;
      default:
        dst[--size]=Float.intBitsToFloat(tableVal);
      }
  #ELSE
      if((tableVal=table[i]) == $EMPTY_TABLE_VAL$ || tableVal == $DELETED_TABLE_VAL$){
        continue;
    #IF OfDouble
      }else if(tableVal == $POS0_TABLE_VAL$){
        dst[--size]=0.0d;
      }else{
        dst[--size]=Double.longBitsToDouble(tableVal);
      }
    #ELSE
      }else if(tableVal==NULL){
        dst[--size]=null;
      }else{
        dst[--size]=tableVal;
      }
    #ENDIF
  #ENDIF
      if(size==0) {
          return;
      }
  }
#ELSE
    int offset;
  #IF OfChar
    if((offset=wordCopy(word0,0,64,dst,0,size)) != size){
        if((offset=wordCopy(word1,64,128,dst,offset,size)) != size){
            if((offset=wordCopy(word2,128,192,dst,offset,size)) != size){
                if((offset=wordCopy(word3,192,256,dst,offset,size)) != size){
  #ELSE
    if((offset=wordCopy(word0,-128,-64,dst,0,size)) != size){
        if((offset=wordCopy(word1,-64,0,dst,offset,size)) != size){
            if((offset=wordCopy(word2,0,64,dst,offset,size)) != size){
                if((offset=wordCopy(word3,64,128,dst,offset,size)) != size){
  #ENDIF
                    final $ArrayType$[] table=this.table;
                    for(int i=0;;++i){
                        $ArrayType$ tableVal;
                        #MACRO IfIsPresentValue(tableVal=table[i])
                        {
                            dst[offset]=CAST(tableVal);
                            if(++offset == size){
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
#ENDIF
}
#ENDDEF
  #MACRO ToArrayHelper($ArrayType$,($ArrayType$))
#IFNOT OfRef
  #MACRO ToArrayHelper(Object,($exposedType$))
  #MACRO ToArrayHelper($BoxedType$,($BoxedType$)($exposedType$))
  #IFNOT OfDouble
  #MACRO ToArrayHelper(double,(double))
    #IFNOT OfFloat
  #MACRO ToArrayHelper(float,(float))
      #IFNOT OfLong
  #MACRO ToArrayHelper(long,(long))
        #IFNOT OfInt
  #MACRO ToArrayHelper(int,(int))
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
    int size;
    final T[] arr=arrConstructor.apply(size=this.size);
    if(size != 0){
        uncheckedCopyIntoArray(size,arr);
    }
    return arr;
  }
  @Override public <T> T[] toArray(T[] dst){
    int size;
    if((size=this.size) != 0){
        uncheckedCopyIntoArray(size,dst=OmniArray.uncheckedArrResize(size,dst));
    }else if(dst.length != 0){
        dst[0]=null;
    }
    return dst;
  }
  @Override
  public String toString(){
      int size;
      if((size=this.size) != 0){
#IF OfRef
        return uncheckedToString(size);
#ELSEIF OfDouble
          var builder=new StringBuilder("[");
          long[] table;
          for(int i=(table=this.table).length;;){
              long tableVal;
              if((tableVal=table[--i]) == $EMPTY_TABLE_VAL$ || tableVal == $DELETED_TABLE_VAL$){
                  continue;
              }else if(tableVal == $POS0_TABLE_VAL$){
                  builder.append(0.0d);
              }else{
                  builder.append(Double.longBitsToDouble(tableVal));
              }
              if(--size == 0){
                  return builder.append(']').toString();
              }
              builder.append(',').append(' ');
          }
#ELSEIF OfChar
          char[] buffer;
          (buffer=new char[size * 3])[0]='[';
          long magicWord;
          if((int)(magicWord=processWordToString(word0,0,64,buffer,size)) != 0){
              if((int)(magicWord=processWordToString(word1,64,128,buffer,magicWord)) != 0){
                  if((int)(magicWord=processWordToString(word2,128,192,buffer,magicWord)) != 0){
                      if((size=(int)(magicWord=processWordToString(word3,192,256,buffer,magicWord))) != 0){
                          int bufferOffset=(int)(magicWord >>> 32);
                          final var table=this.table;
                          for(int i=0;;++i){
                              $exposedType$ tableVal;
                              #MACRO IfIsPresentValue(tableVal=table[i])
                              {
                                  buffer[++bufferOffset]=tableVal;
                                  if(--size == 0){
                                      break;
                                  }
                                  buffer[++bufferOffset]=',';
                                  buffer[++bufferOffset]=' ';
                              }
                          }
                          buffer[++bufferOffset]=']';
                          return new String(buffer,0,bufferOffset + 1);
                      }
                  }
              }
          }
          buffer[size=(int)(magicWord >>> 32) + 1]=']';
          return new String(buffer,0,size + 1);
#ELSEIF OfShort
        byte[] buffer;
        (buffer=new byte[size<<3])[0]='[';
        long magicWord;
        if((int)(magicWord=processWordToString(word0,-128,-64,buffer,size)) != 0){
              if((int)(magicWord=processWordToString(word1,-64,0,buffer,magicWord)) != 0){
                  if((int)(magicWord=processWordToString(word2,0,64,buffer,magicWord)) != 0){
                      if((size=(int)(magicWord=processWordToString(word3,64,128,buffer,magicWord))) != 0){
                          int bufferOffset=(int)(magicWord >>> 32);
                          final var table=this.table;
                          for(int i=0;;++i){
                              $exposedType$ tableVal;
                              #MACRO IfIsPresentValue(tableVal=table[i])
                              {
                                  bufferOffset=ToStringUtil.getStringShort(tableVal,buffer,++bufferOffset);
                                  if(--size == 0){
                                      break;
                                  }
                                  buffer[bufferOffset]=',';
                                  buffer[++bufferOffset]=' ';
                              }
                          }
                          buffer[bufferOffset]=']';
                          return new String(buffer,0,bufferOffset + 1,ToStringUtil.IOS8859CharSet);
                      }
                  }
              }
          }
          buffer[size=(int)(magicWord >>> 32)]=']';
          return new String(buffer,0,size + 1,ToStringUtil.IOS8859CharSet);
#ELSEIF OfInt,OfLong,OfFloat
  #IF OfInt
        if(size<=(OmniArray.MAX_ARR_SIZE/13)){
  #ELSEIF OfLong
        if(size<=(OmniArray.MAX_ARR_SIZE/22)){
  #ELSE
        if(size<=(OmniArray.MAX_ARR_SIZE/17)){
  #ENDIF
          return quickToString(size);
        }else{
          return massiveToString(size);
        }
#ENDIF
      }
      return "[]";
  }
  @Override
  public void writeExternal(ObjectOutput out) throws IOException{
      int size;
      out.writeInt(size=this.size);
      out.writeFloat(this.loadFactor);
      if(size != 0){
#IF OfFloat,OfDouble,OfRef
        $queryParameterType$[] table;
        for(int i=(table=this.table).length;;) {
          $queryParameterType$ tableVal;
  #IF OfFloat
          switch(tableVal=table[--i]) {
            default:
              out.writeInt(tableVal);
              if(--size==0) {
                return;
              }
            case $EMPTY_TABLE_VAL$:
            case $DELETED_TABLE_VAL$:
          }
  #ELSE
          if((tableVal=table[--i]) != $EMPTY_TABLE_VAL$ && tableVal != $DELETED_TABLE_VAL$){
            #IF OfRef
            if(tableVal == NULL){
                tableVal=null;
            }
            out.writeObject(tableVal);
            #ELSE
            out.writeLong(tableVal);
            #ENDIF
            if(--size == 0){
              return;
            }
          }
  #ENDIF
        }
#ELSE
        out.writeLong(word0);
        out.writeLong(word1);
        out.writeLong(word2);
        out.writeLong(word3);
        out.writeInt(size=tableSize);
        if(size != 0){
          $ArrayType$[] table;
          for(int i=(table=this.table).length;;){
            $ArrayType$ tableVal;
            #MACRO IfIsPresentValue(tableVal=table[--i])
            {
              out.write$ClassPrefix$(tableVal);
              if(--size == 0){
                break;
              }
            }
          }
        }
#ENDIF
      }
  }
#IF OfRef
private boolean addToTable(Object val,int hash){
#ELSEIF OfFloat
boolean addToTable(int val,int hash){
#ELSEIF OfDouble
boolean addToTable(long val,int hash){
#ELSE
private boolean addToTable($ArrayType$ val){
#ENDIF
#IF OfRef,OfFloat,OfDouble
  $queryParameterType$[] table;
#ELSE
  $ArrayType$[] table;
#ENDIF
  if((table=this.table)!=null){
    int tableLength;
    int insertHere=-1;
#IFNOT OfFloat,OfDouble,OfRef
    int hash;
#ENDIF
#IF OfFloat,OfDouble,OfRef
    insertInTable:for(final int initialHash=hash&=tableLength=table.length - 1;;){
      $queryParameterType$ tableVal;
#ELSEIF OfLong
    insertInTable:for(final int initialHash=hash=((int)(val^(val>>>32)))&(tableLength=table.length-1);;){
      $ArrayType$ tableVal;
#ELSE
    insertInTable:for(final int initialHash=hash=val&(tableLength=table.length-1);;){
      $ArrayType$ tableVal;
#ENDIF
#IF OfDouble,OfRef
      if((tableVal=table[hash]) == $EMPTY_TABLE_VAL$){
        if(insertHere == -1){
          insertHere=hash;
        }
        break;
      }else if(tableVal == $DELETED_TABLE_VAL$){
        insertHere=hash;
  #IF OfDouble
      }else if(tableVal == val){
  #ELSE
      }else if(val.equals(tableVal)){
  #ENDIF
        // already contained
        return false;
      }
#ELSEIF OfFloat
      switch(tableVal=table[hash]){
        case $EMPTY_TABLE_VAL$:
          if(insertHere == -1){
            insertHere=hash;
          }
          break insertInTable;
        case $DELETED_TABLE_VAL$:
          insertHere=hash;
          break;
        default:
          if(tableVal==val){
            //already contains
            return false;
          }
      }
#ELSEIF OfLong
      if((tableVal=table[hash])==0L){
        if(insertHere==-1){
          insertHere=hash;
        }
        break insertInTable;
      }else if(tableVal==1L){
        insertHere=hash;
      }else if(tableVal==val){
        //already contains
        return false;
      }
#ELSE
      switch(tableVal=table[hash]){
        case 0:
          if(insertHere==-1){
            insertHere=hash;
          }
          break insertInTable;
        case 1:
          insertHere=hash;
          break;
        default:
          if(tableVal==val){
            //already contains
            return false;
          }
      }
#ENDIF
      if((hash=hash + 1 & tableLength) == initialHash){
        break insertInTable;
      }
    }
    insert(table,insertHere,val);
    return true;
  }
  int maxTableSize;
#IF OfFloat,OfDouble,OfRef
  this.table=table=new $queryParameterType$[maxTableSize=this.maxTableSize];
  this.size=1;
  table[hash & maxTableSize - 1]=val;
#ELSE
  this.table=table=new $ArrayType$[maxTableSize=this.maxTableSize];
  this.tableSize=1;
  #IF OfLong
  table[((int)(val^(val>>>32)))&(maxTableSize-1)]=val;
  #ELSE
  table[val&(maxTableSize-1)]=val;  
  #ENDIF
#ENDIF
  this.maxTableSize=(int)(maxTableSize*loadFactor);
  return true;
}
  #MACRO ContainsOrRemoveFromTable<true>()
  #MACRO ContainsOrRemoveFromTable<false>()
#MACRODEF ContainsOrRemoveFromTable<REMOVE>()
#IFSWITCH REMOVE==true
  #IFNOT OfRef,OfDouble,OfFloat
private
  #ENDIF
boolean removeFromTable(
#ELSE
private
boolean tableContains(
#ENDIF
#IF OfRef,OfDouble,OfFloat
$queryParameterType$ val,int hash){
  $queryParameterType$[] table;
  $queryParameterType$ tableVal;
  int tableLength;
  if((tableVal=(table=this.table)[hash&=(tableLength=table.length-1)])!=$EMPTY_TABLE_VAL$){
#ELSE
  #IF OfLong
long val){
  #ELSE
int val){
  #ENDIF
  $ArrayType$[] table;
  $ArrayType$ tableVal;
  int tableLength;
  int hash;
  #IFSWITCH REMOVE==true
  int tableSize;
  if((tableSize=this.tableSize)!=0
  #ELSE
  if(tableSize!=0
  #ENDIF
  #IF OfLong
  &&(tableVal=(table=this.table)[hash=(((int)(val^(val>>>32)))&(tableLength=table.length-1))])!=$EMPTY_TABLE_VAL$){
  #ELSE
  &&(tableVal=(table=this.table)[hash=(val&(tableLength=table.length-1))])!=$EMPTY_TABLE_VAL$){
  #ENDIF
#ENDIF
    final int initialHash=hash;
    do{
#IF OfRef
      if(val.equals(tableVal)){
#ELSE
      if(val==tableVal){
#ENDIF
#IFSWITCH REMOVE==true
  #IF OfChar,OfShort,OfInt,OfLong
        this.tableSize=tableSize-1;
  #ENDIF
        table[hash]=$DELETED_TABLE_VAL$;
#ENDIF
        return true;
      }
    }while((hash=(hash+1)&tableLength)!=initialHash&&(tableVal=table[hash])!=$EMPTY_TABLE_VAL$);
  }
  return false;
}
#ENDDEF
#IF OfRef
  @SuppressWarnings("unchecked")
#ENDIF
  void forEachHelper(int size,$TypeNameModifier$Consumer$<? super E>$ action){
#IF OfFloat,OfDouble,OfRef
    $queryParameterType$[] table;
    for(int i=(table=this.table).length;;){
        $queryParameterType$ tableVal;
  #IF OfDouble,OfRef
        if((tableVal=table[--i]) == $EMPTY_TABLE_VAL$ || tableVal == $DELETED_TABLE_VAL$){
            continue;
    #IF OfDouble
        }else if(tableVal == $POS0_TABLE_VAL$){
            action.accept(0.0d);
        }else{
            action.accept(Double.longBitsToDouble(tableVal));
        }
    #ELSE
        }else if(tableVal == NULL){
          action.accept(null);
        }else{
          action.accept((E)tableVal);
        }
    #ENDIF
  #ELSE
        switch(tableVal=table[--i]){
        case $EMPTY_TABLE_VAL$:
        case $DELETED_TABLE_VAL$:
            continue;
        case $POS0_TABLE_VAL$:
            action.accept(0.0f);
            break;
        default:
            action.accept(Float.intBitsToFloat(tableVal));
        }
  #ENDIF
        if(--size == 0){
            return;
        }
    }
#ELSE
  #IF OfChar
      if((size=processWordForEach(word0,0,64,action,size)) != 0){
          if((size=processWordForEach(word1,64,128,action,size)) != 0){
              if((size=processWordForEach(word2,128,192,action,size)) != 0){
                  if((size=processWordForEach(word3,192,256,action,size)) != 0){
  #ELSE
      if((size=processWordForEach(word0,-128,-64,action,size)) != 0){
          if((size=processWordForEach(word1,-64,0,action,size)) != 0){
              if((size=processWordForEach(word2,0,64,action,size)) != 0){
                  if((size=processWordForEach(word3,64,128,action,size)) != 0){
  #ENDIF
                      final var table=this.table;
                      for(int i=0;;++i){
                          $exposedType$ tableVal;
                          #MACRO IfIsPresentValue(tableVal=table[i])
                          {
                              action.accept(tableVal);
                              if(--size == 0){
                                  break;
                              }
                          }
                      }
                  }
              }
          }
      }
#ENDIF
  }
#IF OfRef
  int uncheckedHashCode(int size){
    int hash=0;
    Object[] table;
    for(int i=(table=this.table).length;;){
      Object tableVal;
      if((tableVal=table[--i]) == null || tableVal == DELETED){
        continue;
      }else if(tableVal != NULL){
        hash+=tableVal.hashCode();
      }
      if(--size == 0){
        return hash;
      }
    }
  }
#ENDIF
#IF OfRef
  @SuppressWarnings("unchecked")
#ENDIF
  boolean uncheckedRemoveIf(int size,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfFloat,OfDouble,OfRef
    int newSize=0;
    $queryParameterType$[] table;
    for(int numLeft=size,i=(table=this.table).length;;){
        $queryParameterType$ tableVal;
  #IF OfRef
        if((tableVal=table[--i]) == $EMPTY_TABLE_VAL$ || tableVal == $DELETED_TABLE_VAL$){
          continue;
        }else if(tableVal == NULL){
          tableVal=null;
        }
        if(filter.test((E)tableVal)){
  #ELSE
        $exposedType$ v;
    #IF OfFloat
        switch(tableVal=table[--i]){
        case $EMPTY_TABLE_VAL$:
        case $DELETED_TABLE_VAL$:
            continue;
        case $POS0_TABLE_VAL$:
            v=0;
            break;
        default:
            v=Float.intBitsToFloat(tableVal);
        }
    #ELSE
        if((tableVal=table[--i]) == $EMPTY_TABLE_VAL$ || tableVal == $DELETED_TABLE_VAL$){
            continue;
        }else if(tableVal == $POS0_TABLE_VAL$){
            v=0;
        }else{
            v=Double.longBitsToDouble(tableVal);
        }
    #ENDIF
        if(filter.test(v)){
  #ENDIF
            table[i]=$DELETED_TABLE_VAL$;
        }else{
            ++newSize;
        }
        if(--numLeft == 0){
            break;
        }
    }
    if(newSize != size){
        this.size=newSize;
        return true;
    }
#ELSE
    long word;
  #IF OfChar
    int numRemoved=Long.bitCount((word=word0) ^ (word0=wordRemoveIf(word,0,filter)))
      + Long.bitCount((word=word1) ^ (word1=wordRemoveIf(word,64,filter)))
      + Long.bitCount((word=word2) ^ (word2=wordRemoveIf(word,128,filter)))
      + Long.bitCount((word=word3) ^ (word3=wordRemoveIf(word,192,filter)));
  #ELSE
    int numRemoved=Long.bitCount((word=word0) ^ (word0=wordRemoveIf(word,-128,filter)))
      + Long.bitCount((word=word1) ^ (word1=wordRemoveIf(word,-64,filter)))
      + Long.bitCount((word=word2) ^ (word2=wordRemoveIf(word,0,filter)))
      + Long.bitCount((word=word3) ^ (word3=wordRemoveIf(word,64,filter)));
  #ENDIF
    int tableSize;
    if((tableSize=this.tableSize)!=0){
      $ArrayType$[] table;
      int newTableSize=0;
      for(int i=(table=this.table).length;;){
        $ArrayType$ tableVal;
        #MACRO IfIsPresentValue(tableVal=table[--i])
        {
          if(filter.test(tableVal)){
            table[i]=1;
            ++numRemoved;
          }else{
            ++newTableSize;
          }
          if(--tableSize==0){
            break;
          }
        }
      }
      this.tableSize=newTableSize;
    }
    if(numRemoved!=0){
      this.size=size-numRemoved;
      return true;
    }
#ENDIF
    return false;
  }
#IF OfRef
  String uncheckedToString(int size){
    var builder=new StringBuilder("[");
    Object[] table;
    for(int i=(table=this.table).length;;){
      Object tableVal;
      if((tableVal=table[--i]) == null || tableVal == DELETED){
        continue;
      }else if(tableVal == NULL){
        builder.append((String)null);
      }else{
        builder.append(tableVal);
      }
      if(--size == 0){
        return builder.append(']').toString();
      }
      builder.append(',').append(' ');
    }
  }
#ENDIF
  @Override
  void updateMaxTableSize(float loadFactor){
#IF OfFloat,OfDouble
      $queryParameterType$[] table;
#ELSE
      $ArrayType$[] table;
#ENDIF
      if((table=this.table) != null){
          this.maxTableSize=(int)(table.length * loadFactor);
      }
  }
#IF OfFloat,OfDouble,OfRef
  private void insert($queryParameterType$[] table,int hash,$queryParameterType$ val){
    int size;
    if((size=++this.size) >= maxTableSize){
        maxTableSize=(int)((hash=table.length << 1) * loadFactor);
        $queryParameterType$[] newTable;
        this.table=newTable=new $queryParameterType$[hash];
        --hash;
        if(size!=1){
          for(int i=0;;++i){
            $queryParameterType$ tableVal;
  #IF OfFloat
            switch(tableVal=table[i]){
            case $EMPTY_TABLE_VAL$:
            case $DELETED_TABLE_VAL$:
              continue;
            default:
            }
  #ELSE
            if((tableVal=table[i]) == $EMPTY_TABLE_VAL$ || tableVal == $DELETED_TABLE_VAL$){
              continue;
            }
  #ENDIF
            SetCommonImpl.quickInsert(tableVal,newTable,hash,hash&SetCommonImpl.tableHash(tableVal));
            if(--size == 1){
              break;
            }
          }
        }
        SetCommonImpl.quickInsert(val,newTable,hash,hash&SetCommonImpl.tableHash(val));
    }else{
        table[hash]=val;
    }
  }
#ELSE
  private void insert($ArrayType$[] table,int hash,$ArrayType$ val){
    int tableSize;
    if((tableSize=++this.tableSize)>=maxTableSize){
      maxTableSize=(int)((hash=table.length<<1)*loadFactor);
      $ArrayType$[] newTable;
      this.table=newTable=new $ArrayType$[hash];
      --hash;
      if(tableSize!=1){
        for(int i=0;;++i){
          $ArrayType$ tableVal;
          #MACRO IfIsPresentValue(tableVal=table[i])
          {
#IF OfLong
            SetCommonImpl.quickInsert(tableVal,newTable,hash,hash&Long.hashCode(tableVal));
#ELSE
            SetCommonImpl.quickInsert(tableVal,newTable,hash,hash&tableVal);
#ENDIF           
            if(--tableSize==1){
              break;
            }
          }
        }
      }
#IF OfLong
      SetCommonImpl.quickInsert(val,newTable,hash,hash&Long.hashCode(val));
#ELSE
      SetCommonImpl.quickInsert(val,newTable,hash,hash&val);
#ENDIF    
    }else{
      table[hash]=val;
    }
  }
#ENDIF 
#IF OfInt,OfLong,OfFloat
  private String massiveToString(int size){
    byte[] buffer;
    ToStringUtil.OmniStringBuilderByte builder;
  #IF OfFloat
    builder=new ToStringUtil.OmniStringBuilderByte(1,new byte[OmniArray.MAX_ARR_SIZE]);
    int[] table;
    for(int i=(table=this.table).length;;){
      int tableVal;
      float f;
      switch(tableVal=table[--i]){
      case $EMPTY_TABLE_VAL$:
      case $DELETED_TABLE_VAL$:
        continue;
      case $POS0_TABLE_VAL$:
        f=0.0f;
        break;
      default:
        f=Float.intBitsToFloat(tableVal);
      }
      builder.uncheckedAppendFloat(f);
      if(--size == 0){
          break;
      }
      builder.uncheckedAppendCommaAndSpace();
    }
  #ELSE
    size=processWordToString(word3,64,128,builder=new ToStringUtil.OmniStringBuilderByte(1,new byte[OmniArray.MAX_ARR_SIZE]),processWordToString(word2,0,64,builder,processWordToString(word1,-64,0,builder,processWordToString(word0,-128,-64,builder,size))));
    final var table=this.table;
    for(int i=0;;++i){
      $exposedType$ tableVal;
      #MACRO IfIsPresentValue(tableVal=table[i])
      {
        builder.uncheckedAppend$ClassPrefix$(tableVal);
        if(--size == 0){
          break;
        }
        builder.uncheckedAppendCommaAndSpace();
      }
    }
  #ENDIF
    builder.uncheckedAppendChar((byte)']');
    (buffer=builder.buffer)[0]=(byte)'[';
    return new String(buffer,0,builder.size,ToStringUtil.IOS8859CharSet);
  }
  private String quickToString(int size){
    byte[] buffer;
  #IF OfFloat
    (buffer=new byte[size * 17])[0]='[';
  #ELSEIF OfInt
    (buffer=new byte[size*13])[0]='[';
  #ELSE
    (buffer=new byte[size*22])[0]='[';
  #ENDIF
  #IF OfFloat
    int[] table;
    int bufferOffset=0;
    for(int i=(table=this.table).length;;){
      int tableVal;
      float f;
      switch(tableVal=table[--i]){
      case $EMPTY_TABLE_VAL$:
      case $DELETED_TABLE_VAL$:
        continue;
      case $POS0_TABLE_VAL$:
        f=0.0f;
        break;
      default:
        f=Float.intBitsToFloat(tableVal);
      }
      bufferOffset=ToStringUtil.getStringFloat(f,buffer,++bufferOffset);
      if(--size == 0){
        break;
      }
      buffer[bufferOffset]=',';
      buffer[++bufferOffset]=' ';
    }
    buffer[bufferOffset]=']';
    return new String(buffer,0,bufferOffset + 1,ToStringUtil.IOS8859CharSet);
  #ELSE
    long magicWord;
    if((int)(magicWord=processWordToString(word0,-128,-64,buffer,size)) != 0){
      if((int)(magicWord=processWordToString(word1,-64,0,buffer,magicWord)) != 0){
        if((int)(magicWord=processWordToString(word2,0,64,buffer,magicWord)) != 0){
          if((size=(int)(magicWord=processWordToString(word3,64,128,buffer,magicWord))) != 0){
            int bufferOffset=(int)(magicWord >>> 32);
            final var table=this.table;
            for(int i=0;;++i){
              $exposedType$ tableVal;
              #MACRO IfIsPresentValue(tableVal=table[i])
              {
                bufferOffset=ToStringUtil.getString$ClassPrefix$(tableVal,buffer,++bufferOffset);
                if(--size == 0){
                  break;
                }
                buffer[bufferOffset]=',';
                buffer[++bufferOffset]=' ';
              }
            }
            buffer[bufferOffset]=']';
            return new String(buffer,0,bufferOffset + 1,ToStringUtil.IOS8859CharSet);
          }
        }
      }
    }
    buffer[size=(int)(magicWord >>> 32)]=']';
    return new String(buffer,0,size + 1,ToStringUtil.IOS8859CharSet);
  #ENDIF
  }
#ENDIF
#IFNOT OfFloat,OfDouble,OfRef

  @Override void clearTable(){
    $ArrayType$[] table;
    for(int i=(table=this.table).length;--i >= 0;){
        table[i]=0;
    }
  }
  #IF OfChar
  private static long processWordToString(long word,int valOffset,int valBound,char[] buffer,long magicWord){
      int bufferOffset=(int)(magicWord >>> 32);
      int numLeft=(int)magicWord;
      do{
          if((word & 1L << valOffset) != 0L){
              buffer[++bufferOffset]=(char)valOffset;
              if(--numLeft == 0){
                  break;
              }
              buffer[++bufferOffset]=',';
              buffer[++bufferOffset]=' ';
          }
      }while(++valOffset != valBound);
      return numLeft | (long)bufferOffset << 32;
  }
  #ELSEIF OfShort,OfInt,OfLong
  private static long processWordToString(long word,int valOffset,int valBound,byte[] buffer,long magicWord){
      int bufferOffset=(int)(magicWord >>> 32);
      int numLeft=(int)magicWord;
      do{
          if((word & 1L << valOffset) != 0L){
              bufferOffset=ToStringUtil.getStringShort(valOffset,buffer,++bufferOffset);
              if(--numLeft == 0){
                  break;
              }
              buffer[bufferOffset]=',';
              buffer[++bufferOffset]=' ';
          }
      }while(++valOffset != valBound);
      return numLeft | (long)bufferOffset << 32;
  }
    #IF OfInt,OfLong
  private static int processWordToString(long word,int valOffset,int valBound,ToStringUtil.OmniStringBuilderByte builder,int numLeft){
      do{
          if((word & 1L << valOffset) != 0L){
              builder.uncheckedAppendShort(valOffset);
              --numLeft;
              builder.uncheckedAppendCommaAndSpace();
          }
      }while(++valOffset != valBound);
      return numLeft;
  }
    #ENDIF
  #ENDIF

  private boolean uncheckedContainsByte(int val){
  #IF OfChar
    switch(val>>6){
      case 0:
        #MACRO WordContains(0,1L<<val)
      case 1:
        #MACRO WordContains(1,1L<<val)
      default:
        return false;
    }
  #ELSEIF OfShort,OfInt,OfLong
    long mask=1L<<val;
    switch(val>>6){
      case -2:
        #MACRO WordContains(0,mask)
      case -1:
        #MACRO WordContains(1,mask)
      case 0:
        #MACRO WordContains(2,mask)
      default:
        #MACRO WordContains(3,mask)
    }
  #ELSE
ERROR unknown type $ClassPrefix$
  #ENDIF
  }
  private boolean uncheckedContainsChar(int val){
  #IF OfChar
    switch(val>>6){
      case 0:
        #MACRO WordContains(0,1L<<val)
      case 1:
        #MACRO WordContains(1,1L<<val)
      case 2:
        #MACRO WordContains(2,1L<<val)
      case 3:
        #MACRO WordContains(3,1L<<val)
      default:
        return tableContains(val);
    }
  #ELSEIF OfShort
    switch(val>>6){
      case 0:
        #MACRO WordContains(2,1L<<val)
      case 1:
        #MACRO WordContains(3,1L<<val)
      default:
        return val<=Short.MAX_VALUE && tableContains(val);
    }
  #ELSEIF OfInt,OfLong
    switch(val>>6){
      case 0:
        #MACRO WordContains(2,1L<<val)
      case 1:
        #MACRO WordContains(3,1L<<val)
      default:
        return tableContains(val);
    }
  #ELSE
ERROR unknown type $ClassPrefix$
  #ENDIF
  }
  #IF OfShort,OfInt,OfLong
  private boolean uncheckedContainsInt(int val){
    switch(val>>6){
      case -2:
        #MACRO WordContains(0,1L<<val)
      case -1:
        #MACRO WordContains(1,1L<<val)
      case 0:
        #MACRO WordContains(2,1L<<val)
      case 1:
        #MACRO WordContains(3,1L<<val)
      default:
        return tableContains(val);
    }
  }
  #ENDIF
  private static $<E>$ int processWordForEach(long word,int valOffset,int valBound,$TypeNameModifier$Consumer$<? super E>$ action,int numLeft){
    do{
      if((word & 1L << valOffset) != 0L){
        action.accept(($exposedType$)valOffset);
        if(--numLeft == 0){
          break;
        }
      }
    }while(++valOffset != valBound);
    return numLeft;
  }
#MACRODEF AddToWord(WORDNUM,MASK)
if((word=this.wordWORDNUM) == (this.wordWORDNUM=word | (MASK))){
  break returnFalse;
}
break;
#ENDDEF
#MACRODEF RemoveFromWord(WORDNUM,MASK)
if((word=this.wordWORDNUM)==(this.wordWORDNUM=(word&(MASK)))){
  break returnFalse;
}
break returnTrue;
#ENDDEF
#MACRODEF WordContains(WORDNUM,MASK)
return (this.wordWORDNUM & (MASK))!=0;
#ENDDEF
  
#ENDIF
  private static class Itr$<E>$
#IF OfRef
  implements OmniIterator.Of$ClassPrefix$$<E>${
#ELSE
  extends Abstract$ClassPrefix$Itr{
#ENDIF
      private final $ClassPrefix$OpenAddressHashSet$<E>$ root;
      private int offset;
      Itr(Itr$<E>$ itr){
        this.root=itr.root;
        this.offset=itr.offset;
      }
      Itr($ClassPrefix$OpenAddressHashSet$<E>$ root){
          this.root=root;
          if(root.size != 0){
#IF OfFloat,OfDouble,OfRef
              final $queryParameterType$[] table;
              for(int offset=(table=root.table).length;;){
  #IF OfFloat
                  switch(table[--offset]){
                  default:
                      this.offset=offset;
                      return;
                  case $EMPTY_TABLE_VAL$:
                  case $DELETED_TABLE_VAL$:
                  }
  #ELSE
                  $queryParameterType$ tableVal;
                  if((tableVal=table[--offset]) != $EMPTY_TABLE_VAL$ && tableVal != $DELETED_TABLE_VAL$){
                      this.offset=offset;
                      return;
                  }
  #ENDIF
              }
#ELSE
              int i;
              if((i=Long.numberOfTrailingZeros(root.word0)) != 64){
                  offset=i;
              }else if((i=Long.numberOfTrailingZeros(root.word1)) != 64){
                  offset=i + 64;
              }else if((i=Long.numberOfTrailingZeros(root.word2)) != 64){
                  offset=i + 128;
              }else if((i=Long.numberOfTrailingZeros(root.word3)) != 64){
                  offset=i + 192;
              }else{
                  final $ArrayType$[] table=root.table;
                  for(i=0;;++i){
                      #MACRO IfIsPresentValue(table[i])
                      {
                          offset=256 + i;
                          return;
                      }
                  }
              }
#ENDIF
          }else{
              this.offset=-1;
          }
      }
      @Override
      public Object clone(){
        return new Itr$<E>$(this);
      }
      @Override
      public boolean hasNext(){
          return offset != -1;
      }
      #MACRO ForEachRemaining($TypeNameModifier$Consumer$<? super E>$,action)
#IFNOT OfRef
      #MACRO ForEachRemaining(Consumer<? super $BoxedType$>,action::accept)
#ENDIF
#MACRODEF ForEachRemaining(CONSUMER,ACTION)
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
@Override public void forEachRemaining(CONSUMER action){
  int offset;
#IF OfRef
  if((offset=this.offset)!=-1){
    Object[] table;
    Object tableVal;
    action.accept((E)((tableVal=(table=root.table)[offset])==NULL?null:tableVal));
    while(--offset!=-1){
      if((tableVal=table[offset]) != $EMPTY_TABLE_VAL$ && tableVal != $DELETED_TABLE_VAL$){
        action.accept((E)(tableVal==NULL?null:tableVal));
      }
    }
    this.offset=-1;
  }
#ELSEIF OfFloat,OfDouble
  if((offset=this.offset)!=-1){
    uncheckedForEachRemaining(offset,ACTION);
  }
#ELSE
  if((offset=this.offset)<256){
    forEachRemainingFromWords(offset,ACTION);
  }else{
    forEachRemainingFromTable(offset-256,ACTION);
  }
#ENDIF
}
#ENDDEF
      #IF OfRef
      @SuppressWarnings("unchecked")
      #ENDIF
      @Override
      public $exposedType$ next$TypeNameModifier$(){
          int offset;
#IF OfFloat,OfDouble,OfRef
          $queryParameterType$[] table;
          var ret=(table=root.table)[offset=this.offset];
          setOffset:for(;;){
            if(--offset == -1){
              break setOffset;
            }
  #IF OfFloat
            switch(table[offset]){
              default:
                break setOffset;
              case $DELETED_TABLE_VAL$:
              case $EMPTY_TABLE_VAL$:
            }
  #ELSE
            $queryParameterType$ tableVal;
            if((tableVal=table[offset]) != $EMPTY_TABLE_VAL$ && tableVal != $DELETED_TABLE_VAL$){
                break;
            }
  #ENDIF
          }
          this.offset=offset;
          #IF OfRef
          if(ret != NULL){
            return (E)ret;
          }
          return null;
          #ELSE
          if(ret!=$POS0_TABLE_VAL$){
            return $ClassPrefix$.$queryParameterType$BitsTo$ClassPrefix$(ret);
          }
          return 0;
          #ENDIF
#ELSE
          if((offset=this.offset) < 256){
              return getNextFromWords(offset);
          }else{
              return getNextFromTable(offset - 256);
          }
#ENDIF
      }
      @Override
      public void remove(){
          $ClassPrefix$OpenAddressHashSet$<E>$ root;
          --(root=this.root).size;
#IF OfFloat,OfDouble,OfRef
          var table=root.table;
          for(int offset=this.offset;;){
  #IF OfFloat
            switch(table[++offset]){
              default:
                table[offset]=$DELETED_TABLE_VAL$;
                return;
              case $EMPTY_TABLE_VAL$:
              case $DELETED_TABLE_VAL$:
            }
  #ELSE
            $queryParameterType$ tableVal;
            if((tableVal=table[++offset]) != $EMPTY_TABLE_VAL$ && tableVal != $DELETED_TABLE_VAL$){
                table[offset]=$DELETED_TABLE_VAL$;
                return;
            }
  #ENDIF
          }
#ELSE
          long word;
          int offset;
          switch((offset=this.offset) - 1 >> 6){
          default:
              $ArrayType$[] table;
              if((table=root.table) != null){
                  int tableOffset;
                  if(offset == -1){
                      tableOffset=table.length;
                  }else{
                      tableOffset=offset-256;
                  }
                  for(;;){
                      #MACRO IfIsPresentValue(table[--tableOffset])
                      {
                          table[tableOffset]=$DELETED_TABLE_VAL$;
                          --root.tableSize;
                          return;
                      }
                      if(tableOffset == 0){
                          break;
                      }
                  }
              }
              offset=0;
          case 3:
              if((offset=Long.numberOfLeadingZeros((word=root.word3)&(-1L>>>-offset)))!=64){
                root.word3=word&~(Long.MIN_VALUE>>>offset);
                return;
              }
              offset=0;
          case 2:
              if((offset=Long.numberOfLeadingZeros((word=root.word2)&(-1L>>>-offset)))!=64){
                root.word2=word&~(Long.MIN_VALUE>>>offset);
                return;
              }
              offset=0;
          case 1:
              if((offset=Long.numberOfLeadingZeros((word=root.word1)&(-1L>>>-offset)))!=64){
                root.word1=word&~(Long.MIN_VALUE>>>offset);
                return;
              }
              offset=0;
          case 0:
              root.word0=(word=root.word0)&~(Long.MIN_VALUE>>>Long.numberOfLeadingZeros(word&(-1L>>>-offset)));
          }
#ENDIF
      }
#IF OfFloat,OfDouble
      private void uncheckedForEachRemaining(int offset,$TypeNameModifier$Consumer$<? super E>$ action){
        $queryParameterType$[] table;
        $queryParameterType$ tableVal;
        action.accept((tableVal=(table=root.table)[offset])==$POS0_TABLE_VAL$?(($exposedType$)0):$convertBitsToVal$(tableVal));
        while(--offset!=-1){    
  #IF OfFloat
          switch(tableVal=table[offset]){
            case $POS0_TABLE_VAL$:
                action.accept(0.0f);
                break;
            default:
                action.accept($convertBitsToVal$(tableVal));
            case $EMPTY_TABLE_VAL$:
            case $DELETED_TABLE_VAL$:
          }
  #ELSE
          if((tableVal=table[offset]) != $EMPTY_TABLE_VAL$ && tableVal != $DELETED_TABLE_VAL$){
              action.accept(tableVal == $POS0_TABLE_VAL$?0.0d:$convertBitsToVal$(tableVal));
          }
  #ENDIF
        }
        this.offset=-1;
      }
#ELSEIFNOT OfRef
      private static $<E>$ void forEachRemainingWordHelper(long word,int offset,$TypeNameModifier$Consumer$<? super E>$ action){
          for(long marker=1L << offset;;++offset){
              if((word & marker) != 0){
  #IF OfChar
                  action.accept(($exposedType$)offset);
  #ELSE
                  action.accept(($exposedType$)(offset-128));
  #ENDIF
              }
              if((marker<<=1) == 0){
                  break;
              }
          }
      }
      private void forEachRemainingFromTable(int offset,$TypeNameModifier$Consumer action){
          $ArrayType$[] table;
          final int tableLength=(table=root.table).length;
          action.accept(table[offset]);
          while(++offset!=tableLength){
              $ArrayType$ tableVal;
              #MACRO IfIsPresentValue(tableVal=table[offset])
              {
                  action.accept(tableVal);
              }
          }
          this.offset=-1;
      }
      private void forEachRemainingFromWords(int offset,$TypeNameModifier$Consumer action){
          final var root=this.root;
          switch(offset >> 6){
          case 0:
              forEachRemainingWordHelper(root.word0,offset,action);
              offset=64;
          case 1:
              forEachRemainingWordHelper(root.word1,offset,action);
              offset=128;
          case 2:
              forEachRemainingWordHelper(root.word2,offset,action);
              offset=192;
          case 3:
              forEachRemainingWordHelper(root.word3,offset,action);
              int tableSize;
              if((tableSize=root.tableSize) != 0){
                  final var table=root.table;
                  for(offset=0;;++offset){
                      $exposedType$ tableVal;
                      #MACRO IfIsPresentValue(tableVal=table[offset])
                      {
                          action.accept(tableVal);
                          if(--tableSize == 0){
                              break;
                          }
                      }
                  }
              }
              this.offset=-1;
          default:
              return;
          }
      }
      private $exposedType$ getNextFromTable(int offset){
          $ArrayType$[] table;
          final var ret=($exposedType$)(table=root.table)[offset];
          for(final int tableLength=table.length;;){
              if(++offset==tableLength){
                this.offset=-1;
                break;
              }
              #MACRO IfIsPresentValue(table[offset])
              {
                this.offset=offset + 256;
                break;
              }
          }
          return ret;
      }
      private $exposedType$ getNextFromWords(int offset){
  #IF OfChar
          final var ret=($exposedType$)offset;
  #ELSE
          final var ret=($exposedType$)(offset-128);
  #ENDIF
            returnVal:for(;;){
                final var root=this.root;
                switch(++offset >> 6){
                case 0:
                    int tail0s;
                    if((tail0s=Long.numberOfTrailingZeros(root.word0 >>> offset)) != 64){
                        this.offset=offset+tail0s;
                        break returnVal;
                    }
                    offset=64;
                case 1:
                    if((tail0s=Long.numberOfTrailingZeros(root.word1 >>> offset)) != 64){
                        this.offset=offset + tail0s;
                        break returnVal;
                    }
                    offset=128;
                case 2:
                    if((tail0s=Long.numberOfTrailingZeros(root.word2 >>> offset)) != 64){
                        this.offset=offset + tail0s;
                        break returnVal;
                    }
                    offset=192;
                case 3:
                    if((tail0s=Long.numberOfTrailingZeros(root.word3 >>> offset)) != 64){
                        this.offset=offset + tail0s;
                        break returnVal;
                    }
                    offset=0;
                    break;
                default:
                    offset-=256;
                }
                if(root.tableSize != 0){
                    final var table=root.table;
                    for(;;++offset){
                        #MACRO IfIsPresentValue(table[offset])
                        {
                            this.offset=offset + 256;
                            break returnVal;
                        }
                    }
                }else{
                    this.offset=-1;
                }
                break returnVal;
            }
            return ret;
      }
#ENDIF
  }
  public static class Checked$<E>$ extends $ClassPrefix$OpenAddressHashSet$<E>${
    transient int modCount;
    public Checked(Collection<? extends $BoxedExposed$> that){
      super(that);
    }
    public Checked(OmniCollection.OfRef<? extends $BoxedExposed$> that){
      super(that);
    }
#IFNOT OfRef
    public Checked(OmniCollection.OfBoolean that){
      super(that);
    }
    public Checked(OmniCollection.$ClassPrefix$Output<?> that){
      super(that);
    }
  #IFNOT OfChar
    public Checked(OmniCollection.OfByte that){
      super(that);
    }
    public Checked(OmniCollection.OfShort that){
      super(that);
    }  
    #IFNOT OfShort
    public Checked(OmniCollection.OfInt that){
      super(that);
    }
      #IFNOT OfInt
    public Checked(OmniCollection.OfLong that){
      super(that);
    }
        #IFNOT OfLong
    public Checked(OmniCollection.OfFloat that){
      super(that);
    }
          #IFNOT OfFloat
    public Checked(OmniCollection.OfDouble that){
      super(that);
    }
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #IFNOT OfShort
    public Checked(OmniCollection.OfChar that){
      super(that);
    }
  #ENDIF
#ENDIF
    public Checked(float loadFactor,Collection<? extends $BoxedExposed$> that){
      super(validateLoadFactor(loadFactor),that);
    }
    public Checked(float loadFactor,OmniCollection.OfRef<? extends $BoxedExposed$> that){
      super(validateLoadFactor(loadFactor),that);
    }
#IFNOT OfRef
    public Checked(float loadFactor,OmniCollection.OfBoolean that){
      super(validateLoadFactor(loadFactor),that);
    }
    public Checked(float loadFactor,OmniCollection.$ClassPrefix$Output<?> that){
      super(validateLoadFactor(loadFactor),that);
    }
  #IFNOT OfChar
    public Checked(float loadFactor,OmniCollection.OfByte that){
      super(validateLoadFactor(loadFactor),that);
    }
    public Checked(float loadFactor,OmniCollection.OfShort that){
      super(validateLoadFactor(loadFactor),that);
    }  
    #IFNOT OfShort
    public Checked(float loadFactor,OmniCollection.OfInt that){
      super(validateLoadFactor(loadFactor),that);
    }
      #IFNOT OfInt
    public Checked(float loadFactor,OmniCollection.OfLong that){
      super(validateLoadFactor(loadFactor),that);
    }
        #IFNOT OfLong
    public Checked(float loadFactor,OmniCollection.OfFloat that){
      super(validateLoadFactor(loadFactor),that);
    }
          #IFNOT OfFloat
    public Checked(float loadFactor,OmniCollection.OfDouble that){
      super(validateLoadFactor(loadFactor),that);
    }
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #IFNOT OfShort
    public Checked(float loadFactor,OmniCollection.OfChar that){
      super(validateLoadFactor(loadFactor),that);
    }
  #ENDIF
#ENDIF
    public Checked(){
      super();
    }
    public Checked($ClassPrefix$OpenAddressHashSet$<E>$ that){
      super(that);
    }
    public Checked(int initialCapacity){
      super(validateInitialCapacity(initialCapacity));
    }
    public Checked(float loadFactor){
        super(validateLoadFactor(loadFactor));
    }
    public Checked(int initialCapacity,float loadFactor){
        super(validateInitialCapacity(initialCapacity),validateLoadFactor(loadFactor));
    }
    @Override public boolean equals(Object val){
      if(val==this){
        return true;
      }
      if(val instanceof Set){
        //TODO optimize
        int modCount=this.modCount;
        try{
          Set<?> that;
          if(size==(that=(Set<?>)val).size()){
            for(final var thatVal:that){
#IF OfRef
              if(!this.contains(thatVal)){
                return false;
              }
#ELSE
              if(!(thatVal instanceof $BoxedType$) || !this.contains(($exposedType$)thatVal)){
                return false;
              }
#ENDIF
            }
            return true;
          }
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
        
      }
      return false;
    }
    
  /*  
#IF OfRef
    @Override public boolean equals(Object val){
      if(val==this){
        return true;
      }
      if(val instanceof Set){
        final int size;
        if((size=this.size)==0){
          return ((Set<?>)val).isEmpty();
        }
        if(val instanceof AbstractOpenAddressHashSet){
          final AbstractOpenAddressHashSet<?> aoahs;
          if(size==(aoahs=(AbstractOpenAddressHashSet<?>)val).size){
            if(aoahs instanceof RefOpenAddressHashSet){
              final int thisModCount=this.modCount;
              try{
                if(aoahs instanceof RefOpenAddressHashSet.Checked){
                  final RefOpenAddressHashSet.Checked<?> that;
                  final int thatModCount=(that=(RefOpenAddressHashSet.Checked<?>)aoahs).modCount;
                  try{
                    return super.isEqualTo(size,that);
                  }finally{
                    CheckedCollection.checkModCount(thatModCount,that.modCount);
                  }
                }else{
                  return super.isEqualTo(size,(RefOpenAddressHashSet<?>)aoahs);
                }
              }finally{
                CheckedCollection.checkModCount(thisModCount,this.modCount);
              }
            }else if(aoahs instanceof AbstractIntegralTypeOpenAddressHashSet){
              if(aoahs instanceof IntOpenAddressHashSet){
                return SetCommonImpl.isEqualTo(size,this,(IntOpenAddressHashSet)aoahs);
              }else if(aoahs instanceof LongOpenAddressHashSet){
                return SetCommonImpl.isEqualTo(size,this,(LongOpenAddressHashSet)aoahs);
              }else if(aoahs instanceof CharOpenAddressHashSet){
                return SetCommonImpl.isEqualTo(size,this,(CharOpenAddressHashSet)aoahs);
              }else{
                //must be ShortOpenAddressHashSet
                return SetCommonImpl.isEqualTo(size,this,(ShortOpenAddressHashSet)aoahs);
              }
            }else if(aoahs instanceof FloatOpenAddressHashSet){
               return SetCommonImpl.isEqualTo(size,this,(FloatOpenAddressHashSet)aoahs);
            }else{
               return SetCommonImpl.isEqualTo(size,this,(DoubleOpenAddressHashSet)aoahs);
            }
          }
        }else if(val instanceof ByteSetImpl){
          if(val instanceof ByteSetImpl.Checked){
             return SetCommonImpl.isEqualTo(size,this,(ByteSetImpl.Checked)val);
          }
          return SetCommonImpl.isEqualTo(size,this,(ByteSetImpl)val);
        }else if(val instanceof BooleanSetImpl){
          return SetCommonImpl.isEqualTo(size,this.table,((BooleanSetImpl)val).state);
        }else{
          return SetCommonImpl.isEqualTo(size,(Set<?>)val,this);
        }
      }
      return false;
    }
#ENDIF
*/

    @Override void updateMaxTableSize(float loadFactor){
      super.updateMaxTableSize(validateLoadFactor(loadFactor));
    }
#IF OfRef
    @Override
    public boolean add($exposedType$ val){
        int hash;
        if(val != null){
            int modCount=this.modCount;
            try{
               
                return addToTable(modCount,val,(hash=val.hashCode()) ^ hash >>> 16);
            }catch(ConcurrentModificationException e){
                throw e;
            }catch(RuntimeException e){
                throw CheckedCollection.checkModCount(modCount,this.modCount,e);
            }
        }else if(super.addToTable(NULL,NULLHASH)){
            ++this.modCount;
            return true;
        }
        return false;
    }
    private boolean addToTable(int modCount,Object val,int hash){
      Object[] table;
      if((table=this.table) != null){
          int tableLength;
          int insertHere=-1;
          for(final int initialHash=hash&=tableLength=table.length - 1;;){
              Object tableVal;
              if((tableVal=table[hash]) == $EMPTY_TABLE_VAL$){
                  if(insertHere == -1){
                      insertHere=hash;
                  }
                  break;
              }else if(tableVal == $DELETED_TABLE_VAL$){
                  insertHere=hash;
              }else if(val.equals(tableVal)){
                  CheckedCollection.checkModCount(modCount,this.modCount);
                  // already contained
                  return false;
              }
              if((hash=hash + 1 & tableLength) == initialHash){
                  break;
              }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount + 1;
          super.insert(table,insertHere,val);
          return true;
      }
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount + 1;
      int maxTableSize;
      this.table=table=new Object[maxTableSize=this.maxTableSize];
      this.maxTableSize=(int)(maxTableSize * loadFactor);
      this.size=1;
      table[hash & maxTableSize - 1]=val;
      return true;
    }
#ELSEIFNOT OfFloat,OfDouble
    @Override public boolean add(boolean val){
      if(super.add(val)){
        ++modCount;
        return true;
      }
      return false;
    }
  #IFNOT OfChar
    @Override public boolean add(byte val){
      if(super.add(val)){
        ++modCount;
        return true;
      }
      return false;
    }
  #ENDIF
  #IF OfLong
    @Override public boolean add(long val){
      if(super.add(val)){
        ++modCount;
        return true;
      }
      return false;
    }
  #ENDIF
  #IF OfInt,OfLong
    @Override public boolean add(int val){
      if(super.add(val)){
        ++modCount;
        return true;
      }
      return false;
    }
  #ENDIF
  #IF OfShort
    @Override public boolean add(short val){
      if(super.add(val)){
        ++modCount;
        return true;
      }
      return false;
    }
  #ENDIF
  #IFNOT OfShort
    @Override public boolean add(char val){
      if(super.add(val)){
        ++modCount;
        return true;
      }
      return false;
    }
  #ENDIF
#ENDIF
    @Override public void clear(){
      if(this.size != 0){
          ++this.modCount;
          this.size=0;
#IF OfFloat,OfDouble,OfRef
          $queryParameterType$[] table;
          for(int i=(table=this.table).length;--i >= 0;){
              table[i]=$EMPTY_TABLE_VAL$;
          }
#ELSE
          if(this.tableSize != 0){
              super.clearTable();
              this.tableSize=0;
          }
          word0=0;
          word1=0;
          word2=0;
          word3=0;
#ENDIF
          
      }
    }
    @Override public Object clone(){
      return new Checked$<E>$(this);
    }
#IF OfRef
    @Override
    public boolean contains(Object val){
        if(size != 0){
            if(val != null){
                int modCount=this.modCount;
                try{
                    return super.tableContains(val,SetCommonImpl.tableHash(val));
                }finally{
                    CheckedCollection.checkModCount(modCount,this.modCount);
                }
            }
            return super.tableContains(NULL,NULLHASH);
        }
        return false;
    }
#ENDIF
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      return new Itr$<E>$(this);
    }
#IF OfRef
    @Override
    public boolean remove(Object val){
        int size;
        if((size=this.size) != 0){
            returnFalse:for(;;){
                returnTrue:for(;;){
                    if(val != null){
                        int modCount=this.modCount;
                        try{
                            if(removeFromTable(modCount,val,SetCommonImpl.tableHash(val))){
                                break returnTrue;
                            }
                        }catch(ConcurrentModificationException e){
                            throw e;
                        }catch(RuntimeException e){
                            throw CheckedCollection.checkModCount(modCount,this.modCount,e);
                        }
                    }else if(super.removeFromTable(NULL,NULLHASH)){
                        ++this.modCount;
                        break returnTrue;
                    }
                    break returnFalse;
                }
                this.size=size - 1;
                return true;
            }
        }
        return false;
    }
    private boolean removeFromTable(int modCount,Object val,int hash){
        Object[] table;
        int tableLength,initialHash;
        Object tableVal;
        if((tableVal=(table=this.table)[initialHash=hash &= (tableLength=table.length - 1)]) != null){
            do{
                if(val.equals(tableVal)){
                    CheckedCollection.checkModCount(modCount,this.modCount);
                    this.modCount=modCount + 1;
                    table[hash]=$DELETED_TABLE_VAL$;
                    return true;
                }
            }while((hash=hash + 1 & tableLength) != initialHash && (tableVal=table[hash]) != null);
        }
        CheckedCollection.checkModCount(modCount,this.modCount);
        return false;
    }
#ELSEIFNOT OfFloat,OfDouble
    @Override public boolean remove(Object val){
      if(super.remove(val)){
        ++modCount;
        return true;
      }
      return false;
    }
    @Override public boolean removeVal(boolean val){
      if(super.removeVal(val)){
        ++modCount;
        return true;
      }
      return false;
    }
    @Override public boolean removeVal(byte val){
      if(super.removeVal(val)){
        ++modCount;
        return true;
      }
      return false;
    }
    @Override public boolean removeVal(char val){
      if(super.removeVal(val)){
        ++modCount;
        return true;
      }
      return false;
    }
  #IF OfShort,OfChar
    @Override public boolean removeVal(short val){
      if(super.removeVal(val)){
        ++modCount;
        return true;
      }
      return false;
    }
  #ENDIF
    @Override public boolean removeVal(int val){
      if(super.removeVal(val)){
        ++modCount;
        return true;
      }
      return false;
    }
    @Override public boolean removeVal(long val){
      if(super.removeVal(val)){
        ++modCount;
        return true;
      }
      return false;
    }
    @Override public boolean removeVal(float val){
      if(super.removeVal(val)){
        ++modCount;
        return true;
      }
      return false;
    }
    @Override public boolean removeVal(double val){
      if(super.removeVal(val)){
        ++modCount;
        return true;
      }
      return false;
    }
#ENDIF
    @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
      return super.toArray((arrSize)->{
        final int modCount=this.modCount;
        try{
          return arrConstructor.apply(arrSize);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      });
    }
    @Override public void writeExternal(ObjectOutput out) throws IOException{
      final int modCount=this.modCount;
      try{
        super.writeExternal(out);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    }
#IF OfFloat,OfDouble
  #IF OfFloat
    @Override boolean addToTable(int val,int hash){
  #ELSE
    @Override boolean addToTable(long val,int hash){
  #ENDIF
        if(super.addToTable(val,hash)){
            ++this.modCount;
            return true;
        }
        return false;
    }
#ENDIF
#IF OfRef,OfDouble,OfFloat
    @Override
    boolean removeFromTable($queryParameterType$ val,int hash){
        if(super.removeFromTable(val,hash)){
            ++this.modCount;
            return true;
        }
        return false;
    }
#ENDIF
    @Override void forEachHelper(int size,$TypeNameModifier$Consumer$<? super E>$ action){
        int modCount=this.modCount;
        try{
            super.forEachHelper(size,action);
        }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
        }
    }
#IF OfRef
    @Override
    int uncheckedHashCode(int size){
        int modCount=this.modCount;
        try{
            return super.uncheckedHashCode(size);
        }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
        }
    }
#ENDIF
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    @Override boolean uncheckedRemoveIf(int size,$TypeNameModifier$Predicate$<? super E>$ filter){
      
      int numRemovedFromTable=0;
      final int modCount=this.modCount;
#IF OfFloat,OfDouble,OfRef
      int[] tableIndicesRemoved;
      $queryParameterType$[] table;
      try{
          for(int numLeft=size,i=(table=this.table).length;;){
  #IFNOT OfRef
              $ArrayType$ v;
  #ENDIF
              $queryParameterType$ tableVal;
  #IF OfFloat
              switch(tableVal=table[--i]){
              case $EMPTY_TABLE_VAL$:
              case $DELETED_TABLE_VAL$:
                  continue;
              case $POS0_TABLE_VAL$:
                  v=0;
                  break;
              default:
                  v=Float.intBitsToFloat(tableVal);
              }
              if(filter.test(v)){
  #ELSE
              if((tableVal=table[--i])==$EMPTY_TABLE_VAL$ || tableVal==$DELETED_TABLE_VAL$) {
                  continue;
    #IF OfRef
              }else if(tableVal==NULL){
                tableVal=null;
              }
              if(filter.test((E)tableVal)){
    #ELSE
              }else if(tableVal==$POS0_TABLE_VAL$) {
                  v=0;
              }else {
                  v=Double.longBitsToDouble(tableVal);
              }
              if(filter.test(v)){
    #ENDIF
  #ENDIF
              
                  (tableIndicesRemoved=new int[numLeft])[0]=i;
                  outer:for(;;){
                    if(--numLeft==0){
                      break;
                    }
                    for(;;){
  #IF OfFloat
                      switch(tableVal=table[--i]){
                        case $EMPTY_TABLE_VAL$:
                        case $DELETED_TABLE_VAL$:
                          continue;
                        case $POS0_TABLE_VAL$:
                          v=0;
                          break;
                        default:
                          v=Float.intBitsToFloat(tableVal);
                      }
                      if(filter.test(v)){
  #ELSE
                      if((tableVal=table[--i])==$EMPTY_TABLE_VAL$ || tableVal==$DELETED_TABLE_VAL$){
                        continue;
    #IF OfRef
                      }else if(tableVal==NULL){
                        tableVal=null;
                      }
                      if(filter.test((E)tableVal)){
    #ELSE
                      }else if(tableVal==$POS0_TABLE_VAL$){
                        v=0;
                      }else{
                        v=Double.longBitsToDouble(tableVal);
                      }
                      if(filter.test(v)){
    #ENDIF
  #ENDIF
                      
                        tableIndicesRemoved[++numRemovedFromTable]=i;
                      }
                      continue outer;
                    }
                  }
                  break;
              }
              if(--numLeft == 0){
                  return false;
              }
          }
      }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
      }
      this.modCount=modCount + 1;
      this.size=size - numRemovedFromTable-1;
      do{
        table[tableIndicesRemoved[numRemovedFromTable]]=$DELETED_TABLE_VAL$;
      }while(--numRemovedFromTable!=-1);
      return true;
      
#ELSE
      int[] tableIndicesRemoved=null;
      long word0;
      long word1;
      long word2;
      long word3;      
      int tableSize;
      int numRemoved;
      $ArrayType$[] table=null;
      try{
  #IF OfChar
          numRemoved=Long.bitCount((word0=this.word0) ^ (word0=wordRemoveIf(word0,0,filter)))
                  + Long.bitCount((word1=this.word1) ^ (word1=wordRemoveIf(word1,64,filter)))
                  + Long.bitCount((word2=this.word2) ^ (word2=wordRemoveIf(word2,128,filter)))
                  + Long.bitCount((word3=this.word3) ^ (word3=wordRemoveIf(word3,192,filter)));
  #ELSE
          numRemoved=Long.bitCount((word0=this.word0) ^ (word0=wordRemoveIf(word0,-128,filter)))
                  + Long.bitCount((word1=this.word1) ^ (word1=wordRemoveIf(word1,-64,filter)))
                  + Long.bitCount((word2=this.word2) ^ (word2=wordRemoveIf(word2,0,filter)))
                  + Long.bitCount((word3=this.word3) ^ (word3=wordRemoveIf(word3,64,filter)));
  #ENDIF
          if((tableSize=this.tableSize) != 0){
            for(int i=(table=this.table).length,numLeftInTable=tableSize;;){
              $exposedType$ tableVal;
              #MACRO IfIsPresentValue(tableVal=table[--i])
              {
                  if(filter.test(tableVal)){
                      (tableIndicesRemoved=new int[numLeftInTable])[0]=i;
                      ++numRemoved;
                      outer:for(;;){
                        if(--numLeftInTable==0){
                          break;
                        }
                        for(;;){
                           #MACRO IfIsPresentValue(tableVal=table[--i])
                           {
                             if(filter.test(tableVal)){
                               tableIndicesRemoved[++numRemovedFromTable]=i;
                               ++numRemoved;
                             }
                             continue outer;
                           }
                        }
                      }
                      break;
                  }
                  if(--numLeftInTable == 0){
                      break;
                  }
               }
            }
          }
      }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
      }
      if(numRemoved != 0){
          this.modCount=modCount + 1;
          this.size=size - numRemoved;
          this.word0=word0;
          this.word1=word1;
          this.word2=word2;
          this.word3=word3;
          if(tableIndicesRemoved != null){
              this.tableSize=tableSize - numRemovedFromTable-1;
              do{
                  table[tableIndicesRemoved[numRemovedFromTable]]=1;
              }while(--numRemovedFromTable !=-1);
          }
          return true;
      }
      return false;
#ENDIF
      
    }
#IF OfRef
    @Override
    String uncheckedToString(int size){
        int modCount=this.modCount;
        try{
            return super.uncheckedToString(size);
        }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
        }
    }
#ENDIF
    private static class Itr$<E>$
#IF OfRef
    implements OmniIterator.Of$ClassPrefix$$<E>${
#ELSE
    extends Abstract$ClassPrefix$Itr{
#ENDIF
      private final Checked$<E>$ root;
      private int offset;
      private int modCount;
      private int lastRet;
      Itr(Itr$<E>$ itr){
        this.root=itr.root;
        this.modCount=itr.modCount;
        this.offset=itr.offset;
        this.lastRet=itr.lastRet;
      }
      Itr(Checked$<E>$ root){
          this.root=root;
          this.modCount=root.modCount;
          this.lastRet=-1;
          if(root.size != 0){
#IF OfFloat,OfDouble,OfRef
              final $queryParameterType$[] table;
              for(int i=(table=root.table).length;;){
  #IF OfFloat
                  switch(table[--i]){
                  default:
                      this.offset=i;
                      return;
                  case $EMPTY_TABLE_VAL$:
                  case $DELETED_TABLE_VAL$:
                  }
  #ELSE
                  $queryParameterType$ tableVal;
                  if((tableVal=table[--i])!=$EMPTY_TABLE_VAL$ && tableVal!=$DELETED_TABLE_VAL$) {
                      this.offset=i;
                      return;
                  }
  #ENDIF
              }
#ELSE
              int i;
              if((i=Long.numberOfTrailingZeros(root.word0)) != 64){
                  offset=i;
              }else if((i=Long.numberOfTrailingZeros(root.word1)) != 64){
                  offset=i + 64;
              }else if((i=Long.numberOfTrailingZeros(root.word2)) != 64){
                  offset=i + 128;
              }else if((i=Long.numberOfTrailingZeros(root.word3)) != 64){
                  offset=i + 192;
              }else{
                  final var table=root.table;
                  for(i=0;;++i){
                      if(table[i] > 1){
                          offset=256 + i;
                          return;
                      }
                  }
              }
#ENDIF
          }else{
              this.offset=-1;
          }
      }
      @Override public Object clone(){
        return new Itr$<E>$(this);
      }
      #MACRO CheckedForEachRemaining($TypeNameModifier$Consumer$<? super E>$,action)
#IFNOT OfRef
      #MACRO CheckedForEachRemaining(Consumer<? super $BoxedType$>,action::accept)
#ENDIF
#MACRODEF CheckedForEachRemaining(CONSUMER,ACTION)
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
@Override public void forEachRemaining(CONSUMER action){
  final int expectedOffset;
  if((expectedOffset=this.offset)!=-1){
#IF OfRef
    var root=this.root;
    int modCount=this.modCount;
    int lastRet;
    int offset;
    try{
        var table=root.table;
        Object tableVal;
        action.accept((E)((tableVal=table[offset=lastRet=expectedOffset])==NULL?null:tableVal));
        while(--offset!=-1){
          if((tableVal=table[offset]) != $EMPTY_TABLE_VAL$ && tableVal != $DELETED_TABLE_VAL$){
              action.accept((E)(tableVal==NULL?null:tableVal));
              lastRet=offset;
          }
        }
    }finally{
        CheckedCollection.checkModCount(modCount,root.modCount,expectedOffset,this.offset);
    }
    this.offset=-1;
    this.lastRet=lastRet;
#ELSEIF OfFloat,OfDouble
    uncheckedForEachRemaining(expectedOffset,ACTION);
#ELSE
    if(offset<256){
      forEachRemainingFromWords(expectedOffset,ACTION);
    }else{
      forEachRemainingFromTable(expectedOffset,ACTION);
    }
#ENDIF
  }
}
#ENDDEF
      @Override
      public boolean hasNext(){
          return this.offset != -1;
      }
#IF OfRef
      @SuppressWarnings("unchecked")
#ENDIF
      @Override
      public $exposedType$ next$TypeNameModifier$(){
          Checked$<E>$ root;
          CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
          int offset;
          if((offset=this.offset) != -1){
              this.lastRet=offset;
#IF OfFloat,OfDouble,OfRef
              $queryParameterType$ table[];
              var ret=(table=root.table)[offset];
              setOffset:for(;;){
                  if(--offset == -1){
                      break setOffset;
                  }
  #IF OfFloat
                  switch(table[offset]){
                  default:
                      break setOffset;
                  case $DELETED_TABLE_VAL$:
                  case $EMPTY_TABLE_VAL$:
                  }
  #ELSE
                  $queryParameterType$ tableVal;
                  if((tableVal=table[offset])!=$EMPTY_TABLE_VAL$ && tableVal!=$DELETED_TABLE_VAL$) {
                      break;
                  }
  #ENDIF
              }
              this.offset=offset;
  #IF OfRef
              if(ret != NULL){
                  return (E)ret;
              }
              return null;
  #ELSE
              if(ret != $POS0_TABLE_VAL$){
                  return $ClassPrefix$.$queryParameterType$BitsTo$ClassPrefix$(ret);
              }
              return 0;
  #ENDIF
#ELSE
              if(offset < 256){
                  return getNextFromWords(root,offset);
              }else{
                  return getNextFromTable(root,offset - 256);
              }
#ENDIF
          }
          throw new NoSuchElementException();
      }
      @Override
      public void remove(){
          int lastRet;
          if((lastRet=this.lastRet) != -1){
              int modCount;
              final Checked$<E>$ root;
              CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
              root.modCount=++modCount;
              this.modCount=modCount;
              --root.size;
#IF OfFloat,OfDouble,OfRef
              root.table[lastRet]=$DELETED_TABLE_VAL$;
#ELSE
              switch(lastRet >> 6){
              case 0:
                  root.word0&=~(1L << lastRet);
                  break;
              case 1:
                  root.word1&=~(1L << lastRet);
                  break;
              case 2:
                  root.word2&=~(1L << lastRet);
                  break;
              case 3:
                  root.word3&=~(1L << lastRet);
                  break;
              default:
                  root.table[lastRet - 256]=$DELETED_TABLE_VAL$;
                  --root.tableSize;
              }
#ENDIF
              this.lastRet=-1;
              return;
          }
          throw new IllegalStateException();
      }
#IF OfFloat,OfDouble
      private void uncheckedForEachRemaining(final int expectedOffset,$TypeNameModifier$Consumer$<? super E>$ action){
          var root=this.root;
          int modCount=this.modCount;
          int lastRet;
          int offset;
          try{
              $queryParameterType$[] table;
              $queryParameterType$ tableVal;
              action.accept((tableVal=(table=root.table)[offset=lastRet=expectedOffset])==$POS0_TABLE_VAL$?(($exposedType$)0):$convertBitsToVal$(tableVal));
              while(--offset!=-1){
  #IF OfFloat
                  switch(tableVal=table[offset]){
                  case $POS0_TABLE_VAL$:
                      action.accept(0.0f);
                      lastRet=offset;
                      break;
                  default:
                      action.accept($convertBitsToVal$(tableVal));
                      lastRet=offset;
                  case $EMPTY_TABLE_VAL$:
                  case $DELETED_TABLE_VAL$:
                  }
  #ELSE
                  if((tableVal=table[offset])!=$EMPTY_TABLE_VAL$ && tableVal!=$DELETED_TABLE_VAL$) {
                      action.accept(tableVal == $POS0_TABLE_VAL$?0.0d:$convertBitsToVal$(tableVal));
                      lastRet=offset;
                  }
  #ENDIF
              }
          }finally{
              CheckedCollection.checkModCount(modCount,root.modCount,expectedOffset,this.offset);
          }
          this.offset=-1;
          this.lastRet=lastRet;
      }
#ELSEIFNOT OfRef
      private static int forEachRemainingWordHelper(long word,int offset,int lastRet,$TypeNameModifier$Consumer action){
          for(long marker=1L << offset;;++offset){
              if((word & marker) != 0){
  #IF OfChar
                  action.accept(($exposedType$)offset);
  #ELSE
                  action.accept(($exposedType$)(offset-128));
  #ENDIF
                  lastRet=offset;
              }
              if((marker<<=1) == 0){
                  return lastRet;
              }
          }
      }
      private void forEachRemainingFromTable(final int expectedOffset,$TypeNameModifier$Consumer action){
          final int modCount=this.modCount;
          final var root=this.root;
          int lastRet;
          int offset;
          try{
              $ArrayType$[] table;
              final int tableLength=(table=root.table).length;
              action.accept(table[lastRet=offset=expectedOffset-256]);
              while(++offset!=tableLength){
                  $exposedType$ tableVal;
                  #MACRO IfIsPresentValue(tableVal=table[offset])
                  {
                      action.accept(tableVal);
                      lastRet=offset;
                  }
              }
          }finally{
              CheckedCollection.checkModCount(modCount,root.modCount,expectedOffset,this.offset);
          }
          this.offset=-1;
          this.lastRet=lastRet+256;
      }
      private void forEachRemainingFromWords(final int expectedOffset,$TypeNameModifier$Consumer action){
          final var root=this.root;
          final int modCount=this.modCount;
          int lastRet=this.lastRet;
          int offset=expectedOffset;
          try{
              switch(offset >> 6){
              case 0:
                  lastRet=forEachRemainingWordHelper(root.word0,offset,lastRet,action);
                  offset=64;
              case 1:
                  lastRet=forEachRemainingWordHelper(root.word1,offset,lastRet,action);
                  offset=128;
              case 2:
                  lastRet=forEachRemainingWordHelper(root.word2,offset,lastRet,action);
                  offset=192;
              default:
                  lastRet=forEachRemainingWordHelper(root.word3,offset,lastRet,action);
                  int tableSize;
                  if((tableSize=root.tableSize) != 0){
                      final var table=root.table;
                      for(offset=0;;++offset){
                          $exposedType$ tableVal;
                          #MACRO IfIsPresentValue(tableVal=table[offset])
                          {
                              action.accept(tableVal);
                              lastRet=offset;
                              if(--tableSize == 0){
                                  break;
                              }
                          }
                      }
                      lastRet+=256;
                  }
              }
          }finally{
              CheckedCollection.checkModCount(modCount,root.modCount,expectedOffset,this.offset);
          }
          this.lastRet=lastRet;
          this.offset=-1;
      }
      private $exposedType$ getNextFromTable(Checked root,int offset){
          $ArrayType$[] table;
          final var ret=($exposedType$)(table=root.table)[offset];
          for(final int tableLength=table.length;;){
              if(++offset==tableLength){
                this.offset=-1;
                break;
              }
              #MACRO IfIsPresentValue(table[offset])
              {
                  this.offset=offset + 256;
                  break;
              }
          }
          return ret;
      }
      private $exposedType$ getNextFromWords(Checked root,int offset){
  #IF OfChar
          final var ret=($exposedType$)offset;
          returnVal:for(;;){
  #ELSE
          final var ret=($exposedType$)(offset-128);
          returnVal:for(;;){
  #ENDIF
              switch(++offset >> 6){
              case 0:
                  int tail0s;
                  if((tail0s=Long.numberOfTrailingZeros(root.word0 >>> offset)) != 64){
                      this.offset=offset+tail0s;
                      break returnVal;
                  }
                  offset=64;
              case 1:
                  if((tail0s=Long.numberOfTrailingZeros(root.word1 >>> offset)) != 64){
                      this.offset=offset+tail0s;
                      break returnVal;
                  }
                  offset=128;
              case 2:
                  if((tail0s=Long.numberOfTrailingZeros(root.word2 >>> offset)) != 64){
                      this.offset=offset+tail0s;
                      break returnVal;
                  }
                  offset=192;
              case 3:
                  if((tail0s=Long.numberOfTrailingZeros(root.word3 >>> offset)) != 64){
                      this.offset=offset+tail0s;
                      break returnVal;
                  }
                  offset=0;
                  break;
              default:
                  offset-=256;
              }
              if(root.tableSize != 0){
                  final var table=root.table;
                  for(;;++offset){
                      #MACRO IfIsPresentValue(table[offset])
                      {
                          this.offset=offset + 256;
                          break returnVal;
                      }
                  }
              }else{
                  this.offset=-1;
              }
              break returnVal;
          }
          return ret;
      }
#ENDIF
    }
  }
}
#MACRODEF IfIsPresentValue(TABLEVAL)
if(((TABLEVAL)&-2)!=0)
#ENDDEF
