#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import java.util.function.IntFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.Comparator;
import java.util.NoSuchElementException;
import omni.api.OmniCollection;
import omni.api.OmniIterator;
import omni.api.OmniList;
import omni.api.OmniStack;
import omni.api.OmniListIterator;
import omni.impl.CheckedCollection;
import omni.util.ArrCopy;
import omni.util.OmniArray;
import omni.util.$ClassPrefix$SortUtil;
#IF OfDouble,OfFloat
import omni.util.HashUtils;
#ENDIF
#IF OfRef
import omni.impl.seq.AbstractSeq;
#ELSE
import omni.impl.seq.Abstract$ClassPrefix$List;
import omni.impl.Abstract$TypeNameModifier$Itr;
#ENDIF
#IFNOT OfBoolean
import omni.util.BitSetUtils;
#ENDIF
#IF OfRef
import java.util.Objects;
import omni.util.OmniPred;
#ELSE
import omni.util.TypeUtil;
  #IF OfInt
import java.util.function.$Comparator$;
  #ELSE
import omni.function.$Comparator$;
  #ENDIF
  #IF OfDouble,OfLong,OfInt
import java.util.function.$UnaryOperator$;
import java.util.function.$TypeNameModifier$Consumer;
import java.util.function.$TypeNameModifier$Predicate;
  #ELSE
    #IFNOT OfBoolean
import omni.function.$UnaryOperator$;
    #ENDIF
import omni.function.$TypeNameModifier$Consumer;
import omni.function.$TypeNameModifier$Predicate;
  #ENDIF
#ENDIF
#IF OfRef
public abstract class $ClassPrefix$ArrSeq$<E>$ extends AbstractSeq implements OmniCollection.Of$ClassPrefix$$<E>$
#ELSE
public abstract class $ClassPrefix$ArrSeq$<E>$ extends Abstract$ClassPrefix$List$<E>$ implements OmniCollection.Of$ClassPrefix$$<E>$
#ENDIF
{
  private static void eraseIndexHelper($ArrayType$[] arr,int index,int newSize)
  {
    ArrCopy.semicheckedCopy(arr,index+1,arr,index,newSize-index);
#IF OfRef
    arr[newSize]=null;
#ENDIF
  }
  #MACRO StaticQueryMethods(StaticContains)
  #MACRO StaticQueryMethods(StaticRelativeIndexOf)
  #MACRO StaticQueryMethods(StaticAbsoluteIndexOf)
  #MACRO StaticQueryMethods(StaticRelativeLastIndexOf)
  #MACRO StaticQueryMethods(StaticAbsoluteLastIndexOf)
  #MACRO StaticQueryMethods(StaticSearch)
#IF OfDouble,OfFloat
  #MACRO StaticDoubleFloatQuery<contains,NaN>()
  #MACRO StaticDoubleFloatQuery<search,NaN>()
  #MACRO StaticDoubleFloatQuery<indexOf,NaN>()
  #MACRO StaticDoubleFloatQuery<lastIndexOf,NaN>()
  #IF OfFloat
  #MACRO StaticDoubleFloatQuery<contains,0>()
  #MACRO StaticDoubleFloatQuery<search,0>()
  #MACRO StaticDoubleFloatQuery<indexOf,0>()
  #MACRO StaticDoubleFloatQuery<lastIndexOf,0>()
  #ENDIF
#ENDIF
  #MACRO SuppressUnchecked()
  private static $<E>$ void uncheckedreplaceAll($ArrayType$[] arr,int offset,int bound,$UnaryOperator$$<E>$ operator)
  {
    do
    {
      arr[offset]=operator.$applyMethod$(($exposedType$)arr[offset]);
    }
    while(++offset!=bound);
  }
  #MACRO SuppressUnchecked()
  static $<E>$ void uncheckedForwardForEach($ArrayType$[] arr,int offset,int bound,$TypeNameModifier$Consumer$<? super E>$ action)
  {
    do
    {
      action.accept(($exposedType$)arr[offset]);
    }
    while(++offset!=bound);
  }
  #MACRO SuppressUnchecked()
  static $<E>$ void uncheckedReverseForEach($ArrayType$[] arr,int offset,int bound,$TypeNameModifier$Consumer$<? super E>$ action)
  {
    do
    {
      action.accept(($exposedType$)arr[--bound]);
    }
    while(bound!=offset);
  }
  private static int forwardHashCode($ArrayType$[] arr,int offset,int bound)
  {
    int hash=31+$hashCodeMethod$(arr[offset]);
    while(++offset!=bound)
    {
      hash=hash*31+$hashCodeMethod$(arr[offset]);
    }
    return hash;
  }
  private static int reverseHashCode($ArrayType$[] arr,int offset,int bound)
  {
    int hash=31+$hashCodeMethod$(arr[offset]);
    while(bound!=offset)
    {
      hash=hash*31+$hashCodeMethod$(arr[offset]);
    }
    return hash;
  }
  private static void forwardToString($ArrayType$[] arr,int offset,int bound,StringBuilder builder)
  {
    for(builder.append(arr[offset]);++offset!=bound;builder.append(',').append(' ').append(arr[offset]));
  }
  private static void reverseToString($ArrayType$[] arr,int offset,int bound,StringBuilder builder)
  {
    for(builder.append(arr[--bound]);bound!=offset;builder.append(',').append(' ').append(arr[--bound]));
  }
#IF OfBoolean

  private static $<E>$ int pullSurvivorsDown($ArrayType$[] arr,int dstOffset,int srcOffset,int srcBound,$ArrayType$ v)
  {
    for(;;)
    {
      arr[dstOffset++]=v;
      do
      {
        if(++srcOffset==srcBound)
        {
          return dstOffset;
        }
      }
      while(arr[srcOffset]^v);
    }
  }
  static $<E>$ int pullSurvivorsUp($ArrayType$[] arr,int srcOffset,int srcBound,$ArrayType$ v)
  {
    for(int dstOffset=srcOffset;;arr[dstOffset--]=v)
    {
      do
      {
        if(--srcOffset==srcBound)
        {
          return dstOffset;
        }
      }
      while(arr[srcOffset]^v);
    }
  }
  static $<E>$ int pullSurvivorsDown($ArrayType$[] arr,int srcOffset,int srcBound,$ArrayType$ v)
  {
    for(int dstOffset=srcOffset;;arr[dstOffset++]=v)
    {
      do
      {
        if(++srcOffset==srcBound)
        {
          return dstOffset;
        }
      }
      while(arr[srcOffset]^v);
    }
  }
#ELSE
  #MACRO SuppressUnchecked()
  static $<E>$ int pullSurvivorsUp($ArrayType$[] arr,int srcBegin,int srcEnd,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    int dstOffset=srcBegin;
    while(srcBegin!=srcEnd)
    {
      final $ArrayType$ v;
      if(!filter.test(($exposedType$)(v=arr[--srcBegin])))
      {
        arr[dstOffset--]=v;
      }
    }
    return dstOffset;
  }
  #MACRO SuppressUnchecked()
  static $<E>$ int pullSurvivorsDown($ArrayType$[] arr,int srcBegin,int srcEnd,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    int dstOffset=srcBegin;
    while(srcBegin!=srcEnd)
    {
      final $ArrayType$ v;
      if(!filter.test(($exposedType$)(v=arr[++srcBegin])))
      {
        arr[dstOffset++]=v;
      }
    }
    return dstOffset;
  }
  #MACRO SuppressUnchecked()
  static $<E>$ int markSurvivorsAndPullUp(CheckedCollection.AbstractModCountChecker modCountChecker,$ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    int dstOffset=srcOffset;
    for(;;)
    {
      if(--srcOffset==srcBound)
      {
        modCountChecker.checkModCount();
        break;
      }
      final $ArrayType$ v;
      if(!filter.test(($exposedType$)(v=arr[srcOffset])))
      {
        int numSurvivors;
        if((numSurvivors=(--srcOffset)-srcBound)!=0)
        {
          final long[] survivors;
          numSurvivors=markSurvivorsReverse(arr,survivors=BitSetUtils.getBitSet(numSurvivors),srcOffset,srcBound,filter);
          modCountChecker.checkModCount();
          arr[dstOffset--]=v;
          if(numSurvivors!=0)
          {
            dstOffset=pullSurvivorsUp(arr,survivors,dstOffset,srcOffset,numSurvivors);
          }
        }
        else
        {
          modCountChecker.checkModCount();
          arr[dstOffset--]=v;
        }
        break;
      }
    }
    return dstOffset;
  }
  #MACRO SuppressUnchecked()
  static $<E>$ int markSurvivorsAndPullDown(CheckedCollection.AbstractModCountChecker modCountChecker,$ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    int dstOffset=srcOffset;
    for(;;)
    {
      if(++srcOffset==srcBound)
      {
        modCountChecker.checkModCount();
        break;
      }
      final $ArrayType$ v;
      if(!filter.test(($exposedType$)(v=arr[srcOffset])))
      {
        int numSurvivors;
        if((numSurvivors=srcBound-++srcOffset)!=0)
        {
          final long[] survivors;
          numSurvivors=markSurvivors(arr,survivors=BitSetUtils.getBitSet(numSurvivors),srcOffset,srcBound,filter);
          modCountChecker.checkModCount();
          arr[dstOffset++]=v;
          if(numSurvivors!=0)
          {
            dstOffset=pullSurvivorsDown(arr,survivors,dstOffset,srcOffset,numSurvivors);
          }
        }
        else
        {
          modCountChecker.checkModCount();
          arr[dstOffset++]=v;
        }
        break;
      }
    }
    return dstOffset;
  }

  #MACRO SuppressUnchecked()
  static $<E>$ int markSurvivorsReverse($ArrayType$[] arr,long[] survivorSet,int offset,int bound,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    for(int numSurvivors=0,wordOffset=survivorSet.length-1;;)
    {
      long word=0L,marker=1L<<63;
      do
      {
        if(!filter.test(($exposedType$)arr[offset]))
        {
          ++numSurvivors;
          word|=marker;
        }
        if(--offset==bound)
        {
          survivorSet[wordOffset]=word;
          return numSurvivors;
        }
      }
      while((marker>>>=1)!=0);
      survivorSet[wordOffset--]=word;
    }
  }
  #MACRO SuppressUnchecked()
  static $<E>$ int markSurvivors($ArrayType$[] arr,long[] survivorSet,int offset,int bound,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    for(int numSurvivors=0,wordOffset=0;;)
    {
      long word=0L,marker=1L;
      do
      {
        if(!filter.test(($exposedType$)arr[offset]))
        {
          ++numSurvivors;
          word|=marker;
        }
        if(++offset==bound)
        {
          survivorSet[wordOffset]=word;
          return numSurvivors;
        }
      }
      while((marker<<=1)!=0);
      survivorSet[wordOffset++]=word;
    }
  }
  static int pullSurvivorsUp($ArrayType$[] arr,long[] survivorSet,int dstOffset,int srcOffset,int numSurvivors)
  {
    for(int survivorSetOffset=survivorSet.length-1;;--survivorSetOffset,srcOffset-=64)
    {
      long survivorWord;
      int runLength;
      if((runLength=Long.numberOfLeadingZeros(survivorWord=survivorSet[survivorSetOffset]))!=64)
      {
        int wordSrcOffset=srcOffset;
        do
        {
          ArrCopy.uncheckedCopy(arr,(wordSrcOffset-=(runLength+(runLength=Long.numberOfLeadingZeros(~(survivorWord<<=runLength))))),arr,dstOffset-=runLength,runLength);
          if((numSurvivors-=runLength)==0)
          {
            return dstOffset;
          }
        }
        while((runLength=Long.numberOfLeadingZeros(survivorWord<<=runLength))!=64);
      }
    }
  }
  static int pullSurvivorsDown($ArrayType$[] arr,long[] survivorSet,int dstOffset,int srcOffset,int numSurvivors)
  {
    for(int survivorSetOffset=0;;++survivorSetOffset,srcOffset+=64)
    {
      long survivorWord;
      int runLength;
      if((runLength=Long.numberOfTrailingZeros(survivorWord=survivorSet[survivorSetOffset]))!=64)
      {
        int wordSrcOffset=srcOffset;
        do
        {
          ArrCopy.uncheckedCopy(arr,wordSrcOffset+=runLength,arr,dstOffset,runLength=Long.numberOfTrailingZeros(~(survivorWord>>>=runLength)));
          dstOffset+=runLength;
          if((numSurvivors-=runLength)==0)
          {
            return dstOffset;
          }
          wordSrcOffset+=runLength;
        }
        while((runLength=Long.numberOfTrailingZeros(survivorWord>>>=runLength))!=64);
      }
    }
  }
#ENDIF
  transient $ArrayType$[] arr;
  private $ClassPrefix$ArrSeq()
  {
    super();
    this.arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
  }
  private $ClassPrefix$ArrSeq(final int capacity)
  {
    super();
    switch(capacity)
    {
    default:
      this.arr=new $ArrayType$[capacity];
      return;
    case OmniArray.DEFAULT_ARR_SEQ_CAP:
      this.arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
    case 0:
    }
  }
  private $ClassPrefix$ArrSeq(final int size,final $ArrayType$[] arr)
  {
    super(size);
    this.arr=arr;
  }
  #MACRO RootQueryObject(boolean,contains,false,\,0,@Override)
  #MACRO RootQueryObject(int,indexOf,-1,,)
  #MACRO RootQueryObject(int,lastIndexOf,-1,,)
  #MACRO RootQueryObject(int,search,-1,,)
  #MACRO QueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,contains,false,$ClassPrefix$ArrSeq,arr\\,0\\,size,,@Override)
#IF OfFloat
  #MACRO BasicQuery(protected,boolean,containsRawInt,int,false,$ClassPrefix$ArrSeq,arr\,0\,size\,val,,@Override)
  @Override
  protected boolean removeValRawInt(final int val)
  {
    final int size;
    if((size=this.size)!=0)
    {
       if(val!=0)
       {
         return uncheckedremoveValBits(size,$convertToBits$(val));
       }
       return uncheckedremoveVal0(size);
    }
    return false;
  }
#ENDIF
  #MACRO ForEachMethods(RootForEach,)
  #MACRO RemoveIf($TypeNameModifier$Predicate$<? super E>$,filter,)
#IFNOT OfRef
  #MACRO RemoveIf(Predicate<? super $BoxedType$>,filter::test,)
  public $BoxedType$ pop()
  {
    return pop$TypeNameModifier$();
  }
  public void push(final $BoxedType$ val)
  {
    push(($exposedType$)val);
  }
#ENDIF
  @Override
  public int hashCode()
  {
    final int size;
    if((size=this.size)!=0)
    {
      return uncheckedHashCode(size);
    }
    return 1;
  }
  #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,indexOf,-1,$ClassPrefix$ArrSeq,arr\\,size,,)
  #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,lastIndexOf,-1,$ClassPrefix$ArrSeq,arr\\,size,,)
  #MACRO Peek($exposedType$,$TypeNameModifier$,($exposedType$),$defaultVal$)
  abstract void uncheckedCopyInto(final $ArrayType$[] dst,final int length);
#IFNOT OfRef
  #MACRO Peek($BoxedType$,,,null)
  abstract void uncheckedCopyInto(final $BoxedType$[] dst,final int length);
  abstract void uncheckedCopyInto(final Object[] dst,final int length);
  #IFNOT OfDouble
  #MACRO Peek(double,Double,$castToDouble$,Double.NaN)
  abstract void uncheckedCopyInto(final double[] dst,final int length);
    #IFNOT OfFloat
  #MACRO Peek(float,Float,$castToFloat$,Float.NaN)
  abstract void uncheckedCopyInto(final float[] dst,final int length);
      #IFNOT OfLong
  #MACRO Peek(long,Long,$castToLong$,Long.MIN_VALUE)
  abstract void uncheckedCopyInto(final long[] dst,final int length);
        #IFNOT OfInt
  #MACRO Peek(int,Int,$castToInt$,Integer.MIN_VALUE)
  abstract void uncheckedCopyInto(final int[] dst,final int length);
          #IFNOT OfChar,OfShort
  #MACRO Peek(short,Short,$castToShort$,Short.MIN_VALUE)
  abstract void uncheckedCopyInto(final short[] dst,final int length);
            #IFNOT OfByte
  #MACRO Peek(byte,Byte,$castToByte$,Byte.MIN_VALUE)
  abstract void uncheckedCopyInto(final byte[] dst,final int length);
  #MACRO Peek(char,Char,$castToChar$,Character.MIN_VALUE)
  abstract void uncheckedCopyInto(final char[] dst,final int length);
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  public $exposedType$ pop$TypeNameModifier$()
  {
    return uncheckedPop(size-1);
  }
  public void push(final $exposedType$ val)
  {
    final int size;
    if((size=this.size)!=0)
    {
      uncheckedAppend(val,size);
    }
    else
    {
      uncheckedInit(val);
    }
  }
  @Override
  public boolean remove(final Object val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfRef
      if(val!=null)
      {
        return this.uncheckedremoveValNonNull(size,val);
      }
      return this.uncheckedremoveVal(size,Objects::isNull);
#ELSE
      if(val instanceof $BoxedType$)
      {
        return this.uncheckedremoveVal(size,$queryCastRef$(val));
      }
#ENDIF
    }
    return false;
  }
  #MACRO QueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,removeVal,false,this,size,,@Override)
  #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,search,-1,$ClassPrefix$ArrSeq,arr\\,size,,)
#IFNOT OfRef
  @Override
#ENDIF
  public $exposedType$ set(final int index,final $exposedType$ val)
  {
    final $ArrayType$[] arr;
    #MACRO SuppressUnchecked()
    final var oldVal=($exposedType$)(arr=this.arr)[index];
    arr[index]=val;
    return oldVal;
  }
  #MACRO ToArrayMethods(uncheckedCopyInto(dst=new retType[size]\\,size);,)
  @Override
  public <T> T[] toArray(final IntFunction<T[]> arrConstructor)
  {
    final int size;
    final T[] dst=arrConstructor.apply(size=this.size);
    if(size!=0)
    {
      uncheckedCopyInto(dst,size);
    }
    return dst;
  }
  @Override
  public <T> T[] toArray(T[] dst)
  {
    final int size;
    if((size=this.size)!=0)
    {
      uncheckedCopyInto(dst=OmniArray.uncheckedArrResize(size,dst),size);
    }
    else if(dst.length!=0)
    {
      dst[0]=null;
    }
    return dst;
  }
  @Override
  public String toString()
  {
    final int size;
    if((size=this.size)!=0)
    {
      final StringBuilder builder;
      uncheckedToString(size,builder=new StringBuilder("["));
      return builder.append(']').toString();
    }
    return "[]";
  }
#IF OfRef
  abstract boolean uncheckedremoveVal(final int size,final Predicate<Object> pred);
  abstract boolean uncheckedremoveValNonNull(final int size,final Object nonNull);
#ELSEIF OfDouble,OfFloat
  abstract boolean uncheckedremoveVal0(final int size);
  abstract boolean uncheckedremoveValBits(final int size,final $queryParameterType$ bits);
  abstract boolean uncheckedremoveValNaN(final int size);
  #MACRO UncheckedDoubleFloatQuery(boolean,removeVal,,$exposedType$,val==,NaN)
#ELSE
  abstract boolean uncheckedremoveVal(final int size,final $queryParameterType$ val);
#ENDIF
  abstract void uncheckedForEach(final int size,final $TypeNameModifier$Consumer$<? super E>$ action);
  abstract int uncheckedHashCode(final int size);
  abstract boolean uncheckedRemoveIf(final int size,final $TypeNameModifier$Predicate$<? super E>$ filter);
  abstract void uncheckedToString(final int size,final StringBuilder builder);
  private int finalizeSubListBatchRemove(final $ArrayType$[] arr,final int newBound,final int oldBound)
  {
    final int newRootSize,numRemoved;
#IF OfRef
    final int rootSize;
    size=newRootSize=(rootSize=size)-(numRemoved=oldBound-newBound);
#ELSE
    size=newRootSize=size-(numRemoved=oldBound-newBound);
#ENDIF
    ArrCopy.semicheckedCopy(arr,oldBound,arr,newBound,newRootSize-newBound);
#IF OfRef
    OmniArray.OfRef.nullifyRange(arr,newRootSize,rootSize-1);
#ENDIF
    return numRemoved;
  }
  private $ArrayType$[] growInsert($ArrayType$[] arr,final int index,final int size)
  {
    if(arr.length==size)
    {
      ArrCopy.semicheckedCopy(arr,0,arr=new $ArrayType$[OmniArray.growBy50Pct(size)],0,index);
      this.arr=arr;
    }
    return arr;
  }
  private void uncheckedAppend(final $exposedType$ val,final int size)
  {
    $ArrayType$[] arr;
    if((arr=this.arr).length==size)
    {
      ArrCopy.uncheckedCopy(arr,0,arr=new $ArrayType$[OmniArray.growBy50Pct(size)],0,size);
    }
    arr[size]=val;
    this.size=size+1;
  }
  private void uncheckedInit(final $exposedType$ val)
  {
    $ArrayType$[] arr;
    if((arr=this.arr)==OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
    {
      this.arr=arr=new $ArrayType$[OmniArray.DEFAULT_ARR_SEQ_CAP];
    }
    else if(arr==null)
    {
      this.arr=arr=new $ArrayType$[1];
    }
    arr[0]=val;
    size=1;
  }
  private void uncheckedInsert(final int index,final $exposedType$ val,final int size)
  {
    final int tailDist;
    if((tailDist=size-index)==0)
    {
      uncheckedAppend(val,size);
    }
    else
    {
      $ArrayType$[] arr;
      ArrCopy.uncheckedCopy(arr=this.arr,index,arr=growInsert(arr,index,size),index+1,tailDist);
      arr[index]=val;
      this.size=size+1;
    }
  }
  private $exposedType$ uncheckedPop(final int newSize)
  {
    this.size=newSize;
#IF OfRef
    final $ArrayType$[] arr;
    @SuppressWarnings("unchecked") final var popped=($exposedType$)(arr=this.arr)[newSize];
    arr[newSize]=null;
    return popped;
#ELSE
    return arr[newSize];
#ENDIF
  }
  public static abstract class Checked$<E>$ extends $ClassPrefix$ArrSeq$<E>$
  {
#IFNOT OfBoolean
    private class ModCountChecker extends CheckedCollection.AbstractModCountChecker
    {
      public ModCountChecker(int expectedModCount)
      {
        super(expectedModCount);
      }
      @Override protected int getActualModCount()
      {
        return modCount;
      }
    }
#ENDIF
    transient int modCount;
    private Checked()
    {
      super();
    }
    private Checked(final int capacity)
    {
      super(capacity);
    }
    private Checked(final int size,final $ArrayType$[] arr)
    {
      super(size,arr);
    }
    @Override
    public boolean add(final $exposedType$ val)
    {
      ++modCount;
      super.push(val);
      return true;
    }  
#IFNOT OfRef
    @Override
#ENDIF
    public void add(final int index,final $exposedType$ val)
    {
      CheckedCollection.checkLo(index);
      final int size;
      CheckedCollection.checkWriteHi(index,size=this.size);
      ++modCount;
      if(size!=0)
      {
        super.uncheckedInsert(index,val,size);
      }
      else
      {
        super.uncheckedInit(val);
      }
    }
    @Override
    public void clear()
    {
#IF OfRef
      final int size;
      if((size=this.size)!=0)
      {
        OmniArray.OfRef.nullifyRange(arr,0,size-1);
#ELSE
      if(size!=0)
      {
#ENDIF
        ++modCount;
        this.size=0;
      }
    }
    #MACRO CheckedRootQueryObject(boolean,contains,0\\,size,0\,size,false)
    #MACRO CheckedRootQueryObject(int,indexOf,size,size,-1)
    #MACRO CheckedRootQueryObject(int,lastIndexOf,size,size,-1)
    #MACRO CheckedRootQueryObject(int,search,size,size,-1)
    #MACRO SuppressUnchecked()
#IFNOT OfRef
    @Override
#ENDIF
    public $exposedType$ get$TypeNameModifier$(final int index)
    {
      CheckedCollection.checkLo(index);
      CheckedCollection.checkReadHi(index,this.size);
      return ($exposedType$)arr[index];
    }
    @Override
    public $exposedType$ pop$TypeNameModifier$()
    {
      final int size;
      if((size=this.size)!=0)
      {
        ++modCount;
        return ($exposedType$)super.uncheckedPop(size-1);
      }
      throw new NoSuchElementException();
    }
    @Override
    public void push(final $exposedType$ val)
    {
      ++modCount;
      super.push(val);
    }
#IFNOT OfRef
    @Override
#ENDIF
    public $exposedType$ $removeAtIndexMethod$(final int index)
    {
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      ++modCount;
      final $ArrayType$[] arr;
      #MACRO SuppressUnchecked()
      final var removed=($exposedType$)(arr=this.arr)[index];
      eraseIndexHelper(arr,index,--size);
      this.size=size;
      return removed;
    }
    @Override
    public $exposedType$ set(final int index,final $exposedType$ val)
    {
      CheckedCollection.checkLo(index);
      CheckedCollection.checkReadHi(index,this.size);
      return super.set(index,val);
    }
    @Override
    public <T> T[] toArray(final IntFunction<T[]> arrConstructor)
    {
      return super.toArray(size->
      {
        #MACRO TryCheckModCount(this,return arrConstructor.apply(size);)
      });
    }
    #MACRO SuppressUnchecked()
    @Override
    boolean uncheckedRemoveIf(int size,final $TypeNameModifier$Predicate$<? super E>$ filter)
    {
      int srcOffset;
      final int modCount=this.modCount;
      try
      {
#IF OfBoolean
        final $ArrayType$[] arr;
        $ArrayType$ v;
        if(filter.test(v=(arr=this.arr)[srcOffset=0]))
        {
          for(;;)
          {
            if(++srcOffset==size)
            {
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.size=0;
              break;
            }
            if(v^arr[srcOffset])
            {
              final boolean tmp=filter.test(v=!v);
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.size=tmp?0:pullSurvivorsDown(arr,0,srcOffset,size,v);
              break;
            }
          }
        }
        else
        {
          #MACRO CheckedRemoveIfHelper(size,this.size,this)
        }
#ELSE
        srcOffset=0;
        final var arr=this.arr;
        for(;;)
        {
          if(filter.test(($exposedType$)arr[srcOffset]))
          {
            break;
          }
          if(++srcOffset==size)
          {
            CheckedCollection.checkModCount(modCount,this.modCount);
            return false;
          }
        }
        int dstOffset=markSurvivorsAndPullDown(new ModCountChecker(modCount),arr,srcOffset,size,filter);
        this.modCount=modCount+1;
  #IF OfRef
        OmniArray.OfRef.nullifyRange(arr,dstOffset,size-1);
  #ENDIF
        this.size=dstOffset;
#ENDIF
      }
      catch(final RuntimeException e)
      {
        throw CheckedCollection.checkModCount(modCount,this.modCount,e);
      }
      return true;
    }
  }
  public static class CheckedList$<E>$ extends Checked$<E>$ implements OmniList.Of$ClassPrefix$$<E>$
  {
    public CheckedList()
    {
      super();
    }
    public CheckedList(final int capacity)
    {
      super(capacity);
    }
    public CheckedList(final int size,final $ArrayType$[] arr)
    {
      super(size,arr);
    }
    @Override
    public Object clone()
    {
      final $ArrayType$[] arr;
      final int size;
      if((size=this.size)!=0)
      {
        ArrCopy.uncheckedCopy(this.arr,0,arr=new $ArrayType$[size],0,size);
      }
      else
      {
        arr=null;
      }
      return new CheckedList$<E>$(size,arr);
    }
    @Override
    public boolean equals(final Object val)
    {
      //TODO implements equals method
      return false;
    }
    @Override
    public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
    {
      return new BidirectionalItr$<E>$(this);
    }
    @Override
    public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
    {
      return new BidirectionalItr$<E>$(this);
    }
    @Override
    public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(final int index)
    {
      CheckedCollection.checkLo(index);
      CheckedCollection.checkWriteHi(index,this.size);
      return new BidirectionalItr$<E>$(this,index);
    }
    @Override
    public void put(final int index,final $exposedType$ val)
    {
      CheckedCollection.checkLo(index);
      CheckedCollection.checkReadHi(index,this.size);
      arr[index]=val;
    }
    #MACRO CheckedRootTryModifyFunc(replaceAll,$UnaryOperator$$<E>$ operator,0!=,$ClassPrefix$ArrSeq,size,replaceAll,operator)
    #MACRO CheckedRootTryModifyFunc(sort,$Comparator$$<? super E>$ sorter,1<,$ClassPrefix$SortUtil,size-1,comparatorSort,sorter)
#IFNOT OfRef
    #MACRO CheckedRootTryModifyFunc(replaceAll,UnaryOperator<$BoxedType$> operator,0!=,$ClassPrefix$ArrSeq,size,replaceAll,operator::apply)
    #MACRO CheckedRootTryModifyFunc(sort,Comparator<? super $BoxedType$> sorter,1<,$ClassPrefix$SortUtil,size-1,comparatorSort,sorter::compare)
#ENDIF
    #MACRO CheckedRootSortNoComparator(reverseSort)
    #MACRO CheckedRootSortNoComparator(sort)
    @Override
    public OmniList.Of$ClassPrefix$$<E>$ subList(final int fromIndex,final int toIndex)
    {
      CheckedCollection.checkSubListRange(fromIndex,toIndex,this.size);
      return new SubList$<E>$(this,fromIndex,toIndex-fromIndex);
    }
    #MACRO CopyIntoArrayMethods<uncheckedCopy>()
    @Override
    void uncheckedForEach(final int size,final $TypeNameModifier$Consumer$<? super E>$ action)
    {
      #MACRO TryCheckModCount(this,uncheckedForwardForEach(arr\,0\,size\,action);)
    }
    @Override
    int uncheckedHashCode(final int size)
    {
#IF OfRef
      #MACRO TryCheckModCount(this,return forwardHashCode(arr\,0\,size);)
#ELSE
      return forwardHashCode(arr,0,size);
#ENDIF
    }
#IF OfRef
    #MACRO UncheckedRemoveVal<First>(!pred.test,,int size\,final Predicate<Object> pred,++this.modCount;)
    @Override
    boolean uncheckedremoveValNonNull(int size,final Object nonNull)
    {
      final var arr=this.arr;
      int index;
      #MACRO TryCheckModCount(this,#MACRO UncheckedConditionalLoop(\,index=0\\,--size\,!nonNull.equals(arr[index])\,++index\,index==size\,false))
      ++modCount;
      eraseIndexHelper(arr,index,size);
      this.size=size;
      return true;
    }
#ELSEIF OfDouble,OfFloat
    #MACRO UncheckedRemoveVal<First>(0!=,0,int size,++this.modCount;)
    #MACRO UncheckedRemoveVal<First>(bits!=$convertToBits$,Bits,int size\,final $queryParameterType$ bits,++this.modCount;)
    #MACRO UncheckedRemoveVal<First>(!$BoxedType$.isNaN,NaN,int size,++this.modCount;)
#ELSEIF OfBoolean
    #MACRO UncheckedRemoveVal<First>(val^,,int size\,final $queryParameterType$ val,++this.modCount;)
#ELSE
    #MACRO UncheckedRemoveVal<First>(val!=,,int size\,final $queryParameterType$ val,++this.modCount;)
#ENDIF
    @Override
    void uncheckedToString(final int size,final StringBuilder builder)
    {
#IF OfRef
      #MACRO TryCheckModCount(this,forwardToString(arr\,0\,size\,builder);)
#ELSE
      forwardToString(arr,0,size,builder);
#ENDIF
    }
    private static class BidirectionalItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>$
    {
      private transient int lastRet=-1;
      private transient final Checked$<E>$ root;
      private transient int cursor;
      private transient int modCount;
      private BidirectionalItr(final Checked$<E>$ root)
      {
        this.root=root;
        this.modCount=root.modCount;
      }
      private BidirectionalItr(final Checked$<E>$ root,final int cursor)
      {
        this.root=root;
        this.modCount=root.modCount;
        this.cursor=cursor;
      }
      @Override
      public void add(final $exposedType$ val)
      {
        final Checked$<E>$ root;
        int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
        final int rootSize,cursor=this.cursor;
        if((rootSize=root.size)!=0)
        {
          (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInsert(cursor,val,rootSize);
        }
        else
        {
          (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInit(val);
        }
        root.modCount=++modCount;
        this.modCount=modCount;
        this.cursor=cursor+1;
        this.lastRet=-1;
      }
      #MACRO ForEachMethods(CheckedBidirectionalItrForEachRemaining,)
      @Override
      public boolean hasNext()
      {
        return cursor!=root.size;
      }
      @Override
      public boolean hasPrevious()
      {
        return cursor!=0;
      }
      #MACRO SuppressUnchecked()
      @Override
      public $exposedType$ next$TypeNameModifier$()
      {
        final Checked$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        final int cursor;
        if((cursor=this.cursor)!=root.size)
        {
          lastRet=cursor;
          this.cursor=cursor+1;
          return ($exposedType$)root.arr[cursor];
        }
        throw new NoSuchElementException();
      }
      @Override
      public int nextIndex()
      {
        return cursor;
      }
      #MACRO SuppressUnchecked()
      @Override
      public $exposedType$ previous$TypeNameModifier$()
      {
        final Checked$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        int cursor;
        if((cursor=this.cursor)!=0)
        {
          lastRet=--cursor;
          this.cursor=cursor;
          return ($exposedType$)root.arr[cursor];
        }
        throw new NoSuchElementException();
      }
      @Override
      public int previousIndex()
      {
        return cursor-1;
      }
      @Override
      public void remove()
      {
        final int lastRet;
        if((lastRet=this.lastRet)!=-1)
        {
          final Checked$<E>$ root;
          int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          eraseIndexHelper(root.arr,lastRet,--root.size);
          root.modCount=++modCount;
          this.modCount=modCount;
          cursor=lastRet;
          this.lastRet=-1;
          return;
        }
        throw new IllegalStateException();
      }
      @Override
      public void set(final $exposedType$ val)
      {
        final int lastRet;
        if((lastRet=this.lastRet)!=-1)
        {
          final Checked$<E>$ root;
          CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
          root.arr[lastRet]=val;
          return;
        }
        throw new IllegalStateException();
      }
    }
#IF OfRef
    private static class SubList$<E>$ extends AbstractSeq implements OmniList.Of$ClassPrefix$$<E>$
#ELSE
    private static class SubList$<E>$ extends Abstract$ClassPrefix$List$<E>$ implements OmniList.Of$ClassPrefix$$<E>$
#ENDIF
    {
      transient final Checked$<E>$ root;
      transient final SubList$<E>$ parent;
      transient final int rootOffset;
      transient int modCount;
      #MACRO BubbleUp(DecrementSize,,--parent.size;++parent.modCount;)
      #MACRO BubbleUp(DecrementSize,\,final int numToRemove,parent.size-=numToRemove;++parent.modCount;)
      #MACRO BubbleUp(IncrementModCount,,++parent.modCount;)
      #MACRO BubbleUp(IncrementSize,,++parent.size;++parent.modCount;)
      private SubList(final Checked$<E>$ root,final int rootOffset,final int size)
      {
        super(size);
        this.root=root;
        this.parent=null;
        this.rootOffset=rootOffset;
        this.modCount=root.modCount;
      }
      private SubList(final Checked$<E>$ root,final SubList$<E>$ parent,final int rootOffset,final int size)
      {
        super(size);
        this.root=root;
        this.parent=parent;
        this.rootOffset=rootOffset;
        this.modCount=root.modCount;
      }
      @Override
      public boolean add(final $exposedType$ val)
      {
        final Checked$<E>$ root;
        int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
        final int rootSize;
        final int size=this.size;
        if((rootSize=root.size)!=0)
        {
          (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInsert(rootOffset+size,val,rootSize);
        }
        else
        {
          (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInit(val);
        }
        root.modCount=++modCount;
        this.modCount=modCount;
        bubbleUpIncrementSize(parent);
        this.size=size+1;
        return true;
      }
      @Override
      public void add(final int index,final $exposedType$ val)
      {
        final Checked$<E>$ root;
        int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
        CheckedCollection.checkLo(index);
        final int size;
        CheckedCollection.checkWriteHi(index,size=this.size);
        final int rootSize;
        if((rootSize=root.size)!=0)
        {
          (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInsert(rootOffset+index,val,rootSize);
        }
        else
        {
          (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInit(val);
        }
        root.modCount=++modCount;
        this.modCount=modCount;
        bubbleUpIncrementSize(parent);
        this.size=size+1;
      }
      @Override
      public void clear()
      {
        final var root=this.root;
        final int modCount=this.modCount;
        final int size;
        if((size=this.size)!=0)
        {
          CheckedCollection.checkModCount(modCount,root.modCount);
          this.modCount=modCount+1;
          this.size=0;
          bubbleUpDecrementSize(parent,size);
          final int newRootSize;
#IF OfRef 
          final int oldRootSize;
          root.size=newRootSize=(oldRootSize=root.size)-size;
#ELSE
          root.size=newRootSize=root.size-size;
#ENDIF
          final $ArrayType$[] arr;
          final int rootOffset;
          ArrCopy.semicheckedCopy(arr=root.arr,(rootOffset=this.rootOffset)+size,arr,rootOffset,newRootSize-rootOffset);
#IF OfRef
          OmniArray.OfRef.nullifyRange(arr,newRootSize,oldRootSize-1);
#ENDIF
        }
        else
        {
          CheckedCollection.checkModCount(modCount,root.modCount);
        }
      }
      @Override
      public Object clone()
      {
        final var root=checkModCountAndGetRoot();
        final $ArrayType$[] arr;
        final int size;
        if((size=this.size)!=0)
        {
          ArrCopy.uncheckedCopy(root.arr,rootOffset,arr=new $ArrayType$[size],0,size);
        }
        else
        {
          arr=null;
        }
        return new CheckedList$<E>$(size,arr);
      }
      #MACRO CheckedSubListQueryObject(boolean,contains,false)
      #MACRO CheckedSubListQueryObject(int,indexOf,-1)
      #MACRO CheckedSubListQueryObject(int,lastIndexOf,-1)
      #MACRO QueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,contains,false,this,size,CheckedCollection.checkModCount(modCount\\,root.modCount);,@Override)
#IF OfFloat
      #MACRO CheckedSubListRawIntQuery(contains)
      #MACRO CheckedSubListRawIntQuery(removeVal)
      #MACRO UncheckedDoubleFloatQuery(int,indexOf,RawInt,int,0!=,0)
      #MACRO UncheckedDoubleFloatQuery(int,lastIndexOf,RawInt,int,0!=,0)
#ENDIF
      @Override
      public boolean equals(final Object val)
      {
        //TODO implements equals method
        return false;
      }
      #MACRO ForEachMethods(CheckedSubListForEach,)
      #MACRO SuppressUnchecked()
      @Override
      public $exposedType$ get$TypeNameModifier$(final int index)
      {
        final var root=checkModCountAndGetRoot();
        CheckedCollection.checkLo(index);
        CheckedCollection.checkReadHi(index,this.size);
        return ($exposedType$)root.arr[index+rootOffset];
      }    
      @Override
      public int hashCode()
      {
#IF OfRef
        final int modCount=this.modCount;
        final var root=this.root;
        try
#ELSE
        final var root=checkModCountAndGetRoot();
#ENDIF
        {
          final int size;
          if((size=this.size)!=0)
          {
            final int rootOffset;
            return forwardHashCode(root.arr,rootOffset=this.rootOffset,rootOffset+size);
          }
          return 1;
        }
#IF OfRef
        finally
        {
          CheckedCollection.checkModCount(modCount,root.modCount);
        }
#ENDIF
      }
      #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,indexOf,-1,this,size,CheckedCollection.checkModCount(modCount\\,root.modCount);,@Override)
      #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,lastIndexOf,-1,this,size,CheckedCollection.checkModCount(modCount\\,root.modCount);,@Override)
      @Override
      public boolean isEmpty()
      {
        CheckedCollection.checkModCount(this.modCount,root.modCount);
        return size==0;
      }
      @Override
      public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
      {
        final int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,root.modCount);
        return new BidirectionalItr$<E>$(this,modCount);
      }
      @Override
      public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
      {
        final int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,root.modCount);
        return new BidirectionalItr$<E>$(this,modCount);
      }
      @Override
      public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(final int index)
      {
        final int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,root.modCount);
        CheckedCollection.checkLo(index);
        CheckedCollection.checkWriteHi(index,size);
        return new BidirectionalItr$<E>$(this,modCount,index+rootOffset);
      }
      @Override
      public void put(final int index,final $exposedType$ val)
      {
        final var root=checkModCountAndGetRoot();
        CheckedCollection.checkLo(index);
        CheckedCollection.checkReadHi(index,this.size);
        root.arr[index+rootOffset]=val;
      }
      @Override
      public boolean remove(final Object val)
      {
        final int size;
        if((size=this.size)!=0)
        {
#IF OfRef
          if(val!=null)
          {
            return uncheckedremoveValNonNull(size,val);
          }
          return uncheckedremoveVal(size,Objects::isNull);
#ELSE
          if(val instanceof $BoxedType$)
          {
            return uncheckedremoveVal(size,$queryCastRef$(val));
          }
#ENDIF
        }
        CheckedCollection.checkModCount(modCount,root.modCount);
        return false;
      }
      #MACRO QueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,removeVal,false,this,size,CheckedCollection.checkModCount(modCount\\,root.modCount);,@Override)
      @Override
      public $exposedType$ $removeAtIndexMethod$(int index)
      {
        #MACRO SubListCheckModCount()
        CheckedCollection.checkLo(index);
        final int size;
        CheckedCollection.checkReadHi(index,size=this.size);
        final $ArrayType$[] arr;
        #MACRO SuppressUnchecked()
        final var removed=($exposedType$)(arr=root.arr)[index+=rootOffset];
        eraseIndexHelper(arr,index,--root.size);
        root.modCount=++modCount;
        bubbleUpDecrementSize(parent);
        this.modCount=modCount;
        this.size=size-1;
        return removed;
      }
      #MACRO RemoveIf($TypeNameModifier$Predicate$<? super E>$,filter,CheckedCollection.checkModCount(this.modCount\,root.modCount);)
      #MACRO CheckedSubListTryModify(replaceAll(final $UnaryOperator$$<E>$ operator),0!=,uncheckedreplaceAll(root.arr\\,rootOffset=this.rootOffset\\,rootOffset+size\\,operator);)      
      #MACRO CheckedSubListTryModify(sort(final $Comparator$$<? super E>$ sorter),1<,$ClassPrefix$SortUtil.uncheckedcomparatorSort(root.arr\\,rootOffset=this.rootOffset\\,rootOffset+size-1\\,sorter);)
#IF OfRef
      #MACRO CheckedSubListTryModify(reverseSort(),1<,$ClassPrefix$SortUtil.uncheckedreverseSort(root.arr\\,rootOffset=this.rootOffset\\,rootOffset+size-1);)
      #MACRO CheckedSubListTryModify(sort(),1<,$ClassPrefix$SortUtil.uncheckedsort(root.arr\\,rootOffset=this.rootOffset\\,rootOffset+size-1);)
#ELSE
      #MACRO CheckedSubListSortNoComparator(reverseSort)
      #MACRO CheckedSubListSortNoComparator(sort)
      #MACRO RemoveIf(Predicate<? super $BoxedType$>,filter::test,CheckedCollection.checkModCount(this.modCount\,root.modCount);)
      #MACRO CheckedSubListTryModify(replaceAll(final UnaryOperator<$BoxedType$> operator),0!=,uncheckedreplaceAll(root.arr\\,rootOffset=this.rootOffset\\,rootOffset+size\\,operator::apply);)
      #MACRO CheckedSubListTryModify(sort(final Comparator<? super $BoxedType$> sorter),1<,$ClassPrefix$SortUtil.uncheckedcomparatorSort(root.arr\\,rootOffset=this.rootOffset\\,rootOffset+size-1\\,sorter::compare);)
#ENDIF
      @Override
      public $exposedType$ set(int index,final $exposedType$ val)
      {
        final var root=checkModCountAndGetRoot();
        CheckedCollection.checkLo(index);
        CheckedCollection.checkReadHi(index,this.size);
        final $ArrayType$[] arr;
        #MACRO SuppressUnchecked()
        final var oldVal=($exposedType$)(arr=root.arr)[index+=rootOffset];
        arr[index]=val;
        return oldVal;
      }
      @Override
      public int size()
      {
        CheckedCollection.checkModCount(this.modCount,root.modCount);
        return size;
      }
      @Override
      public OmniList.Of$ClassPrefix$$<E>$ subList(final int fromIndex,final int toIndex)
      {
        final var root=checkModCountAndGetRoot();
        CheckedCollection.checkSubListRange(fromIndex,toIndex,this.size);
        return new SubList$<E>$(root,this,this.rootOffset+fromIndex,toIndex-fromIndex);
      }
      #MACRO ToArrayMethods(ArrCopy.uncheckedCopy(root.arr\\,rootOffset\\,dst=new retType[size]\\,0\\,size);,final var root=checkModCountAndGetRoot();)
      @Override
      public <T> T[] toArray(final IntFunction<T[]> arrConstructor)
      {
        final var root=this.root;
        final int size;
        final T[] dst;
        #MACRO TryCheckModCount(root,dst=arrConstructor.apply(size=this.size);)
        if(size!=0)
        {
          ArrCopy.uncheckedCopy(root.arr,rootOffset,dst,0,size);
        }
        return dst;
      }
      @Override
      public <T> T[] toArray(T[] arr)
      {
        final var root=checkModCountAndGetRoot();
        final int size;
        if((size=this.size)!=0)
        {
          ArrCopy.uncheckedCopy(root.arr,rootOffset,arr=OmniArray.uncheckedArrResize(size,arr),0,size);
        }
        else if(arr.length!=0)
        {
          arr[0]=null;
        }
        return arr;
      }
      @Override
      public String toString()
      {
#IF OfRef
        final int modCount=this.modCount;
        final var root=this.root;
        try
#ELSE
        final var root=checkModCountAndGetRoot();
#ENDIF
        {
          final int size;
          if((size=this.size)!=0)
          {
            final StringBuilder builder;
            final int rootOffset;
            forwardToString(root.arr,rootOffset=this.rootOffset,rootOffset+size,builder=new StringBuilder("["));
            return builder.append(']').toString();
          }
          return "[]";
        }
#IF OfRef
        finally
        {
          CheckedCollection.checkModCount(modCount,root.modCount);
        }
#ENDIF
      }
#IF OfRef
      #MACRO UncheckedSubListQuery(int,indexOf,final int size\,final Predicate<Object> pred,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size\,pred);
      #MACRO UncheckedSubListQuery(int,lastIndexOf,final int size\,final Predicate<Object> pred,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size\,pred);
      #MACRO UncheckedSubListQuery(boolean,contains,final int size\,final Predicate<Object> pred,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size\,pred)
      #MACRO UncheckedNonNullSubListQuery(boolean,contains)
      #MACRO UncheckedNonNullSubListQuery(int,indexOf)
      #MACRO UncheckedNonNullSubListQuery(int,lastIndexOf)
      #MACRO CheckedSubListRemoveVal(!pred.test,,int size\,final Predicate<Object> pred)
      private boolean uncheckedremoveValNonNull(int size,final Object nonNull)
      {
        final Checked$<E>$ root;
        final var arr=(root=this.root).arr;
        int index;
        #MACRO TryCheckModCount(root,#MACRO UncheckedConditionalLoop(final int bound=(index=this.rootOffset)+(--size);\,\,!nonNull.equals(arr[index])\,\,++index==bound\,false))
        root.modCount=++modCount;
        bubbleUpDecrementSize(parent);
        this.modCount=modCount;
        eraseIndexHelper(arr,index,--root.size);
        this.size=size;
        return true;
      }
#ELSEIF OfDouble,OfFloat
      #MACRO UncheckedDoubleFloatQuery(boolean,contains,,$exposedType$,val==,NaN)
      #MACRO UncheckedDoubleFloatQuery(int,indexOf,,$exposedType$,val==,NaN)
      #MACRO UncheckedDoubleFloatQuery(int,lastIndexOf,,$exposedType$,val==,NaN)
      #MACRO UncheckedDoubleFloatQuery(boolean,removeVal,,$exposedType$,val==,NaN)
      #MACRO UncheckedSubListQuery(boolean,containsBits,final int size\,final $queryParameterType$ bits,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size\,bits)
      #MACRO UncheckedSubListQuery(boolean,contains0,final int size,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedSubListQuery(boolean,containsNaN,final int size,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedSubListQuery(int,indexOfBits,final int size\,final $queryParameterType$ bits,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size\,bits)
      #MACRO UncheckedSubListQuery(int,indexOf0,final int size,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedSubListQuery(int,indexOfNaN,final int size,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedSubListQuery(int,lastIndexOfBits,final int size\,final $queryParameterType$ bits,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size\,bits)
      #MACRO UncheckedSubListQuery(int,lastIndexOf0,final int size,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedSubListQuery(int,lastIndexOfNaN,final int size,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO CheckedSubListRemoveVal(bits!=$convertToBits$,Bits,int size\,final $queryParameterType$ bits)
      #MACRO CheckedSubListRemoveVal(0!=,0,int size)
      #MACRO CheckedSubListRemoveVal($BoxedType$.isNaN,NaN,int size)
#ELSE
      #MACRO UncheckedSubListQuery(boolean,contains,final int size\,final $queryParameterType$ val,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size\,val)
      #MACRO UncheckedSubListQuery(int,indexOf,final int size\,final $queryParameterType$ val,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size\,val)
      #MACRO UncheckedSubListQuery(int,lastIndexOf,final int size\,final $queryParameterType$ val,checkModCountAndGetRoot().arr\,rootOffset=this.rootOffset\,rootOffset+size\,val)
  #IF OfBoolean
      #MACRO CheckedSubListRemoveVal(val^,,int size\,final $queryParameterType$ val)
  #ELSE
      #MACRO CheckedSubListRemoveVal(val!=,,int size\,final $queryParameterType$ val)
  #ENDIF
#ENDIF
      private Checked$<E>$ checkModCountAndGetRoot()
      {
        final Checked$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        return root;
      }
      #MACRO SuppressUnchecked()
      private boolean uncheckedRemoveIf(int size,final $TypeNameModifier$Predicate$<? super E>$ filter)
      {
        final Checked$<E>$ root=this.root;
        int modCount=this.modCount;
        int srcOffset;
        final int srcBound=(srcOffset=rootOffset)+size;
        int dstOffset;
        try
        {
#IF OfBoolean
          final $ArrayType$[] arr;
          $ArrayType$ v;
          if(filter.test(v=(arr=root.arr)[srcOffset]))
          {
            dstOffset=srcOffset;
            for(;;)
            {
              if(++srcOffset==srcBound)
              {
                CheckedCollection.checkModCount(modCount,root.modCount);
                break;
              }
              if(v^arr[srcOffset])
              {
                final boolean tmp=filter.test(v=!v);
                CheckedCollection.checkModCount(modCount,root.modCount);
                if(!tmp)
                {
                  dstOffset=pullSurvivorsDown(arr,dstOffset,srcOffset,size,v);
                }
                break;
              }
            }
          }
          else
          {
            #MACRO CheckedRemoveIfHelper(srcBound,dstOffset,root)
          }
#ELSE
          final var arr=root.arr;
          for(;;)
          {
            if(filter.test(($exposedType$)arr[srcOffset]))
            {
              break;
            }
            if(++srcOffset==srcBound)
            {
              CheckedCollection.checkModCount(modCount,root.modCount);
              return false;
            }
          }
          dstOffset=markSurvivorsAndPullDown(root.new ModCountChecker(modCount),arr,srcOffset,srcBound,filter);
#ENDIF
          root.modCount=++modCount;
          this.modCount=modCount;
          this.size=size-(size=(($ClassPrefix$ArrSeq$<E>$)root).finalizeSubListBatchRemove(arr,dstOffset,srcBound));
          bubbleUpDecrementSize(parent,size);
        }
        catch(final RuntimeException e)
        {
          throw CheckedCollection.checkModCount(modCount,root.modCount,e);
        }
        return true;
      }
      private static class BidirectionalItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>$
      {
        private transient final SubList$<E>$ parent;
        private transient int cursor;
        private transient int lastRet=-1;
        private transient int modCount;
        private BidirectionalItr(final SubList$<E>$ parent,final int modCount)
        {
          this.parent=parent;
          this.cursor=parent.rootOffset;
          this.modCount=modCount;
        }
        private BidirectionalItr(final SubList$<E>$ parent,final int modCount,final int cursor)
        {
          this.parent=parent;
          this.cursor=cursor;
          this.modCount=modCount;
        }
        @Override
        public void add(final $exposedType$ val)
        {
          final SubList$<E>$ parent;
          final Checked$<E>$ root;
          int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=(parent=this.parent).root).modCount);
          final int rootSize;
          final int cursor=this.cursor;
          if((rootSize=root.size)!=0)
          {
            (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInsert(cursor,val,rootSize);
          }
          else
          {
            (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInit(val);
          }
          bubbleUpIncrementSize(parent.parent);
          parent.modCount=++modCount;
          root.modCount=modCount;
          ++parent.size;
          this.cursor=cursor+1;
          this.lastRet=-1;
        }
        #MACRO ForEachMethods(CheckedBidirectionalSubItrForEachRemaining,)
        @Override
        public boolean hasNext()
        {
          final SubList$<E>$ parent;
          return cursor!=(parent=this.parent).rootOffset+parent.size;
        }
        @Override
        public boolean hasPrevious()
        {
          return cursor!=parent.rootOffset;
        }
        #MACRO SuppressUnchecked()
        @Override
        public $exposedType$ next$TypeNameModifier$()
        {
          final Checked$<E>$ root;
          final SubList$<E>$ parent;
          CheckedCollection.checkModCount(modCount,(root=(parent=this.parent).root).modCount);
          final int cursor;
          if((cursor=this.cursor)!=parent.rootOffset+parent.size)
          {
            lastRet=cursor;
            this.cursor=cursor+1;
            return ($exposedType$)root.arr[cursor];
          }
          throw new NoSuchElementException();
        }
        @Override
        public int nextIndex()
        {
          return cursor-parent.rootOffset;
        }
        #MACRO SuppressUnchecked()
        @Override
        public $exposedType$ previous$TypeNameModifier$()
        {
          final Checked$<E>$ root;
          final SubList$<E>$  parent;
          CheckedCollection.checkModCount(modCount,(root=(parent=this.parent).root).modCount);
          int cursor;
          if((cursor=this.cursor)!=parent.rootOffset)
          {
            lastRet=--cursor;
            this.cursor=cursor;
            return ($exposedType$)root.arr[cursor];
          }
          throw new NoSuchElementException();
        }
        @Override
        public int previousIndex()
        {
          return cursor-parent.rootOffset-1;
        }
        @Override
        public void remove()
        {
          final int lastRet;
          if((lastRet=this.lastRet)!=-1)
          {
            final Checked$<E>$ root;
            final SubList$<E>$  parent;
            int modCount;
            CheckedCollection.checkModCount(modCount=this.modCount,(root=(parent=this.parent).root).modCount);
            eraseIndexHelper(root.arr,lastRet,--root.size);
            bubbleUpDecrementSize(parent.parent);
            --parent.size;
            root.modCount=++modCount;
            parent.modCount=modCount;
            this.modCount=modCount;
            cursor=lastRet;
            this.lastRet=-1;
            return;
          }
          throw new IllegalStateException();
        }
        @Override
        public void set(final $exposedType$ val)
        {
          final int lastRet;
          if((lastRet=this.lastRet)!=-1)
          {
            final Checked$<E>$ root;
            CheckedCollection.checkModCount(modCount,(root=parent.root).modCount);
            root.arr[lastRet]=val;
            return;
          }
          throw new IllegalStateException();
        }
      }
    }
  }
  public static class CheckedStack$<E>$ extends Checked$<E>$ implements OmniStack.Of$ClassPrefix$$<E>$
  {
    public CheckedStack()
    {
      super();
    }
    public CheckedStack(final int capacity)
    {
      super(capacity);
    }
    public CheckedStack(final int size,final $ArrayType$[] arr)
    {
      super(size,arr);
    }
    @Override
    public Object clone()
    {
      final $ArrayType$[] arr;
      final int size;
      if((size=this.size)!=0)
      {
        ArrCopy.uncheckedCopy(this.arr,0,arr=new $ArrayType$[size],0,size);
      }
      else
      {
        arr=null;
      }
      return new CheckedStack$<E>$(size,arr);
    }
    @Override
    public boolean equals(final Object val)
    {
      //TODO implements equals method
      return false;
    }
    @Override
    public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
    {
      return new CheckedDescendingItr$<E>$(this);
    }
    #MACRO PollMethods(++modCount;)
    #MACRO CopyIntoArrayMethods<uncheckedReverseCopy>()
    @Override
    void uncheckedForEach(final int size,final $TypeNameModifier$Consumer$<? super E>$ action)
    {
      #MACRO TryCheckModCount(this,uncheckedReverseForEach(arr\,0\,size\,action);)
    }
    @Override
    int uncheckedHashCode(final int size)
    {
#IF OfRef
      #MACRO TryCheckModCount(this,return reverseHashCode(arr\,0\,size);)
#ELSE
      return reverseHashCode(arr,0,size);
#ENDIF
    }
#IF OfRef
    #MACRO UncheckedRemoveVal<Last>(!pred.test,,int size\,final Predicate<Object> pred,++this.modCount;)
    @Override
    boolean uncheckedremoveValNonNull(int size,final Object nonNull)
    {
      final var arr=this.arr;
      int index;
      #MACRO TryCheckModCount(this,#MACRO UncheckedConditionalLoop(\,index=--size\,!nonNull.equals(arr[index])\,--index\,index==0\,false))
      this.modCount=modCount+1;
      eraseIndexHelper(arr,index,size);
      this.size=size;
      return true;
    }
#ELSEIF OfDouble,OfFloat
    #MACRO UncheckedRemoveVal<Last>(0!=,0,int size,++this.modCount;)
    #MACRO UncheckedRemoveVal<Last>(bits!=$convertToBits$,Bits,int size\,final $queryParameterType$ bits,++this.modCount;)
    #MACRO UncheckedRemoveVal<Last>(!$BoxedType$.isNaN,NaN,int size,++this.modCount;)
#ELSEIF OfBoolean
    #MACRO UncheckedRemoveVal<Last>(val^,,int size\,final $queryParameterType$ val,++this.modCount;)
#ELSE
    #MACRO UncheckedRemoveVal<Last>(val!=,,int size\,final $queryParameterType$ val,++this.modCount;)
#ENDIF
    @Override
    void uncheckedToString(final int size,final StringBuilder builder)
    {
#IF OfRef
      #MACRO TryCheckModCount(this,reverseToString(arr\,0\,size\,builder);)
#ELSE
      reverseToString(arr,0,size,builder);
#ENDIF
    }
#IF OfRef
    private static class CheckedDescendingItr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
    private static class CheckedDescendingItr$<E>$ extends Abstract$TypeNameModifier$Itr implements OmniIterator.Of$ClassPrefix$$<E>$
#ENDIF
    {
      private transient final CheckedStack$<E>$ root;
      private transient int cursor;
      private transient int lastRet=-1;
      private transient int modCount;
      private CheckedDescendingItr(CheckedStack$<E>$ root)
      {
        this.root=root;
        cursor=root.size;
        modCount=root.modCount;
      }
      #MACRO ForEachMethods(CheckedDescendingItrForEachRemaining,)
      @Override
      public boolean hasNext()
      {
        return cursor!=0;
      }
      #MACRO SuppressUnchecked()
      @Override
      public $exposedType$ next$TypeNameModifier$()
      {
        final CheckedStack$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        int cursor;
        if((cursor=this.cursor)!=0)
        {
          lastRet=--cursor;
          this.cursor=cursor;
          return ($exposedType$)root.arr[cursor];
        }
        throw new NoSuchElementException();
      }
      @Override
      public void remove()
      {
        final int lastRet;
        if((lastRet=this.lastRet)!=-1)
        {
          final CheckedStack$<E>$ root;
          int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          eraseIndexHelper(root.arr,lastRet,--root.size);
          root.modCount=++modCount;
          this.modCount=modCount;
          this.lastRet=-1;
          return;
        }
        throw new IllegalStateException();
      }
      private void uncheckedForEachRemaining(int cursor,$TypeNameModifier$Consumer$<? super E>$ action)
      {
        final var root=this.root;
        #MACRO TryCheckModCount(root,uncheckedReverseForEach(root.arr\,0\,cursor\,action);)
        this.cursor=0;
        lastRet=0;
      }
    }
  }
  public static abstract class Unchecked$<E>$ extends $ClassPrefix$ArrSeq$<E>$
  {
    private Unchecked()
    {
      super();
    }
    private Unchecked(final int capacity)
    {
      super(capacity);
    }
    private Unchecked(final int size,final $ArrayType$[] arr)
    {
      super(size,arr);
    }
    @Override
    public boolean add(final $exposedType$ val)
    {
      super.push(val);
      return true;
    }
#IFNOT OfRef
    @Override
#ENDIF
    public void add(final int index,final $exposedType$ val)
    {
      final int size;
      if((size=this.size)!=0)
      {
        super.uncheckedInsert(index,val,size);
      }
      else
      {
        super.uncheckedInit(val);
      }
    }
#IF OfRef
    @Override
    public void clear()
    {
      final int size;
      if((size=this.size)!=0)
      {
        OmniArray.OfRef.nullifyRange(arr,0,size-1);
        this.size=0;
      }
    }
#ENDIF
    #MACRO SuppressUnchecked()
#IFNOT OfRef
    @Override
#ENDIF
    public $exposedType$ get$TypeNameModifier$(final int index)
    {
      return ($exposedType$)arr[index];
    }
#IFNOT OfRef
    @Override
#ENDIF
    public $exposedType$ $removeAtIndexMethod$(final int index)
    {
      final $ArrayType$[] arr;
      #MACRO SuppressUnchecked()
      final var removed=($exposedType$)(arr=this.arr)[index];
      eraseIndexHelper(arr,index,--size);
      return removed;
    }
    #MACRO SuppressUnchecked()
    @Override
    boolean uncheckedRemoveIf(int size,final $TypeNameModifier$Predicate$<? super E>$ filter)
    {
      int srcOffset;
#IF OfBoolean
      boolean v;
      if(filter.test(v=arr[srcOffset=0]))
      {
        for(;;)
        {
          if(++srcOffset==size)
          {
            this.size=0;
            break;
          }
          if(v^arr[srcOffset])
          {
            this.size=filter.test(v=!v)?0:pullSurvivorsDown(arr,0,srcOffset,size,v);
            break;
          }
        }
      }
      else
      {
        #MACRO UncheckedRemoveIfHelper(size,this.size)
      }
#ELSE
      srcOffset=0;
      #MACRO UncheckedRemoveIfHelper(size,dummyParam)
  #IF OfRef
      OmniArray.OfRef.nullifyRange(arr,srcOffset=pullSurvivorsDown(arr,srcOffset,--size,filter),size);
      this.size=srcOffset;
  #ELSE
      this.size=pullSurvivorsDown(arr,srcOffset,size-1,filter);
  #ENDIF
#ENDIF
      return true;
    }
  }
  public static class UncheckedList$<E>$ extends Unchecked$<E>$ implements OmniList.Of$ClassPrefix$$<E>$
  {
    public UncheckedList()
    {
      super();
    }
    public UncheckedList(final int capacity)
    {
      super(capacity);
    }
    public UncheckedList(final int size,final $ArrayType$[] arr)
    {
      super(size,arr);
    }
    @Override
    public Object clone()
    {
      final $ArrayType$[] arr;
      final int size;
      if((size=this.size)!=0)
      {
        ArrCopy.uncheckedCopy(this.arr,0,arr=new $ArrayType$[size],0,size);
      }
      else
      {
        arr=null;
      }
      return new UncheckedList$<E>$(size,arr);
    }
    @Override
    public boolean equals(final Object val)
    {
      //TODO implements equals method
      return false;
    }
    @Override
    public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
    {
      return new AscendingItr$<E>$(this);
    }
    @Override
    public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
    {
      return new BidirectionalItr$<E>$(this);
    }
    @Override
    public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(final int index)
    {
      return new BidirectionalItr$<E>$(this,index);
    }
    @Override
    public void put(final int index,final $exposedType$ val)
    {
      arr[index]=val;
    }
    #MACRO UncheckedRootModifyingFunc(replaceAll,final $UnaryOperator$$<E>$ operator,0!=,$ClassPrefix$ArrSeq,replaceAll,size\,operator)
    #MACRO UncheckedRootModifyingFunc(reverseSort,,1<,$ClassPrefix$SortUtil,reverseSort,size-1)
    #MACRO UncheckedRootModifyingFunc(sort,,1<,$ClassPrefix$SortUtil,sort,size-1)
    #MACRO UncheckedRootModifyingFunc(sort,final $Comparator$$<? super E>$ sorter,1<,$ClassPrefix$SortUtil,comparatorSort,size-1\,sorter)
#IFNOT OfRef
    #MACRO UncheckedRootModifyingFunc(replaceAll,final UnaryOperator<$BoxedType$> operator,0!=,$ClassPrefix$ArrSeq,replaceAll,size\,operator::apply)
    #MACRO UncheckedRootModifyingFunc(sort,final Comparator<? super $BoxedType$> sorter,1<,$ClassPrefix$SortUtil,comparatorSort,size-1\,sorter::compare)
#ENDIF
    @Override
    public OmniList.Of$ClassPrefix$$<E>$ subList(final int fromIndex,final int toIndex)
    {
      return new SubList$<E>$(this,fromIndex,toIndex-fromIndex);
    }
    #MACRO CopyIntoArrayMethods<uncheckedCopy>()
    @Override
    void uncheckedForEach(final int size,final $TypeNameModifier$Consumer$<? super E>$ action)
    {
      uncheckedForwardForEach(arr,0,size,action);
    }
    @Override
    int uncheckedHashCode(final int size)
    {
      return forwardHashCode(arr,0,size);
    }
    #MACRO UncheckedRemoveFirstMethods<First>()
    @Override
    void uncheckedToString(final int size,final StringBuilder builder)
    {
      forwardToString(arr,0,size,builder);
    }
#IF OfRef
    private static class AscendingItr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
    private static class AscendingItr$<E>$ extends Abstract$TypeNameModifier$Itr implements OmniIterator.Of$ClassPrefix$$<E>$
#ENDIF
    {
      private transient final UncheckedList$<E>$ root;
      private transient int cursor;
      private AscendingItr(UncheckedList$<E>$ root)
      {
        this.root=root;
      }
      #MACRO ForEachMethods(UncheckedAscendingItrForEachRemaining,)
      @Override
      public boolean hasNext()
      {
        return cursor!=root.size;
      }
      #MACRO SuppressUnchecked()
      @Override
      public $exposedType$ next$TypeNameModifier$()
      {
        return ($exposedType$)root.arr[cursor++];
      }
      @Override
      public void remove()
      {
        final UncheckedList$<E>$ root;
        eraseIndexHelper((root=this.root).arr,--cursor,--root.size);
      }
    }
    private static class BidirectionalItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>$
    {
      private transient final UncheckedList$<E>$ root;
      private transient int cursor;
      private transient int lastRet;
      private BidirectionalItr(final UncheckedList$<E>$ root)
      {
        this.root=root;
      }
      private BidirectionalItr(final UncheckedList$<E>$ root,final int cursor)
      {
        this.root=root;
        this.cursor=cursor;
      }
      @Override
      public void add(final $exposedType$ val)
      {
        final $ClassPrefix$ArrSeq$<E>$ root;
        final int rootSize,cursor=this.cursor;
        if((rootSize=(root=this.root).size)!=0)
        {
          root.uncheckedInsert(cursor,val,rootSize);
        }
        else
        {
          root.uncheckedInit(val);
        }
        this.cursor=cursor+1;
      }
      #MACRO ForEachMethods(UncheckedBidirectionalItrForEachRemaining,)
      @Override
      public boolean hasNext()
      {
         return cursor!=root.size;
      }
      @Override
      public boolean hasPrevious()
      {
        return cursor!=0;
      }
      #MACRO SuppressUnchecked()
      @Override
      public $exposedType$ next$TypeNameModifier$()
      {
        final int lastRet;
        this.lastRet=lastRet=cursor++;
        return ($exposedType$)root.arr[lastRet];
      }
      @Override
      public int nextIndex()
      {
        return cursor;
      }
      #MACRO SuppressUnchecked()
      @Override
      public $exposedType$ previous$TypeNameModifier$()
      {
        final int lastRet;
        this.lastRet=lastRet=--cursor;
        return ($exposedType$)root.arr[lastRet];
      }
      @Override
      public int previousIndex()
      {
        return cursor-1;
      }
      @Override
      public void remove()
      {
        final UncheckedList$<E>$ root;
        final int lastRet;
        eraseIndexHelper((root=this.root).arr,lastRet=this.lastRet,--root.size);
        cursor=lastRet;
      }
      @Override
      public void set($exposedType$ val)
      {
        root.arr[lastRet]=val;
      }
    }
#IF OfRef
    private static class SubList$<E>$ extends AbstractSeq implements OmniList.Of$ClassPrefix$$<E>$
#ELSE
    private static class SubList$<E>$ extends Abstract$ClassPrefix$List$<E>$ implements OmniList.Of$ClassPrefix$$<E>$
#ENDIF
    {
      #MACRO BubbleUp(DecrementSize,,--parent.size;)
      #MACRO BubbleUp(DecrementSize,\,final int numToRemove,parent.size-=numToRemove;)
      #MACRO BubbleUp(IncrementSize,,++parent.size;)
      transient final Unchecked$<E>$ root;
      transient final SubList$<E>$ parent;
      transient final int rootOffset;
      private SubList(final Unchecked$<E>$ root,final int rootOffset,final int size)
      {
        super(size);
        this.root=root;
        this.parent=null;
        this.rootOffset=rootOffset;
      }
      private SubList(final Unchecked$<E>$ root,final SubList$<E>$ parent,final int rootOffset,final int size)
      {
        super(size);
        this.root=root;
        this.parent=parent;
        this.rootOffset=rootOffset;
      }
      @Override
      public boolean add(final $exposedType$ val)
      {
        final $ClassPrefix$ArrSeq$<E>$ root;
        final int rootSize;
        final int size=this.size;
        if((rootSize=(root=this.root).size)!=0)
        {
          root.uncheckedInsert(size+rootOffset,val,rootSize);
        }
        else
        {
          root.uncheckedInit(val);
        }
        this.size=size+1;
        bubbleUpIncrementSize(parent);
        return true;
      }
      @Override
      public void add(final int index,final $exposedType$ val)
      {
        final $ClassPrefix$ArrSeq$<E>$ root;
        final int rootSize;
        if((rootSize=(root=this.root).size)!=0)
        {
          root.uncheckedInsert(index+rootOffset,val,rootSize);
        }
        else
        {
          root.uncheckedInit(val);
        }
        ++size;
        bubbleUpIncrementSize(parent);
      }
      @Override
      public void clear()
      {
        int size;
        if((size=this.size)!=0)
        {
          this.size=0;
          bubbleUpDecrementSize(parent,size);
          final int newRootSize;
          final Unchecked$<E>$ root;
#IF OfRef
          final int oldRootSize;
          (root=this.root).size=newRootSize=(oldRootSize=root.size)-size;
#ELSE
          (root=this.root).size=newRootSize=root.size-size;
#ENDIF
          final $ArrayType$[] arr;
          ArrCopy.semicheckedCopy(arr=root.arr,size+(size=rootOffset),arr,size,newRootSize-size);
#IF OfRef
          OmniArray.OfRef.nullifyRange(arr,newRootSize,oldRootSize-1);
#ENDIF
        }
      }
      @Override
      public Object clone()
      {
        final $ArrayType$[] arr;
        final int size;
        if((size=this.size)!=0)
        {
          ArrCopy.uncheckedCopy(root.arr,rootOffset,arr=new $ArrayType$[size],0,size);
        }
        else
        {
          arr=null;
        }
        return new UncheckedList$<E>$(size,arr);
      }
      #MACRO UncheckedSubListQueryObject(boolean,contains,false)
      #MACRO UncheckedSubListQueryObject(int,indexOf,-1)
      #MACRO UncheckedSubListQueryObject(int,lastIndexOf,-1)
      #MACRO QueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,contains,false,this,size,,@Override)
#IF OfFloat
      @Override
      protected boolean containsRawInt(int val)
      {
        final int size;
        if((size=this.size)!=0)
        {
          final int rootOffset;
          return uncheckedcontainsRawInt(root.arr,rootOffset=this.rootOffset,rootOffset+size,val);
        }
        return false;
      }
#ENDIF    
      @Override
      public boolean equals(Object val)
      {
        //TODO implements equals method
        return false;
      }
      #MACRO ForEachMethods(UncheckedSubListForEach,)
      #MACRO SuppressUnchecked()
      @Override
      public $exposedType$ get$TypeNameModifier$(int index)
      {
        return ($exposedType$)root.arr[index+rootOffset];
      }
      @Override
      public int hashCode()
      {
        final int size;
        if((size=this.size)!=0)
        {
          final int rootOffset;
          return forwardHashCode(root.arr,rootOffset=this.rootOffset,rootOffset+size);
        }
        return 1;
      }
      #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,indexOf,-1,this,size,,@Override)
      #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,lastIndexOf,-1,this,size,,@Override)
      @Override
      public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
      {
        return new AscendingItr$<E>$(this);
      }
      @Override
      public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
      {
        return new BidirectionalItr$<E>$(this);
      }
      @Override
      public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index)
      {
        return new BidirectionalItr$<E>$(this,index+rootOffset);
      }
      @Override
      public void put(int index,$exposedType$ val)
      {
        root.arr[index+rootOffset]=val;
      }     
      @Override
      public boolean remove(Object val)
      {
        final int size;
        if((size=this.size)!=0)
        {
#IFNOT OfRef
          if(val instanceof $BoxedType$)
#ENDIF
          {
            return uncheckedremoveVal(size,$queryCastRef$(val));
          }
        }
        return false;
      }
      #MACRO QueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,removeVal,false,this,size,,@Override)
#IF OfFloat
      @Override
      protected boolean removeValRawInt(int val)
      {
        final int size;
        if((size=this.size)!=0)
        {
          return uncheckedremoveValRawInt(size,val);
        }
        return false;
      }
      #MACRO UncheckedDoubleFloatQuery(int,indexOf,RawInt,int,0!=,0)
      #MACRO UncheckedDoubleFloatQuery(int,lastIndexOf,RawInt,int,0!=,0)
#ENDIF
      @Override
      public $exposedType$ $removeAtIndexMethod$(int index)
      {
        final Unchecked$<E>$ root;
        final $ArrayType$[] arr;
        #MACRO SuppressUnchecked()
        final var removed=($exposedType$)(arr=(root=this.root).arr)[index+=rootOffset];
        eraseIndexHelper(arr,index,--root.size);
        bubbleUpDecrementSize(parent);
        --size;
        return removed;
      }
      #MACRO RemoveIf($TypeNameModifier$Predicate$<? super E>$,filter,)
      #MACRO UncheckedSubListModifyingFunc(replaceAll,final $UnaryOperator$$<E>$ operator,0!=,$ClassPrefix$ArrSeq,replaceAll,size\,operator)
      #MACRO UncheckedSubListModifyingFunc(reverseSort,,1<,$ClassPrefix$SortUtil,reverseSort,size-1)
      #MACRO UncheckedSubListModifyingFunc(sort,,1<,$ClassPrefix$SortUtil,sort,size-1)
      #MACRO UncheckedSubListModifyingFunc(sort,final $Comparator$$<? super E>$ sorter,1<,$ClassPrefix$SortUtil,comparatorSort,size-1\,sorter)
#IFNOT OfRef
      #MACRO UncheckedSubListModifyingFunc(replaceAll,final UnaryOperator<$BoxedType$> operator,0!=,$ClassPrefix$ArrSeq,replaceAll,size\,operator::apply)
      #MACRO UncheckedSubListModifyingFunc(sort,final Comparator<? super $BoxedType$> sorter,1<,$ClassPrefix$SortUtil,comparatorSort,size-1\,sorter::compare)
      #MACRO RemoveIf(Predicate<? super $BoxedType$>,filter::test,)    
#ENDIF
      @Override
      public $exposedType$ set(int index,$exposedType$ val)
      {
        final $ArrayType$[] arr;
        #MACRO SuppressUnchecked()
        final var oldVal=($exposedType$)(arr=root.arr)[index+=rootOffset];
        arr[index]=val;
        return oldVal;
      }
      @Override
      public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
      {
        return new SubList$<E>$(root,this,this.rootOffset+fromIndex,toIndex-fromIndex);
      }
      #MACRO ToArrayMethods(ArrCopy.uncheckedCopy(root.arr\\,rootOffset\\,dst=new retType[size]\\,0\\,size);,)
      @Override
      public <T> T[] toArray(IntFunction<T[]> arrConstructor)
      {
        final int size;
        final T[] dst=arrConstructor.apply(size=this.size);
        if(size!=0)
        {
          ArrCopy.uncheckedCopy(root.arr,rootOffset,dst,0,size);
        }
        return dst;
      }
      @Override
      public <T> T[] toArray(T[] arr)
      {
        final int size;
        if((size=this.size)!=0)
        {
          ArrCopy.uncheckedCopy(root.arr,rootOffset,arr=OmniArray.uncheckedArrResize(size,arr),0,size);
        }
        else if(arr.length!=0)
        {
          arr[0]=null;
        }
        return arr;
      }
      @Override
      public String toString()
      {
        final int size;
        if((size=this.size)!=0)
        {
          final StringBuilder builder;
          final int rootOffset;
          forwardToString(root.arr,rootOffset=this.rootOffset,rootOffset+size,builder=new StringBuilder("["));
          return builder.append(']').toString();
        }
        return "[]";
      }
#IF OfRef
      #MACRO UncheckedSubListQuery(boolean,contains,int size\,Predicate<Object> pred,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,pred)
#ELSEIF OfDouble,OfFloat
      #MACRO UncheckedSubListQuery(boolean,containsBits,int size\,$queryParameterType$ bits,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,bits)
      #MACRO UncheckedSubListQuery(boolean,containsNaN,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedSubListQuery(boolean,contains0,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedDoubleFloatQuery(boolean,contains,,$exposedType$,val==,NaN)
#ELSE
      #MACRO UncheckedSubListQuery(boolean,contains,int size\,$queryParameterType$ val,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,val)
#ENDIF
#IF OfRef
      #MACRO UncheckedSubListQuery(int,indexOf,int size\,Predicate<Object> pred,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,pred)
      #MACRO UncheckedSubListQuery(int,lastIndexOf,int size\,Predicate<Object> pred,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,pred)
#ELSEIF OfDouble,OfFloat
      #MACRO UncheckedSubListQuery(int,indexOfBits,int size\,$queryParameterType$ bits,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,bits)
      #MACRO UncheckedSubListQuery(int,indexOfNaN,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedSubListQuery(int,indexOf0,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedDoubleFloatQuery(int,indexOf,,$exposedType$,val==,NaN)
      #MACRO UncheckedSubListQuery(int,lastIndexOfBits,int size\,$queryParameterType$ bits,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,bits)
      #MACRO UncheckedSubListQuery(int,lastIndexOfNaN,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedSubListQuery(int,lastIndexOf0,int size,root.arr\,rootOffset=this.rootOffset\,rootOffset+size)
      #MACRO UncheckedDoubleFloatQuery(int,lastIndexOf,,$exposedType$,val==,NaN)
#ELSE
      #MACRO UncheckedSubListQuery(int,indexOf,int size\,$queryParameterType$ val,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,val)
      #MACRO UncheckedSubListQuery(int,lastIndexOf,int size\,$queryParameterType$ val,root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,val)
#ENDIF
      #MACRO SuppressUnchecked()
      private boolean uncheckedRemoveIf(int size,final $TypeNameModifier$Predicate$<? super E>$ filter)
      {
        final Unchecked$<E>$ root;
        int srcOffset;
        final int srcBound=(srcOffset=rootOffset)+size;
#IF OfBoolean
        int dstOffset;
        final boolean[] arr;
        boolean v;
        if(filter.test(v=(arr=(root=this.root).arr)[srcOffset]))
        {
          dstOffset=srcOffset;
          for(;;)
          {
            if(++srcOffset==srcBound)
            {
              break;
            }
            if(v^arr[srcOffset])
            {
              if(!filter.test(v=!v))
              {
                dstOffset=pullSurvivorsDown(arr,dstOffset,srcOffset,srcBound,v);
              }
              break;
            }
          }
        }
        else
        {
          #MACRO UncheckedRemoveIfHelper(srcBound,dstOffset)
        }
        this.size=size-(size=(($ClassPrefix$ArrSeq$<E>$)root).finalizeSubListBatchRemove(arr,dstOffset,srcBound));
#ELSE
        final var arr=(root=this.root).arr;
        #MACRO UncheckedRemoveIfHelper(srcBound,dummyParam)
        this.size=size-(size=(($ClassPrefix$ArrSeq$<E>$)root).finalizeSubListBatchRemove(arr,pullSurvivorsDown(arr,srcOffset,srcBound-1,filter),srcBound));
#ENDIF
        bubbleUpDecrementSize(parent,size);
        return true;
      }
#IF OfRef
      #MACRO UncheckedSubListRemoveVal(!pred.test,,int size\,Predicate<Object> pred)
#ELSEIF OfDouble,OfFloat
      #MACRO UncheckedDoubleFloatQuery(boolean,removeVal,,$exposedType$,val==,NaN)
  #IF OfFloat
      #MACRO UncheckedDoubleFloatQuery(boolean,removeVal,RawInt,int,0!=,0)
  #ENDIF
      #MACRO UncheckedSubListRemoveVal(bits!=$convertToBits$,Bits,int size\,$queryParameterType$ bits)
      #MACRO UncheckedSubListRemoveVal(0!=,0,int size)
      #MACRO UncheckedSubListRemoveVal(!$BoxedType$.isNaN,NaN,int size)
#ELSEIF OfBoolean
      #MACRO UncheckedSubListRemoveVal(val^,,int size\,$queryParameterType$ val)
#ELSE
      #MACRO UncheckedSubListRemoveVal(val!=,,int size\,$queryParameterType$ val)
#ENDIF
#IF OfRef
      private static class AscendingItr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
      private static class AscendingItr$<E>$ extends Abstract$TypeNameModifier$Itr implements OmniIterator.Of$ClassPrefix$$<E>$
#ENDIF
      {
        private transient final SubList$<E>$ parent;
        private transient int cursor;
        private AscendingItr(SubList$<E>$ parent)
        {
           this.parent=parent;
           this.cursor=parent.rootOffset;
        }
        #MACRO ForEachMethods(UncheckedSubItrForEachRemaining,\,)
        @Override
        public boolean hasNext()
        {
          final SubList$<E>$ parent;
          return cursor!=(parent=this.parent).rootOffset+parent.size;
        }
        #MACRO SuppressUnchecked()
        @Override
        public $exposedType$ next$TypeNameModifier$()
        {
          return ($exposedType$)parent.root.arr[cursor++];
        }
        @Override
        public void remove()
        {
          final SubList$<E>$ parent;
          final Unchecked$<E>$ root;
          eraseIndexHelper((root=(parent=this.parent).root).arr,--cursor,--root.size);
          bubbleUpDecrementSize(parent.parent);
          --parent.size;
        }
      }
      private static class BidirectionalItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>$
      {
        private transient final SubList$<E>$ parent;
        private transient int cursor;
        private transient int lastRet;
        private BidirectionalItr(final SubList$<E>$ parent)
        {
          this.parent=parent;
          this.cursor=parent.rootOffset;
        }
        private BidirectionalItr(final SubList$<E>$ parent,final int cursor)
        {
          this.parent=parent;
          this.cursor=cursor;
        }
        @Override
        public void add(final $exposedType$ val)
        {
          final SubList$<E>$ parent;
          final $ClassPrefix$ArrSeq$<E>$ root;
          final int rootSize,cursor=this.cursor;
          if((rootSize=(root=(parent=this.parent).root).size)!=0)
          {
            root.uncheckedInsert(cursor,val,rootSize);
          }
          else
          {
            root.uncheckedInit(val);
          }
          bubbleUpIncrementSize(parent.parent);
          ++parent.size;
          this.cursor=cursor+1;
        }
        #MACRO ForEachMethods(UncheckedSubItrForEachRemaining,\,lastRet=bound-1;)
        @Override
        public boolean hasNext()
        {
          final SubList$<E>$ parent;
          return cursor!=(parent=this.parent).rootOffset+parent.size;
        }
        @Override
        public boolean hasPrevious()
        {
          return cursor!=parent.rootOffset;
        }
        #MACRO SuppressUnchecked()
        @Override
        public $exposedType$ next$TypeNameModifier$()
        {
          final int lastRet;
          this.lastRet=lastRet=cursor++;
          return ($exposedType$)parent.root.arr[lastRet];
        }
        @Override
        public int nextIndex()
        {
          return cursor-parent.rootOffset;
        }
        #MACRO SuppressUnchecked()
        @Override
        public $exposedType$ previous$TypeNameModifier$()
        {
          final int lastRet;
          this.lastRet=lastRet=--cursor;
          return ($exposedType$)parent.root.arr[lastRet];
        }
        @Override
        public int previousIndex()
        {
          return cursor-parent.rootOffset-1;
        }
        @Override
        public void remove()
        {
          final SubList$<E>$ parent;
          final Unchecked$<E>$ root;
          final int lastRet;
          eraseIndexHelper((root=(parent=this.parent).root).arr,lastRet=this.lastRet,--root.size);
          bubbleUpDecrementSize(parent.parent);
          --parent.size;
          cursor=lastRet;
        }
        @Override
        public void set($exposedType$ val)
        {
          parent.root.arr[lastRet]=val;
        }
      }
    }
  }
  public static class UncheckedStack$<E>$ extends Unchecked$<E>$ implements OmniStack.Of$ClassPrefix$$<E>$
  {
    public UncheckedStack()
    {
      super();
    }
    public UncheckedStack(final int capacity)
    {
      super(capacity);
    }
    public UncheckedStack(final int size,final $ArrayType$[] arr)
    {
      super(size,arr);
    }
    @Override
    public Object clone()
    {
      final $ArrayType$[] arr;
      final int size;
      if((size=this.size)!=0)
      {
        ArrCopy.uncheckedCopy(this.arr,0,arr=new $ArrayType$[size],0,size);
      }
      else
      {
        arr=null;
      }
      return new UncheckedStack$<E>$(size,arr);
    }
    @Override
    public boolean equals(final Object val)
    {
      //TODO implements equals method
      return false;
    }
    @Override
    public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
    {
      return new UncheckedDescendingItr$<E>$(this);
    }
    #MACRO PollMethods( )
    #MACRO CopyIntoArrayMethods<uncheckedReverseCopy>()
    @Override
    void uncheckedForEach(final int size,final $TypeNameModifier$Consumer$<? super E>$ action)
    {
      uncheckedReverseForEach(arr,0,size,action);
    }
    @Override
    int uncheckedHashCode(final int size)
    {
      return reverseHashCode(arr,0,size);
    }
    #MACRO UncheckedRemoveFirstMethods<Last>()
    @Override
    void uncheckedToString(final int size,final StringBuilder builder)
    {
      reverseToString(arr,0,size,builder);
    }
#IF OfRef
    private static class UncheckedDescendingItr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
    private static class UncheckedDescendingItr$<E>$ extends Abstract$ClassPrefix$Itr implements OmniIterator.Of$ClassPrefix$$<E>$
#ENDIF
    {
      private transient final UncheckedStack$<E>$ root;
      private transient int cursor;
      private UncheckedDescendingItr(UncheckedStack$<E>$ root)
      {
        this.root=root;
        cursor=root.size;
      }
      #MACRO ForEachMethods(UncheckedDescendingItrForEachRemaining,)
      @Override
      public boolean hasNext()
      {
        return cursor!=0;
      }
      #MACRO SuppressUnchecked()
      @Override
      public $exposedType$ next$TypeNameModifier$()
      {
        return ($exposedType$)root.arr[--cursor];
      }
      @Override
      public void remove()
      {
        final UncheckedStack$<E>$ root;
        eraseIndexHelper((root=this.root).arr,cursor,--root.size);
      }
    }
  }
}
#MACRODEF StaticDoubleFloatQuery<MethodName,Suffix>()
private static
#IFSWITCH MethodName==contains
boolean
#ELSE
int
#ENDIF
#IFSWITCH Suffix==NaN
uncheckedMethodName
#ELSE
uncheckedMethodNameRawInt
#ENDIF
($ArrayType$[] arr
#IFSWITCH MethodName==contains
,int offset
#ENDIF
,int bound,$exposedType$ val)
{
#IFSWITCH Suffix==NaN
  if(val==val)
#ELSE
  if(val!=0)
#ENDIF
  {
    return uncheckedMethodNameBits(arr
#IFSWITCH MethodName==contains
    ,0
#ENDIF
    ,bound,$convertToBits$(val));
  }
  return uncheckedMethodNameSuffix(arr
#IFSWITCH MethodName==contains
  ,0
#ENDIF
  ,bound);
}
#ENDDEF
#MACRODEF StaticContains(Suffix,param,indexTest)
static boolean uncheckedcontainsSuffix($ArrayType$[] arr,int offset,int boundparam)
{
  #MACRO UncheckedConditionalLoop(,,indexTest(arr[offset]),,++offset==bound,false)
  return true;
}
#ENDDEF
#MACRODEF StaticRelativeIndexOf(Suffix,param,indexTest)
private static int uncheckedindexOfSuffix($ArrayType$[] arr,int offset,int boundparam)
{
  #MACRO UncheckedConditionalLoop(int index;,index=offset,indexTest(arr[index]),,++index==bound,-1)
  return index-offset;
}
#ENDDEF
#MACRODEF StaticAbsoluteIndexOf(Suffix,param,indexTest)
private static int uncheckedindexOfSuffix($ArrayType$[] arr,int boundparam)
{
  #MACRO UncheckedConditionalLoop(int index;,index=0,indexTest(arr[index]),,++index==bound,-1)
  return index;
}
#ENDDEF
#MACRODEF StaticRelativeLastIndexOf(Suffix,param,indexTest)
private static int uncheckedlastIndexOfSuffix($ArrayType$[] arr,int offset,int boundparam)
{
  #MACRO UncheckedConditionalLoop(,,indexTest(arr[--bound]),,bound==offset,-1)
  return bound-offset;
}
#ENDDEF
#MACRODEF StaticAbsoluteLastIndexOf(Suffix,param,indexTest)
private static int uncheckedlastIndexOfSuffix($ArrayType$[] arr,int boundparam)
{
  #MACRO UncheckedConditionalLoop(,,indexTest(arr[--bound]),,bound==0,-1)
  return bound;
}
#ENDDEF
#MACRODEF StaticSearch(Suffix,param,indexTest)
private static int uncheckedsearchSuffix($ArrayType$[] arr,int boundparam)
{
  #MACRO UncheckedConditionalLoop(int index;,index=bound-1,indexTest(arr[index]),--index,index==0,-1)
  return bound-index;
}
#ENDDEF
#MACRODEF StaticQueryMethods(MacroName)
#IF OfRef
#MACRO MacroName(,\,Predicate<Object> pred,!pred.test)
#ELSEIF OfDouble,OfFloat
#MACRO MacroName(0,,0!=)
#MACRO MacroName(Bits,\,$queryParameterType$ bits,bits!=$convertToBits$)
#MACRO MacroName(NaN,,!$BoxedType$.isNaN)
#ELSEIF OfBoolean
#MACRO MacroName(,\,$queryParameterType$ val,val^) 
#ELSE
#MACRO MacroName(,\,$queryParameterType$ val,val!=)
#ENDIF
#ENDDEF
#MACRODEF CheckedRootQueryObject(retType,methodName,checkedBoundParam,boundParam,negRet)
#IF OfRef
@Override
public retType methodName(final Object val)
{
  final int size;
  if((size=this.size)!=0)
  {
    final var arr=this.arr;
    if(val!=null)
    {
      #MACRO TryCheckModCount(this,return uncheckedmethodName(arr\,checkedBoundParam\,val::equals);)
    }
    return $ClassPrefix$ArrSeq.uncheckedmethodName(arr,boundParam,Objects::isNull);
  }
  return negRet;
}
#ENDIF
#ENDDEF
#MACRODEF RootQueryObject(retType,methodName,negRet,lowerBoundParam,override)
override
public retType methodName(final Object val)
{
  final int size;
  if((size=this.size)!=0)
  {
#IFNOT OfRef
    if(val instanceof $BoxedType$)
#ENDIF
    {
      return $ClassPrefix$ArrSeq.uncheckedmethodName(arrlowerBoundParam,size,$queryCastRef$(val));
    }
  }
  return negRet;
}
#ENDDEF
#MACRODEF Peek(retType,Suffix,cast,defaultVal)
#MACRO SuppressUnchecked()
public retType peekSuffix()
{
  final int size;
  if((size=this.size)!=0)
  {
    return cast(arr[size-1]);
  }
  return defaultVal;
}
#ENDDEF
#MACRODEF CheckedRootTryModifyFunc(methodName,sigParam,sizeCheck,target,sizeParam,uncheckedMethodName,uncheckedMethodParam)
@Override
public void methodName(final sigParam)
{
  final int size;
  if(sizeCheck((size=this.size)))
  {
    #MACRO TryCheckModCount(this,target.uncheckeduncheckedMethodName(arr\,0\,sizeParam\,uncheckedMethodParam);)
    this.modCount=modCount+1;
  }
}
#ENDDEF
#MACRODEF CheckedRootSortNoComparator(sortMethod)
public void sortMethod()
{
  final int size;
  if((size=this.size)>1)
  {
#IF OfRef
    #MACRO TryCheckModCount(this,$ClassPrefix$SortUtil.uncheckedsortMethod(arr\,0\,size-1);)
    this.modCount=modCount+1;
#ELSE
     $ClassPrefix$SortUtil.uncheckedsortMethod(arr,0,size-1);
     ++this.modCount;
#ENDIF
  }
}
#ENDDEF
#MACRODEF CheckedBidirectionalItrForEachRemaining(Consumer,consumerParam)
@Override
public void forEachRemaining(final Consumer action)
{
  final int cursor,bound;
  final Checked$<E>$ root;
  if((cursor=this.cursor)!=(bound=(root=this.root).size))
  {
    #MACRO TryCheckModCount(root,uncheckedForwardForEach(root.arr\,cursor\,bound\,consumerParam);)
  }
}
#ENDDEF
#MACRODEF CheckedSubListQueryObject(retType,methodName,negRet)
@Override
public retType methodName(final Object val)
{
  final int size;
  if((size=this.size)!=0)
  {
#IF OfRef
    if(val!=null)
    {
      return uncheckedmethodNameNonNull(size,val);
    }
    return uncheckedmethodName(size,Objects::isNull);
#ELSE
    if(val instanceof $BoxedType$)
    {
      return uncheckedmethodName(size,$queryCastRef$(val));
    }
#ENDIF
  }
  CheckedCollection.checkModCount(modCount,root.modCount);
  return negRet;
}
#ENDDEF
#MACRODEF CheckedSubListRawIntQuery(methodName)
@Override
protected boolean methodNameRawInt(final int val)
{
  final int size;
  if((size=this.size)!=0)
  {
    if(val!=0)
    {
      return uncheckedmethodNameBits(size,$convertToBits$(val));
    }
    return uncheckedmethodName0(size);
  }
  CheckedCollection.checkModCount(modCount,root.modCount);
  return false;
}
#ENDDEF
#MACRODEF CheckedSubListSortNoComparator(methodName)
@Override
public void methodName()
{
  #MACRO SubListCheckModCount()
  final int size;
  if((size=this.size)>1)
  {
    final int rootOffset;
    $ClassPrefix$SortUtil.uncheckedmethodName(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
    #MACRO SubListIncrementModCount()
  }
}
#ENDDEF
#MACRODEF CheckedSubListTryModify(methodSig,sizeCheck,uncheckedMethodCall)
@Override
public void methodSig
{
  final var root=this.root;
  final int size;
  if(sizeCheck(size=this.size))
  {
    #MACRO TryCheckModCount(root,final int rootOffset;uncheckedMethodCall)
    #MACRO SubListIncrementModCount()
  }
  else
  {
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
}
#ENDDEF
#MACRODEF UncheckedNonNullSubListQuery(retType,methodName)
private retType uncheckedmethodNameNonNull(final int size,final Object nonNull)
{
  final var root=this.root;
  #MACRO TryCheckModCount(root,final int rootOffset;return $ClassPrefix$ArrSeq.uncheckedmethodName(root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,nonNull::equals);)
}
#ENDDEF
#MACRODEF CheckedSubListRemoveVal(indexTest,Suffix,methodParams)
private boolean uncheckedremoveValSuffix(methodParams)
{
  #MACRO SubListCheckModCount()
  #MACRO UncheckedConditionalLoop(final var arr=root.arr;int index;final int bound=(index=this.rootOffset)+(--size);,,indexTest(arr[index]),,++index==bound,false)
  root.modCount=++modCount;
  bubbleUpDecrementSize(parent);
  this.modCount=modCount;
  eraseIndexHelper(arr,index,--root.size);
  this.size=size;
  return true;
}
#ENDDEF
#MACRODEF CheckedBidirectionalSubItrForEachRemaining(Consumer,consumerParam)
@Override
public void forEachRemaining(final Consumer action)
{
  final int cursor,bound;
  final SubList$<E>$ parent;
  if((cursor=this.cursor)!=(bound=(parent=this.parent).rootOffset+parent.size))
  {
    final var root=parent.root;
    #MACRO TryCheckModCount(root,uncheckedForwardForEach(root.arr\,cursor\,bound\,consumerParam);)
    this.cursor=bound;
    lastRet=bound-1;
  }
}
#ENDDEF
#MACRODEF CheckedDescendingItrForEachRemaining(consumerParam,uncheckedConsumerParam)
@Override
public void forEachRemaining(consumerParam action)
{
  final int cursor;
  if((cursor=this.cursor)!=0)
  {
    uncheckedForEachRemaining(cursor,uncheckedConsumerParam);
  }
}
#ENDDEF
#MACRODEF UncheckedRootModifyingFunc(methodName,sigParam,sizeCheck,target,uncheckedMethodName,uncheckedMethodParams)
@Override
public void methodName(sigParam)
{
  final int size;
  if(sizeCheck((size=this.size)))
  {
    target.uncheckeduncheckedMethodName(arr,0,uncheckedMethodParams);
  }
}
#ENDDEF
#MACRODEF UncheckedAscendingItrForEachRemaining(consumerParam,uncheckedConsumerParam)
@Override
public void forEachRemaining(consumerParam action)
{
  final UncheckedList$<E>$ root;
  final int cursor,bound;
  if((cursor=this.cursor)!=(bound=(root=this.root).size))
  {
    uncheckedForwardForEach(root.arr,cursor,bound,uncheckedConsumerParam);
    this.cursor=bound;
  }
}
#ENDDEF
#MACRODEF UncheckedBidirectionalItrForEachRemaining(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  final int cursor,bound;
  final Unchecked$<E>$ root;
  if((cursor=this.cursor)!=(bound=(root=this.root).size))
  {
    uncheckedForwardForEach(root.arr,cursor,bound,consumerParam);
    this.cursor=bound;
    lastRet=bound-1;
  }
}
#ENDDEF
#MACRODEF UncheckedSubListQueryObject(retType,methodName,negRet)
@Override
public retType methodName(Object val)
{
  final int size;
  if((size=this.size)!=0)
  {
#IFNOT OfRef
    if(val instanceof $BoxedType$)
#ENDIF
    {
      return uncheckedmethodName(size,$queryCastRef$(val));
    }
  }
  return negRet;
}
#ENDDEF

#MACRODEF RootForEach(Consumer,consumerParam)
@Override
public void forEach(final Consumer action)
{
  final int size;
  if((size=this.size)!=0)
  {
    uncheckedForEach(size,consumerParam);
  }
}
#ENDDEF
#MACRODEF CheckedSubListForEach(parameterType,paramCast)
@Override
public void forEach(final parameterType action)
{
  final var root=this.root;
  #MACRO TryCheckModCount(root,final int size;if((size=this.size)!=0){final int rootOffset;uncheckedForwardForEach(root.arr\,rootOffset=this.rootOffset\,rootOffset+size\,paramCast);})
}
#ENDDEF
#MACRODEF UncheckedSubListForEach(Consumer,consumerParam)
@Override
public void forEach(Consumer action)
{
  final int size;
  if((size=this.size)!=0)
  {
    final int rootOffset;
    uncheckedForwardForEach(root.arr,rootOffset=this.rootOffset,rootOffset+size,consumerParam);
  }
}
#ENDDEF
#MACRODEF UncheckedSubListModifyingFunc(methodName,sigParam,sizeCheck,target,uncheckedMethodName,uncheckedParams)
@Override
public void methodName(sigParam)
{
  final int size;
  if(sizeCheck((size=this.size)))
  {
    final int rootOffset;
    target.uncheckeduncheckedMethodName(root.arr,rootOffset=this.rootOffset,rootOffset+uncheckedParams);
  }
}
#ENDDEF
#MACRODEF UncheckedSubListRemoveVal(indexTest,Suffix,methodParams)
private boolean uncheckedremoveValSuffix(methodParams)
{
  #MACRO UncheckedConditionalLoop(final Unchecked$<E>$ root;final var arr=(root=this.root).arr;int index;final int bound=(index=this.rootOffset)+(--size);,,indexTest(arr[index]),,++index==bound,false)
  eraseIndexHelper(arr,index,--root.size);
  bubbleUpDecrementSize(parent);
  this.size=size;
  return true;
}
#ENDDEF
#MACRODEF UncheckedDescendingItrForEachRemaining(consumerParam,uncheckedConsumerParam)
@Override
public void forEachRemaining(consumerParam action)
{
  final int cursor;
  if((cursor=this.cursor)!=0)
  {
    uncheckedReverseForEach(root.arr,0,cursor,uncheckedConsumerParam);
    this.cursor=0;
  }
}
#ENDDEF
#MACRODEF ForEachMethods(MacroName,lastBoundParam)
#MACRO MacroName($TypeNameModifier$Consumer$<? super E>$,actionlastBoundParam)
#IFNOT OfRef
#MACRO MacroName(Consumer<? super $BoxedType$>,action::acceptlastBoundParam)
#ENDIF
#ENDDEF
#MACRODEF UncheckedConditionalLoop(beforeLoopDecls,initialization,testCondition,postIter,boundCondition,negRet)
beforeLoopDecls
for(initialization;testCondition;postIter)
{
  if(boundCondition)
  {
    return negRet;
  }
}
#ENDDEF
#MACRODEF TryCheckModCount(modCountSource,InternalCode)
int modCount=this.modCount;
try
{
  InternalCode
}
finally
{
  CheckedCollection.checkModCount(modCount,modCountSource.modCount);
}
#ENDDEF
#MACRODEF Poll(retType,Suffix,emptyVal,cast,incrementModCount)
@Override
public retType pollSuffix()
{
  final int size;
  if((size=this.size)!=0)
  {
    incrementModCount
    return cast((($ClassPrefix$ArrSeq$<E>$)this).uncheckedPop(size-1));
  }
  return emptyVal;
}
#ENDDEF
#MACRODEF PollMethods(incrementModCount)
    #MACRO Poll($exposedType$,$TypeNameModifier$,$defaultVal$,($exposedType$),incrementModCount)
#IFNOT OfRef
    #MACRO Poll($BoxedType$,,null,($BoxedType$),incrementModCount)
  #IFNOT OfDouble
    #MACRO Poll(double,Double,Double.NaN,$castToDouble$,incrementModCount)
    #IFNOT OfFloat
    #MACRO Poll(float,Float,Float.NaN,$castToFloat$,incrementModCount)
      #IFNOT OfLong
    #MACRO Poll(long,Long,Long.MIN_VALUE,$castToLong$,incrementModCount)
        #IFNOT OfInt
    #MACRO Poll(int,Int,Integer.MIN_VALUE,$castToInt$,incrementModCount)
          #IFNOT OfShort,OfChar
    #MACRO Poll(short,Short,Short.MIN_VALUE,$castToShort$,incrementModCount)
            #IFNOT OfByte
    #MACRO Poll(byte,Byte,Byte.MIN_VALUE,$castToByte$,incrementModCount)
    #MACRO Poll(char,Char,Character.MIN_VALUE,$castToChar$,incrementModCount)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF UncheckedDoubleFloatQuery(retType,methodName,Suffix1,sigParamType,test,Suffix2)
private retType uncheckedmethodNameSuffix1(final int size,final sigParamType val)
{
  if(test(val))
  {
    return uncheckedmethodNameBits(size,$convertToBits$(val));
  }
  return uncheckedmethodNameSuffix2(size);
}
#ENDDEF
#MACRODEF RemoveIf(Predicate,predicateParam,checkModCount)
@Override
public boolean removeIf(final Predicate filter)
{
  final int size;
  if((size=this.size)!=0)
  {
    return uncheckedRemoveIf(size,predicateParam);
  }
  checkModCount
  return false;
}
#ENDDEF
#MACRODEF SuppressUnchecked()
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
#ENDDEF
#MACRODEF CheckedRemoveIfHelper(srcBound,dstOffset,modCountSource)
#IF OfBoolean
for(;;)
{
  if(++srcOffset==srcBound)
  {
    CheckedCollection.checkModCount(modCount,modCountSource.modCount);
    return false;
  }
  if(v^arr[srcOffset])
  {
    final boolean tmp=filter.test(!v);
    CheckedCollection.checkModCount(modCount,modCountSource.modCount);
    if(!tmp)
    {
      return false;
    }
    dstOffset=pullSurvivorsDown(arr,srcOffset,size,v);
    break;
  }
}
#ELSE
#ENDIF
#ENDDEF
#MACRODEF UncheckedRemoveIfHelper(srcBound,dstOffset)
#IF OfBoolean
for(;;)
{
  if(++srcOffset==srcBound)
  {
    return false;
  }
  if(v^arr[srcOffset])
  {
    if(!filter.test(!v))
    {
      return false;
    }
    dstOffset=pullSurvivorsDown(arr,srcOffset,srcBound,v);
    break;
  }
}
#ELSE
while(!filter.test(($exposedType$)arr[srcOffset]))
{
  if(++srcOffset==srcBound)
  {
    return false;
  }
}
#ENDIF
#ENDDEF
#MACRODEF UncheckedSubItrForEachRemaining(Consumer,consumerParam,setLastRet)
@Override
public void forEachRemaining(Consumer action)
{
  final int cursor,bound;
  final SubList$<E>$ parent;
  if((cursor=this.cursor)!=(bound=(parent=this.parent).rootOffset+parent.size))
  {
    uncheckedForwardForEach(parent.root.arr,cursor,bound,consumerParam);
    this.cursor=bound;
    setLastRet
  }
}
#ENDDEF
#MACRODEF UncheckedSubListQuery(retType,methodName,methodParams,uncheckedMethodParams)
private retType uncheckedmethodName(methodParams)
{ 
  final int rootOffset;
  return $ClassPrefix$ArrSeq.uncheckedmethodName(uncheckedMethodParams);
}
#ENDDEF
#MACRODEF SubListCheckModCount()
int modCount;
final Checked$<E>$ root;
CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
#ENDDEF
#MACRODEF SubListIncrementModCount()
    root.modCount=++modCount;
    bubbleUpIncrementModCount(parent);
    this.modCount=modCount;
#ENDDEF
#MACRODEF ToArray(uncheckedMethodCall,retType,Name,defaultArr,checkModCount)
@Override
public retType[] toNameArray()
{
  checkModCount
  final int size;
  if((size=this.size)!=0)
  {
    final retType[] dst;
    uncheckedMethodCall
    return dst;
  }
  return defaultArr;
}
#ENDDEF
#MACRODEF ToArrayMethods(uncheckedMethodCall,checkModCount)
#MACRO ToArray(uncheckedMethodCall,$ArrayType$,$TypeNameModifier$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR,checkModCount)
#IFNOT OfRef
#MACRO ToArray(uncheckedMethodCall,$BoxedType$,,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR,checkModCount)
  #IFNOT OfDouble
#MACRO ToArray(uncheckedMethodCall,double,Double,OmniArray.OfDouble.DEFAULT_ARR,checkModCount)
    #IFNOT OfFloat
#MACRO ToArray(uncheckedMethodCall,float,Float,OmniArray.OfFloat.DEFAULT_ARR,checkModCount)
      #IFNOT OfLong
#MACRO ToArray(uncheckedMethodCall,long,Long,OmniArray.OfLong.DEFAULT_ARR,checkModCount)
        #IFNOT OfInt
#MACRO ToArray(uncheckedMethodCall,int,Int,OmniArray.OfInt.DEFAULT_ARR,checkModCount)
          #IFNOT OfChar,OfShort
#MACRO ToArray(uncheckedMethodCall,short,Short,OmniArray.OfShort.DEFAULT_ARR,checkModCount)
            #IFNOT OfByte
#MACRO ToArray(uncheckedMethodCall,byte,Byte,OmniArray.OfByte.DEFAULT_ARR,checkModCount)
#MACRO ToArray(uncheckedMethodCall,char,Char,OmniArray.OfChar.DEFAULT_ARR,checkModCount)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF BasicQuery(access,retType,methodName,paramType,negRet,target,methodParams,checkModCount,override)
override
access retType methodName(final paramType val)
{
  final int size;
  if((size=this.size)!=0)
  {
    return target.uncheckedmethodName(methodParams);
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryBoolean(retType,methodName,negRet,target,methodParams,checkModCount,override)
override
public retType methodName(final boolean val)
{
  final int size;
  if((size=this.size)!=0)
  {
#IF OfDouble,OfFloat
    if(val)
    {
      return target.uncheckedmethodNameBits(methodParams,$TRUE_BITS$);
    }
    return target.uncheckedmethodName0(methodParams);
#ELSE
    return target.uncheckedmethodName(methodParams,$queryCastBoolean$(val));
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryChar(retType,methodName,negRet,target,methodParams,checkModCount,override)
override
public retType methodName(final char val)
{
#IF OfByte,OfShort
  if(val<=$BoxedType$.MAX_VALUE)
#ENDIF
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfFloat
      return target.uncheckedmethodNameRawInt(methodParams,val);
#ELSE
      return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ENDIF
    }
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryShort(retType,methodName,negRet,target,methodParams,checkModCount,override)
override
public retType methodName(final short val)
{
#IF OfChar
  if(val>=0)
#ENDIF
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfFloat
      return target.uncheckedmethodNameRawInt(methodParams,val);
#ELSE
      return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ENDIF
    }
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryInt(retType,methodName,negRet,target,methodParams,checkModCount,override)
override
public retType methodName(final int val)
{
  final int size;
  if((size=this.size)!=0)
  {
#IF OfDouble,OfFloat
    if(val!=0)
    {
  #IF OfFloat
      if(TypeUtil.checkCastToFloat(val))
  #ENDIF
      {
        return target.uncheckedmethodNameBits(methodParams,$convertToBits$(val));
      }
    }
    else
    {
      return target.uncheckedmethodName0(methodParams);
    }
#ELSEIF OfBoolean
    final boolean v;
    switch(val)
    {
      default:
        checkModCount
        return negRet;
      case 0:
        v=false;
        break;
      case 1:
        v=true;
    }
    return target.uncheckedmethodName(methodParams,v);
#ELSE
  #IF OfShort,OfChar,OfByte
    if(val==($exposedType$)val)
  #ENDIF
    {
      return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
    }
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryLong(retType,methodName,negRet,target,methodParams,checkModCount,override)
override
public retType methodName(final long val)
{
  final int size;
  if((size=this.size)!=0)
  {
#IF OfRef,OfLong
    return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ELSEIF OfDouble,OfFloat
    if(val!=0)
    {
      if(TypeUtil.checkCastTo$BoxedType$(val))
      {
        return target.uncheckedmethodNameBits(methodParams,$convertToBits$(val));
      }
    }
    else
    {
      return target.uncheckedmethodName0(methodParams);
    }
#ELSE
    final $exposedType$ v;
  #IF OfBoolean
    if(val==0)
    {
      v=false;
    }
    else if(val==1)
    {
      v=true;
    }
    else
    {
      checkModCount
      return negRet;
    }
  #ELSE
    if(val==(v=($exposedType$)val))
  #ENDIF
    {
      return target.uncheckedmethodName(methodParams,v);
    }
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryFloat(retType,methodName,negRet,target,methodParams,checkModCount,override)
override
public retType methodName(final float val)
{
  final int size;
  if((size=this.size)!=0)
  {
#IF OfRef,OfFloat
    return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ELSEIF OfDouble
    if(val==val)
    {
      return target.uncheckedmethodNameBits(methodParams,$convertToBits$(val));
    }
    return target.uncheckedmethodNameNaN(methodParams);
#ELSE
    final $exposedType$ v;
  #IF OfLong
    if(TypeUtil.floatEquals(val,v=(long)val))
  #ELSEIF OfInt
    if((double)val==(double)(v=(int)val))
  #ELSEIF OfBoolean
    switch(Float.floatToRawIntBits(val))
    {
      default:
        checkModCount
        return negRet;
      case 0:
      case Integer.MIN_VALUE:
        v=false;
        break;
      case TypeUtil.FLT_TRUE_BITS:
        v=true;
    }
  #ELSE
    if(val==(v=($exposedType$)val))
  #ENDIF
    {
      return target.uncheckedmethodName(methodParams,v);
    }
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryDouble(retType,methodName,negRet,target,methodParams,checkModCount,override)
override
public retType methodName(final double val)
{
  final int size;
  if((size=this.size)!=0)
  {
#IF OfRef,OfDouble
    return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ELSE
    final $exposedType$ v;
  #IF OfFloat
    if(val==(v=($exposedType$)val))
    {
      return target.uncheckedmethodNameBits(methodParams,$convertToBits$(v));
    }
    else if(v!=v)
    {
      return target.uncheckedmethodNameNaN(methodParams);
    }
  #ELSE
    #IF OfBoolean
    final long bits;
    if((bits=Double.doubleToRawLongBits(val))==0||bits==Long.MIN_VALUE)
    {
      v=false;
    }
    else if(bits==TypeUtil.DBL_TRUE_BITS)
    {
      v=true;
    }
    else
    {
      checkModCount
      return negRet;
    }
    #ELSE
    if(val==(v=($exposedType$)val))
    #ENDIF
    {
      return target.uncheckedmethodName(methodParams,v);
    }
  #ENDIF
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF UncheckedRemoveVal<Direction>(indexTest,Suffix,methodParams,incrementModCount)
@Override
boolean uncheckedremoveValSuffix(methodParams)
{
#IFSWITCH Direction==First
  #MACRO UncheckedConditionalLoop(final var arr=this.arr;int index;,index=0\,--size,indexTest(arr[index]),++index,index==size,false)
#ELSE
  #MACRO UncheckedConditionalLoop(final var arr=this.arr;int index;,index=--size,indexTest(arr[index]),--index,index==0,false)
#ENDIF
  incrementModCount
  eraseIndexHelper(arr,index,size);
  this.size=size;
  return true;
}
#ENDDEF
#MACRODEF QueryMethods(IFSTATEMENT,retType,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryBoolean(retType,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryInt(retType,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryLong(retType,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryFloat(retType,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryDouble(retType,methodName,negRet,target,methodParams,checkModCount,override)
#IF OfRef,OfByte
#MACRO BasicQuery(public,retType,methodName,byte,negRet,target,methodParams\,$queryCastPrimitive$(val),checkModCount,override)
#ENDIF
IFSTATEMENT
#MACRO QueryChar(retType,methodName,negRet,target,methodParams,checkModCount,override)
  #IFNOT OfByte
#MACRO QueryShort(retType,methodName,negRet,target,methodParams,checkModCount,override)
  #ENDIF
#ENDIF
#IF OfRef
#MACRO BasicQuery(public,retType,methodName,Boolean,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,retType,methodName,Byte,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,retType,methodName,Character,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,retType,methodName,Short,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,retType,methodName,Integer,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,retType,methodName,Long,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,retType,methodName,Float,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,retType,methodName,Double,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#ENDIF
#ENDDEF
#MACRODEF CopyIntoArray(arrType)
@Override
void uncheckedCopyInto(final arrType[] arr,final int size)
{
  ArrCopy.CopyMethod(this.arr,0,arr,0,size);
}
#ENDDEF
#MACRODEF CopyIntoArrayMethods<CopyMethod>()
#MACRO CopyIntoArray($ArrayType$)
#IFNOT OfRef
#MACRO CopyIntoArray(Object)
#MACRO CopyIntoArray($BoxedType$)
  #IFNOT OfDouble
#MACRO CopyIntoArray(double)
    #IFNOT OfFloat
#MACRO CopyIntoArray(float)
      #IFNOT OfLong
#MACRO CopyIntoArray(long)
        #IFNOT OfInt
#MACRO CopyIntoArray(int)
          #IFNOT OfShort,OfChar
#MACRO CopyIntoArray(short)
            #IFNOT OfByte
#MACRO CopyIntoArray(byte)
#MACRO CopyIntoArray(char)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF UncheckedRemoveFirstMethods<Direction>()
#IF OfRef
#MACRO UncheckedRemoveVal<Direction>(!pred.test,,int size\,final Predicate<Object> pred,)
#MACRO UncheckedRemoveVal<Direction>(!nonNull.equals,NonNull,int size\,final Object nonNull,)
#ELSEIF OfDouble,OfFloat
#MACRO UncheckedRemoveVal<Direction>(0!=,0,int size,)
#MACRO UncheckedRemoveVal<Direction>(bits!=$convertToBits$,Bits,int size\,final $queryParameterType$ bits,)
#MACRO UncheckedRemoveVal<Direction>(!$BoxedType$.isNaN,NaN,int size,)
#ELSEIF OfBoolean
#MACRO UncheckedRemoveVal<Direction>(val^,,int size\,final $queryParameterType$ val,)
#ELSE
#MACRO UncheckedRemoveVal<Direction>(val!=,,int size\,final $queryParameterType$ val,)
#ENDIF
#ENDDEF
#MACRODEF BubbleUp(methodName,params,lines)
private static $<E>$ void bubbleUpmethodName(SubList$<E>$ parentparams)
{
  while(parent!=null)
  {
    lines
    parent=parent.parent;
  }
}
#ENDDEF