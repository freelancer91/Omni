#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.api.OmniCollection;
import omni.util.OmniArray;
import omni.api.OmniList;
import omni.api.OmniStack;
import java.util.function.Predicate;
import java.util.function.Consumer;
import java.util.Comparator;
import omni.util.ArrCopy;
import omni.util.$ClassPrefix$SortUtil;
import omni.impl.CheckedCollection;
import java.util.NoSuchElementException;
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import java.util.function.IntFunction;
import java.util.function.UnaryOperator;
import omni.util.TypeUtil;
import java.util.ConcurrentModificationException;
#IF OfInt,OfLong,OfDouble
import java.util.function.$UnaryOperator$;
#ELSEIFNOT OfBoolean
import omni.function.$UnaryOperator$;
#ENDIF
#IF OfInt
import java.util.function.$Comparator$;
#ELSE
import omni.function.$Comparator$;
#ENDIF
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Predicate;
import java.util.function.$TypeNameModifier$Consumer;
#ELSE
import omni.function.$TypeNameModifier$Predicate;
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
#IFNOT OfDouble,OfChar
import omni.util.ToStringUtil;
#ENDIF
#IF OfDouble,OfFloat
import omni.util.HashUtil;
#ENDIF
#IFNOT OfBoolean
import omni.util.BitSetUtil;
#ENDIF
import omni.impl.Abstract$TypeNameModifier$Itr;

public abstract class $ClassPrefix$ArrSeq$<E>$ implements OmniCollection.Of$ClassPrefix$$<E>$
{
  transient int size;
  transient $ArrayType$[] arr;
  private $ClassPrefix$ArrSeq()
  {
    super();
  }
  private $ClassPrefix$ArrSeq(int initialCapacity)
  {
    super();
    switch(initialCapacity)
    { 
    default:
      this.arr=new $ArrayType$[initialCapacity];
      return;
    case OmniArray.DEFAULT_ARR_SEQ_CAP:
      this.arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
    case 0:
    }
  }
  private $ClassPrefix$ArrSeq(int size,$ArrayType$[] arr)
  {
    super();
    this.size=size;
    this.arr=arr;
  }
  
  @Override
  public int size()
  {
    return this.size;
  }
  @Override
  public boolean isEmpty()
  {
    return this.size==0;
  }
  
 }
 
 
#MACRODEF Size()
@Override
public int size()
{
  #IFSWITCH STRUCTNAME==CheckedSubList
  CheckedCollection.checkModCount(modCount,root.modCount);
  #ENDIF
  return this.size;
}
#ENDDEF

#MACRODEF IsEmpty()
@Override
public boolean isEmpty()
{
  #IFSWITCH STRUCTNAME==CheckedSubList
  CheckedCollection.checkModCount(modCount,root.modCount);
  #ENDIF
  return this.size==0;
}
#ENDDEF

#MACRODEF Clear()
@Override
public void clear()
{
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
    #IFSWITCH STRUCTNAME==CheckedSubList
  final CheckedList$<E>$ root;
  int modCount
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount); 
    #ENDIF
  int size;
  if((size=this.size)!=0)
  {
    #IFSWITCH STRUCTNAME==CheckedSubList
    root.modCount=++modCount;
    this.modCount=modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,curr.size-=size,curr=curr.parent){}
    #ELSE
    for(var curr=parent;curr!=null;curr.size-=size,curr=curr.parent){}
    #ENDIF
    int rootSize;
    root.size=OmniArray.Of$ClassPrefix$.removeRangeAndPullDown(root.arr,this.rootOffset,root.size,size);
    this.size=0;
  }
  #ENDIF
  //TODO
  
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  int size;
  if((size=this.size)!=0)
  {
    
  }
  #ENDIF
  
  
}
#ENDDEF
 