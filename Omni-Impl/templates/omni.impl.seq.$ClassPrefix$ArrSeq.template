#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.api.OmniCollection;
import omni.util.OmniArray;
import omni.api.OmniList;
import omni.api.OmniStack;
import java.util.function.Predicate;
import java.util.function.Consumer;
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Predicate;
import java.util.function.$TypeNameModifier$Consumer;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Predicate;
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
import java.util.Comparator;
#IF OfInt
import java.util.function.$Comparator$;
#ELSEIFNOT OfRef
import omni.function.$Comparator$;
#ENDIF
#IFNOT OfRef,OfDouble
import omni.util.ToStringUtil;
#ENDIF
import omni.util.ArrCopy;
import omni.util.$ClassPrefix$SortUtil;
#IF OfRef
import java.util.Objects;
#ENDIF
import omni.impl.CheckedCollection;
#IFNOT OfRef
import omni.util.TypeUtil;
#ENDIF
import java.util.NoSuchElementException;
#IF OfDouble,OfFloat
import omni.util.HashUtil;
#ENDIF
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import java.util.function.IntFunction;
#IF OfRef
import omni.util.OmniPred;
#ENDIF
public abstract class $ClassPrefix$ArrSeq$<E>$ implements OmniCollection.Of$ClassPrefix$$<E>$
{
  transient int size;
  transient $ArrayType$[] arr;
  private $ClassPrefix$ArrSeq()
  {
    super();
  }
  private $ClassPrefix$ArrSeq(int initialCapacity)
  {
    super();
    switch(initialCapacity)
    { 
    default:
      this.arr=new $ArrayType$[initialCapacity];
      return;
    case OmniArray.DEFAULT_ARR_SEQ_CAP:
      this.arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
    case 0:
    }
  }
  private $ClassPrefix$ArrSeq(int size,$ArrayType$[] arr)
  {
    super();
    this.size=size;
    this.arr=arr;
  }
  @Override
  public int size()
  {
    return this.size;
  }
  @Override
  public boolean isEmpty()
  {
    return this.size==0;
  }
  @Override
  public void clear()
  {
#IF OfRef
    int size;
    if((size=this.size)!=0)
    {
      this.size=0;
      OmniArray.OfRef.nullifyRange(arr,0,size-1);
    }
#ELSE
    this.size=0;
#ENDIF
  }
  #MACRO Impl<Unchecked,List>()
  #MACRO Impl<Unchecked,Stack>()
  #MACRO Impl<Checked,List>()
  #MACRO Impl<Checked,Stack>()
#MACRODEF Impl<CHECKED,STRUCTNAME>()
public static class CHECKEDSTRUCTNAMEImpl$<E>$ extends $ClassPrefix$ArrSeq$<E>$ implements OmniSTRUCTNAME.Of$ClassPrefix$$<E>$
{
#IFSWITCH STRUCTNAME==List
  #IF OfDouble,OfFloat
  #MACRO UncheckedIndexOfMethods<Bits>()
  #MACRO UncheckedIndexOfMethods<0>()
  #MACRO UncheckedIndexOfMethods<NaN>()
  #ELSE
  #MACRO UncheckedIndexOfMethods< >()
  #ENDIF
#ENDIF
#IFSWITCH STRUCTNAME==Stack
 #IF OfDouble,OfFloat
  #MACRO UncheckedSearchMethod<Bits>()
  #MACRO UncheckedSearchMethod<0>()
  #MACRO UncheckedSearchMethod<NaN>()
  #ELSE
  #MACRO UncheckedSearchMethod< >()
  #ENDIF
#ENDIF

#IF OfDouble,OfFloat
  #MACRO UncheckedRemoveVal<Bits>()
  #MACRO UncheckedRemoveVal<0>()
  #MACRO UncheckedRemoveVal<NaN>()
#ELSE
  #MACRO UncheckedRemoveVal< >()
#ENDIF
#IF OfRef,OfDouble
  static void uncheckedToString($ArrayType$[] arr,int begin,int end,StringBuilder builder)
  {
  #IFSWITCH STRUCTNAME==Stack
    for(builder.append(arr[end]);begin!=end;builder.append(',').append(' ').append(arr[--end])){}
  #ELSE
    for(builder.append(arr[begin]);begin!=end;builder.append(',').append(' ').append(arr[++begin])){}
  #ENDIF
  }
#ELSEIF OfChar
  static void uncheckedToString($ArrayType$[] arr,int begin,int end,char[] buffer)
  {
    int bufferOffset;
  #IFSWITCH STRUCTNAME==Stack
    for(buffer[bufferOffset=1]=arr[end];begin!=end;buffer[++bufferOffset]=',',buffer[++bufferOffset]=' ',buffer[++bufferOffset]=arr[--end]){}
  #ELSE
    for(buffer[bufferOffset=1]=arr[begin];begin!=end;buffer[++bufferOffset]=',',buffer[++bufferOffset]=' ',buffer[++bufferOffset]=arr[++begin]){}
  #ENDIF
  }
#ELSE
  static int uncheckedToString($ArrayType$[] arr,int begin,int end,char[] buffer)
  {
    int bufferOffset;
  #IF OfByte
    #IFSWITCH STRUCTNAME==Stack
    for(bufferOffset=ToStringUtil.getStringShort(arr[end],buffer,1);begin!=end;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getStringShort(arr[--end],buffer,bufferOffset)){}
    #ELSE
    for(bufferOffset=ToStringUtil.getStringShort(arr[begin],buffer,1);begin!=end;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getStringShort(arr[++begin],buffer,bufferOffset)){}
    #ENDIF
  #ELSE
    #IFSWITCH STRUCTNAME==Stack
    for(bufferOffset=ToStringUtil.getString$ClassPrefix$(arr[end],buffer,1);begin!=end;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getString$ClassPrefix$(arr[--end],buffer,bufferOffset)){}
    #ELSE
    for(bufferOffset=ToStringUtil.getString$ClassPrefix$(arr[begin],buffer,1);begin!=end;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getString$ClassPrefix$(arr[++begin],buffer,bufferOffset)){}
    #ENDIF
  #ENDIF
    return bufferOffset;
  }
  static void uncheckedToString($ArrayType$[] arr,int begin,int end,ToStringUtil.OmniStringBuilder builder)
  {
  #IF OfByte
    #IFSWITCH STRUCTNAME==Stack
    for(builder.uncheckedAppendShort(arr[end]);begin!=end;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppendShort(arr[--end])){}
    #ELSE
    for(builder.uncheckedAppendShort(arr[begin]);begin!=end;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppendShort(arr[++begin])){}
    #ENDIF
  #ELSE
    #IFSWITCH STRUCTNAME==Stack
    for(builder.uncheckedAppend$ClassPrefix$(arr[end]);begin!=end;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppend$ClassPrefix$(arr[--end])){}
    #ELSE
    for(builder.uncheckedAppend$ClassPrefix$(arr[begin]);begin!=end;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppend$ClassPrefix$(arr[++begin])){}
    #ENDIF
  #ENDIF
  }
#ENDIF
  #MACRO SuppressUnchecked()
  static $<E>$ void uncheckedForEach($ArrayType$[] arr,int begin,int end,$TypeNameModifier$Consumer$<? super E>$ action)
  {
#IFSWITCH STRUCTNAME==Stack
    for(;;--end)
    {
      action.accept(($exposedType$)arr[end]);
      if(begin==end)
      {
        return;
      }
    }
#ELSE
    for(;;++begin)
    {
      action.accept(($exposedType$)arr[begin]);
      if(begin==end)
      {
        return;
      }
    }
#ENDIF
  }
  static int uncheckedHashCode($ArrayType$[] arr,int begin,int end)
  {
#IFSWITCH STRUCTNAME==Stack
    int hash=31+$hashCodeMethod$(arr[end]);
    while(begin!=end)
    {
      hash=hash*31+$hashCodeMethod$(arr[--end]);
    }
#ELSE
    int hash=31+$hashCodeMethod$(arr[begin]);
    while(begin!=end)
    {
      hash=hash*31+$hashCodeMethod$(arr[++begin]);
    }
#ENDIF
    return hash;
  }
#IFSWITCH CHECKED==Checked
  transient int modCount;
#ENDIF
  public CHECKEDSTRUCTNAMEImpl()
  {
    super();
  }
  public CHECKEDSTRUCTNAMEImpl(int initialCapacity)
  {
    super(initialCapacity);
  }
  private CHECKEDSTRUCTNAMEImpl(int size,$ArrayType$[] arr)
  {
    super(size,arr);
  }
#IFSWITCH CHECKED==Checked
  @Override
  public void clear()
  {
  #IF OfRef
    final int size;
    if((size=this.size)!=0)
    {
      ++this.modCount;
      this.size=0;
      OmniArray.OfRef.nullifyRange(arr,0,size-1);
    }
  #ELSE
    if(this.size!=0)
    {
      ++this.modCount;
      this.size=0;
    }
  #ENDIF
  }
#ENDIF
  @Override
  public String toString()
  {
    int size;
    if((size=this.size)!=0)
    {
#IF OfBoolean
      if(size>(Integer.MAX_VALUE/6))
      {
        throw new OutOfMemoryError();
      }
#ELSEIF OfDouble,OfFloat
      if(size>(Integer.MAX_VALUE/5))
      {
        throw new OutOfMemoryError();
      }
#ELSE
      if(size>(Integer.MAX_VALUE/3))
      {
        throw new OutOfMemoryError();
      }
#ENDIF
#IF OfRef,OfDouble
      final StringBuilder builder;
  #IF OfRef
    #IFSWITCH CHECKED==Checked
      int modCount=this.modCount;
      try
    #ENDIF
  #ENDIF
      {
        uncheckedToString(arr,0,size-1,builder=new StringBuilder("["));
      }
  #IF OfRef
    #IFSWITCH CHECKED==Checked
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    #ENDIF
  #ENDIF
      return builder.append(']').toString();
#ELSE
      final char[] buffer;
  #IF OfChar
      uncheckedToString(arr,0,size-1,buffer=new char[size*=3]);
      buffer[size-1]=']';
      buffer[0]='[';
      return new String(buffer,0,size);
  #ELSEIF OfBoolean
      #MACRO ToStringFastImpl<false>(7,size<=(int)(OmniArray.MAX_ARR_SIZE/6.5f)?(size*6)+(size>>>1):OmniArray.MAX_ARR_SIZE)
  #ELSEIF OfByte
      #MACRO ToStringFastImpl<false>(6,size<=(int)(OmniArray.MAX_ARR_SIZE/5)?(size*5):OmniArray.MAX_ARR_SIZE)
  #ELSEIF OfShort
      #MACRO ToStringFastImpl<false>(8,size<=(int)(OmniArray.MAX_ARR_SIZE/5.5f)?(size*5)+(size>>>1):OmniArray.MAX_ARR_SIZE)
  #ELSEIF OfInt
      #MACRO ToStringFastImpl<false>(13,size<=(int)(OmniArray.MAX_ARR_SIZE>>>3)?(size<<3):OmniArray.MAX_ARR_SIZE)
  #ELSEIF OfLong
      #MACRO ToStringFastImpl<false>(22,size<=(int)(OmniArray.MAX_ARR_SIZE/12.5f)?(size*12)+(size>>>1):OmniArray.MAX_ARR_SIZE)
  #ELSE
      #MACRO ToStringFastImpl<false>(17,size<=(int)(OmniArray.MAX_ARR_SIZE/11)?(size*11):OmniArray.MAX_ARR_SIZE)
  #ENDIF
#ENDIF
    }
    return "[]";
  }
  @Override
  public int hashCode()
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfRef
  #IFSWITCH CHECKED==Checked
      int modCount=this.modCount;
      try
  #ENDIF
#ENDIF
      {
        return uncheckedHashCode(arr,0,size-1);
      }
#IF OfRef
  #IFSWITCH CHECKED==Checked
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
  #ENDIF
#ENDIF
    }
    return 1;
  }
  @Override
  public <T> T[] toArray(T[] dst)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IFSWITCH STRUCTNAME==Stack
      ArrCopy.uncheckedReverseCopy(this.arr,0,dst=OmniArray.uncheckedArrResize(size,dst),0,size);
#ELSE
      ArrCopy.uncheckedCopy(this.arr,0,dst=OmniArray.uncheckedArrResize(size,dst),0,size);
#ENDIF
    }
    else if(dst.length!=0)
    {
      dst[0]=null;
    }
    return dst;
  }
  @Override
  public <T> T[] toArray(IntFunction<T[]> arrConstructor)
  {
    final int size;
    T[] dst;
#IFSWITCH CHECKED==Checked
    int modCount=this.modCount;
    try
    {
#ENDIF
      dst=arrConstructor.apply(size=this.size);
#IFSWITCH CHECKED==Checked
    }
    finally
    {
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
#ENDIF
    if(size!=0)
    {
#IFSWITCH STRUCTNAME==Stack
      ArrCopy.uncheckedReverseCopy(this.arr,0,dst,0,size);
#ELSE
      ArrCopy.uncheckedCopy(this.arr,0,dst,0,size);
#ENDIF
    }
    return dst;
  }
  @Override
  public boolean equals(Object val)
  {
    //TODO
    return false;
  }
  @Override
  public Object clone()
  {
    final int size;
    if((size=this.size)!=0)
    {
      final $ArrayType$[] copy;
      ArrCopy.uncheckedCopy(arr,0,copy=new $ArrayType$[size],0,size);
      return new CHECKEDSTRUCTNAMEImpl$<E>$(size,copy);
    }
    return new CHECKEDSTRUCTNAMEImpl$<E>$();
  }
  #MACRO SuppressUnchecked()
  @Override
  public void forEach($TypeNameModifier$Consumer$<? super E>$ action)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IFSWITCH CHECKED==Checked
      int modCount=this.modCount;
      try
#ENDIF
      {
        uncheckedForEach(arr,0,size-1,action);
      }
#IFSWITCH CHECKED==Checked
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
#ENDIF
    }
  }
#IFNOT OfRef
  @Override
  public void forEach(Consumer<? super $BoxedType$> action)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IFSWITCH CHECKED==Checked
      int modCount=this.modCount;
      try
#ENDIF
      {
        uncheckedForEach(arr,0,size-1,action::accept);
      }
#IFSWITCH CHECKED==Checked
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
#ENDIF
    }
  }
#ENDIF
  @Override
  public boolean removeIf($TypeNameModifier$Predicate$<? super E>$ filter)
  {
    //TODO
    return false;
  }
#IFNOT OfRef
  @Override
  public boolean removeIf(Predicate<? super $BoxedType$> filter)
  {
    //TODO
    return false;
  }
#ENDIF
  @Override
  public boolean add($exposedType$ val)
  {
    //TODO
    return false;
  }
#IFNOT OfRef
  @Override
  public boolean add($BoxedType$ val)
  {
    //TODO
    return false;
  }
#ENDIF
  #MACRO QueryMethods<removeVal>()
  #MACRO QueryMethods<contains>()
#IFSWITCH STRUCTNAME==List
  #MACRO QueryMethods<indexOf>()
  #MACRO QueryMethods<lastIndexOf>()
  @Override
  public void put(int index,$exposedType$ val)
  {
#IFSWITCH CHECKED==Checked
    if(index<0 || index>=this.size)
    {
      throw new IndexOutOfBoundsException("index="+index+"; size="+this.size);
    }
#ENDIF
    arr[index]=val;
  }
  @Override
  public $exposedType$ set(int index,$exposedType$ val)
  {
#IFSWITCH CHECKED==Checked
    if(index<0 || index>=this.size)
    {
      throw new IndexOutOfBoundsException("index="+index+"; size="+this.size);
    }
#ENDIF
    #MACRO SuppressUnchecked()
    var ret=($exposedType$)arr[index];
    arr[index]=val;
    return ret;
  }
#IFNOT OfRef
  @Override
  public $BoxedType$ set(int index,$BoxedType$ val)
  {
    return set(index,($exposedType$)val);
  }
#ENDIF
  #MACRO SuppressUnchecked()
  @Override
  public $exposedType$ get$TypeNameModifier$(int index)
  {
#IFSWITCH CHECKED==Checked
    if(index<0 || index>=this.size)
    {
      throw new IndexOutOfBoundsException("index="+index+"; size="+this.size);
    }
#ENDIF
    return ($exposedType$)arr[index];
  }
#IFNOT OfRef
  @Override
  public $BoxedType$ get(int index)
  {
    return get$TypeNameModifier$(index);
  }
#ENDIF
 
  @Override
  public void add(int index,$exposedType$ val)
  {
    //TODO
  }
  #IFNOT OfRef
  @Override
  public void add(int index,$BoxedType$ val)
  {
    //TODO
  }
  #ENDIF
  @Override
  public $exposedType$ $removeAtIndexMethod$(int index)
  {
#IFSWITCH CHECKED==Checked
    int size;
    if(index<0 || index>=(size=this.size))
    {
      throw new IndexOutOfBoundsException("index = "+index+"; size="+this.size);
    }
    ++this.modCount;
#ENDIF
    final $ArrayType$[] arr;
    #MACRO SuppressUnchecked()
    $exposedType$ ret=($exposedType$)(arr=this.arr)[index];
    ArrCopy.semicheckedSelfCopy(arr,index+1,index,(--size)-index);
#IF OfRef
    arr[size]=null;
#ENDIF
#IFSWITCH CHECKED==Checked
    this.size=size;
#ENDIF
    return ret;
  }
  @Override
  public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
  {
    //TODO
    return null;
  }
  @Override
  public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index)
  {
    //TODO
    return null;
  }
  @Override
  public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
  {
    //TODO
    return null;
  }
  @Override
  public void stableDescendingSort()
  {
    final int size;
    if((size=this.size)>1)
    {
#IF OfRef
  #IFSWITCH CHECKED==Checked
      final int modCount=this.modCount;
      try
  #ENDIF
#ENDIF
      {
#IF OfRef
        $ClassPrefix$SortUtil.uncheckedStableDescendingSort(arr,0,size);
#ELSE
        $ClassPrefix$SortUtil.uncheckedDescendingSort(arr,0,size);
#ENDIF
      }
#IF OfRef
  #IFSWITCH CHECKED==Checked
      //TODO do we need to catch exceptions in the checked version?
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
        this.modCount=modCount+1;
      }
  #ENDIF
#ENDIF
    }
  }
  @Override
  public void stableAscendingSort()
  {
    final int size;
    if((size=this.size)>1)
    {
#IF OfRef
  #IFSWITCH CHECKED==Checked
      final int modCount=this.modCount;
      try
  #ENDIF
#ENDIF
      {
#IF OfRef
        $ClassPrefix$SortUtil.uncheckedStableAscendingSort(arr,0,size);
#ELSE
        $ClassPrefix$SortUtil.uncheckedAscendingSort(arr,0,size);
#ENDIF
      }
#IF OfRef
  #IFSWITCH CHECKED==Checked
      //TODO do we need to catch exceptions in the checked version?
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
        this.modCount=modCount+1;
      }
  #ENDIF
#ENDIF
    }
  }
#ENDIF
  @Override
  public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
  {
    //TODO
    return null;
  }
  #MACRO ToArrayImpl($ArrayType$,$TypeNameModifier$,NULL,NULL,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
#IFNOT OfRef
  #MACRO ToArrayImpl($BoxedType$,,NULL,NULL,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR)
  #MACRO GetterMethods(ToArrayImpl)
#ENDIF  
#IFSWITCH STRUCTNAME==Stack
  #MACRO QueryMethods<search>()
  @Override
  public $exposedType$ pop$TypeNameModifier$()
  {
    int size;
    if((size=this.size)!=0)
    {
      #MACRO SuppressUnchecked()
      $exposedType$ ret=($exposedType$)arr[--size];
#IFSWITCH CHECKED==Checked
      ++this.modCount;
#ENDIF
#IF OfRef
      arr[size]=null;
#ENDIF
      this.size=size;
      return ret;
    }
    throw new NoSuchElementException();
  }
#IFNOT OfRef
  @Override
  public $BoxedType$ pop()
  {
    return pop$TypeNameModifier$();
  }
#ENDIF
  @Override
  public void push($exposedType$ val)
  {
    //TODO
  }
  #IFNOT OfRef
  @Override
  public void push($BoxedType$ val)
  {
    //TODO
  }
  #ENDIF
  #MACRO SuppressUnchecked()
  #MACRO PeekImpl($exposedType$,$TypeNameModifier$,($exposedType$),$defaultVal$,NULL)
  #MACRO PollImpl($exposedType$,$TypeNameModifier$,($exposedType$),$defaultVal$,NULL)
  #IFNOT OfRef
  #MACRO PollImpl($BoxedType$,,($BoxedType$),null,NULL)
  #MACRO GetterMethods(PollImpl)
  #MACRO PeekImpl($BoxedType$,,($BoxedType$),null,NULL)
  #MACRO GetterMethods(PeekImpl)
  #ENDIF
#ENDIF
}
#ENDDEF  
}

#MACRODEF GetterMethods(MACRONAME)
#IFNOT OfDouble
#MACRO MACRONAME(double,Double,$castToDouble$,Double.NaN,OmniArray.OfDouble.DEFAULT_ARR)
  #IFNOT OfFloat
#MACRO MACRONAME(float,Float,$castToFloat$,Float.NaN,OmniArray.OfFloat.DEFAULT_ARR)
    #IFNOT OfLong
#MACRO MACRONAME(long,Long,$castToLong$,Long.MIN_VALUE,OmniArray.OfLong.DEFAULT_ARR)
      #IFNOT OfInt
#MACRO MACRONAME(int,Int,$castToInt$,Integer.MIN_VALUE,OmniArray.OfInt.DEFAULT_ARR)
        #IFNOT OfShort,OfChar
#MACRO MACRONAME(short,Short,$castToShort$,Short.MIN_VALUE,OmniArray.OfShort.DEFAULT_ARR)
          #IFNOT OfByte
#MACRO MACRONAME(char,Char,$castToChar$,Character.MIN_VALUE,OmniArray.OfChar.DEFAULT_ARR)
#MACRO MACRONAME(byte,Byte,$castToByte$,Byte.MIN_VALUE,OmniArray.OfByte.DEFAULT_ARR)
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF ToArrayImpl(RETTYPE,CLASSPREFIX,CAST,DEFAULTRET,DEFAULTARR)
@Override
public RETTYPE[] toCLASSPREFIXArray()
{
  final int size;
  if((size=this.size)!=0)
  {
    final RETTYPE[] copy;
#IFSWITCH STRUCTNAME==Stack
    ArrCopy.uncheckedReverseCopy(arr,0,copy=new RETTYPE[size],0,size);
#ELSE
    ArrCopy.uncheckedCopy(arr,0,copy=new RETTYPE[size],0,size);
#ENDIF
    return copy;
  }
  return DEFAULTARR;
}
#ENDDEF

#MACRODEF PollImpl(RETTYPE,CLASSPREFIX,CAST,DEFAULTRET,DEFAULTARR)
@Override
public RETTYPE pollCLASSPREFIX()
{
  int size;
  if((size=this.size)!=0)
  {
    RETTYPE ret=CAST(($exposedType$)arr[--size]);
#IFSWITCH CHECKED==Checked
    ++this.modCount;
#ENDIF
#IF OfRef
    arr[size]=null;
#ENDIF
    this.size=size;
    return ret;
  }
  return DEFAULTRET;
}
#ENDDEF

#MACRODEF PeekImpl(RETTYPE,CLASSPREFIX,CAST,DEFAULTRET,DEFAULTARR)
@Override
public RETTYPE peekCLASSPREFIX()
{
  final int size;
  if((size=this.size)!=0)
  {
    return CAST(($exposedType$)arr[size-1]);
  }
  return DEFAULTRET;
}
#ENDDEF

#MACRODEF ToStringFastImpl<SUBLIST>(MAX_ELEMENT_LENGTH,BUFFER_SIZE_EXPR)
if(size<=(OmniArray.MAX_ARR_SIZE/((MAX_ELEMENT_LENGTH)<<1)))
{
  (buffer=new char[size*(MAX_ELEMENT_LENGTH)])[size=uncheckedToString(arr,0,size-1,buffer)]=']';
  buffer[0]='[';
  return new String(buffer,0,size+1);
}
else
{
  final ToStringUtil.OmniStringBuilder builder;
  uncheckedToString(arr,0,size-1,builder=new ToStringUtil.OmniStringBuilder(1,new char[BUFFER_SIZE_EXPR]));
  builder.uncheckedAppendChar(']');
  (buffer=builder.buffer)[0]='[';
  return new String(buffer,0,builder.size);
}
#ENDDEF



#MACRODEF ReturnUncheckedQuery(VAL)
#IFSWITCH STRUCTNAME==Stack,List
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedcontains(this.arr,0,size-1,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedRemoveVal(size,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf
return uncheckedAbsoluteIndexOf(this.arr,0,size,VAL);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return uncheckedAbsoluteLastIndexOf(this.arr,0,size,VAL);
  #ELSEIFSWITCH METHODNAME==search
return uncheckedSearch(size,VAL);
  #ELSE
ERROR ReturnUncheckedQuery(VAL) unknown method name METHODNAME
  #ENDIF
#ELSE
ERROR ReturnUncheckedQuery(VAL) unknown struct name STRUCTNAME
#ENDIF
#ENDDEF

#MACRODEF ReturnUncheckedQueryBits(VAL)
#IFSWITCH STRUCTNAME==Stack,List
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedcontainsBits(this.arr,0,size-1,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedRemoveValBits(size,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf
return uncheckedAbsoluteIndexOfBits(this.arr,0,size,VAL);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return uncheckedAbsoluteLastIndexOfBits(this.arr,0,size,VAL);
  #ELSEIFSWITCH METHODNAME==search
return uncheckedSearchBits(size,VAL);
  #ELSE
ERROR ReturnUncheckedQueryBits(VAL) unknown method name METHODNAME
  #ENDIF
#ELSE
ERROR ReturnUncheckedQueryBits(VAL) unknown struct name STRUCTNAME
#ENDIF
#ENDDEF

#MACRODEF ReturnUncheckedQuery0()
#IFSWITCH STRUCTNAME==Stack,List
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedcontains0(this.arr,0,size-1);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedRemoveVal0(size);
  #ELSEIFSWITCH METHODNAME==indexOf
return uncheckedAbsoluteIndexOf0(this.arr,0,size);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return uncheckedAbsoluteLastIndexOf0(this.arr,0,size);
  #ELSEIFSWITCH METHODNAME==search
return uncheckedSearch0(size);
  #ELSE
ERROR ReturnUncheckedQuery0() unknown method name METHODNAME
  #ENDIF
#ELSE
ERROR ReturnUncheckedQuery0() unknown struct name STRUCTNAME
#ENDIF
#ENDDEF

#MACRODEF ReturnUncheckedQueryNaN()
#IFSWITCH STRUCTNAME==Stack,List
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedcontainsNaN(this.arr,0,size-1);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedRemoveValNaN(size);
  #ELSEIFSWITCH METHODNAME==indexOf
return uncheckedAbsoluteIndexOfNaN(this.arr,0,size);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return uncheckedAbsoluteLastIndexOfNaN(this.arr,0,size);
  #ELSEIFSWITCH METHODNAME==search
return uncheckedSearchNaN(size);
  #ELSE
ERROR ReturnUncheckedQueryNaN() unknown method name METHODNAME
  #ENDIF
#ELSE
ERROR ReturnUncheckedQueryNaN() unknown struct name STRUCTNAME
#ENDIF
#ENDDEF

#MACRODEF DeclareModCount<INPUTTYPE>()
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==Stack,List
    #IFSWITCH METHODNAME==contains,indexOf,lastIndexOf,search
      #IFSWITCH INPUTTYPE==Object
int modCount=this.modCount;
      #ENDIF
    #ELSEIFSWITCH METHODNAME==removeVal
    #ELSE
ERROR DeclareModCount<INPUTTYPE> unknown method name METHODNAME
    #ENDIF
  #ELSE
ERROR DeclareModCount<INPUTTYPE> unknown struct name STRUCTNAME
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF ReturnNegative<INPUTTYPE>()
#IFSWITCH METHODNAME==contains,removeVal
return false;
#ELSE
return -1;
#ENDIF
#ENDDEF

#MACRODEF CheckModAndReturnNegative<INPUTTYPE>()
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==Stack,List
    #IFSWITCH METHODNAME==contains,indexOf,lastIndexOf,search
      #IFSWITCH INPUTTYPE==Object
CheckedCollection.checkModCount(modCount,this.modCount);
      #ENDIF
    #ELSEIFSWITCH METHODNAME==removeVal
    #ELSE
ERROR CheckModAndReturnNegative<INPUTTYPE> unknown method name METHODNAME
    #ENDIF
  #ELSE
ERROR CheckModAndReturnNegative<INPUTTYPE> unknown struct name STRUCTNAME
  #ENDIF
#ENDIF
#IFSWITCH METHODNAME==contains,removeVal
return false;
#ELSE
return -1;
#ENDIF
#ENDDEF

#MACRODEF QueryMethods<METHODNAME>()
#MACRO QueryBoolean()
#MACRO QueryInt()
#MACRO QueryLong()
#MACRO QueryFloat()
#MACRO QueryDouble()
#MACRO QueryObject()
//#IFSWITCH METHODNAME==contains,removeVal
//  #IF OfRef,OfByte
//#MACRO QueryByte()
//  #ENDIF
//#ENDIF
#ENDDEF

#MACRODEF QueryBoolean()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(boolean val)
{
  int size;
  if((size=this.size)!=0)
  {
#IF OfDouble,OfFloat
    if(val)
    {
      #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
    }
    #MACRO ReturnUncheckedQuery0()
#ELSE
    #MACRO ReturnUncheckedQuery($queryCastBoolean$(val))
#ENDIF
  }
  #MACRO ReturnNegative<boolean>()
}
#ENDDEF

#MACRODEF QueryByte()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(byte val)
{
  int size;
  if((size=this.size)!=0)
  {
    #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  }
  #MACRO ReturnNegative<byte>()
}
#ENDDEF

#MACRODEF QueryInt()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(int val)
{
  int size;
  if((size=this.size)!=0)
  {
#IF OfRef,OfLong,OfInt
    #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
#ELSEIF OfDouble,OfFloat
    if(val!=0)
    {
  #IF OfFloat
      if(TypeUtil.checkCastTo$ClassPrefix$(val))
  #ENDIF
      {
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
    }
    else
    {
      #MACRO ReturnUncheckedQuery0()
    }
#ELSEIF OfShort,OfChar,OfByte
    if(val==($exposedType$)val)
    {
      #MACRO ReturnUncheckedQuery(val)
    }
#ELSE
    final $exposedType$ v;
    switch(val)
    {
      default:
  		#MACRO ReturnNegative<int>()
      case 0:
        v=false;
        break;
      case 1:
        v=true;
    }
    #MACRO ReturnUncheckedQuery(v)
#ENDIF
  }
  #MACRO ReturnNegative<int>()
}
#ENDDEF

#MACRODEF QueryLong()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(long val)
{
  int size;
  if((size=this.size)!=0)
  {
#IF OfRef,OfLong
    #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
#ELSEIF OfDouble,OfFloat
    if(val!=0)
    {
      if(TypeUtil.checkCastTo$ClassPrefix$(val))
      {
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
    }
    else
    {
      #MACRO ReturnUncheckedQuery0()
    }
#ELSE
    final $exposedType$ v;
  #IF OfInt,OfShort,OfChar,OfByte
    if(val==(v=($exposedType$)val))
  #ELSE
    if(val==0L)
    {
      v=false;
    }
    else if(val==1L)
    {
      v=true;
    }
    else
    {
      #MACRO ReturnNegative<long>()
    }
  #ENDIF
    {
      #MACRO ReturnUncheckedQuery(v)
    }
#ENDIF
  }
  #MACRO ReturnNegative<long>()
}
#ENDDEF
#MACRODEF QueryFloat()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(float val)
{
  int size;
  if((size=this.size)!=0)
  {
#IF OfRef
    #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
#ELSEIF OfDouble,OfFloat
    if(val==val)
    {
      #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
    }
    #MACRO ReturnUncheckedQueryNaN()
#ELSE
    final $exposedType$ v;
  #IF OfLong
    if(TypeUtil.floatEquals(val,v=(long)val))
  #ELSEIF OfInt
    if((double)val==(double)(v=($exposedType$)val))
  #ELSEIF OfShort,OfChar,OfByte
    if(val==(v=($exposedType$)val))
  #ELSE
    switch(Float.floatToRawIntBits(val))
    {
      default:
        #MACRO ReturnNegative<float>()
      case 0:
      case Integer.MIN_VALUE:
        v=false;
        break;
      case 1:
        v=true;
    }
  #ENDIF
    {
      #MACRO ReturnUncheckedQuery(v)
    }
#ENDIF
  }
  #MACRO ReturnNegative<float>()
}
#ENDDEF

#MACRODEF QueryDouble()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(double val)
{
  int size;
  if((size=this.size)!=0)
  {
#IF OfRef
    #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
#ELSEIF OfDouble,OfFloat
  #IF OfDouble
    if(val==val)
    {
      #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
    }
  #ELSE
    final $exposedType$ v;
    if((v=($exposedType$)val)==val)
    {
      #MACRO ReturnUncheckedQueryBits($convertToBits$(v))
    }
    else if(v!=v)
  #ENDIF
    {
      #MACRO ReturnUncheckedQueryNaN()
    }
#ELSE
    final $exposedType$ v;
  #IF OfLong
    if(TypeUtil.doubleEquals(val,v=(long)val))
  #ELSEIF OfInt,OfShort,OfChar,OfByte
    if((v=($exposedType$)val)==val)
  #ELSE
    final long bits;
    if((bits=Double.doubleToRawLongBits(val))==0L || bits==Long.MIN_VALUE)
    {
      v=false;
    }
    else if(bits==1)
    {
      v=true;
    }
    else
    {
      #MACRO ReturnNegative<double>()
    }
  #ENDIF
    {
      #MACRO ReturnUncheckedQuery(v)
    }
#ENDIF
  }
  #MACRO ReturnNegative<double>()
}
#ENDDEF

#MACRODEF QueryObject()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
#IFSWITCH METHODNAME==removeVal
remove
#ELSE
METHODNAME
#ENDIF
(Object val)
{
  int size;
  if((size=this.size)!=0)
  {
#IFNOT OfRef
    if(val instanceof $BoxedType$)
#ENDIF
    {
#IF OfDouble,OfFloat
      final $exposedType$ v;
      if((v=($exposedType$)val)==v)
      {
        #MACRO ReturnUncheckedQueryBits($convertToBits$(v))
      }
      #MACRO ReturnUncheckedQueryNaN()
#ELSE
  #IFSWITCH METHODNAME==containsVal,indexOf,lastIndexOf
    #IFSWITCH CHECKED==Checked
      int modCount=this.modCount;
      try
    #ENDIF
  #ENDIF
      {
        #MACRO ReturnUncheckedQuery($queryCastRef$(val))
      }
  #IFSWITCH METHODNAME==containsVal,indexOf,lastIndexOf
    #IFSWITCH CHECKED==Checked
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    #ENDIF
  #ENDIF
  
#ENDIF
    }
  }
  #MACRO ReturnNegative<Object>()
}
#ENDDEF

#MACRODEF IndexEquals(VAL)
#IFSWITCH SUFFIX==Bits
val==$convertToBits$(VAL)
#ELSEIFSWITCH SUFFIX==0
0==(VAL)
#ELSEIFSWITCH SUFFIX==NaN
$BoxedType$.isNaN(VAL)
#ELSE
  #IF OfRef
val.test(VAL)
  #ELSE
val==(VAL)
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF IfClause(INDEXTEST,VAL)
if(
#MACRO INDEXTEST(VAL)
)
#ENDDEF
#MACRODEF UncheckedSearchMethod<SUFFIX>()
private int uncheckedSearchSUFFIX(int bound
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ val
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
  #IF OfRef
,Predicate<Object> val
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
)
{
  final var arr=this.arr;
  for(int index=bound-1;;)
  {
    #MACRO IfClause(IndexEquals,arr[index])
    {
      return bound-index;
    }
    if(index==0)
    {
      return -1;
    }
  }
}
#ENDDEF
#MACRODEF UncheckedIndexOfMethods<SUFFIX>()
private static int uncheckedAbsoluteIndexOfSUFFIX($ArrayType$[] arr,int offset,int bound
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ val
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
  #IF OfRef
,Predicate<Object> val
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
)
{
  for(;;)
  {
    #MACRO IfClause(IndexEquals,arr[offset])
    {
      return offset;
    }
    if(++offset==bound)
    {
      return -1;
    }
  }
}
private static int uncheckedAbsoluteLastIndexOfSUFFIX($ArrayType$[] arr,int offset,int bound
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ val
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
  #IF OfRef
,Predicate<Object> val
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
)
{
  for(;;)
  {
    #MACRO IfClause(IndexEquals,arr[--bound])
    {
      return bound;
    }
    if(offset==bound)
    {
      return -1;
    }
  }
}
/*
private static int uncheckedRelativeIndexOfSUFFIX($ArrayType$[] arr,int offset,int bound
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ val
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
  #IF OfRef
,Predicate<Object> val
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
)
{
  for(int i=offset;;)
  {
    #MACRO IfClause(IndexEquals,arr[i])
    {
      return i-offset;
    }
    if(++i==bound)
    {
      return -1;
    }
  }
}
private static int uncheckedRelativeLastIndexOfSUFFIX($ArrayType$[] arr,int offset,int bound
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ val
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
  #IF OfRef
,Predicate<Object> val
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
)
{
  for(;;)
  {
    #MACRO IfClause(IndexEquals,arr[--bound])
    {
      return bound-offset;
    }
    if(offset==bound)
    {
      return -1;
    }
  }
}
*/
#ENDDEF

#MACRODEF UncheckedRemoveVal<SUFFIX>()
private boolean uncheckedRemoveValSUFFIX(int size
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ val
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
  #IF OfRef
,Predicate<Object> val
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
)
{
#IFSWITCH CHECKED==Checked
  int modCount=this.modCount;
#ENDIF
  final var arr=this.arr;
#IFSWITCH STRUCTNAME==Stack
  for(int i=--size;;--i)
  {
    #MACRO IfClause(IndexEquals,arr[i])
    {
  #IFSWITCH CHECKED==Checked
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount+1;
  #ENDIF
      ArrCopy.semicheckedSelfCopy(arr,i+1,i,size-i);
  #IF OfRef
      arr[size]=null;
  #ENDIF
      this.size=size;
      return true;
    }
    if(i==0)
    {
#IFSWITCH CHECKED==Checked
      CheckedCollection.checkModCount(modCount,this.modCount);
#ENDIF
      return false;
    }
  }
#ELSE
  for(int i=0;;)
  {
    #MACRO IfClause(IndexEquals,arr[i])
    {
  #IFSWITCH CHECKED==Checked
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount+1;
  #ENDIF
      ArrCopy.semicheckedSelfCopy(arr,i+1,i,(--size)-i);
  #IF OfRef
      arr[size]=null;
  #ENDIF
      this.size=size;
      return true;
    }
    if(++i==size)
    {
#IFSWITCH CHECKED==Checked
      CheckedCollection.checkModCount(modCount,this.modCount);
#ENDIF
      return false;
    }
  }
#ENDIF
}
#ENDDEF

#MACRODEF SuppressUnchecked()
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
#ENDDEF