#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.api.OmniCollection;
import omni.util.OmniArray;
import omni.api.OmniList;
import omni.api.OmniStack;
import java.util.function.Predicate;
import java.util.function.Consumer;
import java.util.Comparator;
import omni.util.ArrCopy;
import omni.util.$ClassPrefix$SortUtil;
import omni.impl.CheckedCollection;
import java.util.NoSuchElementException;
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import java.util.function.IntFunction;
import java.util.function.UnaryOperator;
#IFNOT OfRef
import omni.util.TypeUtil;
#ENDIF
import java.util.ConcurrentModificationException;
#IF OfInt,OfLong,OfDouble
import java.util.function.$UnaryOperator$;
#ELSEIFNOT OfBoolean,OfRef
import omni.function.$UnaryOperator$;
#ENDIF
#IF OfInt
import java.util.function.$Comparator$;
#ELSEIFNOT OfRef
import omni.function.$Comparator$;
#ENDIF
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Predicate;
import java.util.function.$TypeNameModifier$Consumer;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Predicate;
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
#IFNOT OfDouble,OfChar,OfRef
import omni.util.ToStringUtil;
#ENDIF
#IFNOT OfRef
import omni.impl.Abstract$TypeNameModifier$Itr;
#ENDIF
#IF OfRef
import omni.util.OmniPred;
#ENDIF
import java.io.Externalizable;
import java.io.Serializable;
import java.io.IOException;
import java.io.ObjectOutput;
import java.io.ObjectInput;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.util.RandomAccess;
public abstract class $ClassPrefix$ArrSeq$<E>$ extends 
#IF OfRef
AbstractSeq$<E>$
#ELSE
AbstractSeq<$BoxedType$>
#ENDIF
 implements OmniCollection.Of$ClassPrefix$$<E>$,Externalizable,RandomAccess{
  //TODO refactor the template and/or optimize code generation to make sure that the code generation doesn't take forever
  private static final long serialVersionUID=1L;
  transient $ArrayType$[] arr; 
  private $ClassPrefix$ArrSeq(){
    super();
    this.arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
  }
  private $ClassPrefix$ArrSeq(int initialCapacity){
    super();
    switch(initialCapacity){ 
    default:
      this.arr=new $ArrayType$[initialCapacity];
      return;
    case OmniArray.DEFAULT_ARR_SEQ_CAP:
      this.arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
    case 0:
    }
  }
  private $ClassPrefix$ArrSeq(int size,$ArrayType$[] arr){
    super(size);
    this.arr=arr;
  }
  @Override public void writeExternal(ObjectOutput out) throws IOException{
    int size;
    out.writeInt(size=this.size);
    if(size!=0)
    {
#IF OfByte
      out.write(this.arr,0,size);
#ELSE
      OmniArray.Of$ClassPrefix$.writeArray(arr,0,size-1,out);
#ENDIF
    }
  }
  @Override public void readExternal(ObjectInput in) throws IOException
#IF OfRef
    ,ClassNotFoundException
#ENDIF
  {
    int size;
    this.size=size=in.readInt();
    if(size!=0){
      $ArrayType$[] arr;
#IF OfByte
      in.readFully(arr=new $ArrayType$[size],0,size);
#ELSE
      OmniArray.Of$ClassPrefix$.readArray(arr=new $ArrayType$[size],0,size-1,in);
#ENDIF
      this.arr=arr;
    }
  }
#IFNOT OfBoolean
  #MACRO SuppressUnchecked()
  static $<E>$ long markSurvivors($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter){
    for(long word=0L,marker=1L;;marker<<=1){
      if(!filter.test(($exposedType$)arr[srcOffset])){
        word|=marker;
      }
      if(++srcOffset==srcBound){
        return word;
      }
    }
  }
  #MACRO SuppressUnchecked()
  static $<E>$ int markSurvivors($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter,long[] survivorSet){
    for(int numSurvivors=0,wordOffset=0;;){
      long word=0L,marker=1L;
      do{
        if(!filter.test(($exposedType$)arr[srcOffset])){
          word|=marker;
          ++numSurvivors;
        }
        if(++srcOffset==srcBound){
          survivorSet[wordOffset]=word;
          return numSurvivors;
        }
      }
      while((marker<<=1)!=0L);
      survivorSet[wordOffset++]=word;
    }
  }
  static void pullSurvivorsDown($ArrayType$[] arr,int srcOffset,int dstOffset,long word){
    int numTail0s=Long.numberOfTrailingZeros(word);
    do{
      ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset+=numTail0s,numTail0s=Long.numberOfTrailingZeros(~(word>>>=numTail0s)));
      srcOffset+=numTail0s;
      dstOffset+=numTail0s;
    }while((numTail0s=Long.numberOfTrailingZeros(word>>>=numTail0s))!=64);
  }
  static void pullSurvivorsDown($ArrayType$[] arr,int srcOffset,int dstOffset,int dstBound,long[] survivorSet){
    for(int wordOffset=0;;){
      long word=survivorSet[wordOffset];
      for(int s=srcOffset;;){
        int numTail0s;
        if((numTail0s=Long.numberOfTrailingZeros(word))==64){
          break;
        }
        ArrCopy.uncheckedSelfCopy(arr,dstOffset,s+=numTail0s,numTail0s=Long.numberOfTrailingZeros(~(word>>>=numTail0s)));
        dstOffset+=numTail0s;
        if(numTail0s==64){
          break;
        }else if(dstOffset>=dstBound){
          return;
        }
        s+=numTail0s;
        word>>>=numTail0s;
      }
      ++wordOffset;
      srcOffset+=64;
    }
  }
#ENDIF
  @Override public void clear(){
#IF OfRef
    int size;
    if((size=this.size)!=0){
      this.size=0;
      OmniArray.Of$ClassPrefix$.nullifyRange(this.arr,size-1,0);
    }
#ELSE
    this.size=0;
#ENDIF
  }
  @Override public int hashCode(){
    final int size;
    if((size=this.size)!=0){
      return uncheckedHashCode(size);
    }
    return 1;
  }
  @Override public String toString(){
    int size;
    if((size=this.size)!=0){
#IF OfDouble,OfRef
      final StringBuilder builder=new StringBuilder("[");
      uncheckedToString(size,builder);
      return builder.append(']').toString();
#ELSE
  #IF OfChar
      final char[] buffer;
      uncheckedToString(size,buffer=new char[size*=3]);
      buffer[0]='[';
      buffer[size-1]=']';
      return new String(buffer,0,size);
  #ELSE
      final byte[] buffer;
    #IF OfBoolean
      if(size<=(OmniArray.MAX_ARR_SIZE/7)){(buffer=new byte[size*7])
    #ELSEIF OfByte
      if(size<=(OmniArray.MAX_ARR_SIZE/6)){(buffer=new byte[size*6])
    #ELSEIF OfShort
      if(size<=(OmniArray.MAX_ARR_SIZE>>3)){(buffer=new byte[size<<3])
    #ELSEIF OfInt
      if(size<=(OmniArray.MAX_ARR_SIZE/13)){(buffer=new byte[size*13])
    #ELSEIF OfLong
      if(size<=(OmniArray.MAX_ARR_SIZE/22)){(buffer=new byte[size*22])
    #ELSEIF OfFloat
      if(size<=(OmniArray.MAX_ARR_SIZE/17)){(buffer=new byte[size*17])
    #ENDIF
        [size=uncheckedToString(size,buffer)]=(byte)']';
        buffer[0]=(byte)'[';
        return new String(buffer,0,size+1,ToStringUtil.IOS8859CharSet);
      }else{
        final ToStringUtil.OmniStringBuilderByte builder;
        uncheckedToString(size,builder=new ToStringUtil.OmniStringBuilderByte(1,new byte[OmniArray.MAX_ARR_SIZE]));
        builder.uncheckedAppendChar((byte)']');
        (buffer=builder.buffer)[0]=(byte)'[';
        return new String(buffer,0,builder.size,ToStringUtil.IOS8859CharSet);
      }
  #ENDIF 
#ENDIF
    }
    return "[]";
  }
  abstract int uncheckedHashCode(int size);
#IF OfDouble,OfRef
  abstract void uncheckedToString(int size,StringBuilder builder);
#ELSEIF OfChar
  abstract void uncheckedToString(int size,char[] buffer);
#ELSE
  abstract int uncheckedToString(int size,byte[] buffer);
  abstract void uncheckedToString(int size,ToStringUtil.OmniStringBuilderByte builder);
#ENDIF
  #MACRO RootQueryMethods<Root,contains>()
  #MACRO RootQueryMethods<Root,removeVal>()
  #IF OfRef
  abstract boolean uncheckedremoveValNonNull(int size,Object nonNull);
  abstract boolean uncheckedremoveValNull(int size);
  abstract boolean uncheckedremoveVal(int size,Predicate<Object> pred);
  #ELSEIF OfDouble,OfFloat
  abstract boolean uncheckedremoveValBits(int size,$queryParameterType$ bits);
  abstract boolean uncheckedremoveVal0(int size);
  abstract boolean uncheckedremoveValNaN(int size);
  #ELSE
  abstract boolean uncheckedremoveVal(int size,$queryParameterType$ val);
  #ENDIF
  abstract void uncheckedForEach(int size,$TypeNameModifier$Consumer$<? super E>$ action);
  @Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
    final int size;
    if((size=this.size)!=0){
      uncheckedForEach(size,action);
    }
  }
#IFNOT OfRef
  @Override public void forEach(Consumer<? super $BoxedType$> action){
    final int size;
    if((size=this.size)!=0){
      uncheckedForEach(size,action::accept);
    }
  }
#ENDIF
  private void uncheckedAppend(int size,$exposedType$ val){
    $ArrayType$[] arr;
    if((arr=this.arr).length==size){
      ArrCopy.uncheckedCopy(arr,0,arr=new $ArrayType$[OmniArray.growBy50Pct(size)],0,size);
      this.arr=arr;
    }
    arr[size]=val;
    this.size=size+1;
  }
  private void uncheckedInit($exposedType$ val){
    $ArrayType$[] arr;
    if((arr=this.arr)==null){
      this.arr=new $ArrayType$[]{val};
    }else{
      if(arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR){
        this.arr=arr=new $ArrayType$[OmniArray.DEFAULT_ARR_SEQ_CAP];
      }
      arr[0]=val;
    }
    this.size=1;
  }
  public void push($exposedType$ val){
    final int size;
    if((size=this.size)!=0){
      uncheckedAppend(size,val);
    }else{
      uncheckedInit(val);
    }
  }
  @Override public boolean add($exposedType$ val){
    push(val);
    return true;
  }
#IFNOT OfRef
  @Override public boolean add($BoxedType$ val){
    push(($exposedType$)val);
    return true;
  }
  #IFNOT OfBoolean
  @Override public boolean add(boolean val){
    push(($exposedType$)$queryCastBoolean$(val));
    return true;
  }
  #ENDIF
#ENDIF
#IF OfInt,OfLong
  @Override public boolean add(char val){
    push(($exposedType$)val);
    return true;
  }
#ENDIF
#IF OfInt,OfLong,OfShort
  @Override public boolean add(byte val){
    push(($exposedType$)val);
    return true;
  }
#ENDIF
#IF OfDouble,OfFloat,OfLong
  @Override public boolean add(int val){
    push(($exposedType$)val);
    return true;
  }
  #IF OfFloat
  @Override public boolean add(char val){
    push(($exposedType$)val);
    return true;
  }
  @Override public boolean add(short val){
    push(($exposedType$)val);
    return true;
  }  
  #ENDIF
  #IFNOT OfLong
  @Override public boolean add(long val){
    push(($exposedType$)val);
    return true;
  }
    #IFNOT OfFloat
  @Override public boolean add(float val){
    push(($exposedType$)val);
    return true;
  }
    #ENDIF
  #ENDIF
#ENDIF
  abstract void uncheckedCopyInto($ArrayType$[] dst,int length);
  @Override public <T> T[] toArray(T[] arr){
    final int size;
    if((size=this.size)!=0){
      uncheckedCopyInto(arr=OmniArray.uncheckedArrResize(size,arr),size);
    }else if(arr.length!=0){
      arr[0]=null;
    }
    return arr;
  }
  @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
    final int size;
    T[] dst=arrConstructor.apply(size=this.size);
    if(size!=0){
      uncheckedCopyInto(dst,size);
    }
    return dst;
  }
  #MACRO RootToArrayImpl($ArrayType$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR,$TypeNameModifier$)
#IFNOT OfRef
  abstract void uncheckedCopyInto(Object[] dst,int length);
  abstract void uncheckedCopyInto($BoxedType$[] dst,int length);
  #MACRO RootToArrayImpl($BoxedType$,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR,)
  #IFNOT OfDouble
  abstract void uncheckedCopyInto(double[] dst,int length);
  #MACRO RootToArrayImpl(double,OmniArray.OfDouble.DEFAULT_ARR,Double)
    #IFNOT OfFloat
  abstract void uncheckedCopyInto(float[] dst,int length);
  #MACRO RootToArrayImpl(float,OmniArray.OfFloat.DEFAULT_ARR,Float)
      #IFNOT OfLong
  abstract void uncheckedCopyInto(long[] dst,int length);
  #MACRO RootToArrayImpl(long,OmniArray.OfLong.DEFAULT_ARR,Long)
        #IFNOT OfInt
  abstract void uncheckedCopyInto(int[] dst,int length);
  #MACRO RootToArrayImpl(int,OmniArray.OfInt.DEFAULT_ARR,Int)
          #IFNOT OfShort,OfChar
  abstract void uncheckedCopyInto(short[] dst,int length);
  #MACRO RootToArrayImpl(short,OmniArray.OfShort.DEFAULT_ARR,Short)
            #IFNOT OfByte
  abstract void uncheckedCopyInto(byte[] dst,int length);
  #MACRO RootToArrayImpl(byte,OmniArray.OfByte.DEFAULT_ARR,Byte)
  abstract void uncheckedCopyInto(char[] dst,int length);
  #MACRO RootToArrayImpl(char,OmniArray.OfChar.DEFAULT_ARR,Char)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  boolean uncheckedRemoveIf(int size,$TypeNameModifier$Predicate$<? super E>$ filter){
    #IF OfRef
    final int numRemoved;
    final $ArrayType$[] arr;
    if((numRemoved=uncheckedRemoveIfImpl(arr=this.arr,0,size,filter))!=0){
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,size-1,size-=numRemoved);
    #ELSE
    if(size!=(size-=uncheckedRemoveIfImpl(this.arr,0,size,filter))){
    #ENDIF
      this.size=size;
      return true;
    }
    return false;
  }
  #MACRO RootRemoveIfImpl($TypeNameModifier$Predicate$<? super E>$,filter)
#IFNOT OfRef
  #MACRO RootRemoveIfImpl(Predicate<? super $BoxedType$>,filter::test);
#ENDIF
#IF OfBoolean
  private static int pullSurvivorsDown($ArrayType$[] arr,int srcOffset,int srcBound,int dstOffset,$ArrayType$ retainThis){
    while(++srcOffset!=srcBound){
      if(arr[srcOffset]==retainThis){
        arr[dstOffset++]=retainThis;
      }
    }
    return srcBound-dstOffset;
  }
  private static int uncheckedRemoveIfImpl($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter){
    $ArrayType$ v;
    if(filter.test(v=arr[srcOffset])){
      final int dstOffset=srcOffset;
      while(++srcOffset!=srcBound){
        if(arr[srcOffset]^v){
          if(filter.test(v=!v)){
            break;
          }
          arr[dstOffset]=v;
          return pullSurvivorsDown(arr,srcOffset,srcBound,dstOffset+1,v);
        }
      }
      return srcBound-dstOffset;
    }else{
      while(++srcOffset!=srcBound){
        if(arr[srcOffset]^v){
          if(filter.test(!v)){
            return pullSurvivorsDown(arr,srcOffset,srcBound,srcOffset,v);
          }
          break;
        }
      }
      return 0;
    }
  }
  private static int uncheckedRemoveIfImpl($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter,CheckedCollection.AbstractModCountChecker modCountChecker){
    $ArrayType$ v;
    if(filter.test(v=arr[srcOffset])){
      final int dstOffset=srcOffset;
      while(++srcOffset!=srcBound){
        if(arr[srcOffset]^v){
          if(filter.test(v=!v)){
            break;
          }
          modCountChecker.checkModCount();
          arr[dstOffset]=v;
          return pullSurvivorsDown(arr,srcOffset,srcBound,dstOffset+1,v);
        }
      }
      modCountChecker.checkModCount();
      return srcBound-dstOffset;
    }else{
      while(++srcOffset!=srcBound){
        if(arr[srcOffset]^v){
          if(filter.test(!v)){
            modCountChecker.checkModCount();
            return pullSurvivorsDown(arr,srcOffset,srcBound,srcOffset,v);
          }
          break;
        }
      }
      return 0;
    }
  }
#ELSE
  #MACRO SuppressUnchecked()
  private static $<E>$ int pullSurvivorsDown($ArrayType$[] arr,int srcOffset,int srcBound,int dstOffset,$TypeNameModifier$Predicate$<? super E>$ filter){
    while(++srcOffset!=srcBound){
      final $ArrayType$ v;
      if(!filter.test(($exposedType$)(v=arr[srcOffset])))
      {
        arr[dstOffset++]=v;
      }
    }
    return srcBound-dstOffset;
  }
  #MACRO SuppressUnchecked()
  private static $<E>$ int uncheckedRemoveIfImpl($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter){
    do{
      if(filter.test(($exposedType$)arr[srcOffset])){
        return pullSurvivorsDown(arr,srcOffset,srcBound,srcOffset,filter);
      }
    }while(++srcOffset!=srcBound);
    return 0;
  }
  #MACRO SuppressUnchecked()
  private static $<E>$ int uncheckedRemoveIfImpl($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter,CheckedCollection.AbstractModCountChecker modCountChecker){
    do{
      if(filter.test(($exposedType$)arr[srcOffset])){
        int dstOffset=srcOffset;
        outer:for(;;){
          if(++srcOffset==srcBound){
            modCountChecker.checkModCount();
            break outer;
          }
          $ArrayType$ before;
          if(!filter.test(($exposedType$)(before=arr[srcOffset]))){
            for(int i=srcBound-1;;--i){
              if(i==srcOffset){
                modCountChecker.checkModCount();
                arr[dstOffset++]=before;
                break outer;
              }
              $ArrayType$ after;
              if(!filter.test(($exposedType$)(after=arr[i]))){
                int n;
                if((n=i-(++srcOffset))!=0){
                  if(n>64){
                    long[] survivorSet;
                    int numSurvivors=markSurvivors(arr,srcOffset,i,filter,survivorSet=new long[(n-1>>6)+1]);
                    modCountChecker.checkModCount();
                    if(numSurvivors!=0){
                      if(numSurvivors==n){
                        System.arraycopy(arr,srcOffset-1,arr,dstOffset,numSurvivors+=2);
                        dstOffset+=numSurvivors;
                      }else{
                        arr[dstOffset]=before;
                        pullSurvivorsDown(arr,srcOffset,++dstOffset,dstOffset+=numSurvivors,survivorSet);
                        arr[dstOffset++]=after;
                      }
                      break outer;
                    }
                  }else{
                    long survivorWord=markSurvivors(arr,srcOffset,i,filter);
                    modCountChecker.checkModCount();
                    int numSurvivors;
                    if((numSurvivors=Long.bitCount(survivorWord))!=0){
                      if(numSurvivors==n){
                        ArrCopy.uncheckedSelfCopy(arr,dstOffset,srcOffset-1,numSurvivors+=2);
                        dstOffset+=numSurvivors;
                      }else{
                        arr[dstOffset]=before;
                        pullSurvivorsDown(arr,srcOffset,++dstOffset,survivorWord);
                        arr[dstOffset+=numSurvivors]=after;
                        ++dstOffset;
                      }
                      break outer;
                    }
                  }
                }else{
                  modCountChecker.checkModCount();
                }
                arr[dstOffset++]=before;
                arr[dstOffset++]=after;
                break outer;
              }
            }
          }
        }
        return srcBound-dstOffset;
      }
    }
    while(++srcOffset!=srcBound);
    return 0;
  }
#ENDIF
  #MACRO StructImpl<UncheckedStack>()
  #MACRO StructImpl<UncheckedList>()
  #MACRO StructImpl<UncheckedSubList>()
  #MACRO StructImpl<CheckedStack>()
  #MACRO StructImpl<CheckedList>()
  #MACRO StructImpl<CheckedSubList>()
}
#MACRODEF StructImpl<STRUCTNAME>()
#IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSublist
private
#ELSE
public
#ENDIF
  static class STRUCTNAME$<E>$
#IFSWITCH STRUCTNAME==CheckedStack
    extends UncheckedStack$<E>$
#ELSEIFSWITCH STRUCTNAME==CheckedList
    extends UncheckedList$<E>$
#ELSEIFSWITCH STRUCTNAME==UncheckedStack,UncheckedList
    extends $ClassPrefix$ArrSeq$<E>$
#ELSE
  #IF OfRef
    extends AbstractSeq$<E>$
  #ELSE
    extends AbstractSeq<$BoxedType$>
  #ENDIF
#ENDIF
#IFSWITCH STRUCTNAME==UncheckedList,CheckedSubList,UncheckedSubList
  #IF OfRef
    implements OmniList.Of$ClassPrefix$$<E>$,Cloneable,RandomAccess
  #ELSE
    #IFSWITCH STRUCTNAME==UncheckedList
    implements $ClassPrefix$ListDefault$<E>$,Cloneable,RandomAccess
    #ELSE
    implements $ClassPrefix$SubListDefault$<E>$,Cloneable,RandomAccess
    #ENDIF
  #ENDIF
#ENDIF
#IFSWITCH STRUCTNAME==UncheckedStack
    implements OmniStack.Of$ClassPrefix$$<E>$,Cloneable,RandomAccess
#ENDIF
{
  private static final long serialVersionUID=1L;
  #IFSWITCH STRUCTNAME==CheckedSubList,CheckedList,CheckedStack
  transient int modCount;
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  transient final int rootOffset;
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList
  transient final CheckedList$<E>$ root;
  transient final CheckedSubList$<E>$ parent;
  #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  transient final UncheckedList$<E>$ root;
  transient final UncheckedSubList$<E>$ parent;
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList
  private CheckedSubList(CheckedList$<E>$ root,int rootOffset,int size){
    super(size);
    this.root=root;
    this.parent=null;
    this.rootOffset=rootOffset;
    this.modCount=root.modCount;
  }
  private CheckedSubList(CheckedSubList$<E>$ parent,int rootOffset,int size){
    super(size);
    this.root=parent.root;
    this.parent=parent;
    this.rootOffset=rootOffset;
    this.modCount=parent.modCount;
  }
  #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  private UncheckedSubList(UncheckedList$<E>$ root,int rootOffset,int size){
    super(size);
    this.root=root;
    this.parent=null;
    this.rootOffset=rootOffset;
  }
  private UncheckedSubList(UncheckedSubList$<E>$ parent,int rootOffset,int size){
    super(size);
    this.root=parent.root;
    this.parent=parent;
    this.rootOffset=rootOffset;
  }
  #ELSE
  public STRUCTNAME(){
    super();
  }
  public STRUCTNAME(int initialCapacity){
    super(initialCapacity);
  }
  STRUCTNAME(int size,$ArrayType$[] arr){
    super(size,arr);
  }
  #ENDIF
#IFSWITCH STRUCTNAME==CheckedStack,CheckedList
  private class ModCountChecker extends CheckedCollection.AbstractModCountChecker{
    ModCountChecker(int modCount){
      super(modCount);
    }
    @Override protected int getActualModCount(){
      return STRUCTNAME.this.modCount;
    }
  }
#ENDIF
#IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  @Override public void writeExternal(ObjectOutput out) throws IOException{
    int modCount=this.modCount;
    try{
      super.writeExternal(out);
    }finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
  }
#ENDIF
#IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  private static class SerializableSubList$<E>$ implements Serializable{
    private static final long serialVersionUID=1L;
    private transient $ArrayType$[] arr;
    private transient int size;
    private transient final int rootOffset;
  #IFSWITCH STRUCTNAME==CheckedSubList
    private transient final CheckedList$<E>$.ModCountChecker modCountChecker;
  #ENDIF
    private SerializableSubList($ArrayType$[] arr,int size,int rootOffset
  #IFSWITCH STRUCTNAME==CheckedSubList
      ,CheckedList$<E>$.ModCountChecker modCountChecker
  #ENDIF
    ){
      this.arr=arr;
      this.size=size;
      this.rootOffset=rootOffset;
  #IFSWITCH STRUCTNAME==CheckedSubList
      this.modCountChecker=modCountChecker;
  #ENDIF
    }
    private Object readResolve(){
      #IFSWITCH STRUCTNAME==CheckedSubList
      return new CheckedList$<E>$(size,arr);
      #ELSE
      return new UncheckedList$<E>$(size,arr);
      #ENDIF
    }
    private void readObject(ObjectInputStream ois) throws IOException
  #IF OfRef
      ,ClassNotFoundException
  #ENDIF
    {
      int size;
      this.size=size=ois.readInt();
      if(size!=0){
        $ArrayType$[] arr;
#IF OfByte
        ois.readFully(arr=new $ArrayType$[size]);
#ELSE
        OmniArray.Of$ClassPrefix$.readArray(arr=new $ArrayType$[size],0,size-1,ois);
#ENDIF
        this.arr=arr;
      }
    }
    private void writeObject(ObjectOutputStream oos) throws IOException{
  #IFSWITCH STRUCTNAME==CheckedSubList
      try
  #ENDIF
      {
        int size;
        oos.writeInt(size=this.size);
        if(size!=0){
  #IF OfByte
          oos.write(arr,rootOffset,size);
  #ELSE
          final int rootOffset;
          OmniArray.Of$ClassPrefix$.writeArray(arr,rootOffset=this.rootOffset,rootOffset+size-1,oos);
  #ENDIF
        }
      }
  #IFSWITCH STRUCTNAME==CheckedSubList
      finally{
        modCountChecker.checkModCount();
      }
  #ENDIF
    }
  }
  private Object writeReplace(){
  #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    return new SerializableSubList$<E>$((root=this.root).arr,this.size,this.rootOffset,root.new ModCountChecker(this.modCount));
  #ELSE
    return new SerializableSubList$<E>$(root.arr,this.size,this.rootOffset);
  #ENDIF
  }
#ENDIF
  @Override public boolean equals(Object val){
    //TODO implements equals method for STRUCTNAME$<E>$
    return false;
  }
  @Override public Object clone(){
  #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    CheckedCollection.checkModCount(this.modCount,(root=this.root).modCount);
  #ENDIF
    final $ArrayType$[] copy;
    final int size;
    if((size=this.size)!=0){
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
      ArrCopy.uncheckedCopy(root.arr,rootOffset,copy=new $ArrayType$[size],0,size);
  #ELSE
      ArrCopy.uncheckedCopy(this.arr,0,copy=new $ArrayType$[size],0,size);
  #ENDIF
    }else{
      copy=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
    }
  #IFSWITCH STRUCTNAME==CheckedSubList
    return new CheckedList$<E>$(size,copy);
  #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
    return new UncheckedList$<E>$(size,copy);
  #ELSE
    return new STRUCTNAME$<E>$(size,copy);
  #ENDIF
  }
    #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
    #IF OfRef
  @Override void uncheckedToString(int size,StringBuilder builder){
    final int modCount=this.modCount;
    try{
      super.uncheckedToString(size,builder);
    }finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
  }
    #ENDIF
  #ELSEIFSWITCH STRUCTNAME==UncheckedList,UncheckedStack
    #IF OfRef,OfDouble
  @Override void uncheckedToString(int size,StringBuilder builder){
    #IFSWITCH STRUCTNAME==UncheckedList
    OmniArray.Of$ClassPrefix$.ascendingToString(this.arr,0,size-1,builder);
    #ELSE
    OmniArray.Of$ClassPrefix$.descendingToString(this.arr,0,size-1,builder);
    #ENDIF
  }
    #ELSEIF OfChar
  void uncheckedToString(int size,char[] buffer){
    #IFSWITCH STRUCTNAME==UncheckedList
    OmniArray.Of$ClassPrefix$.ascendingToString(this.arr,0,size-1,buffer,1);
    #ELSE
    OmniArray.Of$ClassPrefix$.descendingToString(this.arr,0,size-1,buffer,1);
    #ENDIF
  }
    #ELSE
  int uncheckedToString(int size,byte[] buffer){
    #IFSWITCH STRUCTNAME==UncheckedList
    return OmniArray.Of$ClassPrefix$.ascendingToString(this.arr,0,size-1,buffer,1);
    #ELSE
    return OmniArray.Of$ClassPrefix$.descendingToString(this.arr,0,size-1,buffer,1);
    #ENDIF
  }
  void uncheckedToString(int size,ToStringUtil.OmniStringBuilderByte builder){
    #IFSWITCH STRUCTNAME==UncheckedList
    OmniArray.Of$ClassPrefix$.ascendingToString(this.arr,0,size-1,builder);
    #ELSE
    OmniArray.Of$ClassPrefix$.descendingToString(this.arr,0,size-1,builder);
    #ENDIF
  }
    #ENDIF
  #ELSE
  @Override public String toString(){
    #IF OfRef
      #IFSWITCH STRUCTNAME==CheckedSubList
    final int modCount=this.modCount;
    final var root=this.root;
    try
      #ENDIF
    {
      final int size;
      if((size=this.size)!=0){
        final StringBuilder builder;
        final int rootOffset;
        OmniArray.Of$ClassPrefix$.ascendingToString(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,builder=new StringBuilder("["));
        return builder.append(']').toString();
      }
      return "[]";
    }
      #IFSWITCH STRUCTNAME==CheckedSubList
    finally{
      CheckedCollection.checkModCount(modCount,root.modCount);
    }
      #ENDIF
    #ELSE
      #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
      #ENDIF
    int size;
    if((size=this.size)!=0){
        final int rootOffset;
      #IF OfDouble
        final StringBuilder builder;
        OmniArray.Of$ClassPrefix$.ascendingToString(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,builder=new StringBuilder("["));
        return builder.append(']').toString();
      #ELSE
        #IF OfChar
        final char[] buffer;
        OmniArray.Of$ClassPrefix$.ascendingToString(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,buffer=new char[size*=3],1);
        buffer[0]='[';
        buffer[size-1]=']';
        return new String(buffer,0,size);
        #ELSE
        final byte[] buffer;
          #IF OfBoolean
        if(size<=(OmniArray.MAX_ARR_SIZE/7)){(buffer=new byte[size*7])
          #ELSEIF OfByte
        if(size<=(OmniArray.MAX_ARR_SIZE/6)){(buffer=new byte[size*6])
          #ELSEIF OfShort
        if(size<=(OmniArray.MAX_ARR_SIZE>>3)){(buffer=new byte[size<<3])
          #ELSEIF OfInt
        if(size<=(OmniArray.MAX_ARR_SIZE/13)){(buffer=new byte[size*13])
          #ELSEIF OfLong
        if(size<=(OmniArray.MAX_ARR_SIZE/22)){(buffer=new byte[size*22])
          #ELSEIF OfFloat
        if(size<=(OmniArray.MAX_ARR_SIZE/17)){(buffer=new byte[size*17])
          #ENDIF
          [size=OmniArray.Of$ClassPrefix$.ascendingToString(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,buffer,1)]=(byte)']';
          buffer[0]=(byte)'[';
          return new String(buffer,0,size+1,ToStringUtil.IOS8859CharSet);
        }else{
          final ToStringUtil.OmniStringBuilderByte builder;
          OmniArray.Of$ClassPrefix$.ascendingToString(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,builder=new ToStringUtil.OmniStringBuilderByte(1,new byte[OmniArray.MAX_ARR_SIZE]));
          builder.uncheckedAppendChar((byte)']');
          (buffer=builder.buffer)[0]=(byte)'[';
          return new String(buffer,0,builder.size,ToStringUtil.IOS8859CharSet);
        }
        #ENDIF 
      #ENDIF
    }
    return "[]";
    #ENDIF
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  #IF OfRef
@Override int uncheckedHashCode(int size){
  final int modCount=this.modCount;
  try{
    return super.uncheckedHashCode(size);
  }finally{
    CheckedCollection.checkModCount(modCount,this.modCount);
  }
}
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedList,UncheckedStack
@Override int uncheckedHashCode(int size){
  #IFSWITCH STRUCTNAME==UncheckedList
  return OmniArray.Of$ClassPrefix$.ascendingSeqHashCode(this.arr,0,size-1);
  #ELSE
  return OmniArray.Of$ClassPrefix$.descendingSeqHashCode(this.arr,0,size-1);
  #ENDIF
}
#ELSE
@Override public int hashCode(){
  #IF OfRef
    #IFSWITCH STRUCTNAME==CheckedSubList
  final int modCount=this.modCount;
  final var root=this.root;
  try
    #ENDIF
  {
    final int size;
    if((size=this.size)!=0){
      final int rootOffset;
      return OmniArray.Of$ClassPrefix$.ascendingSeqHashCode(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
    }
    return 1;
  }
    #IFSWITCH STRUCTNAME==CheckedSubList
  finally{
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
    #ENDIF
  #ELSE
    #IFSWITCH STRUCTNAME==CheckedSubList
  final CheckedList$<E>$ root;
  CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
    #ENDIF
  final int size;
  if((size=this.size)!=0){
    final int rootOffset;
    return OmniArray.Of$ClassPrefix$.ascendingSeqHashCode(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
  }
  return 1;
  #ENDIF
}
#ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList
  @Override public int size(){
    CheckedCollection.checkModCount(modCount,root.modCount);
    return this.size;
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList
  @Override public boolean isEmpty(){
    CheckedCollection.checkModCount(modCount,root.modCount);
    return this.size==0;
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList,CheckedList,CheckedStack
  @Override public void clear(){
    #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
      #IF OfRef
    final int size;
    if((size=this.size)!=0){
      ++this.modCount;
      this.size=0;
      OmniArray.Of$ClassPrefix$.nullifyRange(this.arr,size-1,0);
    }
      #ELSE
    if(this.size!=0){
      ++this.modCount;
      this.size=0;
    }
      #ENDIF
    #ELSE
      #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    int modCount;
    CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
      #ENDIF
    final int size;
    if((size=this.size)!=0){
      #IFSWITCH STRUCTNAME==CheckedSubList
      root.modCount=++modCount;
      this.modCount=modCount;
      for(var curr=parent;curr!=null;curr.modCount=modCount,curr.size-=size,curr=curr.parent){}
      root.size=OmniArray.Of$ClassPrefix$.removeRangeAndPullDown(root.arr,this.rootOffset+size,root.size,size);
      #ELSE
      for(var curr=parent;curr!=null;curr.size-=size,curr=curr.parent){}
      final UncheckedList$<E>$ root;
      (root=this.root).size=OmniArray.Of$ClassPrefix$.removeRangeAndPullDown(root.arr,this.rootOffset+size,root.size,size);
      #ENDIF
      this.size=0;
    }
    #ENDIF
  }
  #ENDIF
  #MACRO QueryMethods<removeVal>()
  #MACRO QueryMethods<contains>()
  #MACRO QueryMethods<indexOf>()
  #MACRO QueryMethods<lastIndexOf>()
  #MACRO QueryMethods<search>()
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
    #IF OfRef
  private boolean uncheckedremoveValNonNull(int size,Object nonNull){
    #IFSWITCH STRUCTNAME==CheckedSubList
    int modCount=this.modCount;
    final CheckedList$<E>$ root;
    final var arr=(root=this.root).arr;
    try
    #ELSE
    final UncheckedList$<E>$ root;
    final var arr=(root=this.root).arr;
    #ENDIF
    {
      for(int index=this.rootOffset,bound=index+(--size);;++index){
        if(nonNull.equals(arr[index])){
    #IFSWITCH STRUCTNAME==CheckedSubList
          CheckedCollection.checkModCount(modCount,root.modCount);
          root.modCount=++modCount;
          this.modCount=modCount;
          for(var curr=parent;curr!=null;curr.modCount=modCount,--curr.size,curr=curr.parent){}
    #ELSE
          for(var curr=parent;curr!=null;--curr.size,curr=curr.parent){}
    #ENDIF
          OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,--root.size);
          this.size=size;
          return true;
        }else if(index==bound){
    #IFSWITCH STRUCTNAME==CheckedSubList
          CheckedCollection.checkModCount(modCount,root.modCount);
    #ENDIF
          return false;
        }
      }
    }
    #IFSWITCH STRUCTNAME==CheckedSubList
    catch(final ConcurrentModificationException e){
      throw e;
    }catch(final RuntimeException e){
      throw CheckedCollection.checkModCount(modCount,root.modCount,e);
    }
    #ENDIF
  }
  #MACRO BasicSubListRemoveVal<Null>()
  #MACRO BasicSubListRemoveVal< >()
    #ELSEIF OfDouble,OfFloat
  #MACRO BasicSubListRemoveVal<Bits>()
  #MACRO BasicSubListRemoveVal<NaN>()
  #MACRO BasicSubListRemoveVal<0>()
    #ELSE
  #MACRO BasicSubListRemoveVal< >()
    #ENDIF
  #ELSEIFSWITCH STRUCTNAME==CheckedStack,UncheckedStack
    #IF OfRef
  @Override boolean uncheckedremoveValNonNull(int size,Object nonNull){
    #IFSWITCH STRUCTNAME==CheckedStack
    int modCount=this.modCount;
    try
    #ENDIF
    {
      final var arr=this.arr;
      for(int index=--size;;--index){
        if(nonNull.equals(arr[index])){
    #IFSWITCH STRUCTNAME==CheckedStack
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
    #ENDIF     
          OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,size);
          this.size=size;
          return true;
        }else if(index==0){
    #IFSWITCH STRUCTNAME==CheckedStack
          CheckedCollection.checkModCount(modCount,this.modCount);
    #ENDIF
          return false;
        }
      }
    }
    #IFSWITCH STRUCTNAME==CheckedStack
    catch(final ConcurrentModificationException e){
      throw e;
    }catch(final RuntimeException e){
      throw CheckedCollection.checkModCount(modCount,this.modCount,e);
    }
    #ENDIF
  }
  #MACRO BasicStackRemoveVal<Null>()
  #MACRO BasicStackRemoveVal< >()
    #ELSEIF OfDouble,OfFloat
  #MACRO BasicStackRemoveVal<Bits>()
  #MACRO BasicStackRemoveVal<NaN>()
  #MACRO BasicStackRemoveVal<0>()
    #ELSE
  #MACRO BasicStackRemoveVal< >()
    #ENDIF
  #ELSEIFSWITCH STRUCTNAME==CheckedList,UncheckedList
    #IF OfRef
  @Override boolean uncheckedremoveValNonNull(int size,Object nonNull){
    #IFSWITCH STRUCTNAME==CheckedList
    int modCount=this.modCount;
    try
    #ENDIF
    {
      final var arr=this.arr;
      for(int index=0;;){
        if(nonNull.equals(arr[index])){
    #IFSWITCH STRUCTNAME==CheckedList
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
    #ENDIF     
          OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,--size);
          this.size=size;
          return true;
        }else if(++index==size)
        {
    #IFSWITCH STRUCTNAME==CheckedList
          CheckedCollection.checkModCount(modCount,this.modCount);
    #ENDIF
          return false;
        }
      }
    }
    #IFSWITCH STRUCTNAME==CheckedList
    catch(final ConcurrentModificationException e){
      throw e;
    }catch(final RuntimeException e){
      throw CheckedCollection.checkModCount(modCount,this.modCount,e);
    }
    #ENDIF
  }
  #MACRO BasicListRemoveVal<Null>()
  #MACRO BasicListRemoveVal< >()
    #ELSEIF OfDouble,OfFloat
  #MACRO BasicListRemoveVal<Bits>()
  #MACRO BasicListRemoveVal<NaN>()
  #MACRO BasicListRemoveVal<0>()
    #ELSE
  #MACRO BasicListRemoveVal< >()
    #ENDIF
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  @Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
    #IFSWITCH STRUCTNAME==CheckedSubList
    int modCount=this.modCount;
    final var root=this.root;
    try
    #ENDIF
    {
      final int size;
      if((size=this.size)!=0){
        final int rootOffset;
        OmniArray.Of$ClassPrefix$.ascendingForEach(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,action);
      }
    }
    #IFSWITCH STRUCTNAME==CheckedSubList
    finally{
      CheckedCollection.checkModCount(modCount,root.modCount);
    }
    #ENDIF
  }
    #IFNOT OfRef
  @Override public void forEach(Consumer<? super $BoxedType$> action){
      #IFSWITCH STRUCTNAME==CheckedSubList
    int modCount=this.modCount;
    final var root=this.root;
    try
      #ENDIF
    {
      final int size;
      if((size=this.size)!=0){
        final int rootOffset;
        OmniArray.Of$ClassPrefix$.ascendingForEach(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,action::accept);
      }
    }
      #IFSWITCH STRUCTNAME==CheckedSubList
    finally{
      CheckedCollection.checkModCount(modCount,root.modCount);
    }
      #ENDIF
  }
    #ENDIF
  #ELSE
  @Override void uncheckedForEach(int size,$TypeNameModifier$Consumer$<? super E>$ action){
    #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
    int modCount=this.modCount;
    try
    #ENDIF
    {
    #IFSWITCH STRUCTNAME==CheckedList,UncheckedList
      OmniArray.Of$ClassPrefix$.ascendingForEach(this.arr,0,size-1,action);
    #ELSE
      OmniArray.Of$ClassPrefix$.descendingForEach(this.arr,0,size-1,action);
    #ENDIF
    }
    #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
    finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
    #ENDIF
  }
  #ENDIF
  private static class Itr$<E>$
  #IF OfRef
    implements OmniIterator.Of$ClassPrefix$$<E>$
  #ELSE
    extends Abstract$TypeNameModifier$Itr$<E>$
  #ENDIF
  {
    transient final STRUCTNAME$<E>$ parent;
    transient int cursor;
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack,CheckedSubList
    transient int lastRet;
    transient int modCount;
  #ENDIF
    private Itr(Itr$<E>$ itr){
      this.parent=itr.parent;
      this.cursor=itr.cursor;
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack,CheckedSubList
      this.lastRet=itr.lastRet;
      this.modCount=itr.modCount;
  #ENDIF
    }
    private Itr(STRUCTNAME$<E>$ parent){
      this.parent=parent;
  #IFSWITCH STRUCTNAME==CheckedList,UncheckedList
      this.cursor=0;
  #ELSEIFSWITCH STRUCTNAME==CheckedStack,UncheckedStack
      this.cursor=parent.size;
  #ELSE
      this.cursor=parent.rootOffset;
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack,CheckedSubList
      this.modCount=parent.modCount;
      this.lastRet=-1;
  #ENDIF
    }
  
    private Itr(STRUCTNAME$<E>$ parent,int cursor){
      this.parent=parent;
      this.cursor=cursor;
    #IFSWITCH STRUCTNAME==CheckedList,CheckedSubList,CheckedStack
      this.modCount=parent.modCount;
      this.lastRet=-1;
    #ENDIF
    }
    @Override public Object clone(){
      return new Itr$<E>$(this);
    }
    @Override public boolean hasNext(){
  #IFSWITCH STRUCTNAME==CheckedList,UncheckedList
      return this.cursor<parent.size;
  #ELSEIFSWITCH STRUCTNAME==CheckedStack,UncheckedStack
      return this.cursor>0;
  #ELSE
      final STRUCTNAME$<E>$ parent;
      return this.cursor<(parent=this.parent).rootOffset+parent.size;
  #ENDIF
    }
    #MACRO IteratorNextImpl<Itr>()
    #MACRO IteratorRemoveImpl<Itr>()
    #MACRO IteratorForEachImpl<Itr>($TypeNameModifier$Consumer$<? super E>$,action)
  #IFNOT OfRef
    #MACRO IteratorForEachImpl<Itr>(Consumer<? super $BoxedType$>,action::accept)
  #ENDIF
  }
  @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
  #IFSWITCH STRUCTNAME==CheckedSubList
    CheckedCollection.checkModCount(modCount,root.modCount);
  #ENDIF
    return new Itr$<E>$(this);
  }
  #IFSWITCH STRUCTNAME==CheckedList,UncheckedList,CheckedSubList,UncheckedSubList
  private static class ListItr$<E>$ extends Itr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>${
    #IFSWITCH STRUCTNAME==UncheckedList,UncheckedSubList
    transient int lastRet;
    #ENDIF
    private ListItr(ListItr$<E>$ itr){
      super(itr);
    #IFSWITCH STRUCTNAME==UncheckedList,UncheckedSubList
      this.lastRet=itr.lastRet;
    #ENDIF 
    }
    private ListItr(STRUCTNAME$<E>$ parent){
      super(parent);
    #IFSWITCH STRUCTNAME==UncheckedList,UncheckedSubList
      this.lastRet=-1;
    #ENDIF
    }
    private ListItr(STRUCTNAME$<E>$ parent,int cursor){
      super(parent,cursor);
    #IFSWITCH STRUCTNAME==UncheckedList,UncheckedSubList
      this.lastRet=-1;
    #ENDIF
    }
    @Override public Object clone(){
      return new ListItr$<E>$(this);
    }
    @Override public boolean hasPrevious(){
    #IFSWITCH STRUCTNAME==UncheckedSubList,CheckedSubList
      return this.cursor>parent.rootOffset;
    #ELSE
      return this.cursor>0;
    #ENDIF
    }
    @Override public int nextIndex(){
    #IFSWITCH STRUCTNAME==UncheckedSubList,CheckedSubList
      return this.cursor-parent.rootOffset;
    #ELSE
      return this.cursor;
    #ENDIF
    }
    @Override public int previousIndex(){
    #IFSWITCH STRUCTNAME==UncheckedSubList,CheckedSubList
      return this.cursor-parent.rootOffset-1;
    #ELSE
      return this.cursor-1;
    #ENDIF
    }
    #IFSWITCH STRUCTNAME==UncheckedList,UncheckedSubList
    #MACRO IteratorNextImpl<ListItr>()
    #MACRO IteratorRemoveImpl<ListItr>()
    #MACRO IteratorForEachImpl<ListItr>($TypeNameModifier$Consumer$<? super E>$,action)
      #IFNOT OfRef
    #MACRO IteratorForEachImpl<Itr>(Consumer<? super $BoxedType$>,action::accept)
      #ENDIF
    #ENDIF
    #MACRO SuppressUnchecked()
    @Override public $exposedType$ previous$TypeNameModifier$(){
    #IFSWITCH STRUCTNAME==CheckedSubList,CheckedList
      final CheckedList$<E>$ root;
      int cursor;
      #IFSWITCH STRUCTNAME==CheckedSubList
      final STRUCTNAME$<E>$ parent;
      CheckedCollection.checkModCount(modCount,(root=(parent=this.parent).root).modCount);
      if((cursor=this.cursor)>parent.rootOffset)
      #ELSE
      CheckedCollection.checkModCount(modCount,(root=this.parent).modCount);
      if((cursor=this.cursor)>0)
      #ENDIF
      {
        this.lastRet=--cursor;
        this.cursor=cursor;
        return ($exposedType$)root.arr[cursor];
      }
      throw new NoSuchElementException();
    #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
      final int lastRet;
      this.lastRet=lastRet=--this.cursor;
      return ($exposedType$)parent.root.arr[lastRet];
    #ELSE
      final int lastRet;
      this.lastRet=lastRet=--this.cursor;
      return ($exposedType$)parent.arr[lastRet];
    #ENDIF
    }
    @Override public void set($exposedType$ val){
    #IFSWITCH STRUCTNAME==CheckedSubList,CheckedList
      final int lastRet;
      if((lastRet=this.lastRet)!=-1){
        final CheckedList$<E>$ root;
      #IFSWITCH STRUCTNAME==CheckedSubList
        CheckedCollection.checkModCount(modCount,(root=this.parent.root).modCount);
      #ELSE
        CheckedCollection.checkModCount(modCount,(root=this.parent).modCount);
      #ENDIF
        root.arr[lastRet]=val;
        return;
      }
      throw new IllegalStateException();
    #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
      parent.root.arr[this.lastRet]=val;
    #ELSE
      parent.arr[this.lastRet]=val;
    #ENDIF
    }
    @Override public void add($exposedType$ val){
    #IFSWITCH STRUCTNAME==CheckedSubList,CheckedList
      int modCount;
      final CheckedList$<E>$ root;
      #IFSWITCH STRUCTNAME==CheckedSubList
      STRUCTNAME$<E>$ parent;
      CheckedCollection.checkModCount(modCount=this.modCount,(root=(parent=this.parent).root).modCount);
      root.modCount=++modCount;
      do{
        parent.modCount=modCount;
        ++parent.size;
      }while((parent=parent.parent)!=null);
      #ELSE
      CheckedCollection.checkModCount(modCount=this.modCount,(root=this.parent).modCount);
      root.modCount=++modCount;
      #ENDIF
      this.modCount=modCount;
      this.lastRet=-1;
      final int rootSize;
      if((rootSize=root.size)!=0)
    #ELSE
      final UncheckedList$<E>$ root;
      final int rootSize;
      #IFSWITCH STRUCTNAME==UncheckedSubList
      STRUCTNAME$<E>$ parent;
      if((rootSize=(root=(parent=this.parent).root).size)!=0)
      #ELSE
      if((rootSize=(root=this.parent).size)!=0)
      #ENDIF
    #ENDIF
      {
        ((UncheckedList$<E>$)root).uncheckedInsert(this.cursor++,rootSize,val);
      }else{
        (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInit(val);
        ++this.cursor;
      }
    #IFSWITCH STRUCTNAME==UncheckedSubList
      do{
        ++parent.size;
      }while((parent=parent.parent)!=null);
    #ENDIF
    }
  }
  @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(){
    #IFSWITCH STRUCTNAME==CheckedSubList
    CheckedCollection.checkModCount(modCount,root.modCount);
    #ENDIF
    return new ListItr$<E>$(this);
  }
  @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index){
    #IFSWITCH STRUCTNAME==CheckedSubList
    CheckedCollection.checkModCount(modCount,root.modCount);
    #ENDIF
    #IFSWITCH STRUCTNAME==CheckedSubList,CheckedList
    CheckedCollection.checkLo(index);
    CheckedCollection.checkWriteHi(index,this.size);
    #ENDIF
    #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
    return new ListItr$<E>$(this,index+this.rootOffset);
    #ELSE
    return new ListItr$<E>$(this,index);
    #ENDIF
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==UncheckedList
    private void uncheckedInsert(int index,int size,$exposedType$ val){
      final int tailDist;
      if((tailDist=size-index)==0){
        super.uncheckedAppend(size,val);
      }else{
        $ArrayType$[] arr;
        if((arr=this.arr).length==size){
          final $ArrayType$[] tmp;
          ArrCopy.semicheckedCopy(arr,0,tmp=new $ArrayType$[OmniArray.growBy50Pct(size)],0,index);
          ArrCopy.uncheckedCopy(arr,index,tmp,index+1,tailDist);
          this.arr=arr=tmp;
        }else{
          ArrCopy.uncheckedCopy(arr,index,arr,index+1,tailDist);
        }
        arr[index]=val;
        this.size=size+1;
      }
    }
  #ENDIF
  #IFSWITCH STRUCTNAME==UncheckedStack
    #IFNOT OfRef
  @Override public void push($BoxedType$ val){
    push(($exposedType$)val);
  }
    #ENDIF
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  @Override public void push($exposedType$ val){
    ++this.modCount;
    super.push(val);
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedList,UncheckedList
  @Override public void add(int index,$exposedType$ val){
    final int size;
    #IFSWITCH STRUCTNAME==CheckedList
    CheckedCollection.checkLo(index);
    CheckedCollection.checkWriteHi(index,size=this.size);
    ++this.modCount;
    if(size!=0){
    #ELSE
    if((size=this.size)!=0){
    #ENDIF
      ((UncheckedList$<E>$)this).uncheckedInsert(index,size,val);
    }else{
      (($ClassPrefix$ArrSeq$<E>$)this).uncheckedInit(val);
    }
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  @Override public boolean add($exposedType$ val){
    #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    int modCount;
    CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
    root.modCount=++modCount;
    this.modCount=modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,++curr.size,curr=curr.parent){}
    if((modCount=root.size)!=0){
      ((UncheckedList$<E>$)root).uncheckedInsert(this.rootOffset+(this.size++),modCount,val);
    #ELSE
    for(var curr=parent;curr!=null;++curr.size,curr=curr.parent){}
    final UncheckedList$<E>$ root;
    final int rootSize;
    if((rootSize=(root=this.root).size)!=0){
      ((UncheckedList$<E>$)root).uncheckedInsert(this.rootOffset+(this.size++),rootSize,val);
    #ENDIF
    }else{
      (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInit(val);
      ++this.size;
    }
    return true;
  }
  @Override public void add(int index,$exposedType$ val){
    #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    int modCount;
    CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
    CheckedCollection.checkLo(index);
    final int size;
    CheckedCollection.checkWriteHi(index,size=this.size);
    root.modCount=++modCount;
    this.modCount=modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,++curr.size,curr=curr.parent){}
    this.size=size+1;
    if((modCount=root.size)!=0){
      ((UncheckedList$<E>$)root).uncheckedInsert(this.rootOffset+index,modCount,val);
    #ELSE
    for(var curr=parent;curr!=null;++curr.size,curr=curr.parent){}
    ++this.size;
    final UncheckedList$<E>$ root;
    final int rootSize;
    if((rootSize=(root=this.root).size)!=0){
      ((UncheckedList$<E>$)root).uncheckedInsert(this.rootOffset+index,rootSize,val);
    #ENDIF
    }else{
      (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInit(val);
    }
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
  @Override  public <T> T[] toArray(T[] arr){
  #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
  #ENDIF
    final int size;
    if((size=this.size)!=0){
      ArrCopy.uncheckedCopy(root.arr,this.rootOffset,arr=OmniArray.uncheckedArrResize(size,arr),0,size);
    }else if(arr.length!=0){
      arr[0]=null;
    }
    return arr;
  }
  @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
    final int size;
    final T[] dst;
    #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    int modCount=this.modCount;
    try
    #ENDIF
    {
      dst=arrConstructor.apply(size=this.size);
    }
    #IFSWITCH STRUCTNAME==CheckedSubList
    finally{
      CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
    }
    #ENDIF
    if(size!=0){
      ArrCopy.uncheckedCopy(root.arr,this.rootOffset,dst,0,size);
    }
    return dst;
  }
  #MACRO SubListToArrayImpl($ArrayType$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR,$TypeNameModifier$)
    #IFNOT OfRef
  #MACRO SubListToArrayImpl($BoxedType$,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR,)
      #IFNOT OfDouble
  #MACRO SubListToArrayImpl(double,OmniArray.OfDouble.DEFAULT_ARR,Double)
        #IFNOT OfFloat
  #MACRO SubListToArrayImpl(float,OmniArray.OfFloat.DEFAULT_ARR,Float)
          #IFNOT OfLong
  #MACRO SubListToArrayImpl(long,OmniArray.OfLong.DEFAULT_ARR,Long)
            #IFNOT OfInt
  #MACRO SubListToArrayImpl(int,OmniArray.OfInt.DEFAULT_ARR,Int)
              #IFNOT OfShort,OfChar
  #MACRO SubListToArrayImpl(short,OmniArray.OfShort.DEFAULT_ARR,Short)
                #IFNOT OfByte
  #MACRO SubListToArrayImpl(byte,OmniArray.OfByte.DEFAULT_ARR,Byte)
  #MACRO SubListToArrayImpl(char,OmniArray.OfChar.DEFAULT_ARR,Char)
                #ENDIF
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF  
  #IFSWITCH STRUCTNAME==UncheckedList,UncheckedStack
  #MACRO UncheckedCopyIntoImpl($ArrayType$)
    #IFNOT OfRef
  #MACRO UncheckedCopyIntoImpl(Object)
  #MACRO UncheckedCopyIntoImpl($BoxedType$)
      #IFNOT OfDouble
  #MACRO UncheckedCopyIntoImpl(double)
        #IFNOT OfFloat
  #MACRO UncheckedCopyIntoImpl(float)
          #IFNOT OfLong
  #MACRO UncheckedCopyIntoImpl(long)
            #IFNOT OfInt
  #MACRO UncheckedCopyIntoImpl(int)
              #IFNOT OfShort,OfChar
  #MACRO UncheckedCopyIntoImpl(short)
                #IFNOT OfByte
  #MACRO UncheckedCopyIntoImpl(byte)
  #MACRO UncheckedCopyIntoImpl(char)
                #ENDIF
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
    return super.toArray(arrSize->{
      final int modCount=this.modCount;
      try{
        return arrConstructor.apply(arrSize);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    });
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==UncheckedList,CheckedList,UncheckedSubList,CheckedSubList
  @Override public void put(int index,$exposedType$ val){
    #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
    #ENDIF
    #IFSWITCH STRUCTNAME==CheckedSubList,CheckedList
    CheckedCollection.checkLo(index);
    CheckedCollection.checkReadHi(index,this.size);
    #ENDIF
    #IFSWITCH STRUCTNAME==CheckedList,UncheckedList
    this.arr[index]=val;
    #ELSE
    root.arr[index+this.rootOffset]=val;
    #ENDIF
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==UncheckedList,CheckedList,UncheckedSubList,CheckedSubList
  #MACRO SuppressUnchecked()
  @Override public $exposedType$ get$TypeNameModifier$(int index){
    #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
    #ENDIF
    #IFSWITCH STRUCTNAME==CheckedSubList,CheckedList
    CheckedCollection.checkLo(index);
    CheckedCollection.checkReadHi(index,this.size);
    #ENDIF
    #IFSWITCH STRUCTNAME==CheckedList,UncheckedList
    return ($exposedType$)this.arr[index];
    #ELSE
    return ($exposedType$)root.arr[index+this.rootOffset];
    #ENDIF
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==UncheckedList,CheckedList,UncheckedSubList,CheckedSubList
  #MACRO SuppressUnchecked()
  @Override public $exposedType$ set(int index,$exposedType$ val){
    #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
    #ENDIF
    #IFSWITCH STRUCTNAME==CheckedSubList,CheckedList
    CheckedCollection.checkLo(index);
    CheckedCollection.checkReadHi(index,this.size);
    #ENDIF
    final $ArrayType$[] arr;
    #IFSWITCH STRUCTNAME==CheckedList,UncheckedList
    final var ret=($exposedType$)(arr=this.arr)[index];
    #ELSE
    final var ret=($exposedType$)(arr=root.arr)[index+=this.rootOffset];
    #ENDIF
    arr[index]=val;
    return ret;
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==UncheckedStack
    #IFNOT OfRef
  @Override public $BoxedType$ pop(){
    return pop$TypeNameModifier$();
  }
    #ENDIF
  #ENDIF
  #IFSWITCH STRUCTNAME==UncheckedStack,CheckedStack
  #MACRO SuppressUnchecked()
  @Override public $exposedType$ pop$TypeNameModifier$(){
    #IFSWITCH STRUCTNAME==CheckedStack
    int size;
    if((size=this.size)!=0){
      ++this.modCount;
      #IF OfRef
      final $ArrayType$[] arr;
      final var ret=($exposedType$)(arr=this.arr)[--size];
      arr[size]=null;
      #ELSE
      final var ret=($exposedType$)arr[--size];
      #ENDIF
      this.size=size;
      return ret;
    }
    throw new NoSuchElementException();
    #ELSE
      #IF OfRef
    final $ArrayType$[] arr;
    final int size;
    final var ret=($exposedType$)(arr=this.arr)[size=--this.size];
    arr[size]=null;
    return ret;
      #ELSE
    return ($exposedType$)arr[--this.size];
      #ENDIF
    #ENDIF
  }
  #ENDIF
  #MACRO PeekAndPollImpl($exposedType$,$defaultVal$,($exposedType$),$TypeNameModifier$)
  #IFNOT OfRef
  #MACRO PeekAndPollImpl($BoxedType$,null,($BoxedType$),)
    #IFNOT OfDouble
  #MACRO PeekAndPollImpl(double,Double.NaN,$castToDouble$,Double)
      #IFNOT OfFloat
  #MACRO PeekAndPollImpl(float,Float.NaN,$castToFloat$,Float)
        #IFNOT OfLong
  #MACRO PeekAndPollImpl(long,Long.MIN_VALUE,$castToLong$,Long)
          #IFNOT OfInt
  #MACRO PeekAndPollImpl(int,Integer.MIN_VALUE,$castToInt$,Int)
            #IFNOT OfShort,OfChar
  #MACRO PeekAndPollImpl(short,Short.MIN_VALUE,$castToShort$,Short)
              #IFNOT OfByte
  #MACRO PeekAndPollImpl(byte,Byte.MIN_VALUE,$castToByte$,Byte)
  #MACRO PeekAndPollImpl(char,Character.MIN_VALUE,$castToChar$,Char)
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #IFSWITCH STRUCTNAME==UncheckedList,CheckedList,UncheckedSubList,CheckedSubList
  #MACRO SuppressUnchecked()
  @Override public $exposedType$ $removeAtIndexMethod$(int index){
    #IFSWITCH STRUCTNAME==CheckedSubList,CheckedList
      #IFSWITCH STRUCTNAME==CheckedSubList
    int modCount;
    final CheckedList$<E>$ root;
    CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
      #ENDIF
    CheckedCollection.checkLo(index);
    int size;
    CheckedCollection.checkReadHi(index,size=this.size);
    #ENDIF
    final $ArrayType$[] arr;
    #IFSWITCH STRUCTNAME==CheckedSubList
    root.modCount=++modCount;
    this.modCount=modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,--curr.size,curr=curr.parent){}
    final var ret=($exposedType$)(arr=root.arr)[index+=this.rootOffset];
    OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,--root.size);
    this.size=size-1;
    #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
    for(var curr=parent;curr!=null;--curr.size,curr=curr.parent){}
    final UncheckedList$<E>$ root;
    final var ret=($exposedType$)(arr=(root=this.root).arr)[index+=this.rootOffset];
    OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,--root.size);
    this.size=size-1;
    #ELSEIFSWITCH STRUCTNAME==CheckedList
    ++this.modCount;
    final var ret=($exposedType$)(arr=this.arr)[index];
    OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,--size);
    this.size=size;
    #ELSE
    final var ret=($exposedType$)(arr=this.arr)[index];
    OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,--size);
    #ENDIF
    return ret;
  }
  #ENDIF
  #IFSWITCH STRUCTNAME==CheckedList,CheckedStack
  @Override boolean uncheckedRemoveIf(int size,$TypeNameModifier$Predicate$<? super E>$ filter){
    final int modCount=this.modCount;
    try{
      #IF OfRef
      final int numRemoved;
      final $ArrayType$[] arr;
      if((numRemoved=uncheckedRemoveIfImpl(arr=this.arr
      #ELSE
      if(size!=(size-=uncheckedRemoveIfImpl(this.arr
      #ENDIF
        ,0,size,filter,new ModCountChecker(modCount)))
      #IF OfRef
        !=0
      #ENDIF
        ){
        this.modCount=modCount+1;
    #IF OfRef
        OmniArray.Of$ClassPrefix$.nullifyRange(arr,size-1,size-=numRemoved);
    #ENDIF
        this.size=size;
        return true;
      }
    }catch(ConcurrentModificationException e){
      throw e;
    }catch(RuntimeException e){
      throw CheckedCollection.checkModCount(modCount,this.modCount,e);
    }
    CheckedCollection.checkModCount(modCount,this.modCount);
    return false;
  }
  #ENDIF
  #MACRO SubListRemoveIfImpl($TypeNameModifier$Predicate$<? super E>$,filter)
  #IFNOT OfRef
  #MACRO SubListRemoveIfImpl(Predicate<? super $BoxedType$>,filter::test)
  #ENDIF
  #MACRO ReplaceAllImpl($UnaryOperator$$<E>$,operator)
  #MACRO ComparatorSortImpl<Stable>($Comparator$$<? super E>$,sorter)
  #MACRO NonComparatorSortImpl<Stable,Ascending>()
  #MACRO NonComparatorSortImpl<Stable,Descending>()
#IFNOT OfRef
  #MACRO ReplaceAllImpl(UnaryOperator<$BoxedType$>,operator::apply)
  #MACRO ComparatorSortImpl<Stable>(Comparator<? super $BoxedType$>,sorter::compare)
#ENDIF
#IFNOT OfBoolean
  #MACRO ComparatorSortImpl<Unstable>($Comparator$$<? super E>$,sorter)
#ENDIF
#IF OfRef
  #MACRO NonComparatorSortImpl<Unstable,Ascending>()
  #MACRO NonComparatorSortImpl<Unstable,Descending>()
#ENDIF
#IFSWITCH STRUCTNAME==CheckedList,UncheckedList,CheckedSubList,UncheckedSubList
  @Override public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex){
  #IFSWITCH STRUCTNAME==CheckedList
    return new CheckedSubList$<E>$(this,fromIndex,CheckedCollection.checkSubListRange(fromIndex,toIndex,this.size));
  #ELSEIFSWITCH STRUCTNAME==UncheckedList
    return new UncheckedSubList$<E>$(this,fromIndex,toIndex-fromIndex);
  #ELSEIFSWITCH STRUCTNAME==CheckedSubList
    CheckedCollection.checkModCount(modCount,root.modCount);
    return new STRUCTNAME$<E>$(this,this.rootOffset+fromIndex,CheckedCollection.checkSubListRange(fromIndex,toIndex,this.size));
  #ELSE
    return new UncheckedSubList$<E>$(this,this.rootOffset+fromIndex,toIndex-fromIndex);
  #ENDIF
  }
#ENDIF
}
#ENDDEF
#MACRODEF RootRemoveIfImpl(PREDICATE,TEST)
@Override public boolean removeIf(PREDICATE filter){
  final int size;
  return (size=this.size)!=0 && uncheckedRemoveIf(size,TEST);
}
#ENDDEF
#MACRODEF SubListRemoveIfImpl(PREDICATE,TEST)
#IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
@Override public boolean removeIf(PREDICATE filter){
  #IFSWITCH STRUCTNAME==CheckedSubList
  int modCount=this.modCount;
  final var root=this.root;
  #ENDIF
  final int size;
  if((size=this.size)!=0){
  #IFSWITCH STRUCTNAME==CheckedSubList
    try
  #ENDIF
    {
      final $ArrayType$[] arr;
      final int numRemoved;
      int rootOffset;
  #IFSWITCH STRUCTNAME==CheckedSubList
      if((numRemoved=uncheckedRemoveIfImpl(arr=root.arr,rootOffset=this.rootOffset,rootOffset+=size,TEST,root.new ModCountChecker(modCount)))!=0){
        root.modCount=++modCount;
        this.modCount=modCount;
        for(var curr=parent;curr!=null;curr.modCount=modCount,curr.size-=numRemoved,curr=curr.parent){}
  #ELSE
      final UncheckedList$<E>$ root;
      if((numRemoved=uncheckedRemoveIfImpl(arr=(root=this.root).arr,rootOffset=this.rootOffset,rootOffset+=size,TEST))!=0){
        for(var curr=parent;curr!=null;curr.size-=numRemoved,curr=curr.parent){}
  #ENDIF
        root.size=OmniArray.Of$ClassPrefix$.removeRangeAndPullDown(arr,rootOffset,root.size,numRemoved);
        this.size=size-numRemoved;
        return true;
      }
    }
  #IFSWITCH STRUCTNAME==CheckedSubList
    catch(ConcurrentModificationException e){
      throw e;
    }catch(RuntimeException e){
      throw CheckedCollection.checkModCount(modCount,root.modCount,e);
    }
  #ENDIF
  }
  #IFSWITCH STRUCTNAME==CheckedSubList
  CheckedCollection.checkModCount(modCount,root.modCount);
  #ENDIF
  return false;
}
#ENDIF
#ENDDEF
#MACRODEF NonComparatorSortImpl<STABLE,DIRECTION>()
#IFSWITCH STRUCTNAME==UncheckedList,CheckedList,UncheckedSubList,CheckedSubList
@Override
  #IFSWITCH STABLE==Stable
public void stableDIRECTIONSort()
  #ELSE
public void unstableDIRECTIONSort()
  #ENDIF
{
  #IFSWITCH STRUCTNAME==CheckedSubList
  final int size;
  if((size=this.size)<2){
    CheckedCollection.checkModCount(modCount,root.modCount);
    return;
  }
  int modCount=this.modCount;
  final var root=this.root;
  try{
    final int rootOffset;
    #IF OfRef
    $ClassPrefix$SortUtil.uncheckedSTABLEDIRECTIONSort(root.arr,rootOffset=this.rootOffset,rootOffset+size);
  }catch(ArrayIndexOutOfBoundsException e){
    throw new IllegalArgumentException("Comparison method violates its general contract!",e);
    #ELSE
    $ClassPrefix$SortUtil.uncheckedDIRECTIONSort(root.arr,rootOffset=this.rootOffset,rootOffset+size);
    #ENDIF
  }finally{
    CheckedCollection.checkModCount(modCount,root.modCount);
    root.modCount=++modCount;
    this.modCount=modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,curr=curr.parent){}  
  }
  #ELSE
  final int size;
  if((size=this.size)>1){
    #IFSWITCH STRUCTNAME==CheckedList
      #IF OfRef
    final int modCount=this.modCount;
    try{
      $ClassPrefix$SortUtil.uncheckedSTABLEDIRECTIONSort(this.arr,0,size);
    }catch(ArrayIndexOutOfBoundsException e){
      throw new IllegalArgumentException("Comparison method violates its general contract!",e);
    }finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount+1;
    }
      #ELSE
    $ClassPrefix$SortUtil.uncheckedDIRECTIONSort(this.arr,0,size);
    this.modCount=modCount+1;
      #ENDIF
    #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
    final int rootOffset;
      #IF OfRef
    $ClassPrefix$SortUtil.uncheckedSTABLEDIRECTIONSort(root.arr,rootOffset=this.rootOffset,rootOffset+size);
      #ELSE
    $ClassPrefix$SortUtil.uncheckedDIRECTIONSort(root.arr,rootOffset=this.rootOffset,rootOffset+size);
      #ENDIF
    #ELSE
      #IF OfRef
    $ClassPrefix$SortUtil.uncheckedSTABLEDIRECTIONSort(this.arr,0,size);
      #ELSE
    $ClassPrefix$SortUtil.uncheckedDIRECTIONSort(this.arr,0,size);
      #ENDIF
    #ENDIF
  }
  #ENDIF
}
#ENDIF
#ENDDEF
#MACRODEF ComparatorSortImpl<STABLE>(COMPARATOR,COMPARE)
#IFSWITCH STRUCTNAME==UncheckedList,CheckedList,UncheckedSubList,CheckedSubList
@Override
#IFSWITCH STABLE==Stable
public void sort(COMPARATOR sorter)
#ELSE
public void unstableSort(COMPARATOR sorter)
#ENDIF
{
  #IFSWITCH STRUCTNAME==CheckedSubList
  final int size;
  if((size=this.size)<2){
    CheckedCollection.checkModCount(modCount,root.modCount);
    return;
  }
    #IF OfRef
  int modCount=this.modCount;
  final var root=this.root;
  try{
    final int rootOffset=this.rootOffset;
    if(sorter==null){
      $ClassPrefix$SortUtil.uncheckedSTABLEAscendingSort(root.arr,rootOffset,rootOffset+size);
    }else{
      $ClassPrefix$SortUtil.uncheckedSTABLESort(root.arr,rootOffset,rootOffset+size,COMPARE);
    }
  }catch(ArrayIndexOutOfBoundsException e){
    throw new IllegalArgumentException("Comparison method violates its general contract!",e);
  }finally{
    CheckedCollection.checkModCount(modCount,root.modCount);
    root.modCount=++modCount;
    this.modCount=modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,curr=curr.parent){}
  }
    #ELSE
  final var root=this.root;
  int modCount=this.modCount;
  if(sorter==null){
    CheckedCollection.checkModCount(modCount,root.modCount);
    final int rootOffset;
    $ClassPrefix$SortUtil.uncheckedAscendingSort(root.arr,rootOffset=this.rootOffset,rootOffset+size);
    root.modCount=++modCount;
    this.modCount=modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,curr=curr.parent){}
  }else{
    try{
      final int rootOffset;
      #IF OfBoolean
      $ClassPrefix$SortUtil.uncheckedSort(root.arr,rootOffset=this.rootOffset,rootOffset+size,COMPARE);
      #ELSE
      $ClassPrefix$SortUtil.uncheckedSTABLESort(root.arr,rootOffset=this.rootOffset,rootOffset+size,COMPARE);
      #ENDIF
    }catch(ArrayIndexOutOfBoundsException e){
      throw new IllegalArgumentException("Comparison method violates its general contract!",e);
    }finally{
      CheckedCollection.checkModCount(modCount,root.modCount);
      root.modCount=++modCount;
      this.modCount=modCount;
      for(var curr=parent;curr!=null;curr.modCount=modCount,curr=curr.parent){}
    }
  }
    #ENDIF
  #ELSE
  final int size;
  if((size=this.size)>1){
    #IFSWITCH STRUCTNAME==CheckedList
      #IF OfRef
    final int modCount=this.modCount;
    try{
      if(sorter==null){
        $ClassPrefix$SortUtil.uncheckedSTABLEAscendingSort(this.arr,0,size);
      }else{
        $ClassPrefix$SortUtil.uncheckedSTABLESort(this.arr,0,size,COMPARE);
      }
    }catch(ArrayIndexOutOfBoundsException e){
      throw new IllegalArgumentException("Comparison method violates its general contract!",e);
    }finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount+1;
    }
      #ELSE
    if(sorter==null){
      $ClassPrefix$SortUtil.uncheckedAscendingSort(this.arr,0,size);
      ++this.modCount;
    }else{
      final int modCount=this.modCount;
      try{
        #IF OfBoolean
        $ClassPrefix$SortUtil.uncheckedSort(this.arr,0,size,COMPARE);
        #ELSE
        $ClassPrefix$SortUtil.uncheckedSTABLESort(this.arr,0,size,COMPARE);
        #ENDIF
      }catch(ArrayIndexOutOfBoundsException e){
        throw new IllegalArgumentException("Comparison method violates its general contract!",e);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
        this.modCount=modCount+1;
      }
    }
      #ENDIF
    #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
    final int rootOffset;
    if(sorter==null){
      #IF OfRef
      $ClassPrefix$SortUtil.uncheckedSTABLEAscendingSort(root.arr,rootOffset=this.rootOffset,rootOffset+size);
      #ELSE
      $ClassPrefix$SortUtil.uncheckedAscendingSort(root.arr,rootOffset=this.rootOffset,rootOffset+size);
      #ENDIF
    }else{
      #IF OfBoolean
      $ClassPrefix$SortUtil.uncheckedSort(root.arr,rootOffset=this.rootOffset,rootOffset+size,COMPARE);
      #ELSE
      $ClassPrefix$SortUtil.uncheckedSTABLESort(root.arr,rootOffset=this.rootOffset,rootOffset+size,COMPARE);
      #ENDIF
    }
    #ELSE
    if(sorter==null){
      #IF OfRef
      $ClassPrefix$SortUtil.uncheckedSTABLEAscendingSort(this.arr,0,size);
      #ELSE
      $ClassPrefix$SortUtil.uncheckedAscendingSort(this.arr,0,size);
      #ENDIF
    }else{
      #IF OfBoolean
      $ClassPrefix$SortUtil.uncheckedSort(this.arr,0,size,COMPARE);
      #ELSE
      $ClassPrefix$SortUtil.uncheckedSTABLESort(this.arr,0,size,COMPARE);
      #ENDIF
    }
    #ENDIF
  }
  #ENDIF
}
#ENDIF
#ENDDEF
#MACRODEF ReplaceAllImpl(OPERATOR,APPLY)
#IFSWITCH STRUCTNAME==UncheckedList,CheckedList,UncheckedSubList,CheckedSubList
@Override public void replaceAll(OPERATOR operator){
  #IFSWITCH STRUCTNAME==CheckedSubList
  final int size;
  if((size=this.size)==0){
    CheckedCollection.checkModCount(modCount,root.modCount);
    return;
  }
  int modCount=this.modCount;
  final var root=this.root;
  try{
    final int rootOffset;
    OmniArray.Of$ClassPrefix$.uncheckedReplaceAll(root.arr,rootOffset=this.rootOffset,rootOffset+size,APPLY);  
  }finally{
    CheckedCollection.checkModCount(modCount,root.modCount);
    root.modCount=++modCount;
    this.modCount=modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,curr=curr.parent){}
  }
  
  #ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  final int size;
  if((size=this.size)!=0){
    final int rootOffset;
    OmniArray.Of$ClassPrefix$.uncheckedReplaceAll(root.arr,rootOffset=this.rootOffset,rootOffset+size,APPLY);  
  }
  #ELSEIFSWITCH STRUCTNAME==CheckedList
  final int size;
  if((size=this.size)!=0){
    int modCount=this.modCount;
    try{
      OmniArray.Of$ClassPrefix$.uncheckedReplaceAll(this.arr,0,size,APPLY);
    }finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount+1;
    }
  }
  #ELSE
  final int size;
  if((size=this.size)!=0){
    OmniArray.Of$ClassPrefix$.uncheckedReplaceAll(this.arr,0,size,APPLY);
  }
  #ENDIF
}
#ENDIF
#ENDDEF
#MACRODEF PeekAndPollImpl(RETTYPE,DEFAULTRET,CAST,CLASSPREFIX)
#IFSWITCH STRUCTNAME==UncheckedStack,CheckedStack
#MACRO SuppressUnchecked()
@Override public RETTYPE pollCLASSPREFIX(){
  int size;
  if((size=this.size)!=0){
  #IFSWITCH STRUCTNAME==CheckedStack
    ++this.modCount;
  #ENDIF
    final var ret=CAST(arr[--size]);
  #IF OfRef
    arr[size]=null;
  #ENDIF
    this.size=size;
    return ret;
  }
  return DEFAULTRET;
}
#ENDIF
#IFSWITCH STRUCTNAME==UncheckedStack
#MACRO SuppressUnchecked()
@Override public RETTYPE peekCLASSPREFIX(){
  final int size;
  if((size=this.size)!=0){
    return CAST(arr[size-1]);
  }
  return DEFAULTRET;
}
#ENDIF
#ENDDEF
#MACRODEF UncheckedCopyIntoImpl(RETTYPE)
#IFSWITCH STRUCTNAME==UncheckedList
@Override void uncheckedCopyInto(RETTYPE[] dst,int length){
  ArrCopy.uncheckedCopy(this.arr,0,dst,0,length);
}
#ELSEIFSWITCH STRUCTNAME==UncheckedStack
@Override void uncheckedCopyInto(RETTYPE[] dst,int length){
  ArrCopy.uncheckedReverseCopy(this.arr,0,dst,0,length);
}
#ENDIF
#ENDDEF
#MACRODEF SubListToArrayImpl(RETTYPE,DEFAULTARR,CLASSPREFIX)
@Override public RETTYPE[] toCLASSPREFIXArray(){
#IFSWITCH STRUCTNAME==CheckedSubList
  final CheckedList$<E>$ root;
  CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
#ENDIF
  final int size;
  if((size=this.size)!=0){
    final RETTYPE[] dst;
    ArrCopy.uncheckedCopy(root.arr,this.rootOffset,dst=new RETTYPE[size],0,size);
    return dst;
  }
  return DEFAULTARR;
}
#ENDDEF
#MACRODEF RootToArrayImpl(RETTYPE,DEFAULTARR,CLASSPREFIX)
@Override public RETTYPE[] toCLASSPREFIXArray(){
  final int size;
  if((size=this.size)!=0){
    final RETTYPE[] dst;
    uncheckedCopyInto(dst=new RETTYPE[size],size);
    return dst;
  }
  return DEFAULTARR;
}
#ENDDEF
#MACRODEF RootQueryMethods<STRUCTNAME,METHODNAME>()
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
#IF OfByte,OfInt,OfLong
  #IFSWITCH METHODNAME==removeVal,contains
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
  #ENDIF
#ENDIF
#IF OfChar,OfRef,OfShort
  #IFSWITCH METHODNAME==removeVal,contains
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
  #ENDIF
#ENDIF
#IF OfFloat
  #IFSWITCH METHODNAME==removeVal,contains
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
  #ENDIF
#ENDIF
#IF OfRef
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
#ENDIF
#ENDDEF
#MACRODEF QueryMethods<METHODNAME>()
#IFSWITCH METHODNAME==contains
  #IFSWITCH STRUCTNAME==UncheckedSubList,CheckedSubList
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
    #IF OfByte,OfInt,OfLong
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
    #ENDIF
    #IF OfChar,OfRef,OfShort
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
    #ENDIF
    #IF OfFloat
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )    
    #ENDIF
    #IF OfRef
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
    #ENDIF
  #ELSEIFSWITCH STRUCTNAME==CheckedList,CheckedStack
    #IF OfRef
#MACRO QueryMethod<Object>( )
    #ENDIF
  #ENDIF
#ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
  #IFSWITCH STRUCTNAME==UncheckedList,CheckedSubList,UncheckedSubList
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
    #IF OfByte
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
    #ENDIF
    #IF OfChar,OfFloat,OfShort
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
    #ENDIF
    #IF OfRef
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
    #ENDIF
  #ELSEIFSWITCH STRUCTNAME==CheckedList
    #IF OfRef
#MACRO QueryMethod<Object>( )
    #ENDIF
  #ENDIF
#ELSEIFSWITCH METHODNAME==search
  #IFSWITCH STRUCTNAME==UncheckedStack
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
    #IF OfByte
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
    #ENDIF
    #IF OfChar,OfFloat,OfShort
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
    #ENDIF
    #IF OfRef
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
    #ENDIF
  #ELSEIFSWITCH STRUCTNAME==CheckedStack
    #IF OfRef
#MACRO QueryMethod<Object>( )
    #ENDIF
  #ENDIF
#ELSEIFSWITCH METHODNAME==removeVal
  #IFSWITCH STRUCTNAME==CheckedSubList,UncheckedSubList
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
    #IF OfByte,OfInt,OfLong
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
    #ENDIF
    #IF OfChar,OfRef,OfShort
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
    #ENDIF
    #IF OfFloat
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
    #ENDIF
    #IF OfRef
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF CheckedSubListQueryModCountDecl()
#IFSWITCH STRUCTNAME==CheckedSubList
  #IFNOTSWITCH METHODNAME==removeVal
final var root=this.root;
final int modCount=this.modCount;
try
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF CheckedSubListQueryFinallyModCount()
#IFSWITCH STRUCTNAME==CheckedSubList
  #IFNOTSWITCH METHODNAME==removeVal
finally{
  CheckedCollection.checkModCount(modCount,root.modCount);
}
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF SizeCheck()
final int size;
if((size=this.size)!=0)
#ENDDEF
#MACRODEF QueryMethod<INPUTTYPE>(CAST)
#IFSWITCH METHODNAME==removeVal
  #IFSWITCH INPUTTYPE==Object
@Override public boolean remove(INPUTTYPE val){
  #ELSE
@Override public boolean METHODNAME(INPUTTYPE val){
  #ENDIF
#ELSEIFSWITCH METHODNAME==contains
@Override public boolean METHODNAME(INPUTTYPE val){
#ELSEIFSWITCH METHODNAME==search,indexOf,lastIndexOf
@Override public int METHODNAME(INPUTTYPE val){
#ELSE
ERROR unknown method name METHODNAME
#ENDIF
#IFSWITCH INPUTTYPE==byte,short
  #IF OfChar
  if(val>=0)
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==char
  #IF OfByte,OfShort
  if(val<=$BoxedType$.MAX_VALUE)
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==int
  #IF OfByte,OfChar,OfShort
  if(val==($ArrayType$)val)
  #ENDIF
#ENDIF
  {
    #MACRO CheckedSubListQueryModCountDecl()
    {
      #MACRO SizeCheck()
      {
#IFSWITCH INPUTTYPE==boolean
  #IF OfDouble,OfFloat
        if(val){
          #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
        }
        #MACRO ReturnUncheckedQuery0()
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastBoolean$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==byte,char,short
  #IF OfDouble,OfFloat
        if(val!=0){
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
        #MACRO ReturnUncheckedQuery0()
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==int
  #IF OfBoolean
        returnFalse:for(;;){
          final $ArrayType$ v;
          switch(val){
          default:
            break returnFalse;
          case 0:
            v=false;
            break;
          case 1:
            v=true;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat,OfDouble
    #IF OfDouble
    #ENDIF
        if(val!=0){
    #IF OfFloat
          if(TypeUtil.checkCastTo$ClassPrefix$(val))
    #ENDIF
          {
            #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
          }
        }else{
          #MACRO ReturnUncheckedQuery0()
        }
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==long
  #IF OfBoolean
        returnFalse:for(;;){
          final $ArrayType$ v;
          if(val==0L){
            v=false;
          }else if(val==1L){
            v=true;
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat,OfDouble
        if(val!=0){
          if(TypeUtil.checkCastTo$ClassPrefix$(val)){
            #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
          }
        }else{
          #MACRO ReturnUncheckedQuery0()
        }
  #ELSEIF OfByte,OfChar,OfShort,OfInt
        final $ArrayType$ v;
        if((v=($ArrayType$)val)==val){
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==float
  #IF OfBoolean
        returnFalse:for(;;){
          final $ArrayType$ v;
          switch(Float.floatToRawIntBits(val)){
            default:
              break returnFalse;
            case 0:
            case Integer.MIN_VALUE:
              v=false;
              break;
            case TypeUtil.FLT_TRUE_BITS:
              v=true;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat,OfDouble
        if(val==val){
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
        #MACRO ReturnUncheckedQueryNaN()
  #ELSEIF OfRef
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ELSE
        final $ArrayType$ v;
    #IF OfLong
        if(TypeUtil.floatEquals(val,v=($ArrayType$)val))
    #ELSEIF OfInt
        if((double)val==(double)(v=($ArrayType$)val))
    #ELSE
        if(val==(v=($ArrayType$)val))
    #ENDIF
        {
          #MACRO ReturnUncheckedQuery(v)
        }
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==double
  #IF OfBoolean
        returnFalse:for(;;){
          final $ArrayType$ v;
          long bits;
          if((bits=Double.doubleToRawLongBits(val))==0 || bits==Long.MIN_VALUE){
            v=false;
          }else if(bits==TypeUtil.DBL_TRUE_BITS){
            v=true;
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat
        final $ArrayType$ v;
        if(val==(v=($ArrayType$)val)){
          #MACRO ReturnUncheckedQueryBits($convertToBits$(v))
        }else if(v!=v){
          #MACRO ReturnUncheckedQueryNaN()
        }
  #ELSEIF OfDouble
        if(val==val){
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
        #MACRO ReturnUncheckedQueryNaN()
  #ELSEIF OfRef
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ELSE
        final $ArrayType$ v;
    #IF OfLong
        if(TypeUtil.doubleEquals(val,v=($ArrayType$)val))
    #ELSE
        if(val==(v=($ArrayType$)val))
    #ENDIF
        {
          #MACRO ReturnUncheckedQuery(v)
        }
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==Object
  #IF OfRef
        if(val!=null){
          #MACRO ReturnUncheckedQueryNonNull(val)
        }
        #MACRO ReturnUncheckedQueryNull()
  #ELSE
        //TODO a pattern-matching switch statement would be great here
        returnFalse:for(;;){
    #IF OfBoolean
          final boolean b;
          if(val instanceof Boolean){
            b=(boolean)val;
          }else if(val instanceof Integer||val instanceof Byte||val instanceof Short){
            switch(((Number)val).intValue()){
              default:
                break returnFalse;
              case 0:
                b=false;
                break;
              case 1:
                b=true;
            }
          }else if(val instanceof Float){
            switch(Float.floatToRawIntBits((float)val)){
              default:
                break returnFalse;
              case 0:
              case Integer.MIN_VALUE:
                b=false;
                break;
              case TypeUtil.FLT_TRUE_BITS:
                b=true;
            }
          }else if(val instanceof Double){
            final long bits;
            if((bits=Double.doubleToRawLongBits((double)val))==0L || bits==Long.MIN_VALUE){
              b=false;
            }else if(bits==TypeUtil.DBL_TRUE_BITS){
              b=true;
            }else{
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long v;
            if((v=(long)val)==0L){
              b=false;
            }else if(v==1L){
              b=true;
            }else{
             break returnFalse;
            }
          }else if(val instanceof Character){
            switch(((Character)val).charValue()){
              default:
                break returnFalse;
              case 0:
                b=false;
                break;
              case 1:
                b=true;
            }
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(b)
    #ELSEIF OfByte
          final int i;
          if(val instanceof Byte){
            i=(byte)val;
          }else if(val instanceof Integer||val instanceof Short){
            if((i=((Number)val).intValue())!=(byte)i){
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(byte)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)!=(i=(byte)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(byte)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            if((i=(char)val)>Byte.MAX_VALUE){
              break returnFalse;
            }
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfChar
          final int i;
          if(val instanceof Character){
            i=(char)val;
          }else if(val instanceof Integer){
            if((i=(int)val)!=(char)i){
              break returnFalse;
            }
          }else if(val instanceof Byte||val instanceof Short){
            if((i=((Number)val).shortValue())<0){
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(char)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)!=(i=(char)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(char)d)){
              break returnFalse;
            }
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfShort
          final int i;
          if(val instanceof Short||val instanceof Byte){
            i=((Number)val).shortValue();
          }else if(val instanceof Integer){
            if((i=(int)val)!=(short)i){
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(short)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)!=(i=(short)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(short)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            if((i=(char)val)>Short.MAX_VALUE){
              break returnFalse;
            }
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfInt
          final int i;
          if(val instanceof Integer||val instanceof Byte||val instanceof Short){
            i=((Number)val).intValue();
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(int)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((double)(f=(float)val)!=(double)(i=(int)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(int)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            i=(char)val;
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfLong
          final long l;
          if(val instanceof Long||val instanceof Integer||val instanceof Byte||val instanceof Short){
            l=((Number)val).longValue();
          }else if(val instanceof Float){
            final float f;
            if(!TypeUtil.floatEquals(f=(float)val,l=(long)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if(!TypeUtil.doubleEquals(d=(double)val,l=(long)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            l=(char)val;
          }else if(val instanceof Boolean){
            l=TypeUtil.castToLong((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(l);
    #ELSEIF OfFloat
          if(val instanceof Float){
            final float f;
            if((f=(float)val)==f){
               #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
            }
            #MACRO ReturnUncheckedQueryNaN()
          }else if(val instanceof Double){
            final double d;
            final float f;
            if((d=(double)val)==(f=(float)d)){
              #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
            }else if(f!=f){
              #MACRO ReturnUncheckedQueryNaN()
            }else{
              break returnFalse;
            }
          }else if(val instanceof Integer){
            final int i;
            if((i=(int)val)!=0){
              if(!TypeUtil.checkCastToFloat(i)){
                break returnFalse;
              }
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=0){
              if(!TypeUtil.checkCastToFloat(l)){
                break returnFalse;
              }
              #MACRO ReturnUncheckedQueryBits($convertToBits$(l))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Short||val instanceof Byte){
            final int i;
            if((i=((Number)val).shortValue())!=0){
     
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Character){
            final int i;
            if((i=(char)val)!=0){
     
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Boolean){
            if((boolean)val){
              #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
            }
            #MACRO ReturnUncheckedQuery0()
          }else{
            break returnFalse;
          }
    #ELSE
          if(val instanceof Double){
            final double d;
            if((d=(double)val)==d){
               #MACRO ReturnUncheckedQueryBits($convertToBits$(d))
            }
            #MACRO ReturnUncheckedQueryNaN()
          }else if(val instanceof Float){
            
            final float f;
            if((f=(float)val)==f){
               #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
            }
            #MACRO ReturnUncheckedQueryNaN()
          }else if(val instanceof Integer|| val instanceof Short||val instanceof Byte){
            final int i;
            if((i=((Number)val).intValue())!=0){
     
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=0){
              if(!TypeUtil.checkCastToDouble(l)){
                break returnFalse;
              }
              #MACRO ReturnUncheckedQueryBits($convertToBits$(l))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Character){
            final int i;
            if((i=(char)val)!=0){
     
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Boolean){
            if((boolean)val){
              #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
            }
            #MACRO ReturnUncheckedQuery0()
          }else{
            break returnFalse;
          }
    #ENDIF
        }
  #ENDIF
#ELSE
        if(val!=null){
          #MACRO ReturnUncheckedQuery($queryCastRef$(CAST(val)))
        }
        #MACRO ReturnUncheckedQueryNull()
#ENDIF
      } //end size check
    } //end checked sublist try modcount
    #MACRO CheckedSubListQueryFinallyModCount()
  }//end val check
#IFSWITCH METHODNAME==search,indexOf,lastIndexOf
  return -1;
#ELSE
  #MACRO CheckedSubListRemoveValModCountCheck()
  return false;
#ENDIF
}
#ENDDEF
#MACRODEF CheckedSubListRemoveValModCountCheck()
#IFSWITCH STRUCTNAME==CheckedSubList
  #IFSWITCH METHODNAME==removeVal
CheckedCollection.checkModCount(modCount,root.modCount);
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryNonNull(VAL)
#IFNOT OfRef
ERROR ReturnUncheckedQueryNonNull<METHODNAME,STRUCTNAME>(VAL) is only valid for OfRef
#ENDIF
#IFSWITCH STRUCTNAME==Root
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(this.arr,0,size-1,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENonNull(size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNonNull<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedStack
  #IFSWITCH METHODNAME==search
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(this.arr,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNonNull<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedList
  #IFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(this.arr,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNonNull<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENonNull(size,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(root.arr,this.rootOffset,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNonNull<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==CheckedStack
final int modCount=this.modCount;
try{
  #IFSWITCH METHODNAME==contains
  return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(this.arr,0,size-1,VAL);
  #ELSEIFSWITCH METHODNAME==search
  return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(this.arr,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNonNull<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
}finally{
  CheckedCollection.checkModCount(modCount,this.modCount);
}
#ELSEIFSWITCH STRUCTNAME==CheckedList
final int modCount=this.modCount;
try{
  #IFSWITCH METHODNAME==contains
  return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(this.arr,0,size-1,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
  return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(this.arr,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNonNull<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
}finally{
  CheckedCollection.checkModCount(modCount,this.modCount);
}
#ELSEIFSWITCH STRUCTNAME==CheckedSubList
  #IFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENonNull(size,VAL);
  #ELSE
    #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,VAL);
    #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf,
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENonNull(root.arr,this.rootOffset,size,VAL);
    #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNonNull<METHODNAME,STRUCTNAME>(VAL)
    #ENDIF
  #ENDIF
#ELSE
ERROR unknown struct STRUCTNAME for ReturnUncheckedQueryNonNull<METHODNAME,STRUCTNAME>(VAL)
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryNull()
#IFNOT OfRef
ERROR ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>() is only valid for OfRef
#ENDIF
#IFSWITCH STRUCTNAME==Root
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(this.arr,0,size-1);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENull(size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedStack
  #IFSWITCH METHODNAME==search
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(this.arr,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedList
  #IFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(this.arr,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENull(size);
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(root.arr,this.rootOffset,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENull(size);
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(root.arr,this.rootOffset,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==CheckedStack
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(this.arr,0,size-1);
  #ELSEIFSWITCH METHODNAME==search
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(this.arr,size);  
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==CheckedList
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(this.arr,0,size-1);
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(this.arr,size);  
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==CheckedSubList
  #IFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENull(size);
  #ELSE
    #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
    #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf,
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENull(root.arr,this.rootOffset,size);
    #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>()
    #ENDIF
  #ENDIF
#ELSE
ERROR unknown struct STRUCTNAME for ReturnUncheckedQueryNull<METHODNAME,STRUCTNAME>()
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryNaN()
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQueryNaN<METHODNAME,STRUCTNAME>() is only valid for OfFloat and OfDouble
#ENDIF
#IFSWITCH STRUCTNAME==Root
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENaN(this.arr,0,size-1);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENaN(size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNaN<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedStack
  #IFSWITCH METHODNAME==search
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENaN(this.arr,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNaN<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedList
  #IFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENaN(this.arr,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNaN<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENaN(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENaN(size);
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENaN(root.arr,this.rootOffset,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNaN<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==CheckedSubList
  #IFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMENaN(size);
  #ELSE
    #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENaN(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
    #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf,
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMENaN(root.arr,this.rootOffset,size);
    #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryNaN<METHODNAME,STRUCTNAME>()
    #ENDIF
  #ENDIF
#ELSE
ERROR unknown struct STRUCTNAME for ReturnUncheckedQueryNaN<METHODNAME,STRUCTNAME>()
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQuery0()
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQuery0<METHODNAME,STRUCTNAME>() is only valid for OfFloat and OfDouble
#ENDIF
#IFSWITCH STRUCTNAME==Root
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME0(this.arr,0,size-1);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAME0(size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery0<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedStack
  #IFSWITCH METHODNAME==search
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME0(this.arr,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery0<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedList
  #IFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME0(this.arr,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery0<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME0(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAME0(size);
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME0(root.arr,this.rootOffset,size);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery0<METHODNAME,STRUCTNAME>()
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==CheckedSubList
  #IFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAME0(size);
  #ELSE
    #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME0(root.arr,rootOffset=this.rootOffset,rootOffset+size-1);
    #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf,
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME0(root.arr,this.rootOffset,size);
    #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery0<METHODNAME,STRUCTNAME>()
    #ENDIF
  #ENDIF
#ELSE
ERROR unknown struct STRUCTNAME for ReturnUncheckedQuery0<METHODNAME,STRUCTNAME>()
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryBits(VAL)
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQueryBits<METHODNAME,STRUCTNAME>(VAL) is only valid for OfFloat and OfDouble
#ENDIF
#IFSWITCH STRUCTNAME==Root
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMEBits(this.arr,0,size-1,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMEBits(size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryBits<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedStack
  #IFSWITCH METHODNAME==search
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMEBits(this.arr,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryBits<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedList
  #IFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMEBits(this.arr,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryBits<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMEBits(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMEBits(size,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMEBits(root.arr,this.rootOffset,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryBits<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==CheckedSubList
  #IFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAMEBits(size,VAL);
  #ELSE
    #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMEBits(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,VAL);
    #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf,
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAMEBits(root.arr,this.rootOffset,size,VAL);
    #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQueryBits<METHODNAME,STRUCTNAME>(VAL)
    #ENDIF
  #ENDIF
#ELSE
ERROR unknown struct STRUCTNAME for ReturnUncheckedQueryBits<METHODNAME,STRUCTNAME>(VAL)
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQuery(VAL)
#IF OfDouble,OfFloat
ERROR ReturnUncheckedQuery<METHODNAME,STRUCTNAME>(VAL) is not valid for OfFloat and OfDouble
#ENDIF
#IFSWITCH STRUCTNAME==Root
  #IFSWITCH METHODNAME==contains
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME(this.arr,0,size-1,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAME(size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedStack
  #IFSWITCH METHODNAME==search
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME(this.arr,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedList
  #IFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME(this.arr,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  #IFSWITCH METHODNAME==contains
final int rootOffset;
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAME(size,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf
return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME(root.arr,this.rootOffset,size,VAL);
  #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery<METHODNAME,STRUCTNAME>(VAL)
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==CheckedSubList
  #IFSWITCH METHODNAME==removeVal
return this.uncheckedMETHODNAME(size,VAL);
  #ELSE
    #IFSWITCH METHODNAME==contains
  final int rootOffset;
  return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME(root.arr,rootOffset=this.rootOffset,rootOffset+size-1,VAL);
    #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf,
  return OmniArray.Of$ClassPrefix$.uncheckedMETHODNAME(root.arr,this.rootOffset,size,VAL);
    #ELSE
ERROR unknown method METHODNAME for ReturnUncheckedQuery<METHODNAME,STRUCTNAME>(VAL)
    #ENDIF
  #ENDIF
#ELSE
ERROR unknown struct STRUCTNAME for ReturnUncheckedQuery<METHODNAME,STRUCTNAME>(VAL)
#ENDIF
#ENDDEF
#MACRODEF IteratorForEachImpl<ITRTYPE>(CONSUMER,ACTION)
@Override public void forEachRemaining(CONSUMER action){
#IFSWITCH STRUCTNAME==CheckedSubList
  int cursor;
  final int bound;
  final STRUCTNAME$<E>$ parent;
  if((cursor=this.cursor)<(bound=(parent=this.parent).rootOffset+parent.size)){
    final int modCount=this.modCount;
    final var root=parent.root;
    try{
      OmniArray.Of$ClassPrefix$.ascendingForEach(root.arr,cursor,cursor=bound-1,ACTION);
    }finally{
      CheckedCollection.checkModCount(modCount,root.modCount);
    }
    this.cursor=bound;
    this.lastRet=cursor;
  }
#ELSEIFSWITCH STRUCTNAME==CheckedList
  int cursor;
  final int bound;
  final STRUCTNAME$<E>$ parent;
  if((cursor=this.cursor)<(bound=(parent=this.parent).size)){
    final int modCount=this.modCount;
    try{
      OmniArray.Of$ClassPrefix$.ascendingForEach(parent.arr,cursor,cursor=bound-1,ACTION);
    }finally{
      CheckedCollection.checkModCount(modCount,parent.modCount);
    }
    this.cursor=bound;
    this.lastRet=cursor;
  }
#ELSEIFSWITCH STRUCTNAME==CheckedStack
  final int cursor;
  if((cursor=this.cursor)>0){
    final int modCount=this.modCount;
    final var parent=this.parent;
    try{
      OmniArray.Of$ClassPrefix$.descendingForEach(parent.arr,0,cursor-1,ACTION);
    }finally{
      CheckedCollection.checkModCount(modCount,parent.modCount);
    }
    this.cursor=0;
    this.lastRet=0;
  }
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  #IFSWITCH ITRTYPE==ListItr
  int cursor;
  final int bound;
  #ELSE
  final int cursor,bound;
  #ENDIF
  final STRUCTNAME$<E>$ parent;
  if((cursor=this.cursor)<(bound=(parent=this.parent).rootOffset+parent.size)){
    #IFSWITCH ITRTYPE==ListItr
    OmniArray.Of$ClassPrefix$.ascendingForEach(parent.root.arr,cursor,cursor=bound-1,ACTION);
    this.lastRet=cursor;
    #ELSE
    OmniArray.Of$ClassPrefix$.ascendingForEach(parent.root.arr,cursor,bound-1,ACTION);
    #ENDIF
    this.cursor=bound;
  }
#ELSEIFSWITCH STRUCTNAME==UncheckedList
  #IFSWITCH ITRTYPE==ListItr
  int cursor;
  final int bound;
  #ELSE
  final int cursor,bound;
  #ENDIF
  final STRUCTNAME$<E>$ parent;
  if((cursor=this.cursor)<(bound=(parent=this.parent).size)){
    #IFSWITCH ITRTYPE==ListItr
    OmniArray.Of$ClassPrefix$.ascendingForEach(parent.arr,cursor,cursor=bound-1,ACTION);
    this.lastRet=cursor;
    #ELSE
    OmniArray.Of$ClassPrefix$.ascendingForEach(parent.arr,cursor,bound-1,ACTION);
    #ENDIF
    this.cursor=bound;
  }
#ELSE
  final int cursor;
  if((cursor=this.cursor)>0){
    OmniArray.Of$ClassPrefix$.descendingForEach(parent.arr,0,cursor-1,ACTION);
    this.cursor=0;
  }
#ENDIF
}
#ENDDEF
#MACRODEF IteratorNextImpl<ITRTYPE>()
#MACRO SuppressUnchecked()
@Override public $exposedType$ next$TypeNameModifier$(){
#IFSWITCH STRUCTNAME==CheckedSubList,CheckedList,CheckedStack
  #IFSWITCH STRUCTNAME==CheckedSubList
  final CheckedList$<E>$ root;
  final STRUCTNAME$<E>$ parent;
  CheckedCollection.checkModCount(modCount,(root=(parent=this.parent).root).modCount);
  final int cursor;
  if((cursor=this.cursor)<(parent.rootOffset+parent.size))
  #ELSE
  final STRUCTNAME$<E>$ root;
  CheckedCollection.checkModCount(modCount,(root=this.parent).modCount);
    #IFSWITCH STRUCTNAME==CheckedList
  final int cursor;
  if((cursor=this.cursor)<root.size)
    #ELSE
  int cursor;
  if((cursor=this.cursor)>0)
    #ENDIF
  #ENDIF
  {  
  #IFSWITCH STRUCTNAME==CheckedList,CheckedSubList
    this.lastRet=cursor;
    this.cursor=cursor+1;
  #ELSE
    this.lastRet=--cursor;
    this.cursor=cursor;
  #ENDIF
    return ($exposedType$)root.arr[cursor];
  }
  throw new NoSuchElementException();
#ELSEIFSWITCH STRUCTNAME==UncheckedSubList
  #IFSWITCH ITRTYPE==ListItr
  int lastRet;
  this.lastRet=lastRet=this.cursor++;
  return ($exposedType$)parent.root.arr[lastRet];
  #ELSE
  return ($exposedType$)parent.root.arr[cursor++];
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==UncheckedList
  #IFSWITCH ITRTYPE==ListItr
  int lastRet;
  this.lastRet=lastRet=this.cursor++;
  return ($exposedType$)parent.arr[lastRet];
  #ELSE
  return ($exposedType$)parent.arr[cursor++];
  #ENDIF
#ELSE
  return ($exposedType$)parent.arr[--cursor];
#ENDIF
}
#ENDDEF
#MACRODEF IteratorRemoveImpl<ITRTYPE>()
@Override public void remove(){
#IFSWITCH STRUCTNAME==CheckedSubList,CheckedStack,CheckedList
  final int lastRet;
  if((lastRet=this.lastRet)!=-1){
    int modCount;
  #IFSWITCH STRUCTNAME==CheckedSubList
    final CheckedList$<E>$ root;
    STRUCTNAME$<E>$ parent;
    CheckedCollection.checkModCount(modCount=this.modCount,(root=(parent=this.parent).root).modCount);
    root.modCount=++modCount;
    do{
      parent.modCount=modCount;
      --parent.size;
    }while((parent=parent.parent)!=null);
  #ELSE
    final STRUCTNAME$<E>$ root;
    CheckedCollection.checkModCount(modCount=this.modCount,(root=this.parent).modCount);
    root.modCount=++modCount;
  #ENDIF
    this.modCount=modCount;
    OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(root.arr,lastRet,--root.size);
    this.cursor=lastRet;
    this.lastRet=-1;
    return;
  }
  throw new IllegalStateException();
#ELSE
  #IFSWITCH STRUCTNAME==UncheckedSubList
  STRUCTNAME$<E>$ parent;
  final UncheckedList$<E>$ root;
    #IFSWITCH ITRTYPE==ListItr
  final int lastRet;
  OmniArray.Of$ClassPrefix$.removeIndexAndPullDown((root=(parent=this.parent).root).arr,lastRet=this.lastRet,--root.size);
  this.cursor=lastRet;
    #ELSE
  OmniArray.Of$ClassPrefix$.removeIndexAndPullDown((root=(parent=this.parent).root).arr,--this.cursor,--root.size);
    #ENDIF
  do{
    --parent.size;
  }while((parent=parent.parent)!=null);
  #ELSEIFSWITCH STRUCTNAME==UncheckedList
  final STRUCTNAME$<E>$ root;
    #IFSWITCH ITRTYPE==ListItr
  final int lastRet;
  OmniArray.Of$ClassPrefix$.removeIndexAndPullDown((root=this.parent).arr,lastRet=this.lastRet,--root.size);
  this.cursor=lastRet;
    #ELSE
  OmniArray.Of$ClassPrefix$.removeIndexAndPullDown((root=this.parent).arr,--this.cursor,--root.size);
    #ENDIF
  #ELSE
  final STRUCTNAME$<E>$ root;
  OmniArray.Of$ClassPrefix$.removeIndexAndPullDown((root=this.parent).arr,this.cursor,--root.size);
  #ENDIF
#ENDIF
}
#ENDDEF
#MACRODEF IfClause(MACRONAME,VAL)
if(
#MACRO MACRONAME(VAL)
)
#ENDDEF
#MACRODEF IndexEquals(VAL)
#IFSWITCH SUFFIX==NonNull
nonNull.equals(VAL)
#ELSEIFSWITCH SUFFIX==Bits
bits==$convertToBits$(VAL)
#ELSEIFSWITCH SUFFIX==NaN
$BoxedType$.isNaN(VAL)
#ELSEIFSWITCH SUFFIX==Null
VAL==null
#ELSEIFSWITCH SUFFIX==0
VAL==0
#ELSE
  #IF OfRef
pred.test(VAL)
  #ELSE
val==VAL
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF BasicStackRemoveVal<SUFFIX>()
@Override boolean uncheckedremoveValSUFFIX(int size
#MACRO OptionalParameter()
){
  final var arr=this.arr;
  for(int index=--size;;--index){
    #MACRO IfClause(IndexEquals,arr[index])
    {
#IFSWITCH STRUCTNAME==CheckedStack
      ++this.modCount;
#ENDIF
      OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,size);
      this.size=size;
      return true;
    }else if(index==0){
      return false;
    }
  }
}
#ENDDEF
#MACRODEF BasicListRemoveVal<SUFFIX>()
@Override boolean uncheckedremoveValSUFFIX(int size
#MACRO OptionalParameter()
){
  final var arr=this.arr;
  for(int index=0;;){
    #MACRO IfClause(IndexEquals,arr[index])
    {
#IFSWITCH STRUCTNAME==CheckedList
      ++this.modCount;
#ENDIF
      OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,--size);
      this.size=size;
      return true;
    }else if(++index==size){
      return false;
    }
  }
}
#ENDDEF
#MACRODEF BasicSubListRemoveVal<SUFFIX>()
private boolean uncheckedremoveValSUFFIX(int size
#MACRO OptionalParameter()
){
#IFSWITCH STRUCTNAME==CheckedSubList
  int modCount;
  final CheckedList$<E>$ root;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
  final var arr=root.arr;
#ELSE
  final UncheckedList$<E>$ root;
  final var arr=(root=this.root).arr;
#ENDIF
  for(int index=this.rootOffset,bound=index+(--size);;++index){
    #MACRO IfClause(IndexEquals,arr[index])
    {
#IFSWITCH STRUCTNAME==CheckedSubList
      root.modCount=++modCount;
      this.modCount=modCount;
      for(var curr=parent;curr!=null;curr.modCount=modCount,--curr.size,curr=curr.parent){}
#ELSE
      for(var curr=parent;curr!=null;--curr.size,curr=curr.parent){}
#ENDIF
      OmniArray.Of$ClassPrefix$.removeIndexAndPullDown(arr,index,--root.size);
      this.size=size;
      return true;
    }else if(index==bound){
      return false;
    }
  }
}
#ENDDEF
#MACRODEF OptionalParameter()
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==NonNull
,Object nonNull
#ELSEIFSWITCH SUFFIX==NaN,Null,0
#ELSE
  #IF OfRef
,Predicate<Object> pred
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF SuppressUnchecked()
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
#ENDDEF