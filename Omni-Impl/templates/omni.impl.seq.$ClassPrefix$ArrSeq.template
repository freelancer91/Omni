#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
package omni.impl.seq;
import omni.api.OmniCollection;
import omni.util.OmniArray;
import omni.api.OmniList;
import omni.api.OmniStack;
import java.util.function.Predicate;
import java.util.function.Consumer;
import java.util.Comparator;
import omni.util.ArrCopy;
import omni.util.$ClassPrefix$SortUtil;
import omni.impl.CheckedCollection;
import java.util.NoSuchElementException;
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import java.util.function.IntFunction;
import java.util.function.UnaryOperator;
import omni.util.TypeUtil;
import java.util.ConcurrentModificationException;
#IF OfInt,OfLong,OfDouble
import java.util.function.$UnaryOperator$;
#ELSEIFNOT OfBoolean
import omni.function.$UnaryOperator$;
#ENDIF
#IF OfInt
import java.util.function.$Comparator$;
#ELSE
import omni.function.$Comparator$;
#ENDIF
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Predicate;
import java.util.function.$TypeNameModifier$Consumer;
#ELSE
import omni.function.$TypeNameModifier$Predicate;
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
#IFNOT OfDouble,OfChar
import omni.util.ToStringUtil;
#ENDIF
#IF OfDouble,OfFloat
import omni.util.HashUtil;
#ENDIF
#IFNOT OfBoolean
import omni.util.BitSetUtil;
#ENDIF
public abstract class $ClassPrefix$ArrSeq$<E>$ implements OmniCollection.Of$ClassPrefix$$<E>$
{
  transient int size;
  transient $ArrayType$[] arr;
  private $ClassPrefix$ArrSeq()
  {
    super();
  }
  private $ClassPrefix$ArrSeq(int initialCapacity)
  {
    super();
    switch(initialCapacity)
    { 
    default:
      this.arr=new $ArrayType$[initialCapacity];
      return;
    case OmniArray.DEFAULT_ARR_SEQ_CAP:
      this.arr=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
    case 0:
    }
  }
  private $ClassPrefix$ArrSeq(int size,$ArrayType$[] arr)
  {
    super();
    this.size=size;
    this.arr=arr;
  }
  @Override
  public void clear()
  {
    this.size=0;
  }
  @Override
  public boolean isEmpty()
  {
    return this.size==0;
  }
  @Override
  public int size()
  {
    return this.size;
  }
  #MACRO RemoveIfImpl($TypeNameModifier$Predicate$<? super E>$,filter)
  #MACRO RemoveIfImpl(Predicate<? super $BoxedType$>,filter::test)
  
  
  static void uncheckedForEachAscending($ArrayType$[] arr,int offset,int bound,$TypeNameModifier$Consumer$<? super E>$ action)
  {
    do
    {
      action.accept(($exposedType$)arr[offset]);
    }
    while(++offset!=bound);
  }
  static void uncheckedForEachDescending($ArrayType$[] arr,int offset,int bound,$TypeNameModifier$Consumer$<? super E>$ action)
  {
    do
    {
      action.accept(($exposedType$)arr[--bound]);
    }
    while(bound!=offset);
  }
  

  private static int doRemoveIf($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
#IF OfBoolean
    $ArrayType$ v;
    
    if(filter.test(v=arr[srcOffset]))
    {
      int dstOffset=srcOffset;
      while(++srcOffset!=srcBound)
      {
        if(arr[srcOffset]^v)
        {
          if(!filter.test(v=!v))
          {
            arr[dstOffset]=v;
            return pullSurvivorsDown(arr,srcOffset,srcBound,dstOffset+1,v);
          }
          break;
        }
      }
      return dstOffset;
    }
    else
    {
      while(++srcOffset!=srcBound)
      {
        if(arr[srcOffset]^v)
        {
          if(filter.test(!v))
          {
            return pullSurvivorsDown(arr,srcOffset,srcBound,srcOffset,v);
          }
          break;
        }
      }
      return srcBound;
    }
#ELSE
    do
    {
      if(filter.test(($exposedType$)arr[srcOffset]))
      {
        return pullSurvivorsDown(arr,srcOffset,srcBound,filter);
      }
    }
    while(++srcOffset!=srcBound);
    return srcBound;
#ENDIF
  }
  
  
#IF OfBoolean
    private static int pullSurvivorsDown($ArrayType$[] arr,int srcOffset,int srcBound,int dstOffset,$ArrayType$ retainThis)
    {
      while(++srcOffset!=srcBound)
      {
        if(arr[srcOffset]==retainThis)
        {
          arr[dstOffset++]=retainThis;
        }
      }
      return dstOffset;
    }
#ELSE
    private static $<E>$ int pullSurvivorsDown($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter)
    {
      int dstOffset=srcOffset;
      while(++srcOffset!=srcBound)
      {
        final $ArrayType$ v;
        if(!filter.test(($exposedType$)(v=arr[srcOffset])))
        {
          arr[dstOffset++]=v;
        }
      }
      return dstOffset;
    }
#ENDIF
  

    private static int doRemoveIf($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter,CheckedCollection.AbstractModCountChecker modCountChecker)
    {
      try
      {
#IF OfBoolean
        $ArrayType$ v;
        if(filter.test(v=arr[srcOffset]))
        {
          int dstOffset=srcOffset;
          while(++srcOffset!=srcBound)
          {
            if(arr[srcOffset]^v)
            {
              if(!filter.test(v=!v))
              {
                modCountChecker.checkModCount();
                arr[dstOffset]=v;
                return pullSurvivorsDown(arr,srcOffset,srcBound,dstOffset+1,v);
              }
              break;
            }
          }
          modCountChecker.checkModCount();
          return dstOffset;
        }
        else
        {
          while(++srcOffset!=srcBound)
          {
            if(arr[srcOffset]^v)
            {
              if(!filter.test(!v))
              {
                break;
              }
              modCountChecker.checkModCount();
              return pullSurvivorsDown(arr,srcOffset,srcBound,srcOffset,v);
            }
          }
        }
        modCountChecker.checkModCount();
        return srcBound;
#ELSE
        do
        {
          if(filter.test(($exposedType$)arr[srcOffset]))
          {
            int dstOffset=srcOffset;
            while(++srcOffset!=srcBound)
            {
              final $ArrayType$ v;
              if(!filter.test(v=arr[srcOffset]))
              {
                int newDstOffset=markAndPullDown(arr,srcOffset+1,srcBound,filter,dstOffset+1,modCountChecker);
                arr[dstOffset]=v;
                return newDstOffset;
              }
            }
            modCountChecker.checkModCount();
            return dstOffset;
          }
        }
        while(++srcOffset!=srcBound);
        modCountChecker.checkModCount();
        return srcBound;
#ENDIF
      }
      catch(final ConcurrentModificationException e)
      {
        throw e;
      }
      catch(final RuntimeException e)
      {
        throw modCountChecker.handleException(e);
      }
    }
#IFNOT OfBoolean
    private static int markAndPullDown($ArrayType$[] arr,int srcOffset,int srcBound,$TypeNameModifier$Predicate$<? super E>$ filter,int dstOffset,CheckedCollection.AbstractModCountChecker modCountChecker)
    {
      int nRemaining;
      if((nRemaining=(srcBound-srcOffset))!=0)
      {
        if(nRemaining>64)
        {
          long[] survivorSet;
          int numSurvivors=BitSetUtil.markSurvivors(arr,srcOffset,srcBound,filter,survivorSet=BitSetUtil.getBitSet(nRemaining));
          modCountChecker.checkModCount();
          if(numSurvivors!=0)
          {
            if(numSurvivors==nRemaining)
            {
              System.arraycopy(arr,srcOffset,arr,dstOffset,numSurvivors);
              dstOffset+=numSurvivors;
            }
            else
            {
              BitSetUtil.pullSurvivorsDown(arr,srcOffset,dstOffset,dstOffset+=numSurvivors,survivorSet);
            }
          }
        }
        else
        {
          long word=BitSetUtil.markSurvivors(arr,srcOffset,srcBound,filter);
          modCountChecker.checkModCount();
          int numSurvivors;
          if((numSurvivors=Long.bitCount(word))!=0)
          {
            if(numSurvivors==nRemaining)
            {
              ArrCopy.uncheckedCopy(arr,srcOffset,arr,dstOffset,numSurvivors);
              dstOffset+=numSurvivors;
            }
            else
            {
              BitSetUtil.pullSurvivorsDown(arr,srcOffset,dstOffset,dstOffset+=numSurvivors,word);
            }
          }
        }
      }
      else
      {
        modCountChecker.checkModCount();
      }
      return dstOffset;
    }
#ENDIF
  
  
  
  
#IFNOT OfBoolean
  @Override
  public boolean add(boolean val)
  {
    push($queryCastBoolean$(val));
    return true;
  }
#ENDIF
#IF OfLong,OfFloat,OfDouble
  @Override
  public boolean add(int val)
  {
    push(($exposedType$)val);
    return true;
  }
  #IFNOT OfLong
  @Override
  public boolean add(char val)
  {
    push(($exposedType$)val);
    return true;
  }
  @Override
  public boolean add(long val)
  {
    push(($exposedType$)val);
    return true;
  }
  @Override
  public boolean add(short val)
  {
    push(($exposedType$)val);
    return true;
  }
    #IFNOT OfFloat
  @Override
  public boolean add(float val)
  {
    push(($exposedType$)val);
    return true;
  }
    #ENDIF
  #ENDIF
#ENDIF
  @Override
  public boolean add($exposedType$ val)
  {
    push(val);
    return true;
  }
  @Override
  public boolean add($BoxedType$ val)
  {
    push(($exposedType$)val);
    return true;
  }

 
  
  @Override
  public int hashCode()
  {
    int size;
    if((size=this.size)!=0)
    {
      return uncheckedHashCode(size);
    }
    return 1;
  }
  @Override
  public String toString()
  {
    int size;
    if((size=this.size)!=0)
    {
#IF OfBoolean
      if(size>(Integer.MAX_VALUE/6))
      {
        throw new OutOfMemoryError();
      }
#ELSEIF OfDouble,OfFloat
      if(size>(Integer.MAX_VALUE/5))
      {
        throw new OutOfMemoryError();
      }
#ELSE
      if(size>(Integer.MAX_VALUE/3))
      {
        throw new OutOfMemoryError();
      }
#ENDIF
#IF OfDouble
      final StringBuilder builder;
      uncheckedToString(size,builder=new StringBuilder("["));
      return builder.append(']').toString();
#ELSEIF OfChar
      final char[] buffer;
      uncheckedToString(size,buffer=new char[size*=3]);
      buffer[size-1]=']';
      buffer[0]='[';
      return new String(buffer,0,size);
#ELSEIF OfBoolean
      #MACRO ToStringFastImpl<false>(7,size<=(int)(OmniArray.MAX_ARR_SIZE/6.5f)?(size*6)+(size>>>1):OmniArray.MAX_ARR_SIZE)
#ELSEIF OfByte
      #MACRO ToStringFastImpl<false>(6,size<=(int)(OmniArray.MAX_ARR_SIZE/5)?(size*5):OmniArray.MAX_ARR_SIZE)
#ELSEIF OfShort
      #MACRO ToStringFastImpl<false>(8,size<=(int)(OmniArray.MAX_ARR_SIZE/5.5f)?(size*5)+(size>>>1):OmniArray.MAX_ARR_SIZE)
#ELSEIF OfInt
      #MACRO ToStringFastImpl<false>(13,size<=(int)(OmniArray.MAX_ARR_SIZE>>>3)?(size<<3):OmniArray.MAX_ARR_SIZE)
#ELSEIF OfLong
      #MACRO ToStringFastImpl<false>(22,size<=(int)(OmniArray.MAX_ARR_SIZE/12.5f)?(size*12)+(size>>>1):OmniArray.MAX_ARR_SIZE)
#ELSE
      #MACRO ToStringFastImpl<false>(17,size<=(int)(OmniArray.MAX_ARR_SIZE/11)?(size*11):OmniArray.MAX_ARR_SIZE)
#ENDIF
    }
    return "[]";
  }

  @Override
  public <T> T[] toArray(T[] dst)
  {
    int size;
    if((size=this.size)!=0)
    {
      uncheckedCopyInto(dst=OmniArray.uncheckedArrResize(size,dst),size);
    }
    else if(dst.length!=0)
    {
      dst[0]=null;
    }
    return dst;
  }
#IF OfDouble,OfFloat
  #MACRO UncheckedContains<Bits>()
  #MACRO UncheckedContains<0>()
  #MACRO UncheckedContains<NaN>()
  abstract boolean uncheckedremoveValBits(int size,$queryParameterType$ bits);
  abstract boolean uncheckedremoveVal0(int size);
  abstract boolean uncheckedremoveValNaN(int size);
#ELSE
  #MACRO UncheckedContains< >()
  abstract boolean uncheckedremoveVal(int size,$queryParameterType$ val);
#ENDIF
  #MACRO QueryMethods<removeVal>()
  #MACRO QueryMethods<contains>()
  abstract void uncheckedCopyInto(Object[] dst,int size);
  #MACRO ToArrayImpl($exposedType$,$ClassPrefix$,($exposedType$),$defaultVal$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
  #MACRO GetterMethods(ToArrayImpl)



  abstract int uncheckedHashCode(int size);
#IF OfDouble
  abstract void uncheckedToString(int size,StringBuilder builder);
#ELSEIF OfChar
  abstract void uncheckedToString(int size,char[] buffer);
#ELSE
  abstract int uncheckedToString(int size,char[] buffer);
  abstract void uncheckedToString(int size,ToStringUtil.OmniStringBuilder builder);
#ENDIF
  
  abstract void uncheckedForEach(int size,$TypeNameModifier$Consumer$<? super E>$ action);

  
  
  private void uncheckedInit($exposedType$ val)
  {
    $ArrayType$[] arr;
    if((arr=this.arr)==OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
    {
      this.arr=arr=new $ArrayType$[OmniArray.DEFAULT_ARR_SEQ_CAP];
    }
    else if(arr==null)
    {
      this.arr=arr=new $ArrayType$[1];
    }
    arr[0]=val;
    this.size=1;
  }
  private void uncheckedAppend(int size,$exposedType$ val)
  {
    $ArrayType$[] arr;
    if((arr=this.arr).length==size)
    {
      ArrCopy.uncheckedCopy(arr,0,arr=new $ArrayType$[OmniArray.growBy50Pct(size)],0,size);
      this.arr=arr;
    }
    arr[size]=val;
    this.size=size+1;
  }
  public void push($exposedType$ val)
  {
    int size;
    if((size=this.size)!=0)
    {
      uncheckedAppend(size,val);
    }
    else
    {
      uncheckedInit(val);
    }
  }
  private void uncheckedInsert(int size,int index,$exposedType$ val)
  {
    int tailDist;
    if((tailDist=size-index)==0)
    {
      uncheckedAppend(size,val);
    }
    else
    {
      $ArrayType$[] arr;
      if((arr=this.arr).length==size)
      {
        $ArrayType$[] newArr;
        ArrCopy.semicheckedCopy(arr,0,newArr=new $ArrayType$[OmniArray.growBy50Pct(size)],0,index);
        ArrCopy.uncheckedCopy(arr,index,newArr,index+1,tailDist);
        this.arr=arr=newArr;
      }
      else
      {
        ArrCopy.uncheckedCopy(arr,index,arr,index+1,tailDist);
      }
      arr[index]=val;
      this.size=size+1;
    }
  
    
  }
  public void push($BoxedType$ val)
  {
    push(($exposedType$)val);
  }
  private $exposedType$ uncheckedremoveAtIndex(int index,int size)
  {
    final $ArrayType$[] arr;
    final $exposedType$ ret=($exposedType$)(arr=this.arr)[index];
    ArrCopy.semicheckedSelfCopy(arr,index+1,index,(--size)-index);
    this.size=size;
    return ret;
  }
  
  #MACRO StructImpl<Stack,Unchecked>()
  #MACRO StructImpl<Stack,Checked>()
  #MACRO StructImpl<List,Unchecked>()
  #MACRO StructImpl<List,Checked>()
  #MACRO StructImpl<SubList,Unchecked>()
  #MACRO StructImpl<SubList,Checked>()

  private static abstract class AbstractItr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
  {
    #MACRO GetterMethods(IteratorNextImpl)
  }

  private static abstract interface ListDefault$<E>$ extends OmniList.Of$ClassPrefix$$<E>$
  {
    @Override
    public default void add(int index,$BoxedType$ val)
    {
      add(index,($exposedType$)val);
    }
    @Override
    public default $BoxedType$ get(int index)
    {
      return get$TypeNameModifier$(index);
    }
    @Override
    public default $BoxedType$ set(int index,$BoxedType$ val)
    {
      return set(index,($exposedType$)val);
    }
    @Override
    public default  $BoxedType$ remove(int index)
    {
      return $removeAtIndexMethod$(index);
    }
  }
  private static abstract interface SubListDefault$<E>$ extends ListDefault$<E>$
  {
    @Override
    public default boolean add($BoxedType$ val)
    {
      return this.add(($exposedType$)val);
    }
#IFNOT OfBoolean
    @Override
    public default boolean add(boolean val)
    {
      return this.add($queryCastBoolean$(val));
    }
  #IF OfLong,OfFloat,OfDouble
    @Override
    public default boolean add(int val)
    {
      return this.add(($exposedType$)val);
    }
    #IFNOT OfLong
    @Override
    public default boolean add(char val)
    {
      return this.add(($exposedType$)val);
    }
    @Override
    public default boolean add(short val)
    {
      return this.add(($exposedType$)val);
    }
    @Override
    public default boolean add(long val)
    {
      return this.add(($exposedType$)val);
    }
      #IFNOT OfFloat
    @Override
    public default boolean add(float val)
    {
      return this.add(($exposedType$)val);
    }
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  }
  

}




#MACRODEF StructImpl<STRUCTNAME,CHECKED>()
#IFSWITCH STRUCTNAME==SubList
private
#ELSE
public
#ENDIF
static class CHECKEDSTRUCTNAME$<E>$
#IFSWITCH STRUCTNAME==List,Stack
  #IFSWITCH CHECKED==Unchecked
  extends $ClassPrefix$ArrSeq$<E>$
  #ELSE
  extends UncheckedSTRUCTNAME$<E>$
  #ENDIF
#ENDIF
#IFSWITCH STRUCTNAME==SubList
  implements STRUCTNAMEDefault$<E>$
#ELSE
  #IFSWITCH CHECKED==Unchecked
    #IFSWITCH STRUCTNAME==Stack
  implements OmniSTRUCTNAME.Of$ClassPrefix$$<E>$
    #ELSE
  implements STRUCTNAMEDefault$<E>$
    #ENDIF
  #ENDIF
#ENDIF
{
#IFSWITCH STRUCTNAME==SubList
  transient final CHECKEDList$<E>$ root;
  transient final CHECKEDSTRUCTNAME$<E>$ parent;
  transient final int rootOffset;
  transient int size;
#ENDIF
#IFSWITCH CHECKED==Checked
  transient int modCount;
#ENDIF



#IFSWITCH STRUCTNAME==SubList
  private CHECKEDSTRUCTNAME(CHECKEDList$<E>$ root,int rootOffset,int size
  #IFSWITCH CHECKED==Checked
    ,int modCount
  #ENDIF
  )
  {
  #IFSWITCH CHECKED==Checked
    this.modCount=modCount;
  #ENDIF
    this.root=root;
    this.parent=null;
    this.rootOffset=rootOffset;
    this.size=size;
  }
  private CHECKEDSTRUCTNAME(CHECKEDSTRUCTNAME$<E>$ parent,int rootOffset,int size
  #IFSWITCH CHECKED==Checked
    ,int modCount
  #ENDIF
  )
  {
  #IFSWITCH CHECKED==Checked
    this.modCount=modCount;
  #ENDIF
    this.root=parent.root;
    this.parent=parent;
    this.rootOffset=rootOffset;
    this.size=size;
  }
#ELSE
  public CHECKEDSTRUCTNAME()
  {
    super();
  }
  public CHECKEDSTRUCTNAME(int initialCapacity)
  {
    super(initialCapacity);
  }
  private CHECKEDSTRUCTNAME(int size,$ArrayType$[] arr)
  {
    super(size,arr);
  }
#ENDIF

  @Override
  public boolean equals(Object val)
  {
    //TODO implement equals(Object) method
    return false;
  }
  @Override
  public Object clone()
  {
    final $ArrayType$[] copy;
    final int size;
    #MACRO SubListCheckModCount<clone>()
    if((size=this.size)!=0)
    {
#IFSWITCH STRUCTNAME==SubList
      ArrCopy.uncheckedCopy(root.arr,this.rootOffset,copy=new $ArrayType$[size],0,size);
#ELSE
      ArrCopy.uncheckedCopy(this.arr,0,copy=new $ArrayType$[size],0,size);
#ENDIF
    }
    else
    {
      copy=OmniArray.Of$ClassPrefix$.DEFAULT_ARR;
    }
#IFSWITCH STRUCTNAME==SubList
    return new CHECKEDList$<E>$(size,copy);
#ELSE
    return new CHECKEDSTRUCTNAME$<E>$(size,copy);
#ENDIF
  }
  @Override
  public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
  {
    #MACRO SubListCheckModCount<iterator>()
    return new Itr$<E>$(this);
  }
  @Override
  public <T> T[] toArray(IntFunction<T[]> arrConstructor)
  {
#IFSWITCH STRUCTNAME==SubList
    final int size;
    final T[] dst;
  #IFSWITCH CHECKED==Checked
    int modCount=this.modCount;
    final var root=this.root;
    try
  #ENDIF
    {
      dst=arrConstructor.apply(size=this.size);
    }
  #IFSWITCH CHECKED==Checked
    finally
    {
      CheckedCollection.checkModCount(modCount,root.modCount);
    }
  #ENDIF
    if(size!=0)
    {
      ArrCopy.uncheckedCopy(root.arr,this.rootOffset,dst,0,size);
    }
    return dst;
#ELSE
  #IFSWITCH CHECKED==Unchecked
    final int size;
    T[] dst=arrConstructor.apply(size=this.size);
    if(size!=0)
    {
    #IFSWITCH STRUCTNAME==Stack
      ArrCopy.uncheckedReverseCopy(this.arr,0,dst,0,size);
    #ELSE
      ArrCopy.uncheckedCopy(this.arr,0,dst,0,size);
    #ENDIF
    }
    return dst;
  #ELSE
    return super.toArray((arrSize)->
    {
      int modCount=this.modCount;
      try
      {
        return arrConstructor.apply(arrSize);
      }
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    });
  #ENDIF
#ENDIF
  }
  #MACRO SubTypeToArrayImpl($exposedType$,$ClassPrefix$,($exposedType$),$defaultVal$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
  #MACRO GetterMethods(SubTypeToArrayImpl)
  #MACRO ItrImpl<Itr>()
#IF OfDouble,OfFloat
  #MACRO UncheckedRemoveVal<Bits>()
  #MACRO UncheckedRemoveVal<0>()
  #MACRO UncheckedRemoveVal<NaN>()
#ELSE
  #MACRO UncheckedRemoveVal< >()
#ENDIF


   #MACRO ForEachImpl($TypeNameModifier$Consumer$<? super E>$,action)
  #MACRO ForEachImpl(Consumer<? super $BoxedType$>,action::accept)
  

 


#IFSWITCH STRUCTNAME==Stack
  @Override
  public $exposedType$ pop$TypeNameModifier$()
  {
  #IFSWITCH CHECKED==Unchecked
    return ($exposedType$)arr[--this.size];
  #ELSE
    int size;
    if((size=this.size)!=0)
    {
      ++this.modCount;
      final $exposedType$ ret=($exposedType$)arr[--size];
      this.size=size;
      return ret;
    }
    throw new NoSuchElementException();
  #ENDIF
  }
  #MACRO PollImpl($exposedType$,$ClassPrefix$,($exposedType$),$defaultVal$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
  #MACRO GetterMethods(PollImpl)
  #IFSWITCH CHECKED==Unchecked
  @Override
  public $BoxedType$ pop()
  {
    return pop$TypeNameModifier$();
  }
  #MACRO QueryMethods<search>()
  #MACRO PeekImpl($exposedType$,$ClassPrefix$,($exposedType$),$defaultVal$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
  #MACRO GetterMethods(PeekImpl)
    #IF OfDouble,OfFloat
  #MACRO UncheckedSearch<Bits>()
  #MACRO UncheckedSearch<0>()
  #MACRO UncheckedSearch<NaN>()
    #ELSE
  #MACRO UncheckedSearch< >()
    #ENDIF
  #ENDIF
#ENDIF




#IFSWITCH STRUCTNAME==List
  #IFSWITCH CHECKED==Unchecked
  private void uncheckedAdd(int index,$exposedType$ val,int size)
  {
    if(size!=0)
    {
      super.uncheckedInsert(size,index,val);
    }
    else
    {
      super.uncheckedInit(val);
    }
  }
  /*
  private void sublistForEach(int rootOffset,int size,$TypeNameModifier$Consumer$<? super E>$ action)
  {
    final var arr=this.arr;
    for(size+=rootOffset;;)
    {
      action.accept(($exposedType$)arr[rootOffset]);
      if(++rootOffset==size)
      {
        return;
      }
    }
  }
  */
  private void uncheckedReplaceAll(int offset,int bound,$UnaryOperator$$<E>$ operator)
  {
    final var arr=this.arr;
    for(;;)
    {
      arr[offset]=operator.$applyMethod$(($exposedType$)arr[offset]);
      if(++offset==bound)
      {
        return;
      }
    }
  }
    #IF OfDouble,OfFloat
  #MACRO SubListContains<Bits>()
  #MACRO SubListContains<0>()
  #MACRO SubListContains<NaN>()
  #MACRO SubListIndexOf<Bits>()
  #MACRO UncheckedIndexOf<Bits>()
  #MACRO SubListIndexOf<0>()
  #MACRO UncheckedIndexOf<0>()
  #MACRO SubListIndexOf<NaN>()
  #MACRO UncheckedIndexOf<NaN>()
  #MACRO SubListLastIndexOf<Bits>()
  #MACRO UncheckedLastIndexOf<Bits>()
  #MACRO SubListLastIndexOf<0>()
  #MACRO UncheckedLastIndexOf<0>()
  #MACRO SubListLastIndexOf<NaN>()
  #MACRO UncheckedLastIndexOf<NaN>()
    #ELSE
  #MACRO SubListContains< >()
  #MACRO SubListIndexOf< >()
  #MACRO UncheckedIndexOf< >()
  #MACRO SubListLastIndexOf< >()
  #MACRO UncheckedLastIndexOf< >()
    #ENDIF
  #ENDIF
#ENDIF


#IFSWITCH STRUCTNAME==SubList

  #MACRO RemoveIfImpl($TypeNameModifier$Predicate$<? super E>$,filter)
  #MACRO RemoveIfImpl(Predicate<? super $BoxedType$>,filter::test)
  #MACRO QueryMethods<contains>()
   
  @Override
  public int hashCode()
  {
    #MACRO SubListCheckModCount<hashCode>()
    int size;
    if((size=this.size)!=0)
    {
      final $ArrayType$[] arr;
      int hash;
      int i;
      for(hash=31+$hashCodeMethod$((arr=root.arr)[i=this.rootOffset]),size+=i;++i!=size;hash=hash*31+$hashCodeMethod$(arr[i])){}
      return hash;
    }
    return 1;
  }
  @Override
  public boolean isEmpty()
  {
    #MACRO SubListCheckModCount<isEmpty>()
    return this.size==0;
  }

  #MACRO QueryMethods<removeVal>()
  @Override
  public int size()
  {
    #MACRO SubListCheckModCount<size>()
    return this.size;
  }
  @Override
  public <T> T[] toArray(T[] dst)
  {
    #MACRO SubListCheckModCount<toArray>()
    int size;
    if((size=this.size)!=0)
    {
      ArrCopy.uncheckedCopy(root.arr,this.rootOffset,dst=OmniArray.uncheckedArrResize(size,dst),0,size);
    }
    else if(dst.length!=0)
    {
      dst[0]=null;
    }
    return dst;
  }
  @Override
  public String toString()
  {
    #MACRO SubListCheckModCount<toString>()
    int size;
    if((size=this.size)!=0)
    {
 #IF OfBoolean
      if(size>(Integer.MAX_VALUE/6))
      {
        throw new OutOfMemoryError();
      }
#ELSEIF OfDouble,OfFloat
      if(size>(Integer.MAX_VALUE/5))
      {
        throw new OutOfMemoryError();
      }
#ELSE
      if(size>(Integer.MAX_VALUE/3))
      {
        throw new OutOfMemoryError();
      }
#ENDIF
#IF OfDouble
      final StringBuilder builder;
      final $ArrayType$[] arr;
      int i;
      for(builder=new StringBuilder("[").append((arr=root.arr)[i=this.rootOffset]),size+=i;++i!=size;builder.append(',').append(' ').append(arr[i])){}
      return builder.append(']').toString();
#ELSEIF OfChar
      final char[] buffer;
      final $ArrayType$[] arr;
      int bufferOffset,i;
      for((buffer=new char[size*3])[bufferOffset=1]=(arr=root.arr)[i=this.rootOffset],size+=i;++i!=size;buffer[++bufferOffset]=',',buffer[++bufferOffset]=' ',buffer[++bufferOffset]=arr[i]){}
      buffer[++bufferOffset]=']';
      buffer[0]='[';
      return new String(buffer,0,bufferOffset+1);
#ELSEIF OfBoolean
      #MACRO ToStringFastImpl<true>(7,size<=(int)(OmniArray.MAX_ARR_SIZE/6.5f)?(size*6)+(size>>>1):OmniArray.MAX_ARR_SIZE)
#ELSEIF OfByte
      #MACRO ToStringFastImpl<true>(6,size<=(int)(OmniArray.MAX_ARR_SIZE/5)?(size*5):OmniArray.MAX_ARR_SIZE)
#ELSEIF OfShort
      #MACRO ToStringFastImpl<true>(8,size<=(int)(OmniArray.MAX_ARR_SIZE/5.5f)?(size*5)+(size>>>1):OmniArray.MAX_ARR_SIZE)
#ELSEIF OfInt
      #MACRO ToStringFastImpl<true>(13,size<=(int)(OmniArray.MAX_ARR_SIZE>>>3)?(size<<3):OmniArray.MAX_ARR_SIZE)
#ELSEIF OfLong
      #MACRO ToStringFastImpl<true>(22,size<=(int)(OmniArray.MAX_ARR_SIZE/12.5f)?(size*12)+(size>>>1):OmniArray.MAX_ARR_SIZE)
#ELSE
      #MACRO ToStringFastImpl<true>(17,size<=(int)(OmniArray.MAX_ARR_SIZE/11)?(size*11):OmniArray.MAX_ARR_SIZE)
#ENDIF
    }
    return "[]";
  }
  @Override
  public boolean add($exposedType$ val)
  {
    int rootSize;
#IFSWITCH CHECKED==Checked
    #MACRO SubListCheckModCount<add>()
    root.modCount=++modCount;
    this.modCount=modCount;
    if((rootSize=root.size)!=0)
#ELSE
    final UncheckedList$<E>$ root;
    if((rootSize=(root=this.root).size)!=0)
#ENDIF
    {
      #MACRO BubbleUpIncrementSize()
      (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInsert(rootSize,this.rootOffset,val);
      ++this.size;
    }
    else
    {
      #MACRO BubbleUpInit()
      (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInit(val);
      this.size=1;
    }
    return true;
  }
#IFSWITCH CHECKED==Checked
  private $ClassPrefix$ArrSeq$<E>$ checkModCountAndGetRoot()
  {
    final CHECKEDList$<E>$ root;
    CheckedCollection.checkModCount(this.modCount,(root=this.root).modCount);
    return root;
  }
#ENDIF
  @Override
  public void clear()
  {
    #MACRO SubListCheckModCount<clear>()
    int size;
    if((size=this.size)!=0)
    {
#IFSWITCH CHECKED==Checked
      root.modCount=++modCount;
      this.modCount=modCount;
      for(var curr=parent;curr!=null;parent.modCount=modCount,parent.size-=size){}
      int rootOffset;
      ArrCopy.semicheckedSelfCopy(root.arr,(rootOffset=this.rootOffset)+size,rootOffset,(root.size-=size)-rootOffset);
#ELSE
      for(var curr=parent;curr!=null;parent.size-=size){}
      final UncheckedList$<E>$ root;
      int rootOffset;
      ArrCopy.semicheckedSelfCopy((root=this.root).arr,(rootOffset=this.rootOffset)+size,rootOffset,(root.size-=size)-rootOffset);
#ENDIF
      this.size=0;
    }
  }
#ENDIF





#IFSWITCH STRUCTNAME==List,Stack
  @Override
  void uncheckedForEach(int size,$TypeNameModifier$Consumer$<? super E>$ action)
  {
  #IFSWITCH CHECKED==Checked
    int modCount=this.modCount;
    try
  #ENDIF
    {
  #IFSWITCH STRUCTNAME==Stack
      uncheckedForEachDescending(this.arr,0,size,action);
  #ELSE
      uncheckedForEachAscending(this.arr,0,size,action);
  #ENDIF
    }
  #IFSWITCH CHECKED==Checked
    finally
    {
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
  #ENDIF
  }

  

  #MACRO SubTypeToArrayImpl(Object,,,,)
  
  #IFSWITCH CHECKED==Unchecked
  @Override
  int uncheckedHashCode(int size)
  {
    final $ArrayType$[] arr;
    int hash;
    #IFSWITCH STRUCTNAME==Stack
    for(hash=31+$hashCodeMethod$((arr=this.arr)[--size]);size!=0;hash=hash*31+$hashCodeMethod$(arr[--size])){}
    #ELSE
    int i;
    for(hash=31+$hashCodeMethod$((arr=this.arr)[i=0]);++i!=size;hash=hash*31+$hashCodeMethod$(arr[i])){}
    #ENDIF
    return hash;
  }
    #IF OfDouble
  @Override
  void uncheckedToString(int size,StringBuilder builder)
  {
    final $ArrayType$[] arr;
      #IFSWITCH STRUCTNAME==Stack
    for(builder.append((arr=this.arr)[--size]);size!=0;builder.append(',').append(' ').append(arr[--size])){}
      #ELSE
    int i;
    for(builder.append((arr=this.arr)[i=0]);++i!=size;builder.append(',').append(' ').append(arr[i])){}
      #ENDIF
  }
    #ELSEIF OfChar
  @Override
  void uncheckedToString(int size,char[] buffer)
  {
    final $ArrayType$[] arr;
    int bufferOffset;
      #IFSWITCH STRUCTNAME==Stack
    for(buffer[bufferOffset=1]=(arr=this.arr)[--size];size!=0;buffer[++bufferOffset]=',',buffer[++bufferOffset]=' ',buffer[++bufferOffset]=arr[--size]){}
      #ELSE
    int i;
    for(buffer[bufferOffset=1]=(arr=this.arr)[i=0];++i!=size;buffer[++bufferOffset]=',',buffer[++bufferOffset]=' ',buffer[++bufferOffset]=arr[i]){}
      #ENDIF
  }
    #ELSE
  @Override
  int uncheckedToString(int size,char[] buffer)
  {
    final $ArrayType$[] arr;
    int bufferOffset;
      #IFSWITCH STRUCTNAME==Stack
        #IF OfByte
    for(bufferOffset=ToStringUtil.getStringShort((arr=this.arr)[--size],buffer,1);size!=0;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getStringShort(arr[--size],buffer,bufferOffset)){}
        #ELSE
    for(bufferOffset=ToStringUtil.getString$ClassPrefix$((arr=this.arr)[--size],buffer,1);size!=0;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getString$ClassPrefix$(arr[--size],buffer,bufferOffset)){}
        #ENDIF
      #ELSE
    int i;
        #IF OfByte
    for(bufferOffset=ToStringUtil.getStringShort((arr=this.arr)[i=0],buffer,1);++i!=size;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getStringShort(arr[i],buffer,bufferOffset)){}
        #ELSE
    for(bufferOffset=ToStringUtil.getString$ClassPrefix$((arr=this.arr)[i=0],buffer,1);++i!=size;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getString$ClassPrefix$(arr[i],buffer,bufferOffset)){}
        #ENDIF
      #ENDIF
    return bufferOffset;
  }
  @Override
  void uncheckedToString(int size,ToStringUtil.OmniStringBuilder builder)
  {
    final $ArrayType$[] arr;
      #IFSWITCH STRUCTNAME==Stack
        #IF OfByte
    for(builder.uncheckedAppendShort((arr=this.arr)[--size]);size!=0;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppendShort(arr[--size])){}
        #ELSE
    for(builder.uncheckedAppend$ClassPrefix$((arr=this.arr)[--size]);size!=0;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppend$ClassPrefix$(arr[--size])){}
        #ENDIF
      #ELSE
    int i;
        #IF OfByte
    for(builder.uncheckedAppendShort((arr=this.arr)[i=0]);++i!=size;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppendShort(arr[i])){}
        #ELSE
    for(builder.uncheckedAppend$ClassPrefix$((arr=this.arr)[i=0]);++i!=size;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppend$ClassPrefix$(arr[i])){}
        #ENDIF
      #ENDIF
  }
    #ENDIF
  #ELSE
  #MACRO RemoveIfImpl($TypeNameModifier$Predicate$<? super E>$,filter)
  #MACRO RemoveIfImpl(Predicate<? super $BoxedType$>,filter::test)
  public void push($exposedType$ val)
  {
    ++this.modCount;
    super.push(val);
  }
  @Override
  public void clear()
  {
    if(this.size!=0)
    {
      ++this.modCount;
      this.size=0;
    }
  }
  #ENDIF
#ENDIF





#IFSWITCH STRUCTNAME==List,SubList

   #MACRO ItrImpl<LstItr>()




  @Override
  public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
  {
  #IFSWITCH CHECKED==Checked
    #MACRO SubListCheckModCount<subList>()
    int span;
    if((span=toIndex-fromIndex)<0|| fromIndex<0 ||  toIndex>this.size)
    {
      throw new InvalidReadIndexException("fromIndex="+fromIndex+"; toIndex="+toIndex+"; size="+this.size);
    }
  #ENDIF
  #IFSWITCH STRUCTNAME==SubList
    #IFSWITCH CHECKED==Unchecked
    return new CHECKEDSTRUCTNAME$<E>$(this,this.rootOffset+fromIndex,toIndex-fromIndex);
    #ELSE
    return new CHECKEDSTRUCTNAME$<E>$(this,this.rootOffset+fromIndex,span,modCount);
    #ENDIF
  #ELSE
    #IFSWITCH CHECKED==Unchecked
    return new CHECKEDSubList$<E>$(this,fromIndex,toIndex-fromIndex);
    #ELSE
    return new CHECKEDSubList$<E>$(this,fromIndex,span,modCount);
    #ENDIF
  #ENDIF
  }
  @Override
  public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
  {
    #MACRO SubListCheckModCount<listIterator>()
    return new LstItr$<E>$(this);
  }
  @Override
  public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index)
  {
    #MACRO SubListCheckModCount<listIterator>()
  #IFSWITCH CHECKED==Checked
    if(index<0 || size<index)
    {
      throw new InvalidWriteIndexException(index,size);
    }
  #ENDIF
  #IFSWITCH STRUCTNAME==SubList
    return new LstItr$<E>$(this,index+this.rootOffset);
  #ELSE
    return new LstItr$<E>$(this,index);
  #ENDIF
  }
  #MACRO ComparatorSortImpl<Stable>($Comparator$$<? super E>$,sorter)
  #MACRO ComparatorSortImpl<Stable>(Comparator<? super $BoxedType$>,sorter::compare)
  #IFNOT OfBoolean
  #MACRO ComparatorSortImpl<Unstable>($Comparator$$<? super E>$,sorter)
  #ENDIF
  #MACRO NonComparatorSortImpl(Ascending)
  #MACRO NonComparatorSortImpl(Descending)
  #MACRO ReplaceAllImpl($UnaryOperator$$<E>$,operator)
  #MACRO ReplaceAllImpl(UnaryOperator<$BoxedType$>,operator::apply)
  @Override
  public void add(int index,$exposedType$ val)
  {
    #MACRO SubListCheckModCount<add>()
  #IFSWITCH CHECKED==Checked
    int size;
    if((size=this.size)<index || index<0)
    {
      throw new InvalidWriteIndexException(index,size);
    }
    #IFSWITCH STRUCTNAME==SubList
    root.modCount=++modCount;
    this.modCount=modCount;
    #ELSE
    ++this.modCount;
    #ENDIF
  #ENDIF
  #IFSWITCH STRUCTNAME==SubList
    int rootSize;
    #IFSWITCH CHECKED==Checked
    if((rootSize=root.size)!=0)
    #ELSE
    final CHECKEDList$<E>$ root;
    if((rootSize=(root=this.root).size)!=0)
    #ENDIF
    {
      #MACRO BubbleUpIncrementSize()
      (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInsert(rootSize,index+this.rootOffset,val);
      ++this.size;
    }
    else
    {
      #MACRO BubbleUpInit()
      (($ClassPrefix$ArrSeq$<E>$)root).uncheckedInit(val);
      this.size=1;
    }
  #ELSE
    ((UncheckedList$<E>$)this).uncheckedAdd(index,val,size);
  #ENDIF
  }
   
  @Override
  public $exposedType$ get$TypeNameModifier$(int index)
  {
    #MACRO SubListCheckModCount<get>()
    #MACRO CheckGetPutIndex<Read>()
  #IFSWITCH STRUCTNAME==List
    return ($exposedType$)arr[index];
  #ELSE
    return ($exposedType$)root.arr[index+this.rootOffset];
  #ENDIF
  }
  @Override
  public void put(int index,$exposedType$ val)
  {
    #MACRO SubListCheckModCount<put>()
    #MACRO CheckGetPutIndex<Write>()
  #IFSWITCH STRUCTNAME==List
    arr[index]=val;
  #ELSE
    root.arr[index+this.rootOffset]=val;
  #ENDIF
  }
  @Override
  public $exposedType$ set(int index,$exposedType$ val)
  {
    #MACRO SubListCheckModCount<set>()
    #MACRO CheckGetPutIndex<Read>()
    final $ArrayType$[] arr;
  #IFSWITCH STRUCTNAME==List
    final $exposedType$ ret=($exposedType$)(arr=this.arr)[index];
  #ELSE
    final $exposedType$ ret=($exposedType$)(arr=root.arr)[index+=this.rootOffset];
  #ENDIF
    arr[index]=val;
    return ret;
  }
  @Override
  public $exposedType$ $removeAtIndexMethod$(int index)
  {
    #MACRO SubListCheckModCount<removeAtIndex>()
  #IFSWITCH CHECKED==Checked
    int size;
    if((size=this.size)<=index || index<0)
    {
      throw new InvalidWriteIndexException(index,size);
    }
  #ENDIF
  #IFSWITCH STRUCTNAME==List
    #IFSWITCH CHECKED==Checked
    ++this.modCount;
    #ENDIF
    return (($ClassPrefix$ArrSeq$<E>$)this).uncheckedremoveAtIndex(index,size);
  #ELSE
    #IFSWITCH CHECKED==Checked
    root.modCount=++modCount;
    this.modCount=modCount;
    #ENDIF
    #MACRO BubbleUpDecrementSize()
    #IFSWITCH CHECKED==Checked
    this.size=size-1;
    return (($ClassPrefix$ArrSeq$<E>$)root).uncheckedremoveAtIndex(index+this.rootOffset,root.size);
    #ELSE
    --this.size;
    final $ClassPrefix$ArrSeq$<E>$ root;
    return (root=this.root).uncheckedremoveAtIndex(index+this.rootOffset,root.size);
    #ENDIF
  #ENDIF
  }
  #IFSWITCH CHECKED==Unchecked

  //TODO implement AND and OR in the template switches to avoid writing this twice
  #MACRO QueryMethods<indexOf>()
  //TODO implement AND and OR in the template switches to avoid writing this twice
  #MACRO QueryMethods<lastIndexOf>()
  #ELSEIFSWITCH STRUCTNAME==SubList

  //TODO implement AND and OR in the template switches to avoid writing this twice
  #MACRO QueryMethods<indexOf>()
  //TODO implement AND and OR in the template switches to avoid writing this twice
  #MACRO QueryMethods<lastIndexOf>()
  #ENDIF

  
  
#ENDIF



}
#ENDDEF






#MACRODEF ComparatorSortImpl<STABLE>(COMPARATOR,ACTION)
@Override
#IFSWITCH STABLE==Stable
public void sort(COMPARATOR sorter)
#ELSE
public void unstableSort(COMPARATOR sorter)
#ENDIF
{
  int size;
  if((size=this.size)>1)
  {
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH CHECKED==Checked
    int modCount=this.modCount;
    final var root=this.root;
    try
  #ENDIF
#ENDIF
    {
      if(sorter==null)
      {
#IFSWITCH STRUCTNAME==List
        $ClassPrefix$SortUtil.uncheckedAscendingSort(this.arr,0,size);
#ELSE
        final int rootOffset;
        $ClassPrefix$SortUtil.uncheckedAscendingSort(root.arr,rootOffset=this.rootOffset,rootOffset+size);
#ENDIF
      }
      else
      {
#IFSWITCH STRUCTNAME==List
  #IFSWITCH STABLE==Stable
    #IF OfBoolean
        $ClassPrefix$SortUtil.uncheckedSort(this.arr,0,size,ACTION);
    #ELSE
        $ClassPrefix$SortUtil.uncheckedStableSort(this.arr,0,size,ACTION);
    #ENDIF  
  #ELSE
        $ClassPrefix$SortUtil.uncheckedUnstableSort(this.arr,0,size,ACTION);
  #ENDIF
#ELSE
        final int rootOffset;
  #IFSWITCH STABLE==Stable
    #IF OfBoolean
        $ClassPrefix$SortUtil.uncheckedSort(root.arr,rootOffset=this.rootOffset,rootOffset+size,ACTION);
    #ELSE
        $ClassPrefix$SortUtil.uncheckedStableSort(root.arr,rootOffset=this.rootOffset,rootOffset+size,ACTION);
    #ENDIF  
  #ELSE
        $ClassPrefix$SortUtil.uncheckedUnstableSort(root.arr,rootOffset=this.rootOffset,rootOffset+size,ACTION);
  #ENDIF
#ENDIF
      }
#IFSWITCH STRUCTNAME==List
  #IFSWITCH CHECKED==Checked
      ++this.modCount;
  #ENDIF
#ENDIF
    }
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH CHECKED==Checked
    finally
    {
      #MACRO BubbleUpIncrementModCount()
    }
  #ENDIF
#ENDIF
  }
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==SubList
  else
  {
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
  #ENDIF
#ENDIF
}
#ENDDEF



#MACRODEF BubbleUpIncrementModCount()
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==SubList
CheckedCollection.checkModCount(modCount,root.modCount);
root.modCount=++modCount;
this.modCount=modCount;
for(var curr=parent;curr!=null;curr.modCount=modCount,curr=curr.parent){}
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF NonComparatorSortImpl(DIRECTION)
@Override
public void stableDIRECTIONSort()
{
  int size;
  if((size=this.size)>1)
  {
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==SubList
    int modCount=this.modCount;
    final var root=this.root;
    try
  #ENDIF
#ENDIF
    {
#IFSWITCH STRUCTNAME==List
      $ClassPrefix$SortUtil.uncheckedDIRECTIONSort(this.arr,0,size);
  #IFSWITCH CHECKED==Checked
      ++this.modCount;
  #ENDIF
#ELSE
      final int rootOffset;
      $ClassPrefix$SortUtil.uncheckedDIRECTIONSort(root.arr,rootOffset=this.rootOffset,rootOffset+size);
#ENDIF
    }
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==SubList
    finally
    {
      #MACRO BubbleUpIncrementModCount()
    }
  #ENDIF
#ENDIF

  }
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==SubList
  else
  {
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
  #ENDIF
#ENDIF
}
#ENDDEF

#MACRODEF ReplaceAllImpl(UNARYOPERATOR,ACTION)
@Override
public void replaceAll(UNARYOPERATOR operator)
{
  int size;
  if((size=this.size)!=0)
  {
#IFSWITCH CHECKED==Checked
    int modCount=this.modCount;
  #IFSWITCH STRUCTNAME==SubList
    final var root=this.root;
  #ENDIF
    try
#ENDIF
    {
#IFSWITCH STRUCTNAME==List
      ((UncheckedList$<E>$)this).uncheckedReplaceAll(0,size,ACTION);
#ELSE
      final int rootOffset;
      ((UncheckedList$<E>$)root).uncheckedReplaceAll(rootOffset=this.rootOffset,rootOffset+size,ACTION);
#ENDIF
    }
#IFSWITCH CHECKED==Checked
    finally
    {
  #IFSWITCH STRUCTNAME==List
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount+1;
  #ELSE
      #MACRO BubbleUpIncrementModCount()
  #ENDIF
    }
#ENDIF
  }
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==SubList
  else
  {
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
  #ENDIF
#ENDIF
}
#ENDDEF

#MACRODEF ForEachImpl(CONSUMER,ACTION)

@Override
public void forEach(CONSUMER action)
{
  int size;
  if((size=this.size)!=0)
  {
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==SubList
    final var root=this.root;
  #ENDIF
    int modCount=this.modCount;
    try
#ENDIF
    {
#IFSWITCH STRUCTNAME==SubList
      int rootOffset;
      uncheckedForEachAscending(root.arr,rootOffset=this.rootOffset,rootOffset+size,ACTION);
#ELSEIFSWITCH STRUCTNAME==List
      uncheckedForEachAscending(arr,0,size,ACTION);
#ELSE
      uncheckedForEachDescending(arr,0,size,ACTION);
#ENDIF
    }
#IFSWITCH CHECKED==Checked
    finally
    {
  #IFSWITCH STRUCTNAME==SubList
      CheckedCollection.checkModCount(modCount,root.modCount);
  #ELSE
      CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
    }
#ENDIF
  }
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH CHECKED==Checked
  else
  {
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
  #ENDIF
#ENDIF
}

#ENDDEF

#MACRODEF UncheckedSearch<SUFFIX>()
private int uncheckedsearchSUFFIX(int size
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
,$queryParameterType$ val
#ENDIF
)
{
  final var arr=this.arr;
  for(int i=size-1;;--i)
  {
    #MACRO IfClause(IndexEquals,arr[i])
    {
      return size-i;
    }
    if(i==0)
    {
      return -1;
    }
  }
}
#ENDDEF

#MACRODEF UncheckedIndexOf<SUFFIX>()
private int uncheckedindexOfSUFFIX(int size
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
,$queryParameterType$ val
#ENDIF
)
{
  final var arr=this.arr;
  for(int i=0;;)
  {
    #MACRO IfClause(IndexEquals,arr[i])
    {
      return i;
    }
    if(++i==size)
    {
      return -1;
    }
  }
}
#ENDDEF

#MACRODEF UncheckedLastIndexOf<SUFFIX>()
private int uncheckedlastIndexOfSUFFIX(int size
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
,$queryParameterType$ val
#ENDIF
)
{
  final var arr=this.arr;
  for(;;)
  {
    #MACRO IfClause(IndexEquals,arr[--size])
    {
      return size;
    }
    if(size==0)
    {
      return -1;
    }
  }
}
#ENDDEF

#MACRODEF RemoveIfImpl(FILTER,ACTION)
@Override
public boolean removeIf(FILTER filter)
{
  int size;
  if((size=this.size)!=0)
  {
    int newBound;
#IFSWITCH STRUCTNAME==SubList
    final $ArrayType$[] arr;
    final CHECKEDList$<E>$ root;
    int rootOffset,rootBound,numRemoved;
  #IFSWITCH CHECKED==Checked
    int modCount;
    if((numRemoved=(rootBound=(rootOffset=this.rootOffset)+size)-(newBound=doRemoveIf(arr=(root=this.root).arr,rootOffset,rootBound,ACTION,new CheckedCollection.AbstractModCountChecker(modCount=this.modCount){
      @Override
      protected int getActualModCount(){
        return root.modCount;
      }
    })))!=0)
  #ELSE
    if((numRemoved=(rootBound=(rootOffset=this.rootOffset)+size)-(newBound=doRemoveIf(arr=(root=this.root).arr,rootOffset,rootBound,ACTION)))!=0)
  #ENDIF
    {
  #IFSWITCH CHECKED==Checked
      root.modCount=++modCount;
      this.modCount=modCount;
      for(var curr=parent;curr!=null;curr.modCount=modCount,curr.size-=numRemoved,curr=curr.parent){}
  #ELSE
      for(var curr=parent;curr!=null;curr.size-=numRemoved,curr=curr.parent){}
  #ENDIF
      int rootSize;
      ArrCopy.semicheckedSelfCopy(arr,rootBound,newBound,(rootSize=root.size)-rootBound);
      root.size=rootSize-numRemoved;
      this.size=size-numRemoved;
      return true;
    }
#ELSE
  #IFSWITCH CHECKED==Checked
    int modCount;
    if(size!=(newBound=doRemoveIf(this.arr,0,size,ACTION,new CheckedCollection.AbstractModCountChecker(modCount=this.modCount){
      @Override
      protected int getActualModCount(){
        return CHECKEDSTRUCTNAME.this.modCount;
      }
    })))
  #ELSE
    if(size!=(newBound=doRemoveIf(this.arr,0,size,ACTION)))
  #ENDIF
    {
  #IFSWITCH CHECKED==Checked
      this.modCount=modCount+1;
  #ENDIF
      this.size=newBound;
      return true;
    }
#ENDIF
  }
#IFSWITCH CHECKED==Checked
  #IFSWITCH STRUCTNAME==SubList
  else
  {
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
  #ENDIF
#ENDIF
  return false;
}
#ENDDEF

#MACRODEF UncheckedRemoveVal<SUFFIX>()
#IFSWITCH STRUCTNAME==List,Stack
@Override
boolean
#ELSEIFSWITCH STRUCTNAME==SubList
private boolean
#ELSE
ERROR unknown struct name STRUCTNAME in UncheckedRemoveVal<SUFFIX>()
#ENDIF
uncheckedremoveValSUFFIX(int size
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
,$queryParameterType$ val
#ENDIF
)
{
#IFSWITCH STRUCTNAME==SubList
  final CHECKEDList$<E>$ root;
  final var arr=(root=this.root).arr;
  #IFSWITCH CHECKED==Checked
  int modCount=this.modCount;
  try
  #ENDIF
  {
    for(int i=this.rootOffset,bound=i+size;;)
    {
      #MACRO IfClause(IndexEquals,arr[i])
      {
  #IFSWITCH CHECKED==Checked
        CheckedCollection.checkModCount(modCount,root.modCount);
        root.modCount=++modCount;
        this.modCount=modCount;
  #ENDIF
        #MACRO BubbleUpDecrementSize()
        this.size=size-1;
        ArrCopy.semicheckedSelfCopy(arr,i+1,i,(--root.size)-i);
        return true;
      }
      if(++i==bound)
      {
  #IFSWITCH CHECKED==Checked
        CheckedCollection.checkModCount(modCount,root.modCount);
  #ENDIF
        return false;
      }
    }
  }
  #IFSWITCH CHECKED==Checked
  catch(ConcurrentModificationException e)
  {
    throw e;
  }
  catch(RuntimeException e)
  {
    throw CheckedCollection.checkModCount(modCount,this.modCount,e);
  }
  #ENDIF
#ELSEIFSWITCH STRUCTNAME==Stack
  final var arr=this.arr;
  for(int i=--size;;)
  {
    #MACRO IfClause(IndexEquals,arr[i])
    {
  #IFSWITCH CHECKED==Checked
      ++this.modCount;
  #ENDIF
      ArrCopy.semicheckedSelfCopy(arr,i+1,i,size-i);
      this.size=size;
      return true;
    }
    if(i==0)
    {
      return false;
    }
  }
#ELSEIFSWITCH STRUCTNAME==List
  final var arr=this.arr;
  for(int i=0;;)
  {
    #MACRO IfClause(IndexEquals,arr[i])
    {
  #IFSWITCH CHECKED==Checked
      ++this.modCount;
  #ENDIF
      ArrCopy.semicheckedSelfCopy(arr,i+1,i,(--size)-i);
      this.size=size;
      return true;
    }
    if(++i==size)
    {
      return false;
    }
  }
#ELSE
ERROR unknown struct name STRUCTNAME in UncheckedRemoveVal<SUFFIX>()
#ENDIF
}
#ENDDEF

#MACRODEF PollImpl(RETTYPE,CLASSPREFIX,CAST,DEFAULTRET,DEFAULTARR)
@Override
public RETTYPE pollCLASSPREFIX()
{
  int size;
  if((size=this.size)!=0)
  {
    final RETTYPE ret=CAST(($exposedType$)arr[--size]);
#IFSWITCH CHECKED==Checked
    ++this.modCount;
#ENDIF
    this.size=size;
    return ret;
  }
  return DEFAULTRET;
}
#ENDDEF

#MACRODEF SubTypeToArrayImpl(RETTYPE,CLASSPREFIX,CAST,DEFAULTRET,DEFAULTARR)
#IFSWITCH STRUCTNAME==SubList
@Override
public RETTYPE[] toCLASSPREFIXArray()
{
  #MACRO SubListCheckModCount<toArray>()
  final int size;
  if((size=this.size)!=0)
  {
    final RETTYPE[] copy;
    ArrCopy.uncheckedCopy(root.arr,this.rootOffset,copy=new RETTYPE[size],0,size);
    return copy;
  }
  return DEFAULTARR;
}
#ELSE
  #IFSWITCH CHECKED==Unchecked
@Override
void uncheckedCopyInto(RETTYPE[] dst,int size)
{
  #IFSWITCH STRUCTNAME==Stack
  ArrCopy.uncheckedReverseCopy(this.arr,0,dst,0,size);
  #ELSE
  ArrCopy.uncheckedCopy(this.arr,0,dst,0,size);
  #ENDIF
}
  #ENDIF
#ENDIF
#ENDDEF



#MACRODEF ToArrayImpl(RETTYPE,CLASSPREFIX,CAST,DEFAULTRET,DEFAULTARR)
abstract void uncheckedCopyInto(RETTYPE[] dst,int size);
@Override
public RETTYPE[] toCLASSPREFIXArray()
{
  final int size;
  if((size=this.size)!=0)
  {
    final RETTYPE[] copy;
    uncheckedCopyInto(copy=new RETTYPE[size],size);
    return copy;
  }
  return DEFAULTARR;
}
#ENDDEF
#MACRODEF PeekImpl(RETTYPE,CLASSPREFIX,CAST,DEFAULTRET,DEFAULTARR)
public RETTYPE peekCLASSPREFIX()
{
  final int size;
  if((size=this.size)!=0)
  {
    return CAST(($exposedType$)arr[size-1]);
  }
  return DEFAULTRET;
}
#ENDDEF

#MACRODEF SubListIndexOf<SUFFIX>()
private int sublistindexOfSUFFIX(int rootOffset,int size
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
,$queryParameterType$ val
#ENDIF
)
{
  final var arr=this.arr;
  int i;
  for(size+=(i=rootOffset);;)
  {
    #MACRO IfClause(IndexEquals,arr[i])
    {
      return i-rootOffset;
    }
    if(++i==size)
    {
      return -1;
    }
  }
}
#ENDDEF

#MACRODEF SubListLastIndexOf<SUFFIX>()
private int sublistlastIndexOfSUFFIX(int rootOffset,int size
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
,$queryParameterType$ val
#ENDIF
)
{
  final var arr=this.arr;
  for(size+=(rootOffset-1);;--size)
  {
    #MACRO IfClause(IndexEquals,arr[size])
    {
      return size-rootOffset;
    }
    if(size==rootOffset)
    {
      return -1;
    }
  }
}
#ENDDEF

#MACRODEF SubListContains<SUFFIX>()
private boolean sublistcontainsSUFFIX(int rootOffset,int size
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
,$queryParameterType$ val
#ENDIF
)
{
  final var arr=this.arr;
  for(size+=rootOffset;;)
  {
    #MACRO IfClause(IndexEquals,arr[rootOffset])
    {
      return true;
    }
    if(++rootOffset==size)
    {
      return false;
    }
  }
}
#ENDDEF

#MACRODEF UncheckedContains<SUFFIX>()
private boolean uncheckedcontainsSUFFIX(int size
#IFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==0
#ELSEIFSWITCH SUFFIX==NaN
#ELSE
,$queryParameterType$ val
#ENDIF
)
{
  for(final var arr=this.arr;;)
  {
    #MACRO IfClause(IndexEquals,arr[--size])
    {
      return true;
    }
    if(size==0)
    {
      return false;
    }
  }
}
#ENDDEF
#MACRODEF ToStringFastImpl<SUBLIST>(MAX_ELEMENT_LENGTH,BUFFER_SIZE_EXPR)
final char[] buffer;
if(size<=(OmniArray.MAX_ARR_SIZE/((MAX_ELEMENT_LENGTH)<<1)))
{
#IFSWITCH SUBLIST==true
  final $ArrayType$[] arr;
  int bufferOffset,i;
  #IF OfByte
  for(bufferOffset=ToStringUtil.getStringShort((arr=root.arr)[i=this.rootOffset],buffer=new char[size*(MAX_ELEMENT_LENGTH)],1),size+=i;++i!=size;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getStringShort(arr[i],buffer,bufferOffset)){}
  #ELSE
  for(bufferOffset=ToStringUtil.getString$ClassPrefix$((arr=root.arr)[i=this.rootOffset],buffer=new char[size*(MAX_ELEMENT_LENGTH)],1),size+=i;++i!=size;buffer[bufferOffset]=',',buffer[++bufferOffset]=' ',bufferOffset=ToStringUtil.getString$ClassPrefix$(arr[i],buffer,bufferOffset)){}
  #ENDIF
  buffer[bufferOffset]=']';
  buffer[0]='[';
  return new String(buffer,0,bufferOffset+1);
#ELSE
  (buffer=new char[size*(MAX_ELEMENT_LENGTH)])[size=uncheckedToString(size,buffer)]=']';
  buffer[0]='[';
  return new String(buffer,0,size+1);
#ENDIF
  
}
else
{
  final ToStringUtil.OmniStringBuilder builder;
#IFSWITCH SUBLIST==true
  final $ArrayType$[] arr;
  int i;
  #IF OfByte
  for((builder=new ToStringUtil.OmniStringBuilder(1,new char[BUFFER_SIZE_EXPR])).uncheckedAppendShort((arr=root.arr)[i=this.rootOffset]),size+=i;++i!=size;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppendShort(arr[i])){}
  #ELSE
  for((builder=new ToStringUtil.OmniStringBuilder(1,new char[BUFFER_SIZE_EXPR])).uncheckedAppend$ClassPrefix$((arr=root.arr)[i=this.rootOffset]),size+=i;++i!=size;builder.uncheckedAppendCommaAndSpace(),builder.uncheckedAppend$ClassPrefix$(arr[i])){}
  #ENDIF
#ELSE
  uncheckedToString(size,builder=new ToStringUtil.OmniStringBuilder(1,new char[BUFFER_SIZE_EXPR]));
#ENDIF
  builder.uncheckedAppendChar(']');
  (buffer=builder.buffer)[0]='[';
  return new String(buffer,0,builder.size);
}
#ENDDEF

#MACRODEF GetterMethods(MACRONAME)
#MACRO MACRONAME($BoxedType$,,($BoxedType$),null,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR)
#IFNOT OfDouble
#MACRO MACRONAME(double,Double,$castToDouble$,Double.NaN,OmniArray.OfDouble.DEFAULT_ARR)
  #IFNOT OfFloat
#MACRO MACRONAME(float,Float,$castToFloat$,Float.NaN,OmniArray.OfFloat.DEFAULT_ARR)
    #IFNOT OfLong
#MACRO MACRONAME(long,Long,$castToLong$,Long.MIN_VALUE,OmniArray.OfLong.DEFAULT_ARR)
      #IFNOT OfInt
#MACRO MACRONAME(int,Int,$castToInt$,Integer.MIN_VALUE,OmniArray.OfInt.DEFAULT_ARR)
        #IFNOT OfShort,OfChar
#MACRO MACRONAME(short,Short,$castToShort$,Short.MIN_VALUE,OmniArray.OfShort.DEFAULT_ARR)
          #IFNOT OfByte
#MACRO MACRONAME(char,Char,$castToChar$,Character.MIN_VALUE,OmniArray.OfChar.DEFAULT_ARR)
#MACRO MACRONAME(byte,Byte,$castToByte$,Byte.MIN_VALUE,OmniArray.OfByte.DEFAULT_ARR)
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF IteratorNextImpl(RETTYPE,CLASSPREFIX,CAST,DEFAULTRET,DEFAULTARR)
@Override
public RETTYPE nextCLASSPREFIX()
{
  return CAST(next$ClassPrefix$());
}
#ENDDEF



#MACRODEF ReturnUncheckedQuery(VAL)
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH METHODNAME==contains
return ((UncheckedList$<E>$)root).sublistcontains(this.rootOffset,size,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedremoveVal(size,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf
return ((UncheckedList$<E>$)root).sublistindexOf(this.rootOffset,size,VAL);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return ((UncheckedList$<E>$)root).sublistlastIndexOf(this.rootOffset,size,VAL);
  #ELSE
ERROR unknown method name METHODNAME in macro ReturnUncheckedQuery(VAL)
  #ENDIF
#ELSE
  #IFSWITCH METHODNAME==contains
return uncheckedcontains(size,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedremoveVal(size,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf
return uncheckedindexOf(size,VAL);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return uncheckedlastIndexOf(size,VAL);
  #ELSEIFSWITCH METHODNAME==search
return uncheckedsearch(size,VAL);
  #ELSE
ERROR unknown method name METHODNAME in macro ReturnUncheckedQuery(VAL)
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF ReturnUncheckedQueryBits(VAL)
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH METHODNAME==contains
return ((UncheckedList$<E>$)root).sublistcontainsBits(this.rootOffset,size,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedremoveValBits(size,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf
return ((UncheckedList$<E>$)root).sublistindexOfBits(this.rootOffset,size,VAL);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return ((UncheckedList$<E>$)root).sublistlastIndexOfBits(this.rootOffset,size,VAL);
  #ELSE
ERROR unknown method name METHODNAME in macro ReturnUncheckedQueryBits(VAL)
  #ENDIF
#ELSE
  #IFSWITCH METHODNAME==contains
return uncheckedcontainsBits(size,VAL);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedremoveValBits(size,VAL);
  #ELSEIFSWITCH METHODNAME==indexOf
return uncheckedindexOfBits(size,VAL);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return uncheckedlastIndexOfBits(size,VAL);
  #ELSEIFSWITCH METHODNAME==search
return uncheckedsearchBits(size,VAL);
  #ELSE
ERROR unknown method name METHODNAME in macro ReturnUncheckedQueryBits(VAL)
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF ReturnUncheckedQuery0()
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH METHODNAME==contains
return ((UncheckedList$<E>$)root).sublistcontains0(this.rootOffset,size);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedremoveVal0(size);
  #ELSEIFSWITCH METHODNAME==indexOf
return ((UncheckedList$<E>$)root).sublistindexOf0(this.rootOffset,size);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return ((UncheckedList$<E>$)root).sublistlastIndexOf0(this.rootOffset,size);
  #ELSE
ERROR unknown method name METHODNAME in macro ReturnUncheckedQuery0()
  #ENDIF
#ELSE
  #IFSWITCH METHODNAME==contains
return uncheckedcontains0(size);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedremoveVal0(size);
  #ELSEIFSWITCH METHODNAME==indexOf
return uncheckedindexOf0(size);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return uncheckedlastIndexOf0(size);
  #ELSEIFSWITCH METHODNAME==search
return uncheckedsearch0(size);
  #ELSE
ERROR unknown method name METHODNAME in macro ReturnUncheckedQuery0()
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF ReturnUncheckedQueryNaN()
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH METHODNAME==contains
return ((UncheckedList$<E>$)root).sublistcontainsNaN(this.rootOffset,size);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedremoveValNaN(size);
  #ELSEIFSWITCH METHODNAME==indexOf
return ((UncheckedList$<E>$)root).sublistindexOfNaN(this.rootOffset,size);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return ((UncheckedList$<E>$)root).sublistlastIndexOfNaN(this.rootOffset,size);
  #ELSE
ERROR unknown method name METHODNAME in macro ReturnUncheckedQueryNaN()
  #ENDIF
#ELSE
  #IFSWITCH METHODNAME==contains
return uncheckedcontainsNaN(size);
  #ELSEIFSWITCH METHODNAME==removeVal
return uncheckedremoveValNaN(size);
  #ELSEIFSWITCH METHODNAME==indexOf
return uncheckedindexOfNaN(size);
  #ELSEIFSWITCH METHODNAME==lastIndexOf
return uncheckedlastIndexOfNaN(size);
  #ELSEIFSWITCH METHODNAME==search
return uncheckedsearchNaN(size);
  #ELSE
ERROR unknown method name METHODNAME in macro ReturnUncheckedQueryNaN()
  #ENDIF
#ENDIF
#ENDDEF


#MACRODEF ReturnNegative<INPUTTYPE>()
#IFSWITCH METHODNAME==contains,removeVal
return false;
#ELSE
return -1;
#ENDIF
#ENDDEF



#MACRODEF QueryCheckModCount()
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH CHECKED==Checked
    #IFSWITCH METHODNAME==removeVal
CheckedCollection.checkModCount(this.modCount,root.modCount);
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF QueryMethods<METHODNAME>()
#MACRO QueryBoolean()
#MACRO QueryInt()
#MACRO QueryLong()
#MACRO QueryFloat()
#MACRO QueryDouble()
#MACRO QueryObject()
  #IFSWITCH METHODNAME==contains,removeVal
    #IFNOT OfBoolean
#MACRO QueryByte()
#MACRO QueryChar()
      #IF OfChar,OfShort,OfFloat,OfDouble
#MACRO QueryShort()
      #ENDIF
    #ENDIF
  #ELSEIFSWITCH METHODNAME==indexOf,lastIndexOf,search
    #IF OfByte,OfChar,OfShort,OfFloat
#MACRO QueryChar()
      #IF OfByte
#MACRO QueryByte()
      #ELSE
#MACRO QueryShort()
      #ENDIF
    #ENDIF
  #ELSE
ERROR unknown method name METHODNAME in QueryMethods<METHODNAME>
  #ENDIF
#ENDDEF

#MACRODEF QueryBoolean()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(boolean val)
{
  #MACRO QueryDeclareModCount()
  int size;
  if((size=this.size)!=0)
  {
#IF OfDouble,OfFloat
    if(val)
    {
      #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
    }
    #MACRO ReturnUncheckedQuery0()
#ELSE
    #MACRO ReturnUncheckedQuery($queryCastBoolean$(val))
#ENDIF
  }
  #MACRO QueryCheckModCount()
  #MACRO ReturnNegative<boolean>()
}
#ENDDEF

#MACRODEF QueryByte()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(byte val)
{
  #MACRO QueryDeclareModCount()
#IF OfChar
  if(val>=0)
#ENDIF
  {
    int size;
    if((size=this.size)!=0)
    {
#IF OfDouble,OfFloat
      if(val!=0)
      {
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
      #MACRO ReturnUncheckedQuery0()
#ELSE
      #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
#ENDIF
    }
  }
  #MACRO QueryCheckModCount()
  #MACRO ReturnNegative<byte>()
}
#ENDDEF

#MACRODEF QueryChar()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(char val)
{
  #MACRO QueryDeclareModCount()
#IF OfShort,OfByte
  if(val<=$BoxedType$.MAX_VALUE)
#ENDIF
  {
    int size;
    if((size=this.size)!=0)
    {
#IF OfDouble,OfFloat
      if(val!=0)
      {
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
      #MACRO ReturnUncheckedQuery0()
#ELSE
      #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
#ENDIF
    }
  }
  #MACRO QueryCheckModCount()
  #MACRO ReturnNegative<char>()
}
#ENDDEF

#MACRODEF QueryShort()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(short val)
{
  #MACRO QueryDeclareModCount()
#IF OfChar
  if(val>=0)
#ENDIF
  {
    int size;
    if((size=this.size)!=0)
    {
#IF OfDouble,OfFloat
      if(val!=0)
      {
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
      #MACRO ReturnUncheckedQuery0()
#ELSE
      #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
#ENDIF
    }
  }
  #MACRO QueryCheckModCount()
  #MACRO ReturnNegative<short>()
}
#ENDDEF

#MACRODEF QueryInt()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(int val)
{
  #MACRO QueryDeclareModCount()
  int size;
  if((size=this.size)!=0)
  {
#IF OfLong,OfInt
    #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
#ELSEIF OfDouble,OfFloat
    if(val!=0)
    {
  #IF OfFloat
      if(TypeUtil.checkCastTo$ClassPrefix$(val))
  #ENDIF
      {
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
    }
    else
    {
      #MACRO ReturnUncheckedQuery0()
    }
#ELSEIF OfShort,OfChar,OfByte
    if(val==($exposedType$)val)
    {
      #MACRO ReturnUncheckedQuery(val)
    }
#ELSE
    final $exposedType$ v;
    switch(val)
    {
      default:
        #MACRO QueryCheckModCount()
  		  #MACRO ReturnNegative<int>()
      case 0:
        v=false;
        break;
      case 1:
        v=true;
    }
    #MACRO ReturnUncheckedQuery(v)
#ENDIF
  }
  #MACRO QueryCheckModCount()
  #MACRO ReturnNegative<int>()
}
#ENDDEF

#MACRODEF QueryLong()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(long val)
{
  #MACRO QueryDeclareModCount()
  int size;
  if((size=this.size)!=0)
  {
#IF OfLong
    #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
#ELSEIF OfDouble,OfFloat
    if(val!=0)
    {
      if(TypeUtil.checkCastTo$ClassPrefix$(val))
      {
        #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
      }
    }
    else
    {
      #MACRO ReturnUncheckedQuery0()
    }
#ELSE
    final $exposedType$ v;
  #IF OfInt,OfShort,OfChar,OfByte
    if(val==(v=($exposedType$)val))
  #ELSE
    if(val==0L)
    {
      v=false;
    }
    else if(val==1L)
    {
      v=true;
    }
    else
    {
      #MACRO QueryCheckModCount()
      #MACRO ReturnNegative<long>()
    }
  #ENDIF
    {
      #MACRO ReturnUncheckedQuery(v)
    }
#ENDIF
  }
  #MACRO QueryCheckModCount()
  #MACRO ReturnNegative<long>()
}
#ENDDEF
#MACRODEF QueryFloat()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(float val)
{
  #MACRO QueryDeclareModCount()
  int size;
  if((size=this.size)!=0)
  {
#IF OfDouble,OfFloat
    if(val==val)
    {
      #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
    }
    #MACRO ReturnUncheckedQueryNaN()
#ELSE
    final $exposedType$ v;
  #IF OfLong
    if(TypeUtil.floatEquals(val,v=(long)val))
  #ELSEIF OfInt
    if((double)val==(double)(v=($exposedType$)val))
  #ELSEIF OfShort,OfChar,OfByte
    if(val==(v=($exposedType$)val))
  #ELSE
    switch(Float.floatToRawIntBits(val))
    {
      default:
        #MACRO QueryCheckModCount()
        #MACRO ReturnNegative<float>()
      case 0:
      case Integer.MIN_VALUE:
        v=false;
        break;
      case 1:
        v=true;
    }
  #ENDIF
    {
      #MACRO ReturnUncheckedQuery(v)
    }
#ENDIF
  }
  #MACRO QueryCheckModCount()
  #MACRO ReturnNegative<float>()
}
#ENDDEF

#MACRODEF QueryDouble()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
METHODNAME(double val)
{
  #MACRO QueryDeclareModCount()
  int size;
  if((size=this.size)!=0)
  {
#IF OfDouble,OfFloat
  #IF OfDouble
    if(val==val)
    {
      #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
    }
  #ELSE
    final $exposedType$ v;
    if((v=($exposedType$)val)==val)
    {
      #MACRO ReturnUncheckedQueryBits($convertToBits$(v))
    }
    else if(v!=v)
  #ENDIF
    {
      #MACRO ReturnUncheckedQueryNaN()
    }
#ELSE
    final $exposedType$ v;
  #IF OfLong
    if(TypeUtil.doubleEquals(val,v=(long)val))
  #ELSEIF OfInt,OfShort,OfChar,OfByte
    if((v=($exposedType$)val)==val)
  #ELSE
    final long bits;
    if((bits=Double.doubleToRawLongBits(val))==0L || bits==Long.MIN_VALUE)
    {
      v=false;
    }
    else if(bits==1)
    {
      v=true;
    }
    else
    {
      #MACRO QueryCheckModCount()
      #MACRO ReturnNegative<double>()
    }
  #ENDIF
    {
      #MACRO ReturnUncheckedQuery(v)
    }
#ENDIF
  }
  #MACRO QueryCheckModCount()
  #MACRO ReturnNegative<double>()
}
#ENDDEF

#MACRODEF QueryObject()
@Override
public
#IFSWITCH METHODNAME==contains,removeVal
boolean
#ELSE
int
#ENDIF
#IFSWITCH METHODNAME==removeVal
remove
#ELSE
METHODNAME
#ENDIF
(Object val)
{
  #MACRO QueryDeclareModCount()
  int size;
  if((size=this.size)!=0)
  {
    if(val instanceof $BoxedType$)
    {
#IF OfDouble,OfFloat
      final $exposedType$ v;
      if((v=($exposedType$)val)==v)
      {
        #MACRO ReturnUncheckedQueryBits($convertToBits$(v))
      }
      #MACRO ReturnUncheckedQueryNaN()
#ELSE
      #MACRO ReturnUncheckedQuery($queryCastRef$(val))
#ENDIF
    }
  }
  #MACRO QueryCheckModCount()
  #MACRO ReturnNegative<Object>()
}
#ENDDEF

#MACRODEF CheckGetPutIndex<ACCESSTYPE>()
#IFSWITCH CHECKED==Checked
if(index<0 || index>=size)
{
  throw new InvalidACCESSTYPEIndexException(index,size);
}
#ENDIF
#ENDDEF


#MACRODEF IndexEquals(VAL)
#IFSWITCH SUFFIX==Bits
bits==$convertToBits$(VAL)
#ELSEIFSWITCH SUFFIX==0
0==VAL
#ELSEIFSWITCH SUFFIX==NaN
$BoxedType$.isNaN(VAL)
#ELSE
val==VAL
#ENDIF
#ENDDEF

#MACRODEF IfClause(INDEXTEST,VAL)
if(
#MACRO INDEXTEST(VAL)
)
#ENDDEF

#MACRODEF BubbleUpDecrementSize()
#IFSWITCH CHECKED==Checked
for(var curr=parent;curr!=null;curr.modCount=modCount,--curr.size,curr=curr.parent){}
#ELSE
for(var curr=parent;curr!=null;--curr.size,curr=curr.parent){}
#ENDIF
#ENDDEF

#MACRODEF BubbleUpIncrementSize()
#IFSWITCH CHECKED==Checked
for(var curr=parent;curr!=null;curr.modCount=modCount,++curr.size,curr=curr.parent){}
#ELSE
for(var curr=parent;curr!=null;++curr.size,curr=curr.parent){}
#ENDIF
#ENDDEF
#MACRODEF BubbleUpInit()
#IFSWITCH CHECKED==Checked
for(var curr=parent;curr!=null;curr.modCount=modCount,curr.size=1,curr=curr.parent){}
#ELSE
for(var curr=parent;curr!=null;curr.size=1,curr=curr.parent){}
#ENDIF
#ENDDEF

#MACRODEF QueryDeclareModCount()
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH CHECKED==Checked
    #IFSWITCH METHODNAME==indexOf,lastIndexOf,contains
final var root=checkModCountAndGetRoot();
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF


#MACRODEF SubListCheckModCount<METHODNAME>()
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH CHECKED==Checked
    #IFSWITCH METHODNAME==isEmpty,size,iterator,listIterator
CheckedCollection.checkModCount(this.modCount,root.modCount);
    #ELSEIFSWITCH METHODNAME==hashCode,toString,toArray,get,put,clone,set
final var root=checkModCountAndGetRoot();
    #ELSEIFSWITCH METHODNAME==clear,add,removeAtIndex
int modCount;
final CHECKEDList$<E>$ root;
CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
    #ELSEIFSWITCH METHODNAME==subList
final int modCount;
CheckedCollection.checkModCount(modCount=this.modCount,root.modCount);
    #ELSE
ERROR unknown method name METHODNAME for SubListCheckModCount<METHODNAME>()
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF

#MACRODEF ItrImpl<ITRTYPE>()
private static class ITRTYPE$<E>$
#IFSWITCH ITRTYPE==LstItr
  extends Itr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>$
#ELSEIFSWITCH ITRTYPE==Itr
  extends AbstractItr$<E>$
#ELSE
ERROR unknown itr type ITRTYPE
#ENDIF
{
#IFSWITCH ITRTYPE==Itr
  transient final CHECKEDSTRUCTNAME$<E>$ parent;
  transient int cursor;
  #IFSWITCH CHECKED==Checked
  transient int modCount;
  transient int lastRet;
  #ENDIF
#ELSE
  #IFSWITCH CHECKED==Unchecked
  transient int lastRet;
  #ENDIF
#ENDIF
  private ITRTYPE(CHECKEDSTRUCTNAME$<E>$ parent)
  {
#IFSWITCH ITRTYPE==Itr
    this.parent=parent;
  #IFSWITCH STRUCTNAME==SubList
    this.cursor=parent.rootOffset;
  #ELSEIFSWITCH STRUCTNAME==Stack
    this.cursor=parent.size;
  #ENDIF
  #IFSWITCH CHECKED==Checked
    this.modCount=parent.modCount;
    this.lastRet=-1;
  #ENDIF
#ELSE
    super(parent);
  #IFSWITCH CHECKED==Unchecked
    this.lastRet=-1;
  #ENDIF
#ENDIF
  }
#IFSWITCH STRUCTNAME==List,SubList
  private ITRTYPE(CHECKEDSTRUCTNAME$<E>$ parent,int cursor)
  {
#IFSWITCH ITRTYPE==Itr
    this.parent=parent;
    #IFSWITCH STRUCTNAME==SubList
    this.cursor=cursor+parent.rootOffset;
    #ELSE
    this.cursor=cursor;
    #ENDIF
    #IFSWITCH CHECKED==Checked
    this.modCount=parent.modCount;
    this.lastRet=-1;
    #ENDIF
#ELSE
    super(parent);
  #IFSWITCH CHECKED==Unchecked
    this.lastRet=-1;
  #ENDIF
#ENDIF
  }
#ENDIF

#IFSWITCH ITRTYPE==Itr
  #MACRO IteratorNext()
  #MACRO IteratorForEach($TypeNameModifier$Consumer$<? super E>$,action)
  #MACRO IteratorForEach(Consumer<? super $BoxedType$>,action::accept)
  @Override
  public boolean hasNext()
  {
#IFSWITCH STRUCTNAME==Stack
    return this.cursor>0;
#ELSEIFSWITCH STRUCTNAME==SubList
    final CHECKEDSTRUCTNAME$<E>$ parent;
    return this.cursor<(parent=this.parent).rootOffset+parent.size;
#ELSE
    return this.cursor<parent.size;
#ENDIF
  }
  #MACRO IteratorRemove()
#ELSE
  #IFSWITCH CHECKED==Unchecked
  #MACRO IteratorNext()
  #MACRO IteratorForEach($TypeNameModifier$Consumer$<? super E>$,action)
  #MACRO IteratorForEach(Consumer<? super $BoxedType$>,action::accept)
  #MACRO IteratorRemove()
  #ENDIF
  @Override
  public boolean hasPrevious()
  {
#IFSWITCH STRUCTNAME==SubList
    return this.cursor>parent.rootOffset;
#ELSE
    return this.cursor>0;
#ENDIF
  }
  @Override
  public int nextIndex()
  {
#IFSWITCH STRUCTNAME==SubList
    return this.cursor-parent.rootOffset;
#ELSE
    return this.cursor;
#ENDIF
  }
  @Override
  public int previousIndex()
  {
#IFSWITCH STRUCTNAME==SubList
    return this.cursor-parent.rootOffset-1;
#ELSE
    return this.cursor-1;
#ENDIF
  }
  @Override
  public $exposedType$ previous$ClassPrefix$()
  {
  #IFSWITCH CHECKED==Checked
        int cursor;
        final CHECKEDList$<E>$ root;
      #IFSWITCH STRUCTNAME==List
        CheckedCollection.checkModCount(this.modCount,(root=this.parent).modCount);
        if((cursor=this.cursor)<=0)
      #ELSE
        final CHECKEDSTRUCTNAME$<E>$ parent;
        CheckedCollection.checkModCount(this.modCount,(root=(parent=this.parent).root).modCount);
        if((cursor=this.cursor)<=parent.rootOffset)
      #ENDIF
        {
           throw new NoSuchElementException();
        }
        this.cursor=--cursor;
        this.lastRet=cursor;
        return ($exposedType$)root.arr[cursor];
  #ELSE
        final int ret;
        this.lastRet=ret=--this.cursor;
      #IFSWITCH STRUCTNAME==List
        return ($exposedType$)parent.arr[ret];
      #ELSE
        return ($exposedType$)parent.root.arr[ret];
      #ENDIF

  #ENDIF
  }
  
  @Override
  public void add($exposedType$ val)
  {
    //TODO implement LstItr.add($exposedType$)
  }
  @Override
  public void set($exposedType$ val)
  {
    //TODO implement LstItr.set($exposedType$)
  }
  
#ENDIF


}
#ENDDEF

#MACRODEF IteratorRemove()
@Override
public void remove()
{
#IFSWITCH CHECKED==Checked
  int cursor;
  if((cursor=this.lastRet)==-1)
  {
    throw new IllegalStateException();
  }
  int modCount;
  #IFSWITCH STRUCTNAME==SubList
  CHECKEDSTRUCTNAME$<E>$ parent;
  final CHECKEDList$<E>$ root;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=(parent=this.parent).root).modCount);
  root.modCount=++modCount;
  do{
    parent.modCount=modCount;
    --parent.size;
  }while((parent=parent.parent)!=null);
  #ELSE
  final CHECKEDSTRUCTNAME$<E>$ root;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.parent).modCount);
  root.modCount=++modCount;
  #ENDIF
  this.modCount=modCount;
  ArrCopy.semicheckedSelfCopy(root.arr,cursor+1,cursor,(--root.size)-cursor);
  this.cursor=cursor;
  this.lastRet=-1;
#ELSE
  #IFSWITCH ITRTYPE==LstItr
    #IFSWITCH STRUCTNAME==SubList
  CHECKEDSTRUCTNAME$<E>$ parent;
  final CHECKEDList$<E>$ root;
  int cursor;
  ArrCopy.semicheckedSelfCopy((root=(parent=this.parent).root).arr,(cursor=this.lastRet)+1,cursor,(--root.size)-cursor);
  do{
    --parent.size;
  }while((parent=parent.parent)!=null);
  this.cursor=cursor;
    #ELSE
  final CHECKEDSTRUCTNAME$<E>$ parent;
  int cursor;
  ArrCopy.semicheckedSelfCopy((parent=this.parent).arr,(cursor=this.lastRet)+1,cursor,(--parent.size)-cursor);
  this.cursor=cursor;
    #ENDIF
  this.lastRet=-1;
  #ELSE
    #IFSWITCH STRUCTNAME==SubList
  CHECKEDSTRUCTNAME$<E>$ parent;
  final CHECKEDList$<E>$ root;
  int cursor;
  ArrCopy.semicheckedSelfCopy((root=(parent=this.parent).root).arr,cursor=this.cursor,--cursor,(--root.size)-cursor);
  do{
    --parent.size;
  }while((parent=parent.parent)!=null);
  this.cursor=cursor;
    #ELSE
  final CHECKEDSTRUCTNAME$<E>$ parent;
  int cursor;
      #IFSWITCH STRUCTNAME==Stack
  ArrCopy.semicheckedSelfCopy((parent=this.parent).arr,(cursor=this.cursor)+1,cursor,(--parent.size)-cursor);
      #ELSE
  ArrCopy.semicheckedSelfCopy((parent=this.parent).arr,cursor=this.cursor,--cursor,(--parent.size)-cursor);
  this.cursor=cursor;
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
}
#ENDDEF
#MACRODEF IteratorForEach(CONSUMER,ACTION)
@Override
public void forEachRemaining(CONSUMER action)
{
  int cursor;
#IFSWITCH STRUCTNAME==Stack
  if((cursor=this.cursor)>0)
  {
  #IFSWITCH CHECKED==Checked
    final CHECKEDSTRUCTNAME$<E>$ root=this.parent;
  #ENDIF
#ELSE
  int bound;
  #IFSWITCH STRUCTNAME==List
  final CHECKEDSTRUCTNAME$<E>$ root;
  
  if((cursor=this.cursor)<(bound=(root=this.parent).size))
  {
  #ELSE
  
  
  final CHECKEDSTRUCTNAME$<E>$ parent;
  if((cursor=this.cursor)<(bound=(parent=this.parent).rootOffset+parent.size))
  {
#IFSWITCH CHECKED==Checked
    final CHECKEDList$<E>$ root=parent.root;
#ENDIF
  #ENDIF
#ENDIF
#IFSWITCH CHECKED==Checked
    int modCount=this.modCount;
    try
#ENDIF
    {
#IFSWITCH STRUCTNAME==Stack
      #IFSWITCH CHECKED==Checked
      uncheckedForEachDescending(root.arr,0,cursor,ACTION);
      #ELSE
      uncheckedForEachDescending(this.parent.arr,0,cursor,ACTION);
      #ENDIF
#ELSEIFSWITCH STRUCTNAME==SubList
      #IFSWITCH CHECKED==Checked
      uncheckedForEachAscending(root.arr,cursor,bound,ACTION);
      #ELSE
      uncheckedForEachAscending(parent.root.arr,cursor,bound,ACTION);
      #ENDIF
#ELSE
      uncheckedForEachAscending(root.arr,cursor,bound,ACTION);
#ENDIF
    }
#IFSWITCH CHECKED==Checked
    finally
    {
      CheckedCollection.checkModCount(modCount,root.modCount);
    }
    #IFSWITCH STRUCTNAME==Stack
    this.lastRet=0;
    #ELSE
    this.lastRet=bound-1;
    #ENDIF
#ELSE
  #IFSWITCH ITRTYPE==LstItr
    this.lastRet=bound-1;
  #ENDIF
#ENDIF
#IFSWITCH STRUCTNAME==Stack
    this.cursor=0;
#ELSE
    this.cursor=bound;
#ENDIF
  }
}
#ENDDEF
#MACRODEF IteratorNext()
@Override
public $exposedType$ next$ClassPrefix$()
{
#IFSWITCH CHECKED==Checked
      final int cursor;
  #IFSWITCH STRUCTNAME==Stack
      final CHECKEDSTRUCTNAME$<E>$ root;
      CheckedCollection.checkModCount(this.modCount,(root=this.parent).modCount);
      if((cursor=this.cursor)<0)
      {
        throw new NoSuchElementException();
      }
      this.cursor=cursor-1;
  #ELSE
      final CHECKEDList$<E>$ root;
    #IFSWITCH STRUCTNAME==List
      CheckedCollection.checkModCount(this.modCount,(root=this.parent).modCount);
      if((cursor=this.cursor)>=root.size)
    #ELSE
      final CHECKEDSTRUCTNAME$<E>$ parent;
      CheckedCollection.checkModCount(this.modCount,(root=(parent=this.parent).root).modCount);
      if((cursor=this.cursor)>=parent.rootOffset+parent.size)
    #ENDIF
      {
         throw new NoSuchElementException();
      }
      this.cursor=cursor+1;
  #ENDIF
      this.lastRet=cursor;
      return ($exposedType$)root.arr[cursor];
#ELSE
  #IFSWITCH ITRTYPE==LstItr
      final int ret;
      this.lastRet=ret=this.cursor++;
    #IFSWITCH STRUCTNAME==List
      return ($exposedType$)parent.arr[ret];
    #ELSE
      return ($exposedType$)parent.root.arr[ret];
    #ENDIF
  #ELSE
    #IFSWITCH STRUCTNAME==Stack
      return ($exposedType$)parent.arr[this.cursor--];
    #ELSEIFSWITCH STRUCTNAME==List
      return ($exposedType$)parent.arr[this.cursor++];
    #ELSE
      return ($exposedType$)parent.root.arr[this.cursor++];
    #ENDIF
  #ENDIF
#ENDIF
}
#ENDDEF

