#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfComparable
package omni.impl;
import java.util.function.IntFunction;
import java.io.Serializable;
import omni.api.OmniSortedSet;
import omni.util.ArrCopy;
import omni.api.OmniIterator;
import omni.util.OmniArray;
#IF OfChar,OfShort,OfFloat
import omni.function.$TypeNameModifier$Predicate;
import omni.function.$TypeNameModifier$Consumer;
#ENDIF
#IF OfDouble,OfLong,OfInt
import java.util.function.$TypeNameModifier$Predicate;
import java.util.function.$TypeNameModifier$Consumer;
#ENDIF
import java.util.function.Predicate;
import java.util.function.Consumer;
#IF OfChar,OfFloat,OfDouble,OfComparable
import omni.util.OmniArray;
#ENDIF
#IF OfComparable
import java.util.Collections;
import java.util.Comparator;
#ELSE
import omni.function.$TypeNameModifier$Comparator;
#ENDIF
#IF OfChar,OfShort,OfInt,OfLong,OfFloat,OfDouble
import omni.util.TypeUtil;
#ENDIF
#IF OfLong,OfDouble,OfComparable
import java.util.function.$TypeNameModifier$ToIntFunction;
#ENDIF
#IF OfFloat
import omni.function.$TypeNameModifier$ToIntFunction;
#ENDIF
#IF OfShort,OfInt,OfChar
import java.util.function.IntUnaryOperator;
#ENDIF
#IF OfComparable
public abstract class $ClassPrefix$NavigableSetImpl<E extends Comparable<E>>
  extends $ClassPrefix$UntetheredArrSeq$<E>$ implements OmniSortedSet.OfRef$<E>$
#ELSE
public abstract class $ClassPrefix$NavigableSetImpl
  extends $ClassPrefix$UntetheredArrSeq$<E>$ implements OmniSortedSet.Of$ClassPrefix$$<E>$
#ENDIF
  
{
  $ClassPrefix$NavigableSetImpl(int head,$ArrayType$[] arr,int tail){
    super(head,arr,tail);
  }
  $ClassPrefix$NavigableSetImpl(){
    super();
  }
  

#IF OfComparable
  private static <E extends Comparable<E>> int privateCompare($exposedType$ key1,$exposedType$ key2){
#ELSEIF OfChar,OfShort
  private static int privateCompare(int key1,int key2){
#ELSE
  private static int privateCompare($exposedType$ key1,$exposedType$ key2){
#ENDIF
#IF OfShort,OfChar
    return Integer.signum(key1-key2);
#ELSE
  #IF OfComparable
    if(key2!=null){
      return Integer.signum(-key2.compareTo(key1));
    }
  #ELSE
    if(key1==key2){
      return 0;
    }
    if(key1>key2){
      return 1;
    }
  #ENDIF
    return -1;
#ENDIF
  }
#IF OfChar
  private boolean uncheckedAdd0(int tail){
    $ArrayType$[] arr;
    int head;
    if((arr=this.arr)[head=this.head]!=0){
      int newHead;
      switch(Integer.signum(tail-(newHead=head-1))){
        case 0:
          //fragmented must grow
          final $ArrayType$[] tmp;
          int arrLength;
          ArrCopy.uncheckedCopy(arr,0,tmp=$NewArray$[tail=OmniArray.growBy50Pct(arrLength=arr.length)],0,head);
          ArrCopy.uncheckedCopy(arr,head,tmp,newHead=tail-(arrLength-=head),arrLength);
          this.arr=tmp;
          this.head=newHead-1;
          return true;
        default:
          //nonfragmented
          if(newHead==-1 && tail==(newHead=arr.length-1)){
            //must grow
            this.tail=(newHead=OmniArray.growBy50Pct(++tail))-1;
            ArrCopy.uncheckedCopy(arr,0,arr=$NewArray$[newHead],newHead-=(tail),tail);
            this.arr=arr;
            this.head=newHead-1;
            return true;
          }
        case -1:
          //fragmented
      }
      arr[newHead]=0;
      this.head=newHead;
      return true;
    }
    return false;
  }
#ENDIF
#IF OfFloat,OfDouble
  private static int comparePos0($exposedType$ key){
    if(key<0){
      return 1;
    }
  #IF OfFloat
    switch(Float.floatToRawIntBits(key)){
      case 0:
        return 0;
      case Integer.MIN_VALUE:
        return 1;
      default:
    }
  #ELSE
    final long bits;
    if((bits=Double.doubleToRawLongBits(key))==0){
      return 0;
    }else if(bits==Long.MIN_VALUE){
      return 1;
    }
  #ENDIF
    return -1;
  }
  private static int compareNeg0($exposedType$ key){
    if(key<0){
      return 1;
    }
  #IF OfFloat
    if(Float.floatToRawIntBits(key)==Integer.MIN_VALUE){
  #ELSE
    if(Double.doubleToRawLongBits(key)==Long.MIN_VALUE){
  #ENDIF
      return 0;
    }
    return -1;
  }
  private boolean uncheckedAddNegInf(int tail){
    final $ArrayType$[] arr;
    final int head;
    if((arr=this.arr)[head=this.head]!=$BoxedType$.NEGATIVE_INFINITY){
      super.insertAtHead(arr,$BoxedType$.NEGATIVE_INFINITY,head,tail);
      return true;
    }
    return false;
  }
#ENDIF
#IF OfInt,OfShort,OfChar
  private static IntUnaryOperator getSearchFunction(int key){
#ELSEIF OfComparable
  private static <E extends Comparable<E>> ToIntFunction<E> getSearchFunction(E key){
#ELSE
  private static $BoxedType$ToIntFunction getSearchFunction($exposedType$ key){
#ENDIF
    return (k)->privateCompare(k,key);
  }
#IF OfDouble,OfFloat,OfComparable
  #IF OfComparable
  @SuppressWarnings("unchecked")
  #ENDIF
  private boolean uncheckedAddUndefined(int tail){
    $ArrayType$[] arr;
  #IF OfComparable
    if((arr=this.arr)[tail]!=null){
  #ELSE
    if(!$BoxedType$.isNaN((arr=this.arr)[tail])){
  #ENDIF
      int head;
      switch(Integer.signum((++tail)-(head=this.head))){
        case 0:
          //fragmented must grow
          final $ArrayType$[] tmp;
          int arrLength;
          ArrCopy.uncheckedCopy(arr,0,tmp=$NewArray$[head=OmniArray.growBy50Pct(arrLength=arr.length)],0,tail);
          ArrCopy.uncheckedCopy(arr,tail,tmp,head-=(arrLength-=tail),arrLength);
          this.head=head;
  #IF OfComparable
          this.arr=tmp;
  #ELSE
          this.arr=arr=tmp;
  #ENDIF
          break;
        default:
          //nonfragmented
          if(tail==arr.length){
            if(head==0){
              //must grow
              ArrCopy.uncheckedCopy(arr,0,arr=$NewArray$[OmniArray.growBy50Pct(tail)],0,tail);
              this.arr=arr;
            }else{
              tail=0;
            }
          }
        case -1:
          //fragmented
      }
  #IF OfDouble,OfFloat
      arr[tail]=$BoxedType$.NaN;
  #ENDIF
      this.tail=tail;
      return true;
    }
    return false;
  }
#ENDIF
  @Override public boolean add($exposedType$ key){
    int tail;
    if((tail=this.tail)!=-1){
#IF OfComparable,OfDouble,OfFloat,OfChar
  #IF OfComparable
      if(key!=null){
  #ELSEIF OfFloat,OfDouble
      if(key==key){
  #ELSE
      if(key!=0){
  #ENDIF
  #IF OfFloat
        final FloatToIntFunction compareFunc;
        switch(Float.floatToRawIntBits(key)){
          default:
            return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
          case 0xff800000:
            return this.uncheckedAddNegInf(tail);
          case 0:
            compareFunc=$ClassPrefix$NavigableSetImpl::comparePos0;
            break;
          case Integer.MIN_VALUE:
            compareFunc=$ClassPrefix$NavigableSetImpl::compareNeg0;
        }
        return super.uncheckedAdd(tail,key,compareFunc);
  #ELSEIF OfDouble
        final DoubleToIntFunction compareFunc;
        final long bits;
        if((bits=Double.doubleToRawLongBits(key))==0){
          compareFunc=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else if(bits==Long.MIN_VALUE){
          compareFunc=$ClassPrefix$NavigableSetImpl::compareNeg0;
        }else{
          return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
        }
        return super.uncheckedAdd(tail,key,compareFunc);
  #ELSE
        return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
  #ENDIF
      }
  #IF OfChar
      return uncheckedAdd0(tail);
  #ELSE
      return uncheckedAddUndefined(tail);
  #ENDIF
#ELSE
      return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
#ENDIF
    }else{
      super.insertAtMiddle(key);
      return true;
    }
  }
#IFNOT OfComparable
  @Override public boolean add($BoxedType$ key){
    return add(($exposedType$)key);
  }
  @Override public boolean add(boolean key){
    final int tail;
    if((tail=this.tail)!=-1){
  #IF OfChar,OfDouble,OfFloat
      if(key){
        return super.uncheckedAdd(tail,($exposedType$)1,$ClassPrefix$NavigableSetImpl::privateCompare);
      }
    #IF OfChar
      return uncheckedAdd0(tail);
    #ELSE
      return super.uncheckedAdd(tail,($exposedType$)0,$ClassPrefix$NavigableSetImpl::comparePos0);
    #ENDIF
  #ELSE
      return super.uncheckedAdd(tail,$queryCastBoolean$(key),$ClassPrefix$NavigableSetImpl::privateCompare);
  #ENDIF
    }else{
      super.insertAtMiddle($queryCastBoolean$(key));
      return true;
    }
  }
#ENDIF
#IF OfInt,OfLong,OfShort
  @Override public boolean add(byte key){
    final int tail;
    if((tail=this.tail)!=-1){
      return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
    }else{
      super.insertAtMiddle(key);
      return true;
    }
  }
#ENDIF
#IF OfFloat,OfInt,OfLong
  @Override public boolean add(char key){
    final int tail;
    if((tail=this.tail)!=-1){
  #IF OfFloat
      if(key==0){
        return super.uncheckedAdd(tail,0,$ClassPrefix$NavigableSetImpl::comparePos0);
      }
  #ENDIF
      return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
    }else{
      super.insertAtMiddle(key);
      return true;
    }
  }
#ENDIF
#IF OfFloat
  @Override public boolean add(short key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==0){
        return super.uncheckedAdd(tail,0,$ClassPrefix$NavigableSetImpl::comparePos0);
      }
      return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
    }else{
      super.insertAtMiddle(key);
      return true;
    }
  }
#ENDIF
#IF OfDouble,OfFloat,OfLong
  @Override public boolean add(int key){
    final int tail;
    if((tail=this.tail)!=-1){
  #IFNOT OfLong
      if(key==0){
        return super.uncheckedAdd(tail,0,$ClassPrefix$NavigableSetImpl::comparePos0);
      }
  #ENDIF
      return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
    }else{
      super.insertAtMiddle(key);
      return true;
    }
  }
#ENDIF
#IF OfDouble,OfFloat
  @Override public boolean add(long key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==0){
        return super.uncheckedAdd(tail,0,$ClassPrefix$NavigableSetImpl::comparePos0);
      }
      return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
    }else{
      super.insertAtMiddle(key);
      return true;
    }
  }
#ENDIF
#IF OfDouble
  @Override public boolean add(float key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==key){
        final DoubleToIntFunction compareFunc;
        switch(Float.floatToRawIntBits(key)){
          default:
            return super.uncheckedAdd(tail,key,$ClassPrefix$NavigableSetImpl::privateCompare);
          case 0xff800000:
            return this.uncheckedAddNegInf(tail);
          case 0:
            compareFunc=$ClassPrefix$NavigableSetImpl::comparePos0;
            break;
          case Integer.MIN_VALUE:
            compareFunc=$ClassPrefix$NavigableSetImpl::compareNeg0;
        }
        return super.uncheckedAdd(tail,key,compareFunc);
      }
      return uncheckedAddUndefined(tail);
    }else{
      super.insertAtMiddle(key);
      return true;
    }
  }
#ENDIF

#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean contains(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
#IF OfDouble
      final $BoxedType$ToIntFunction searchFunction;
      if(key instanceof Double){
        final double k;
        if((k=(double)key)==k){
          final long bits;
          if((bits=Double.doubleToRawLongBits(k))==0){
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }else if(bits==Long.MIN_VALUE){
            searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
          }else{
            searchFunction=getSearchFunction(k);
          }
        }else{
          return $BoxedType$.isNaN(arr[tail]);
        }
      }else if(key instanceof Integer || key instanceof Byte || key instanceof Short){
        final int k;
        if((k=((Number)key).intValue())==0){
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else{
          searchFunction=getSearchFunction(k);
        }
      }else if(key instanceof Long){
        final long k;
        if(!TypeUtil.checkCastToDouble(k=(long)key)){
          return false;
        }
        if(k==0){
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else{
          searchFunction=getSearchFunction(k);
        }
      }else if(key instanceof Float){
        final float k;
        if((k=(float)key)==k){
          switch(Float.floatToRawIntBits(k)){
            case 0xff800000:
              return arr[head]==$BoxedType$.NEGATIVE_INFINITY;
            case 0:
              searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
              break;
            case Integer.MIN_VALUE:
              searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
              break;
            default:
              searchFunction=getSearchFunction(k);
          }
        }else{
          return $BoxedType$.isNaN(arr[tail]);
        }
      }else if(key instanceof Character){
        final char k;
        if((k=(char)key)==0){
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else{
          searchFunction=getSearchFunction(k);
        }
      }else if(key instanceof Boolean){
        if((boolean)key){
          searchFunction=getSearchFunction(1);
        }else{
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }
      }else{
        return false;
      }
      return super.uncheckedContainsMatch(head,tail,searchFunction);
#ELSEIF OfFloat
      final $BoxedType$ToIntFunction searchFunction;
      if(key instanceof Float){
        final float k;
        if((k=(float)key)==k){
          switch(Float.floatToRawIntBits(k)){
            case 0xff800000:
              return arr[head]==$BoxedType$.NEGATIVE_INFINITY;
            case 0:
              searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
              break;
            case Integer.MIN_VALUE:
              searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
              break;
            default:
              searchFunction=getSearchFunction(k);
          }
        }else{
          return $BoxedType$.isNaN(arr[tail]);
        }
      }else if(key instanceof Integer){
        final int k;
        if(!TypeUtil.checkCastToFloat(k=(int)key)){
          return false;
        }
        if(k==0){
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else{
          searchFunction=getSearchFunction(k);
        }
      }else if(key instanceof Long){
        final long k;
        if(!TypeUtil.checkCastToFloat(k=(long)key)){
          return false;
        }
        if(k==0){
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else{
          searchFunction=getSearchFunction(k);
        }
      }else if(key instanceof Double){
        final double d;
        final float k;
        if((d=(double)key)==(k=(float)d)){
          switch(Float.floatToRawIntBits(k)){
            case 0xff800000:
              return arr[head]==$BoxedType$.NEGATIVE_INFINITY;
            case 0:
              searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
              break;
            case Integer.MIN_VALUE:
              searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
              break;
            default:
              searchFunction=getSearchFunction(k);
          }
        }else{
          return k!=k && $BoxedType$.isNaN(arr[tail]);
        }
      }else if(key instanceof Byte || key instanceof Short){
        final short k;
        if((k=((Number)key).shortValue())==0){
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else{
          searchFunction=getSearchFunction(k);
        }
      }else if(key instanceof Character){
        final char k;
        if((k=(char)key)==0){
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else{
          searchFunction=getSearchFunction(k);
        }
      }else if(key instanceof Boolean){
        if((boolean)key){
          searchFunction=getSearchFunction(1);
        }else{
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }
      }else{
        return false;
      }
      return super.uncheckedContainsMatch(head,tail,searchFunction);
#ELSEIF OfLong
      final long l;
      if(key instanceof Long || key instanceof Integer || key instanceof Byte || key instanceof Short){
        l=((Number)key).longValue();
      }else if(key instanceof Float){
        final float k;
        if(!TypeUtil.floatEquals(k=(float)key,l=(long)k)){
          return false;
        }
      }else if(key instanceof Double){
        final double k;
        if(!TypeUtil.doubleEquals(k=(double)key,l=(long)k)){
          return false;
        }
      }else if(key instanceof Character){
        l=(char)key;
      }else if(key instanceof Boolean){
        l=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedContainsMatch(head,tail,getSearchFunction(l));
#ELSEIF OfInt
      final int i;
      if(key instanceof Integer || key instanceof Byte || key instanceof Short){
        i=((Number)key).intValue();
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(i=(int)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((double)(f=(float)key)!=(double)(i=(int)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(i=(int)d)){
          return false;
        }
      }else if(key instanceof Character){
        i=(char)key;
      }else if(key instanceof Boolean){
        i=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedContainsMatch(head,tail,getSearchFunction(i));
#ELSEIF OfShort
      final int i;
      if(key instanceof Short || key instanceof Byte){
        i=((Number)key).shortValue();
      }else if(key instanceof Integer){
        if((i=(int)key)!=(short)i){
          return false;
        }
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(i=(short)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(i=(short)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(i=(short)d)){
          return false;
        }
      }else if(key instanceof Character){
        if((i=(char)key)>$BoxedType$.MAX_VALUE){
          return false;
        }
      }else if(key instanceof Boolean){
        i=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedContainsMatch(head,tail,getSearchFunction(i));
#ELSEIF OfChar
      final int i;
      if(key instanceof Character){
        i=(char)key;
      }else if(key instanceof Integer || key instanceof Byte || key instanceof Short){
        if((i=((Number)key).intValue())!=(char)i){
          return false;
        }
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(i=(char)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(i=(char)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(i=(char)d)){
          return false;
        }
      }else if(key instanceof Boolean){
        i=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedContainsMatch(head,tail,getSearchFunction(i));
#ELSE
      if(key instanceof Comparable){
        return super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)key));
      }else if(key==null){
        return arr[tail]==null;
      }
#ENDIF
    }
    return false;
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean remove(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
#IF OfDouble
      jumpToRemoveTail:for(;;){
        final $BoxedType$ToIntFunction searchFunction;
        if(key instanceof Double){
          final double k;
          if((k=(double)key)==k){
            final long bits;
            if((bits=Double.doubleToRawLongBits(k))==0){
              searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
            }else if(bits==Long.MIN_VALUE){
              searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
            }else{
              searchFunction=getSearchFunction(k);
            }
          }else{
            break jumpToRemoveTail;
          }
        }else if(key instanceof Integer || key instanceof Byte || key instanceof Short){
          final int k;
          if((k=((Number)key).intValue())==0){
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }else{
            searchFunction=getSearchFunction(k);
          }
        }else if(key instanceof Long){
          final long k;
          if(!TypeUtil.checkCastToDouble(k=(long)key)){
            return false;
          }
          if(k==0){
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }else{
            searchFunction=getSearchFunction(k);
          }
        }else if(key instanceof Float){
          final float k;
          if((k=(float)key)==k){
            switch(Float.floatToRawIntBits(k)){
              case 0xff800000:
                return arr[head]==$BoxedType$.NEGATIVE_INFINITY;
              case 0:
                searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
                break;
              case Integer.MIN_VALUE:
                searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
                break;
              default:
                searchFunction=getSearchFunction(k);
            }
          }else{
            break jumpToRemoveTail;
          }
        }else if(key instanceof Character){
          final char k;
          if((k=(char)key)==0){
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }else{
            searchFunction=getSearchFunction(k);
          }
        }else if(key instanceof Boolean){
          if((boolean)key){
            searchFunction=getSearchFunction(1);
          }else{
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }
        }else{
          return false;
        }
        return super.uncheckedRemoveMatch(tail,searchFunction);
      }
      final $ArrayType$[] arr;
      if($BoxedType$.isNaN((arr=this.arr)[tail])){
        switch(Integer.signum(tail-head)){
          case 0:
            this.tail=-1;
            break;
          case -1:
            if(tail==0){
              this.tail=arr.length-1;
              break;
            }
          default:
            this.tail=tail-1;
        }
        return true;
      }
      return false;
#ELSEIF OfFloat
      jumpToRemoveTail:for(;;){
        final $BoxedType$ToIntFunction searchFunction;
        if(key instanceof Float){
          final float k;
          if((k=(float)key)==k){
            switch(Float.floatToRawIntBits(k)){
              case 0xff800000:
                return arr[head]==$BoxedType$.NEGATIVE_INFINITY;
              case 0:
                searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
                break;
              case Integer.MIN_VALUE:
                searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
                break;
              default:
                searchFunction=getSearchFunction(k);
            }
          }else{
            break jumpToRemoveTail;
          }
        }else if(key instanceof Integer){
          final int k;
          if(!TypeUtil.checkCastToFloat(k=(int)key)){
            return false;
          }
          if(k==0){
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }else{
            searchFunction=getSearchFunction(k);
          }
        }else if(key instanceof Long){
          final long k;
          if(!TypeUtil.checkCastToFloat(k=(long)key)){
            return false;
          }
          if(k==0){
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }else{
            searchFunction=getSearchFunction(k);
          }
        }else if(key instanceof Double){
          final double d;
          final float k;
          if((d=(double)key)==(k=(float)d)){
            switch(Float.floatToRawIntBits(k)){
              case 0xff800000:
                return arr[head]==$BoxedType$.NEGATIVE_INFINITY;
              case 0:
                searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
                break;
              case Integer.MIN_VALUE:
                searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
                break;
              default:
                searchFunction=getSearchFunction(k);
            }
          }else if(k!=k){
            break jumpToRemoveTail;
          }else{
            return false;
          }
        }else if(key instanceof Byte || key instanceof Short){
          final short k;
          if((k=((Number)key).shortValue())==0){
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }else{
            searchFunction=getSearchFunction(k);
          }
        }else if(key instanceof Character){
          final char k;
          if((k=(char)key)==0){
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }else{
            searchFunction=getSearchFunction(k);
          }
        }else if(key instanceof Boolean){
          if((boolean)key){
            searchFunction=getSearchFunction(1);
          }else{
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
          }
        }else{
          return false;
        }
        return super.uncheckedRemoveMatch(tail,searchFunction);
      }
      final $ArrayType$[] arr;
      if($BoxedType$.isNaN((arr=this.arr)[tail])){
        switch(Integer.signum(tail-head)){
          case 0:
            this.tail=-1;
            break;
          case -1:
            if(tail==0){
              this.tail=arr.length-1;
              break;
            }
          default:
            this.tail=tail-1;
        }
        return true;
      }
      return false;
#ELSEIF OfLong
      final long l;
      if(key instanceof Long || key instanceof Integer || key instanceof Byte || key instanceof Short){
        l=((Number)key).longValue();
      }else if(key instanceof Float){
        final float k;
        if(!TypeUtil.floatEquals(k=(float)key,l=(long)k)){
          return false;
        }
      }else if(key instanceof Double){
        final double k;
        if(!TypeUtil.doubleEquals(k=(double)key,l=(long)k)){
          return false;
        }
      }else if(key instanceof Character){
        l=(char)key;
      }else if(key instanceof Boolean){
        l=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedRemoveMatch(tail,getSearchFunction(l));
#ELSEIF OfInt
      final int i;
      if(key instanceof Integer || key instanceof Byte || key instanceof Short){
        i=((Number)key).intValue();
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(i=(int)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((double)(f=(float)key)!=(double)(i=(int)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(i=(int)d)){
          return false;
        }
      }else if(key instanceof Character){
        i=(char)key;
      }else if(key instanceof Boolean){
        i=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedRemoveMatch(tail,getSearchFunction(i));
#ELSEIF OfShort
      final int i;
      if(key instanceof Short || key instanceof Byte){
        i=((Number)key).shortValue();
      }else if(key instanceof Integer){
        if((i=(int)key)!=(short)i){
          return false;
        }
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(i=(short)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(i=(short)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(i=(short)d)){
          return false;
        }
      }else if(key instanceof Character){
        if((i=(char)key)>$BoxedType$.MAX_VALUE){
          return false;
        }
      }else if(key instanceof Boolean){
        i=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedRemoveMatch(tail,getSearchFunction(i));
#ELSEIF OfChar
      final int i;
      if(key instanceof Character){
        i=(char)key;
      }else if(key instanceof Integer || key instanceof Byte || key instanceof Short){
        if((i=((Number)key).intValue())!=(char)i){
          return false;
        }
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(i=(char)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(i=(char)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(i=(char)d)){
          return false;
        }
      }else if(key instanceof Boolean){
        i=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedRemoveMatch(tail,getSearchFunction(i));
#ELSE
      if(key instanceof Comparable){
        return super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)key));
      }else if(key==null){
        return uncheckedRemoveNull(tail);
      }
#ENDIF
    }
    return false;
  }
#IF OfComparable
  private boolean uncheckedRemoveNull(int tail){
    final $ArrayType$[] arr;
    if(((arr=this.arr)[tail])==null){
      switch(Integer.signum(tail-head)){
        case 0:
          this.tail=-1;
          break;
        case -1:
          if(tail==0){
            this.tail=arr.length-1;
            break;
          }
        default:
          this.tail=tail-1;
      }
      return true;
    }
    return false;
  }
  #MACRO ContainsAndRemoveBoxed(Boolean)
  #MACRO ContainsAndRemoveBoxed(Byte)
  #MACRO ContainsAndRemoveBoxed(Character)
  #MACRO ContainsAndRemoveBoxed(Short)
  #MACRO ContainsAndRemoveBoxed(Integer)
  #MACRO ContainsAndRemoveBoxed(Long)
  #MACRO ContainsAndRemoveBoxed(Float)
  #MACRO ContainsAndRemoveBoxed(Double)
#MACRODEF ContainsAndRemoveBoxed(PARAMTYPE)
#IF OfComparable
@SuppressWarnings("unchecked")
#ENDIF
@Override public boolean removeVal(PARAMTYPE key){
  final int tail;
  if((tail=this.tail)!=-1){
    if(key!=null){
      return super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)key));
    }
    return uncheckedRemoveNull(tail);
  }
  return false;
}
#IF OfComparable
@SuppressWarnings("unchecked")
#ENDIF
@Override public boolean contains(PARAMTYPE key){
  final int tail;
  if((tail=this.tail)!=-1){
    if(key!=null){
      return super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)key));
    }
    return arr[tail]==null;
  }
  return false;
}
#ENDDEF
#ENDIF
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean contains(boolean key){
#IF OfChar,OfShort,OfInt,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction($queryCastBoolean$(key)));
#ELSEIF OfFloat,OfDouble
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,key?getSearchFunction(1):$ClassPrefix$NavigableSetImpl::comparePos0);
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)(Boolean)key));
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean removeVal(boolean key){
#IF OfChar,OfShort,OfInt,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction($queryCastBoolean$(key)));
#ELSEIF OfFloat,OfDouble
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,key?getSearchFunction(1):$ClassPrefix$NavigableSetImpl::comparePos0);
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)(Boolean)key));
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
#IFNOT OfDouble,OfFloat
  @Override public boolean contains(byte key){
  #IF OfChar
    final int tail;
    return key>=0 && (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(key));
  #ELSEIF OfShort,OfInt,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(key));
  #ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)(Byte)key));
  #ENDIF
  }
  #IF OfComparable
  @SuppressWarnings("unchecked")
  #ENDIF
  @Override public boolean removeVal(byte key){
  #IF OfChar
    final int tail;
    return key>=0 && (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(key));
  #ELSEIF OfShort,OfInt,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(key));
  #ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)(Byte)key));
  #ENDIF
  }
#ENDIF
#IFNOT OfDouble
  #IF OfComparable
  @SuppressWarnings("unchecked")
  #ENDIF
  @Override public boolean contains(char key){
  #IF OfChar,OfInt,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(key));
  #ELSEIF OfShort
    final int tail;
    return key<=$BoxedType$.MAX_VALUE && (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(key));
  #ELSEIF OfFloat
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,key!=0?getSearchFunction(key):$ClassPrefix$NavigableSetImpl::comparePos0);
  #ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)(Character)key));
  #ENDIF
  }
  #IF OfComparable
  @SuppressWarnings("unchecked")
  #ENDIF
  @Override public boolean removeVal(char key){
  #IF OfChar,OfInt,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(key));
  #ELSEIF OfShort
    final int tail;
    return key<=$BoxedType$.MAX_VALUE && (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(key));
  #ELSEIF OfFloat
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,key!=0?getSearchFunction(key):$ClassPrefix$NavigableSetImpl::comparePos0);
  #ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)(Character)key));
  #ENDIF
  }
#ENDIF
#IFNOT OfDouble,OfInt
  #IF OfComparable
  @SuppressWarnings("unchecked")
  #ENDIF
  @Override public boolean contains(short key){
  #IF OfChar
    final int tail;
    return key>=0 && (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(key));
  #ELSEIF OfShort,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(key));
  #ELSEIF OfFloat
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,key!=0?getSearchFunction(key):$ClassPrefix$NavigableSetImpl::comparePos0);
  #ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)(Short)key));
  #ENDIF
  }
  #IF OfComparable
  @SuppressWarnings("unchecked")
  #ENDIF
  @Override public boolean removeVal(short key){
  #IF OfChar
    final int tail;
    return key>=0 && (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(key));
  #ELSEIF OfShort,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(key));
  #ELSEIF OfFloat
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,key!=0?getSearchFunction(key):$ClassPrefix$NavigableSetImpl::comparePos0);
  #ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)(Short)key));
  #ENDIF
  }
#ENDIF
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean contains(int key){
#IF OfChar,OfShort
    final int tail;
    return key==($exposedType$)key && (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(key));
#ELSEIF OfInt,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(key));
#ELSEIF OfFloat
    final int tail;
    return (tail=this.tail)!=-1 && TypeUtil.checkCastToFloat(key) && super.uncheckedContainsMatch(head,tail,key==0?$ClassPrefix$NavigableSetImpl::comparePos0:getSearchFunction(key));
#ELSEIF OfDouble
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,key==0?$ClassPrefix$NavigableSetImpl::comparePos0:getSearchFunction(key));
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)(Integer)key));
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean removeVal(int key){
#IF OfChar,OfShort
    final int tail;
    return key==($exposedType$)key && (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(key));
#ELSEIF OfInt,OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(key));
#ELSEIF OfFloat
    final int tail;
    return (tail=this.tail)!=-1 && TypeUtil.checkCastToFloat(key) && super.uncheckedRemoveMatch(tail,key==0?$ClassPrefix$NavigableSetImpl::comparePos0:getSearchFunction(key));
#ELSEIF OfDouble
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,key==0?$ClassPrefix$NavigableSetImpl::comparePos0:getSearchFunction(key));
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)(Integer)key));
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean contains(long key){
#IF OfChar,OfShort,OfInt
    final int tail;
    final int i;
    return (tail=this.tail)!=-1 && key==(i=($exposedType$)key) && super.uncheckedContainsMatch(head,tail,getSearchFunction(i));
#ELSEIF OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(key));
#ELSEIF OfFloat,OfDouble
    final int tail;
    return (tail=this.tail)!=-1 && TypeUtil.checkCastTo$BoxedType$(key) && super.uncheckedContainsMatch(head,tail,key==0?$ClassPrefix$NavigableSetImpl::comparePos0:getSearchFunction(key));
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)(Long)key));
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean removeVal(long key){
#IF OfChar,OfShort,OfInt
    final int tail;
    final int i;
    return (tail=this.tail)!=-1 && key==(i=($exposedType$)key) && super.uncheckedRemoveMatch(tail,getSearchFunction(i));
#ELSEIF OfLong
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(key));
#ELSEIF OfFloat,OfDouble
    final int tail;
    return (tail=this.tail)!=-1 && TypeUtil.checkCastTo$BoxedType$(key) && super.uncheckedRemoveMatch(tail,key==0?$ClassPrefix$NavigableSetImpl::comparePos0:getSearchFunction(key));
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)(Long)key));
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean contains(float key){
#IF OfChar,OfShort
    final int tail;
    final int i;
    return (tail=this.tail)!=-1 && key==(i=($exposedType$)key) && super.uncheckedContainsMatch(head,tail,getSearchFunction(i));
#ELSEIF OfInt
    final int tail;
    final int i;
    return (tail=this.tail)!=-1 && (double)key==(double)(i=(int)key) && super.uncheckedContainsMatch(head,tail,getSearchFunction(i));
#ELSEIF OfLong
    final int tail;
    final long l;
    return (tail=this.tail)!=-1 && TypeUtil.floatEquals(key,l=(long)key) && super.uncheckedContainsMatch(head,tail,getSearchFunction(l));
#ELSEIF OfFloat,OfDouble
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==key){
        final $BoxedType$ToIntFunction searchFunction;
        switch(Float.floatToRawIntBits(key)){
          case 0xff800000:
            return arr[head]==$BoxedType$.NEGATIVE_INFINITY;
          case 0:
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
            break;
          case Integer.MIN_VALUE:
            searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
            break;
          default:
            searchFunction=getSearchFunction(key);
        }
        return super.uncheckedContainsMatch(head,tail,searchFunction);
      }
      return $BoxedType$.isNaN(arr[tail]);
    }
    return false;
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)(Float)key));
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean removeVal(float key){
#IF OfChar,OfShort
    final int tail;
    final int i;
    return (tail=this.tail)!=-1 && key==(i=($exposedType$)key) && super.uncheckedRemoveMatch(tail,getSearchFunction(i));
#ELSEIF OfInt
    final int tail;
    final int i;
    return (tail=this.tail)!=-1 && (double)key==(double)(i=(int)key) && super.uncheckedRemoveMatch(tail,getSearchFunction(i));
#ELSEIF OfLong
    final int tail;
    final long l;
    return (tail=this.tail)!=-1 && TypeUtil.floatEquals(key,l=(long)key) && super.uncheckedRemoveMatch(tail,getSearchFunction(l));
#ELSEIF OfFloat,OfDouble
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==key){
        final $BoxedType$ToIntFunction searchFunction;
        switch(Float.floatToRawIntBits(key)){
          case 0:
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
            break;
          case Integer.MIN_VALUE:
            searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
            break;
          default:
            searchFunction=getSearchFunction(key);
        }
        return super.uncheckedRemoveMatch(tail,searchFunction);
      }
      final $ArrayType$[] arr;
      if($BoxedType$.isNaN((arr=this.arr)[tail])){
        switch(Integer.signum(tail-head)){
          case 0:
            this.tail=-1;
            break;
          case -1:
            if(tail==0){
              this.tail=arr.length-1;
              break;
            }
          default:
            this.tail=tail-1;
        }
        return true;
      }
    }
    return false;
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)(Float)key));
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean contains(double key){
#IF OfChar,OfShort,OfInt
    final int tail;
    final int i;
    return (tail=this.tail)!=-1 && key==(i=($exposedType$)key) && super.uncheckedContainsMatch(head,tail,getSearchFunction(i));
#ELSEIF OfLong
    final int tail;
    final long l;
    return (tail=this.tail)!=-1 && TypeUtil.doubleEquals(key,l=(long)key) && super.uncheckedContainsMatch(head,tail,getSearchFunction(l));
#ELSEIF OfFloat
    final int tail;
    if((tail=this.tail)!=-1){
      final float f;
      if((f=(float)key)==key){
        final $BoxedType$ToIntFunction searchFunction;
        switch(Float.floatToRawIntBits(f)){
          case 0xff800000:
            return arr[head]==$BoxedType$.NEGATIVE_INFINITY;
          case 0:
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
            break;
          case Integer.MIN_VALUE:
            searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
            break;
          default:
            searchFunction=getSearchFunction(f);
        }
        return super.uncheckedContainsMatch(head,tail,searchFunction);
      }
      return f!=f && $BoxedType$.isNaN(arr[tail]);
    }
    return false;
#ELSEIF OfDouble
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==key){
        final $BoxedType$ToIntFunction searchFunction;
        final long bits;
        if((bits=Double.doubleToRawLongBits(key))==0){
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else if(bits==Long.MIN_VALUE){
          searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
        }else{
          searchFunction=getSearchFunction(key);
        }
        return super.uncheckedContainsMatch(head,tail,searchFunction);
      }
      return $BoxedType$.isNaN(arr[tail]);
    }
    return false;
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(head,tail,getSearchFunction(($exposedType$)(Double)key));
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public boolean removeVal(double key){
#IF OfChar,OfShort,OfInt
    final int tail;
    final int i;
    return (tail=this.tail)!=-1 && key==(i=($exposedType$)key) && super.uncheckedRemoveMatch(tail,getSearchFunction(i));
#ELSEIF OfLong
    final int tail;
    final long l;
    return (tail=this.tail)!=-1 && TypeUtil.doubleEquals(key,l=(long)key) && super.uncheckedRemoveMatch(tail,getSearchFunction(l));
#ELSEIF OfFloat
    final int tail;
    if((tail=this.tail)!=-1){
      final float f;
      if((f=(float)key)==key){
        final $BoxedType$ToIntFunction searchFunction;
        switch(Float.floatToRawIntBits(f)){
          case 0:
            searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
            break;
          case Integer.MIN_VALUE:
            searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
            break;
          default:
            searchFunction=getSearchFunction(f);
        }
        return super.uncheckedRemoveMatch(tail,searchFunction);
      }
      else if(f!=f){
        final $ArrayType$[] arr;
        if($BoxedType$.isNaN((arr=this.arr)[tail])){
          switch(Integer.signum(tail-head)){
            case 0:
              this.tail=-1;
              break;
            case -1:
              if(tail==0){
                this.tail=arr.length-1;
                break;
              }
            default:
              this.tail=tail-1;
          }
          return true;
        }
      }
    }
    return false;
#ELSEIF OfDouble
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==key){
        final $BoxedType$ToIntFunction searchFunction;
        final long bits;
        if((bits=Double.doubleToRawLongBits(key))==0){
          searchFunction=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else if(bits==Long.MIN_VALUE){
          searchFunction=$ClassPrefix$NavigableSetImpl::compareNeg0;
        }else{
          searchFunction=getSearchFunction(key);
        }
        return super.uncheckedRemoveMatch(tail,searchFunction);
      }
      final $ArrayType$[] arr;
      if($BoxedType$.isNaN((arr=this.arr)[tail])){
        switch(Integer.signum(tail-head)){
          case 0:
            this.tail=-1;
            break;
          case -1:
            if(tail==0){
              this.tail=arr.length-1;
              break;
            }
          default:
            this.tail=tail-1;
        }
        return true;
      }
    }
    return false;
#ELSE
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getSearchFunction(($exposedType$)(Double)key));
#ENDIF
  }

#IF OfComparable
  private static class AscendingFullView<E extends Comparable<E>> extends $ClassPrefix$UntetheredArrSeq.AbstractFullView$<E>$ implements OmniSortedSet.OfRef$<E>$,Cloneable,Serializable
#ELSE
  private static class AscendingFullView extends $ClassPrefix$UntetheredArrSeq.AbstractFullView$<E>$ implements OmniSortedSet.Of$ClassPrefix$$<E>$,Cloneable,Serializable
#ENDIF
  {
    #MACRO AscendingDescendingFullViewBody<Ascending>()
  }
#IF OfComparable
  private static class DescendingFullView<E extends Comparable<E>> extends $ClassPrefix$UntetheredArrSeq.AbstractFullView$<E>$ implements OmniSortedSet.OfRef$<E>$,Cloneable,Serializable
#ELSE
  private static class DescendingFullView extends $ClassPrefix$UntetheredArrSeq.AbstractFullView$<E>$ implements OmniSortedSet.Of$ClassPrefix$$<E>$,Cloneable,Serializable
#ENDIF
  {
    #MACRO AscendingDescendingFullViewBody<Descending>()
  }

#IF OfComparable
  public static class Ascending<E extends Comparable<E>> extends $ClassPrefix$NavigableSetImpl$<E>$ implements Cloneable
#ELSE
  public static class Ascending$<E>$ extends $ClassPrefix$NavigableSetImpl$<E>$ implements Cloneable
#ENDIF
  {
    #MACRO AscendingDescendingRootBody<Ascending>()

  }
#IF OfComparable
  public static class Descending<E extends Comparable<E>> extends $ClassPrefix$NavigableSetImpl$<E>$ implements Cloneable
#ELSE
  public static class Descending$<E>$ extends $ClassPrefix$NavigableSetImpl$<E>$ implements Cloneable
#ENDIF
  {
    #MACRO AscendingDescendingRootBody<Descending>()

  }
  

  
}
#MACRODEF AscendingDescendingFullViewBody<DIRECTION>()
DIRECTIONFullView($ClassPrefix$UntetheredArrSeq$<E>$ root){
  super(root);
}

@Override public <T> T[] toArray(T[] arr){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
@Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
@Override public $TypeNameModifier$Comparator$<E>$ comparator(){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniSortedSet.OfRef$<E>$ headSet($exposedType$ toElement){
#ELSE
@Override public OmniSortedSet.Of$ClassPrefix$$<E>$ headSet($exposedType$ toElement){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniSortedSet.OfRef$<E>$ tailSet($exposedType$ fromElement){
#ELSE
@Override public OmniSortedSet.Of$ClassPrefix$$<E>$ tailSet($exposedType$ fromElement){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniSortedSet.OfRef$<E>$ subSet($exposedType$ fromElement, $exposedType$ toElement){
#ELSE
@Override public OmniSortedSet.Of$ClassPrefix$$<E>$ subSet($exposedType$ fromElement, $exposedType$ toElement){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IFNOT OfComparable
@Override public OmniSortedSet.Of$ClassPrefix$$<E>$ headSet($BoxedType$ toElement){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
@Override public OmniSortedSet.Of$ClassPrefix$$<E>$ tailSet($BoxedType$ fromElement){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
@Override public OmniSortedSet.Of$ClassPrefix$$<E>$ subSet($BoxedType$ fromElement,$BoxedType$ toElement){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#ENDIF
#IF OfComparable
@SuppressWarnings("unchecked")
#ENDIF
@Override public $exposedType$ first$TypeNameModifier$(){
  final $ClassPrefix$UntetheredArrSeq$<E>$ root;
#IFSWITCH DIRECTION==Ascending
  return($exposedType$)(root=this.root).arr[root.head];
#ELSE
  return($exposedType$)(root=this.root).arr[root.tail];
#ENDIF
}
#IF OfComparable
@SuppressWarnings("unchecked")
#ENDIF
@Override public $exposedType$ last$TypeNameModifier$(){
  final $ClassPrefix$UntetheredArrSeq$<E>$ root;
#IFSWITCH DIRECTION==Ascending
  return($exposedType$)(root=this.root).arr[root.tail];
#ELSE
  return($exposedType$)(root=this.root).arr[root.head];
#ENDIF
}
@Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
  final $ClassPrefix$UntetheredArrSeq$<E>$ root;
  int tail;
  if((tail=(root=this.root).tail)!=-1){
#IFSWITCH DIRECTION==Ascending
    root.ascendingForEach(root.head,tail,action);
#ELSE
    root.descendingForEach(root.head,tail,action);
#ENDIF
  }
}
#IFNOT OfComparable
@Override public void forEach(Consumer<? super $BoxedType$> action){
  final $ClassPrefix$UntetheredArrSeq$<E>$ root;
  int tail;
  if((tail=(root=this.root).tail)!=-1){
#IFSWITCH DIRECTION==Ascending
    root.ascendingForEach(root.head,tail,action::accept);
#ELSE
    root.descendingForEach(root.head,tail,action::accept);
#ENDIF
  }
}
#ENDIF
#IF OfComparable
@Override public OmniIterator.OfRef<E> iterator(){
#ELSE
@Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
#MACRO ToArray<root,$ArrayType$>($TypeNameModifier$,($ArrayType$[])OmniArray.OfRef.DEFAULT_COMPARABLE_ARR)
#ELSE
#MACRO ToArray<root,$ArrayType$>($TypeNameModifier$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
#ENDIF
#IF OfChar,OfShort,OfInt,OfLong,OfFloat,OfDouble
#MACRO ToArray<root,$BoxedType$>(,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR)
#ENDIF
#IF OfChar,OfShort,OfInt,OfLong,OfFloat
#MACRO ToArray<root,double>(Double,OmniArray.OfDouble.DEFAULT_ARR)
#ENDIF
#IF OfChar,OfShort,OfInt,OfLong
#MACRO ToArray<root,float>(Float,OmniArray.OfFloat.DEFAULT_ARR)
#ENDIF
#IF OfChar,OfShort,OfInt
#MACRO ToArray<root,long>(Long,OmniArray.OfLong.DEFAULT_ARR)
#ENDIF
#IF OfChar,OfShort
#MACRO ToArray<root,int>(Int,OmniArray.OfInt.DEFAULT_ARR)
#ENDIF
#ENDDEF
#MACRODEF AscendingDescendingRootBody<DIRECTION>()
public DIRECTION(){
  super();
}
public DIRECTION(int head,$ArrayType$[] arr,int tail){
  super(head,arr,tail);
}
@Override public $TypeNameModifier$Comparator$<E>$ comparator(){
#IFSWITCH DIRECTION==Ascending
  #IF OfComparable
  return Comparator.nullsLast(Comparable::compareTo);
  #ELSE
  return $BoxedType$::compare;
  #ENDIF
#ELSE
  #IF OfComparable
  return Comparator.nullsFirst(Collections.reverseOrder());
  #ELSE
  return $TypeNameModifier$Comparator::descendingCompare;
  #ENDIF
#ENDIF
}
#IF OfComparable
@SuppressWarnings("unchecked")
#ENDIF
@Override public $exposedType$ first$TypeNameModifier$(){
#IFSWITCH DIRECTION==Ascending
  return ($exposedType$)arr[head];
#ELSE
  return ($exposedType$)arr[tail];
#ENDIF
}
#IF OfComparable
@SuppressWarnings("unchecked")
#ENDIF
@Override public $exposedType$ last$TypeNameModifier$(){
#IFSWITCH DIRECTION==Ascending
  return ($exposedType$)arr[tail];
#ELSE
  return ($exposedType$)arr[head];
#ENDIF
}

#IF OfComparable
@Override public OmniSortedSet.OfRef<E> headSet($exposedType$ toElement){
#ELSE
@Override public OmniSortedSet.Of$ClassPrefix$ headSet($exposedType$ toElement){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}

#IFNOT OfComparable
@Override public OmniSortedSet.Of$ClassPrefix$ headSet($BoxedType$ toElement){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#ENDIF

#IF OfComparable
@Override public OmniSortedSet.OfRef<E> tailSet($exposedType$ fromElement){
#ELSE
@Override public OmniSortedSet.Of$ClassPrefix$ tailSet($exposedType$ fromElement){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}

#IFNOT OfComparable
@Override public OmniSortedSet.Of$ClassPrefix$ tailSet($BoxedType$ fromElement){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#ENDIF

#IF OfComparable
@Override public OmniSortedSet.OfRef<E> subSet($exposedType$ fromElement,$exposedType$ toElement){
#ELSE
@Override public OmniSortedSet.Of$ClassPrefix$ subSet($exposedType$ fromElement,$exposedType$ toElement){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}

#IFNOT OfComparable
@Override public OmniSortedSet.Of$ClassPrefix$ subSet($BoxedType$ fromElement,$BoxedType$ toElement){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#ENDIF

#IF OfComparable
@SuppressWarnings("unchecked")
#ENDIF
@Override public Object clone(){
  int tail;
  if((tail=this.tail)!=-1){
    final $ArrayType$[] dst;
    final int head,cloneTail;
    int size;
    if((size=(++tail)-(head=this.head))>0){
      ArrCopy.uncheckedCopy(arr,head,dst=$NewArray$[size],0,size);
      cloneTail=size-1;
    }else{
      final $ArrayType$[] arr;
      dst=$NewArray$[size+=(arr=this.arr).length];
      cloneTail=size-1;
      ArrCopy.uncheckedCopy(arr,0,dst,size-=tail,tail);
      ArrCopy.uncheckedCopy(arr,head,dst,0,size);
    }
    return new DIRECTION$<E>$(0,dst,cloneTail);
  }
  return new DIRECTION$<E>$();
}
#IFSWITCH DIRECTION==Descending
  #IF OfComparable
  #MACRO ToArray<this,$ArrayType$>($TypeNameModifier$,($ArrayType$[])OmniArray.OfRef.DEFAULT_COMPARABLE_ARR)
  #ELSE
  #MACRO ToArray<this,$ArrayType$>($TypeNameModifier$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR)
  #ENDIF
  #IF OfChar,OfShort,OfInt,OfLong,OfFloat,OfDouble
  #MACRO ToArray<this,$BoxedType$>(,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR)
  #ENDIF
  #IF OfChar,OfShort,OfInt,OfLong,OfFloat
  #MACRO ToArray<this,double>(Double,OmniArray.OfDouble.DEFAULT_ARR)
  #ENDIF
  #IF OfChar,OfShort,OfInt,OfLong
  #MACRO ToArray<this,float>(Float,OmniArray.OfFloat.DEFAULT_ARR)
  #ENDIF
  #IF OfChar,OfShort,OfInt
  #MACRO ToArray<this,long>(Long,OmniArray.OfLong.DEFAULT_ARR)
  #ENDIF
  #IF OfChar,OfShort
  #MACRO ToArray<this,int>(Int,OmniArray.OfInt.DEFAULT_ARR)
  #ENDIF
  #IF OfComparable
  #MACRO DescendingAccessMethods($exposedType$,$exposedType$,ceiling,floor,)
  #ELSE
  #MACRO DescendingAccessMethods($BoxedType$,$exposedType$,ceiling,floor,)
  #MACRO DescendingAccessMethods($exposedType$,$exposedType$,$exposedType$Ceiling,$exposedType$Floor,$TypeNameModifier$)
    #IFNOT OfDouble
  #MACRO DescendingAccessMethods(double,double,doubleCeiling,doubleFloor,Double) 
      #IFNOT OfFloat
  #MACRO DescendingAccessMethods(float,float,floatCeiling,floatFloor,Float) 
        #IFNOT OfLong
  #MACRO DescendingAccessMethods(long,long,longCeiling,longFloor,Long) 
          #IFNOT OfInt
  #MACRO DescendingAccessMethods(int,int,intCeiling,intFloor,Int) 
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF ToArray<SOURCE,DSTARR>(TYPENAMEMODIFIER,DEFAULTARR)
#IFSWITCH SOURCE==this
  #IFSWITCH DIRECTION==Descending
    #IF OfComparable
@SuppressWarnings("unchecked")
    #ENDIF
@Override public DSTARR[] toTYPENAMEMODIFIERArray(){
  
}
  #ENDIF
#ELSE

#ENDIF

#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
@Override public DSTARR[] toTYPENAMEMODIFIERArray(){
  int tail;
#IFSWITCH SOURCE==this
  if((tail=this.tail)!=-1){
#ELSE
  final $ClassPrefix$UntetheredArrSeq$<E>$ root;
  if((tail=(root=this.root).tail)!=-1){
#ENDIF
    DSTARR[] dst;
    final int head;
    int size;
    if((size=(++tail)-(head=SOURCE.head))>0){
#IFSWITCH DIRECTION==Ascending
  #IF OfComparable
      ArrCopy.uncheckedCopy(SOURCE.arr,head,dst=new Comparable[size],0,size);
  #ELSE
      ArrCopy.uncheckedCopy(SOURCE.arr,head,dst=new DSTARR[size],0,size);
  #ENDIF
#ELSE
  #IF OfComparable
      ArrCopy.uncheckedReverseCopy(SOURCE.arr,head,dst=new Comparable[size],0,size);
  #ELSE
      ArrCopy.uncheckedReverseCopy(SOURCE.arr,head,dst=new DSTARR[size],0,size);
  #ENDIF
#ENDIF
    }else{
      final $ArrayType$[] arr;
#IFSWITCH DIRECTION==Ascending
  #IF OfComparable
      ArrCopy.uncheckedCopy(arr=SOURCE.arr,head,dst=new Comparable[size+=arr.length],0,size-=tail);
  #ELSE
      ArrCopy.uncheckedCopy(arr=SOURCE.arr,head,dst=new DSTARR[size+=arr.length],0,size-=tail);
  #ENDIF
      ArrCopy.uncheckedCopy(arr,0,dst,size,tail);
#ELSE
  #IF OfComparable
      ArrCopy.uncheckedReverseCopy(arr=SOURCE.arr,head,dst=new Comparable[size+=arr.length],tail,size-tail);
  #ELSE
      ArrCopy.uncheckedReverseCopy(arr=SOURCE.arr,head,dst=new DSTARR[size+=arr.length],tail,size-tail);
  #ENDIF
      ArrCopy.uncheckedReverseCopy(arr,0,dst,0,tail);
#ENDIF

    }
    return dst;
  }
  return DEFAULTARR;
}
#ENDDEF
#MACRODEF AscendingAccessMethods()
#IF OfComparable
  @SuppressWarnings("unchecked")
  private static <E extends Comparable<E>> E nonfragmentedCeilingImpl($ArrayType$[] arr,int head,int tail, E val){
#ELSEIF OfDouble,OfFloat
  private static $exposedType$ nonfragmentedCeilingImpl($ArrayType$[] arr,int head,int tail,$BoxedType$ToIntFunction searchFunc){
#ELSEIF OfLong
  private static $exposedType$ nonfragmentedCeilingImpl($ArrayType$[] arr,int head,int tail,long val){
#ELSE
  private static $exposedType$ nonfragmentedCeilingImpl($ArrayType$[] arr,int head,int tail,int val){
#ENDIF
    for(;;){
      final int mid;
      final $ArrayType$ tmp;
#IF OfComparable
      switch(Integer.signum((tmp=arr[mid=(head+tail)>>>1]).compareTo(val))){
#ELSEIF OfDouble,OfFloat
      switch(searchFunc.applyAsInt(tmp=arr[mid=(head+tail)>>>1])){
#ELSE
      switch(privateCompare(val,tmp=arr[mid=(head+tail)>>>1])){
#ENDIF
        case 1:
          if((tail=mid-1)>=head){
            continue;
          }
        case 0:
          return ($exposedType$)tmp;
        default:
          if((head=mid+1)>tail){
            return ($exposedType$)arr[head];
          }
      }
    }
  }
  
#IF OfComparable
  @SuppressWarnings("unchecked")
  private static <E extends Comparable<E>> E nonfragmentedFloorImpl($ArrayType$[] arr,int head,int tail, E val){
#ELSEIF OfDouble,OfFloat
  private static $exposedType$ nonfragmentedFloorImpl($ArrayType$[] arr,int head,int tail,$BoxedType$ToIntFunction searchFunc){
#ELSEIF OfLong
  private static $exposedType$ nonfragmentedFloorImpl($ArrayType$[] arr,int head,int tail,long val){
#ELSE
  private static $exposedType$ nonfragmentedFloorImpl($ArrayType$[] arr,int head,int tail,int val){
#ENDIF
    for(;;){
      final int mid;
      final $ArrayType$ tmp;
#IF OfComparable
      switch(Integer.signum((tmp=arr[mid=(head+tail)>>>1]).compareTo(val))){
#ELSEIF OfDouble,OfFloat
      switch(searchFunc.applyAsInt(tmp=arr[mid=(head+tail)>>>1])){
#ELSE
      switch(privateCompare(val,tmp=arr[mid=(head+tail)>>>1])){
#ENDIF
        case -1:
          if((head=mid+1)<=tail){
            continue;
          }
        case 0:
          return ($exposedType$)tmp;
        default:
          if((tail=mid-1)<head){
            return ($exposedType$)arr[tail];
          }
      }
    }
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
  private static <E extends Comparable<E>> E nonfragmentedHigherImpl($ArrayType$[] arr,int head,int tail, E val){
#ELSEIF OfDouble,OfFloat
  private static $exposedType$ nonfragmentedHigherImpl($ArrayType$[] arr,int head,int tail,$BoxedType$ToIntFunction searchFunc){
#ELSEIF OfLong
  private static $exposedType$ nonfragmentedHigherImpl($ArrayType$[] arr,int head,int tail,long val){
#ELSE
  private static $exposedType$ nonfragmentedHigherImpl($ArrayType$[] arr,int head,int tail,int val){
#ENDIF
    for(;;){
      final int mid;
      final $ArrayType$ tmp;
#IF OfComparable
      switch(Integer.signum((tmp=arr[mid=(head+tail)>>>1]).compareTo(val))){
#ELSEIF OfDouble,OfFloat
      switch(searchFunc.applyAsInt(tmp=arr[mid=(head+tail)>>>1])){
#ELSE
      switch(privateCompare(val,tmp=arr[mid=(head+tail)>>>1])){
#ENDIF
        case 1:
          if((tail=mid-1)>=head){
            continue;
          }
          return ($exposedType$)tmp;
        case 0:
          return ($exposedType$)arr[mid+1];
        default:
          if((head=mid+1)>tail){
            return ($exposedType$)arr[head];
          }
      }
    }
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
  private static <E extends Comparable<E>> E nonfragmentedHigherImpl($ArrayType$[] arr,int head,int tail, E val){
#ELSEIF OfDouble,OfFloat
  private static $exposedType$ nonfragmentedHigherImpl($ArrayType$[] arr,int head,int tail,$BoxedType$ToIntFunction searchFunc){
#ELSEIF OfLong
  private static $exposedType$ nonfragmentedHigherImpl($ArrayType$[] arr,int head,int tail,long val){
#ELSE
  private static $exposedType$ nonfragmentedHigherImpl($ArrayType$[] arr,int head,int tail,int val){
#ENDIF
    for(;;){
      final int mid;
      final $ArrayType$ tmp;
#IF OfComparable
      switch(Integer.signum((tmp=arr[mid=(head+tail)>>>1]).compareTo(val))){
#ELSEIF OfDouble,OfFloat
      switch(searchFunc.applyAsInt(tmp=arr[mid=(head+tail)>>>1])){
#ELSE
      switch(privateCompare(val,tmp=arr[mid=(head+tail)>>>1])){
#ENDIF
        case -1:
          if((head=mid+1)<=tail){
            continue;
          }
          return ($exposedType$)tmp;
        case 0:
          return ($exposedType$)arr[mid-1];
        default:
          if((tail=mid-1)<head){
            return ($exposedType$)arr[tail];
          }
      }
    }
  }
  
#IF OfComparable
  @SuppressWarnings("unchecked")
  private static <E extends Comparable<E>> E fragmentedCeilingImpl($ArrayType$[] arr,int head,int tail, E val){
#ELSEIF OfDouble,OfFloat
  private static $exposedType$ fragmentedCeilingImpl($ArrayType$[] arr,int head,int tail,$BoxedType$ToIntFunction searchFunc){
#ELSEIF OfLong
  private static $exposedType$ fragmentedCeilingImpl($ArrayType$[] arr,int head,int tail,long val){
#ELSE
  private static $exposedType$ fragmentedCeilingImpl($ArrayType$[] arr,int head,int tail,int val){
#ENDIF
    final $ArrayType$ tmp;
    final int mid;
#IF OfComparable
    switch((tmp=arr[mid=arr.length-1]).compareTo(val)){
#ELSEIF OfDouble,OfFloat
    switch(searchFunc.applyAsInt(tmp=arr[mid=arr.length-1])){
#ELSE
    switch(privateCompare(val,tmp=arr[mid=arr.length-1])){
#ENDIF
      case 1:
        if((tail=mid-1)>=head){
          break;
        }
      case 0:
        return ($exposedType$)tmp;
      default:
        if((head=0)>tail){
          return ($exposedType$)arr[0];
        }
    }
#IF OfDouble,OfFloat
    return nonfragmentedCeilingImpl(arr,head,tail,searchFunc);
#ELSE
    return nonfragmentedCeilingImpl(arr,head,tail,val);
#ENDIF
  }

#IF OfComparable
  @SuppressWarnings("unchecked")
  private static <E extends Comparable<E>> E fragmentedFloorImpl($ArrayType$[] arr,int head,int tail, val){
#ELSEIF OfDouble,OfFloat
  private static $exposedType$ fragmentedFloorImpl($ArrayType$[] arr,int head,int tail,$BoxedType$ToIntFunction searchFunc){
#ELSEIF OfLong
  private static $exposedType$ fragmentedFloorImpl($ArrayType$[] arr,int head,int tail,long val){
#ELSE
  private static $exposedType$ fragmentedFloorImpl($ArrayType$[] arr,int head,int tail,int val){
#ENDIF
    final $ArrayType$ tmp;
    final int mid;
#IF OfComparable
    switch((tmp=arr[mid=arr.length-1]).compareTo(val)){
#ELSEIF OfDouble,OfFloat
    switch(searchFunc.applyAsInt(tmp=arr[mid=arr.length-1])){
#ELSE
    switch(privateCompare(val,tmp=arr[mid=arr.length-1])){
#ENDIF
      case -1:
        if((head=0)<=tail){
          break;
        }
      case 0:
        return ($exposedType$)tmp;
      default:
        if((tail=mid-1)<head){
          return ($exposedType$)arr[tail];
        }
    }
#IF OfDouble,OfFloat
    return nonfragmentedFloorImpl(arr,head,tail,searchFunc);
#ELSE
    return nonfragmentedFloorImpl(arr,head,tail,val);
#ENDIF
  }

#IF OfComparable
  @SuppressWarnings("unchecked")
  private static <E extends Comparable<E>> E fragmentedHigherImpl($ArrayType$[] arr,int head,int tail, val){
#ELSEIF OfDouble,OfFloat
  private static $exposedType$ fragmentedHigherImpl($ArrayType$[] arr,int head,int tail,$BoxedType$ToIntFunction searchFunc){
#ELSEIF OfLong
  private static $exposedType$ fragmentedHigherImpl($ArrayType$[] arr,int head,int tail,long val){
#ELSE
  private static $exposedType$ fragmentedHigherImpl($ArrayType$[] arr,int head,int tail,int val){
#ENDIF
    final $ArrayType$ tmp;
    final int mid;
#IF OfComparable
    switch((tmp=arr[mid=arr.length-1]).compareTo(val)){
#ELSEIF OfDouble,OfFloat
    switch(searchFunc.applyAsInt(tmp=arr[mid=arr.length-1])){
#ELSE
    switch(privateCompare(val,tmp=arr[mid=arr.length-1])){
#ENDIF
      case 1:
        if((tail=mid-1)>=head){
          break;
        }
        return ($exposedType$)tmp;
      default:
        if((head=0)<=tail){
          break;
        }
      case 0:
        return ($exposedType$)arr[0];
    }
#IF OfDouble,OfFloat
    return nonfragmentedHigherImpl(arr,head,tail,searchFunc);
#ELSE
    return nonfragmentedHigherImpl(arr,head,tail,val);
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
  private static <E extends Comparable<E>> E fragmentedLowerImpl($ArrayType$[] arr,int head,int tail, val){
#ELSEIF OfDouble,OfFloat
  private static $exposedType$ fragmentedLowerImpl($ArrayType$[] arr,int head,int tail,$BoxedType$ToIntFunction searchFunc){
#ELSEIF OfLong
  private static $exposedType$ fragmentedLowerImpl($ArrayType$[] arr,int head,int tail,long val){
#ELSE
  private static $exposedType$ fragmentedLowerImpl($ArrayType$[] arr,int head,int tail,int val){
#ENDIF
    final $ArrayType$ tmp;
    final int mid;
#IF OfComparable
    switch((tmp=arr[mid=arr.length-1]).compareTo(val)){
#ELSEIF OfDouble,OfFloat
    switch(searchFunc.applyAsInt(tmp=arr[mid=arr.length-1])){
#ELSE
    switch(privateCompare(val,tmp=arr[mid=arr.length-1])){
#ENDIF
      case -1:
        if((head=0)<=tail){
          break;
        }
        return ($exposedType$)tmp;
      default:
        if((tail=mid-1)>=head){
          break;
        }
      case 0:
        return ($exposedType$)arr[mid-1];
    }
#IF OfDouble,OfFloat
    return nonfragmentedLowerImpl(arr,head,tail,searchFunc);
#ELSE
    return nonfragmentedLowerImpl(arr,head,tail,val);
#ENDIF
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
  @Override public E ceiling(E val){
#ELSE
  @Override public $exposedType$ $exposedType$Ceiling($exposedType$ val){
#ENDIF
    final int tail;
  #IF OfComparable
    if(val!=null && (tail=this.tail)!=-1){
  #ELSEIF OfDouble,OfFloat
    if(val==val && (tail=this.tail)!=-1){
  #ELSE
    if((tail=this.tail)!=-1){
  #ENDIF
  #IF OfComparable
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      if((tmp=(arr=this.arr)[tail])==null){
        final int head;
        switch(Integer.signum(tail-(head=this.head))){
          case 1:
            return nonfragmentedCeilingImpl(arr,head,tail-1,val);
          default:
            return fragmentedCeilingImpl(arr,head,tail-1,val);
          case 0:
        }
      }else{
        switch(Integer.signum(tmp.compareTo(val))){
          case 1:
            final int head;
            switch(Integer.signum(tail-(head=this.head))){
              case 1:
                return nonfragmentedCeilingImpl(arr,head,tail-1,val);
              default:
                return fragmentedCeilingImpl(arr,head,tail-1,val);
              case 0:
            }
           case 0:
            return ($exposedType$)tmp;
          default:
        }
      }
  #ELSEIF OfDouble,OfFloat
    
      //TODO
      throw new omni.util.NotYetImplementedException();
  #ELSE
      //TODO
      throw new omni.util.NotYetImplementedException();
  #ENDIF
    }
    return $defaultVal$;
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
  @Override public E floor(E val){
#ELSE
  @Override public $exposedType$ $exposedType$Floor($exposedType$ val){
#ENDIF
    final int tail;
    if((tail=this.tail)!=-1){
#IF OfComparable
      if(val==null){
        return ($exposedType$)arr[tail];
      }
      final int head;
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      if((tmp=(arr=this.arr)[head=this.head])!=null){
        switch(Integer.signum(tmp.compareTo(val))){
          case -1:
            switch(Integer.signum(tail-head)){
              case 1:
                return nonfragmentedFloorImpl(arr,head+1,tail,val);
              default:
                return fragmentedFloorImpl(arr,head+1,tail,val);
              case 0:
            }
          case 0:
            return ($exposedType$)tmp;
          default:
        }
      }
#ELSE
      //TODO
      throw new omni.util.NotYetImplementedException();
#ENDIF
    }
    return $defaultVal$;
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public $exposedType$ higher$TypeNameModifier$($exposedType$ val){
    final int tail;
#IF OfComparable
    if(val!=null && (tail=this.tail)!=-1){
#ELSEIF OfDouble,OfFloat
    if(val==val && (tail=this.tail)!=-1){
#ELSE
    if((tail=this.tail)!=-1){
#ENDIF
#IF OfComparable
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      if((tmp=(arr=this.arr)[tail])==null){
        final int head;
        switch(Integer.signum(tail-(head=this.head))){
          case 1:
            return nonfragmentedHigherImpl(arr,head,tail-1,val);
          default:
            return fragmentedHigherImpl(arr,head,tail-1,val);
          case 0:
        }
      }else{
        if(tmp.compareTo(val)>0){
          final int head;
          switch(Integer.signum(tail-(head=this.head))){
            case 0:
              return ($exposedType$)tmp;
            case 1:
              return nonfragmentedHigherImpl(arr,head,tail-1,val);
            default:
              return fragmentedHigherImpl(arr,head,tail-1,val);
          }
        }
      }
#ELSE
      //TODO
      throw new omni.util.NotYetImplementedException();
#ENDIF
    }
    return $defaultVal$;
  }
  
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public $exposedType$ lower$TypeNameModifier$($exposedType$ val){
    final int tail;
    if((tail=this.tail)!=-1){
#IF OfComparable
      final var arr=this.arr;
      final $ArrayType$ tmp;
      if(val==null){
        if((tmp=arr[tail])==null){
          switch(Integer.signum(tail-head)){
            default:
              if(tail==0){
                return ($exposedType$)arr[arr.length-1];
              }
            case 1:
              return ($exposedType$)arr[tail-1];
            case 0:
          }
        }
        return ($exposedType$)tmp;
      }else{
        final int head;
        if((tmp=arr[head=this.head])!=null && tmp.compareTo(val)<0){
          switch(Integer.signum(tail-head)){
            case 0:
              return ($exposedType$)tmp;
            case 1:
              return nonfragmentedLowerImpl(arr,head+1,tail,val);
            default:
              return fragmentedLowerImpl(arr,head+1,tail,val);
          }
        }
      }
#ELSE
      //TODO
      throw new omni.util.NotYetImplementedException();
#ENDIF
    }
    return $defaultVal$;
  }
#IFNOT OfComparable
  @Override public $BoxedType$ ceiling($exposedType$ val){
    final int tail;
    if((tail=this.tail)!=-1){
  #IF OfDouble,OfFloat
      if(val!=val){
        final $ArrayType$ tmp;
        if($BoxedType$.isNan(tmp=arr[tail])){
          return tmp;
        }
      }else
  #ENDIF
      {
  #IF OfDouble,OfFloat
        final $BoxedType$ToIntFunction searchFunc;
    #IF OfDouble
        final long bits;
        if((bits=Double.doubleToRawLongBits(val))==0){
          searchFunc=$ClassPrefix$NavigableSetImpl::comparePos0;
        }else if(bits==Long.MIN_VALUE){
          searchFunc=$ClassPrefix$NavigableSetImpl::compareNeg0;
        }else{
          searchFunc=getSearchFunction(val);
        }
    #ELSE
        switch(Float.floatToRawIntBits(val)){
          case 0xff800000
            return arr[head];
          case 0:
            searchFunc=$ClassPrefix$NavigableSetImpl::comparePos0;
            break;
          case Integer.MIN_VALUE:
            searchFunc=$ClassPrefix$NavigableSetImpl::compareNeg0;
            break;
          default:
            searchFunc=getSearchFunction(val);
        }
    #ENDIF
  #ENDIF
        final $ArrayType$ tmp;
  #IF OfDouble,OfFloat
        switch(searchFunc.applyAsInt(tmp=(arr=this.arr)[tail])){
  #ELSE
        switch(privateCompare(val,tmp=(arr=this.arr)[tail])){
  #ENDIF
          default:
            switch(Integer.signum(tail-(head=this.head))){
              case 1:
  #IF OfDouble,OfFloat
                return nonfragmentedCeilingImpl(arr,head,tail,searchFunc);
              default:
                return fragmentedCeilingImpl(arr,head,tail,searchFunc);
  #ELSE
                return nonfragmentedCeilingImpl(arr,head,tail,val);
              default:
                return fragmentedCeilingImpl(arr,head,tail,val);
  #ENDIF
              case 0:
            }
          case 0:
            return tmp;
          case 1:
        }
      }
    }
    return null;
  }
  @Override public $BoxedType$ floor($exposedType$ val){
    #IF OfDouble,OfFloat
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSEIF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
  @Override public $BoxedType$ higher($exposedType$ val){
    #IF OfDouble,OfFloat
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSEIF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
  @Override public $BoxedType$ lower($exposedType$ val){
    #IF OfDouble,OfFloat
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSEIF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
  #IFNOT OfDouble
  @Override public double doubleCeiling(double val){
    #IF OfFloat
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSEIF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
  @Override public double doubleFloor(double val){
    #IF OfFloat
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSEIF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
  @Override public double higherDouble(double val){
    #IF OfFloat
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSEIF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
  @Override public double lowerDouble(double val){
    #IF OfFloat
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSEIF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
    #IFNOT OfFloat
  @Override public float floatCeiling(float val){
    #IF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
  @Override public float floatFloor(float val){
    #IF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
  @Override public float higherFloat(float val){
    #IF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
  @Override public float lowerFloat(float val){
    #IF OfLong,OfInt
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ELSE
    //TODO
    throw new omni.util.NotYetImplementedException();
    #ENDIF
  }
      #IFNOT OfLong
  @Override public long longCeiling(long val){
    final int tail;
    if(val<=$BoxedType$.MAX_VALUE && (tail=this.tail)!=-1){
      if(val<=$BoxedType$.MIN_VALUE){
        return arr[head];
      }
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      final int iVal;
      switch(privateCompare(iVal=(int)val,(tmp=(arr=this.arr)[tail]))){
        default:
          final int head;
          switch(Integer.signum(tail-(head=this.head))){
            case 1:
              return nonfragmentedCeilingImpl(arr,head,tail-1,iVal);
            default:
              return fragmentedCeilingImpl(arr,head,tail-1,iVal);
            case 0:
          }
        case 0:
          return tmp;
        case 1:
      }
    }
    return Long.MIN_VALUE;
  }
  @Override public long longFloor(long val){
    final int tail;
    if(val>=$BoxedType$.MIN_VALUE && (tail=this.tail)!=-1){
      if(val>=$BoxedType$.MAX_VALUE){
        return arr[tail];
      }
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      final int head;
      final int iVal;
      switch(privateCompare(iVal=(int)val,(tmp=(arr=this.arr)[head=this.head]))){
        default:
          switch(Integer.signum(tail-head)){
            case 1:
              return nonfragmentedFloorImpl(arr,head+1,tail,iVal);
            default:
              return fragmentedFloorImpl(arr,head+1,tail,iVal);
            case 0:
          }
        case 0:
          return tmp;
        case -1:
      }
    }
    return Long.MIN_VALUE;
  }
  @Override public long higherLong(long val){
    final int tail;
    if(val<$BoxedType$.MAX_VALUE && (tail=this.tail)!=-1){
      if(val<$BoxedType$.MIN_VALUE){
        return arr[head];
      }
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      final int iVal;
      if((iVal=(int)val)<(arr=this.arr)[tail]){
        final int head;
        switch(Integer.signum(tail-(head=this.head))){
          case 1:
            return nonfragmentedHigherImpl(arr,head,tail-1,iVal);
          default:
            return fragmentedHigherImpl(arr,head,tail-1,iVal);
          case 0:
            return tmp;
        }
      }
    }
    return Long.MIN_VALUE;
  }
  @Override public long lowerLong(long val){
    final int tail;
    if(val>$BoxedType$.MIN_VALUE && (tail=this.tail)!=-1){
      if(val>$BoxedType$.MAX_VALUE){
        return arr[tail];
      }
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      final int head;
      final int iVal;
      if((iVal=(int)val)>(tmp=(arr=this.arr)[head=this.head])){
        switch(Integer.signum(tail-(head)){
          case 1:
            return nonfragmentedLowerImpl(arr,head+1,tail,iVal);
          default:
            return fragmentedLowerImpl(arr,head+1,tail,iVal);
          case 0:
            return tmp;
        }
      }
    }
    return Long.MIN_VALUE;
  }
        #IFNOT OfInt
  @Override public int intCeiling(int val){
    final int tail;
    if(val<=$BoxedType$.MAX_VALUE && (tail=this.tail)!=-1){
      if(val<=$BoxedType$.MIN_VALUE){
        return arr[head];
      }
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      switch(Integer.signum(val-(tmp=(arr=this.arr)[tail]))){
        default:
          final int head;
          switch(Integer.signum(tail-(head=this.head))){
            case 1:
              return nonfragmentedCeilingImpl(arr,head,tail-1,val);
            default:
              return fragmentedCeilingImpl(arr,head,tail-1,val);
            case 0:
          }
        case 0:
          return tmp;
        case 1:
      }
    }
    return Integer.MIN_VALUE;
  }
  @Override public int intFloor(int val){
    final int tail;
    if(val>=$BoxedType$.MIN_VALUE && (tail=this.tail)!=-1){
      if(val>=$BoxedType$.MAX_VALUE){
        return arr[tail];
      }
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      final int head;
      switch(Integer.signum(val-(tmp=(arr=this.arr)[head=this.head]))){
        default:
          switch(Integer.signum(tail-head)){
            case 1:
              return nonfragmentedFloorImpl(arr,head+1,tail,val);
            default:
              return fragmentedFloorImpl(arr,head+1,tail,val);
            case 0:
          }
        case 0:
          return tmp;
        case -1:
      }
    }
    return Integer.MIN_VALUE;
  }
  @Override public int higherInt(int val){
    final int tail;
    if(val<$BoxedType$.MAX_VALUE && (tail=this.tail)!=-1){
      if(val<$BoxedType$.MIN_VALUE){
        return arr[head];
      }
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      if(val<(arr=this.arr)[tail]){
        final int head;
        switch(Integer.signum(tail-(head=this.head))){
          case 1:
            return nonfragmentedHigherImpl(arr,head,tail-1,val);
          default:
            return fragmentedHigherImpl(arr,head,tail-1,val);
          case 0:
            return tmp;
        }
      }
    }
    return Integer.MIN_VALUE;
  }
  @Override public int lowerInt(int val){
    final int tail;
    if(val>$BoxedType$.MIN_VALUE && (tail=this.tail)!=-1){
      if(val>$BoxedType$.MAX_VALUE){
        return arr[tail];
      }
      final $ArrayType$[] arr;
      final $ArrayType$ tmp;
      final int head;
      if(val>(tmp=(arr=this.arr)[head=this.head])){
        switch(Integer.signum(tail-(head)){
          case 1:
            return nonfragmentedLowerImpl(arr,head+1,tail,val);
          default:
            return fragmentedLowerImpl(arr,head+1,tail,val);
          case 0:
            return tmp;
        }
      }
    }
    return Integer.MIN_VALUE;
  }
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF

#ENDDEF
#MACRODEF DescendingAccessMethods(RETTYPE,PARAMTYPE,CEILINGNAME,FLOORNAME,TYPENAMEMODIFIER)
/*
@Override public RETTYPE CEILINGNAME(PARAMTYPE val){
  return super.FLOORNAME(val);
}
@Override public RETTYPE FLOORNAME(PARAMTYPE val){
  return super.CEILINGNAME(val);
}
@Override public RETTYPE higherTYPENAMEMODIFIER(PARAMTYPE val){
  return super.lowerTYPENAMEMODIFIER(val);
}
@Override public RETTYPE lowerTYPENAMEMODIFIER(PARAMTYPE val){
  return super.higherTYPENAMEMODIFIER(val);
}
*/
#ENDDEF





