#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfComparable
package omni.impl;
import omni.api.OmniIterator;
import omni.api.OmniNavigableSet;
import omni.util.ArrCopy;
#IF OfChar,OfFloat,OfDouble,OfComparable
import omni.util.OmniArray;
#ENDIF
#IF OfComparable
import java.util.Comparator;
import java.util.Collections;
#ELSE
import omni.function.$TypeNameModifier$Comparator;
#ENDIF
#IF OfChar,OfShort,OfInt,OfLong,OfFloat,OfDouble
import omni.util.TypeUtil;
#ENDIF
#IF OfLong,OfDouble,OfComparable
import java.util.function.$TypeNameModifier$ToIntFunction;
#ENDIF
#IF OfFloat
import omni.function.$TypeNameModifier$ToIntFunction;
#ENDIF
#IF OfShort,OfInt,OfChar
import java.util.function.IntUnaryOperator;
#ENDIF
#IF OfComparable
public abstract class $ClassPrefix$NavigableSetImpl<E extends Comparable<E>>
  extends $ClassPrefix$UntetheredArrSeq$<E>$ implements OmniNavigableSet.OfRef$<E>$
#ELSE
public abstract class $ClassPrefix$NavigableSetImpl
  extends $ClassPrefix$UntetheredArrSeq$<E>$ implements OmniNavigableSet.Of$ClassPrefix$$<E>$
#ENDIF
  
{
  $ClassPrefix$NavigableSetImpl(int head,$ArrayType$[] arr,int tail){
    super(head,arr,tail);
  }
  $ClassPrefix$NavigableSetImpl(){
    super();
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public $exposedType$ first$TypeNameModifier$(){
    return ($exposedType$)arr[head];
  }
#IF OfComparable
  @SuppressWarnings("unchecked")
#ENDIF
  @Override public $exposedType$ last$TypeNameModifier$(){
    return ($exposedType$)arr[tail];
  }
  @Override public boolean add($exposedType$ key){
    final int tail;
    if((tail=this.tail)!=-1){
  #IF OfComparable
      if(key!=null){
        return super.uncheckedAdd(tail,key,this::insertionCompare);
      }
      return this.uncheckedAddNull(tail);
  #ELSEIF OfFloat,OfDouble
      if(key==key){
        final $TypeNameModifier$ToIntFunction insertionComparator;
    #IF OfFloat
        switch(Float.floatToRawIntBits(key)){
          default:
            return super.uncheckedAdd(tail,key,this::insertionCompare);
          case 0x7f800000:
            return this.uncheckedAddPosInf(tail);
          case 0xff800000:
            return this.uncheckedAddNegInf(tail);
          case 0:
            insertionComparator=this::comparePos0;
            break;
          case Integer.MIN_VALUE:
            insertionComparator=this::compareNeg0;
        }
    #ELSEIF OfDouble
        final long bits;
        if((bits=Double.doubleToRawLongBits(key))==0L){
          insertionComparator=this::comparePos0;
        }else if(bits==Long.MIN_VALUE){
          insertionComparator=this::compareNeg0;
        }else{
          return super.uncheckedAdd(tail,key,this::insertionCompare);
        }
    #ENDIF
        return super.uncheckedAdd(tail,key,insertionComparator);
      }
      return this.uncheckedAddNaN(tail);
  #ELSE
    #IF OfChar
      switch(key){
        case 0:
          return this.uncheckedAdd0(tail);
        case 1:
          return this.uncheckedAdd1(tail);
        default:
      }
    #ENDIF
      return super.uncheckedAdd(tail,key,this::insertionCompare);
  #ENDIF
    }else{
      super.insertAtMiddle(key);
      return true;
    }
  }
#IFNOT OfComparable
  @Override public boolean add($BoxedType$ key){
    return this.add(($exposedType$)key);
  }
  @Override public boolean add(boolean key){
    final int tail;
    if((tail=this.tail)!=-1){
      #IF OfFloat,OfDouble
      if(key){
        return super.uncheckedAdd(tail,1,this::insertionCompare);
      }else{
        return super.uncheckedAdd(tail,0,this::comparePos0);
      }
      #ELSEIF OfChar
      if(key){
        return this.uncheckedAdd0(tail);
      }else{
        return this.uncheckedAdd1(tail);
      }
      #ELSE
      return super.uncheckedAdd(tail,$queryCastBoolean$(key),this::insertionCompare);
      #ENDIF
    }else{
      super.insertAtMiddle($queryCastBoolean$(key));
      return true;
    }
  }
#ENDIF
#IF OfShort,OfInt,OfLong
  @Override public boolean add(byte key){
    return this.add(($exposedType$)key);
  }
#ENDIF

#IF OfInt,OfLong,OfFloat
  #MACRO AddIntType(char)
#ENDIF
#IF OfFloat
  #MACRO AddIntType(short)
#ENDIF
#IF OfLong,OfFloat,OfDouble
  #MACRO AddIntType(int)
#ENDIF
#IF OfFloat,OfDouble
  #MACRO AddIntType(long)
#ENDIF
#MACRODEF AddIntType(PARAMTYPE)
@Override public boolean add(PARAMTYPE key){
  final int tail;
  if((tail=this.tail)!=-1){
    #IF OfDouble,OfFloat
    if(key==0){
      return super.uncheckedAdd(tail,key,this::comparePos0);
    }
    #ENDIF
    return super.uncheckedAdd(tail,key,this::insertionCompare);
  }else{
    super.insertAtMiddle(key);
    return true;
  }
}
#ENDDEF


#IF OfDouble
  @Override public boolean add(float key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==key){
        $TypeNameModifier$ToIntFunction insertionComparator;
        switch(Float.floatToRawIntBits(key)){
          default:
            return super.uncheckedAdd(tail,key,this::insertionCompare);
          case 0x7f800000:
            return this.uncheckedAddPosInf(tail);
          case 0xff800000:
            return this.uncheckedAddNegInf(tail);
          case 0:
            insertionComparator=this::comparePos0;
            break;
          case Integer.MIN_VALUE:
            insertionComparator=this::compareNeg0;
        }
        return super.uncheckedAdd(tail,key,insertionComparator);
      }
      return this.uncheckedAddNaN(tail);
    }else{
      super.insertAtMiddle(key);
      return true;
    }
  }
#ENDIF
#IF OfShort
  abstract int insertionCompare(int key1,int key2);
#ELSE
  abstract int insertionCompare($exposedType$ key1,$exposedType$ key2);
#ENDIF
#IF OfComparable
  abstract boolean uncheckedAddNull(int tail);
#ENDIF
#IF OfDouble,OfFloat
  abstract int comparePos0($exposedType$ key);
  abstract int compareNeg0($exposedType$ key);
  abstract int comparePos1($exposedType$ key);
  abstract boolean uncheckedAddNaN(int tail);
  abstract boolean uncheckedAddPosInf(int tail);
  abstract boolean uncheckedAddNegInf(int tail);
#ENDIF
#IF OfChar
  abstract boolean uncheckedAdd0(int tail);
  abstract boolean uncheckedAdd1(int tail);
#ENDIF
#IF OfChar
  abstract boolean uncheckedcontains(int tail,int key);
  abstract boolean uncheckedremoveVal(int tail,int key);
  abstract boolean uncheckedcontains(int tail,boolean key);
  abstract boolean uncheckedremoveVal(int tail,boolean key);
#ENDIF
#IF OfChar
  @Override public boolean contains(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && uncheckedcontains(tail,key);
  }
  @Override public boolean removeVal(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && uncheckedremoveVal(tail,key);
  }
  @Override public boolean contains(byte key){
    final int tail;
    return key>=0 && (tail=this.tail)!=-1 && uncheckedcontains(tail,key);
  }
  @Override public boolean removeVal(byte key){
    final int tail;
    return key>=0 && (tail=this.tail)!=-1 && uncheckedremoveVal(tail,key);
  }
  @Override public boolean contains(char key){
    final int tail;
    return (tail=this.tail)!=-1 && uncheckedcontains(tail,key);
  }
  @Override public boolean removeVal(char key){
    final int tail;
    return (tail=this.tail)!=-1 && uncheckedremoveVal(tail,key);
  }
  @Override public boolean contains(short key){
    final int tail;
    return key>=0 && (tail=this.tail)!=-1 && uncheckedcontains(tail,key);
  }
  @Override public boolean removeVal(short key){
    final int tail;
    return key>=0 && (tail=this.tail)!=-1 && uncheckedremoveVal(tail,key);
  }
  @Override public boolean contains(int key){
    final int tail;
    return key==(char)key && (tail=this.tail)!=-1 && uncheckedcontains(tail,key);
  }
  @Override public boolean removeVal(int key){
    final int tail;
    return key==(char)key && (tail=this.tail)!=-1 && uncheckedremoveVal(tail,key);
  }
  @Override public boolean contains(long key){
    final int tail,k;
    return (tail=this.tail)!=-1 && key==(k=(char)key) && uncheckedcontains(tail,k);
  }
  @Override public boolean removeVal(long key){
    final int tail,k;
    return (tail=this.tail)!=-1 && key==(k=(char)key) && uncheckedremoveVal(tail,k);
  }
  @Override public boolean contains(float key){
    final int tail,k;
    return (tail=this.tail)!=-1 && key==(k=(char)key) && uncheckedcontains(tail,k);
  }
  @Override public boolean removeVal(float key){
    final int tail,k;
    return (tail=this.tail)!=-1 && key==(k=(char)key) && uncheckedremoveVal(tail,k);
  }
  @Override public boolean contains(double key){
    final int tail,k;
    return (tail=this.tail)!=-1 && key==(k=(char)key) && uncheckedcontains(tail,k);
  }
  @Override public boolean removeVal(double key){
    final int tail,k;
    return (tail=this.tail)!=-1 && key==(k=(char)key) && uncheckedremoveVal(tail,k);
  }
  @Override public boolean contains(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final int k;
      if(key instanceof Character){
        k=(char)key;
      }else if(key instanceof Integer){
        if((k=(int)key)!=(char)k){
          return false;
        }
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(k=(char)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(k=(char)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(k=(char)d)){
          return false;
        }
      }else if(key instanceof Byte || key instanceof Short){
        if((k=((Number)key).shortValue())<0){
          return false;
        }
      }else if(key instanceof Boolean){
        return uncheckedcontains(tail,(boolean)key);
      }else{
        return false;
      }
      return uncheckedcontains(tail,k);
    }
    return false;
  }
  @Override public boolean remove(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final int k;
      if(key instanceof Character){
        k=(char)key;
      }else if(key instanceof Integer){
        if((k=(int)key)!=(char)k){
          return false;
        }
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(k=(char)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(k=(char)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(k=(char)d)){
          return false;
        }
      }else if(key instanceof Byte || key instanceof Short){
        if((k=((Number)key).shortValue())<0){
          return false;
        }
      }else if(key instanceof Boolean){
        return uncheckedremoveVal(tail,(boolean)key);
      }else{
        return false;
      }
      return uncheckedremoveVal(tail,k);
    }
    return false;
  }
#ENDIF
#IF OfComparable
  abstract boolean uncheckedremoveNull(int tail);
  abstract $TypeNameModifier$ToIntFunction$<E>$ getQueryComparator($exposedType$ key);
  @SuppressWarnings("unchecked")
  @Override public boolean contains(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,this.getQueryComparator(($exposedType$)(Boolean)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean contains(byte key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,this.getQueryComparator(($exposedType$)(Byte)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean contains(char key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,this.getQueryComparator(($exposedType$)(Character)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean contains(short key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,this.getQueryComparator(($exposedType$)(Short)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean contains(int key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,this.getQueryComparator(($exposedType$)(Integer)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean contains(long key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,this.getQueryComparator(($exposedType$)(Long)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean contains(float key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,this.getQueryComparator(($exposedType$)(Float)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean contains(double key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,this.getQueryComparator(($exposedType$)(Double)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)(Boolean)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(byte key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)(Byte)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(char key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)(Character)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(short key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)(Short)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(int key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)(Integer)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(long key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)(Long)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(float key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)(Float)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(double key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)(Double)key));
  }
  @SuppressWarnings("unchecked")
  @Override public boolean remove(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key!=null){
        return super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)key));
      }
      return this.uncheckedremoveNull(tail);
    }
    return false;
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(Boolean key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key!=null){
        return super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)key));
      }
      return this.uncheckedremoveNull(tail);
    }
    return false;
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(Byte key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key!=null){
        return super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)key));
      }
      return this.uncheckedremoveNull(tail);
    }
    return false;
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(Character key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key!=null){
        return super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)key));
      }
      return this.uncheckedremoveNull(tail);
    }
    return false;
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(Short key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key!=null){
        return super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)key));
      }
      return this.uncheckedremoveNull(tail);
    }
    return false;
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(Integer key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key!=null){
        return super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)key));
      }
      return this.uncheckedremoveNull(tail);
    }
    return false;
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(Long key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key!=null){
        return super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)key));
      }
      return this.uncheckedremoveNull(tail);
    }
    return false;
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(Float key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key!=null){
        return super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)key));
      }
      return this.uncheckedremoveNull(tail);
    }
    return false;
  }
  @SuppressWarnings("unchecked")
  @Override public boolean removeVal(Double key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key!=null){
        return super.uncheckedRemoveMatch(tail,this.getQueryComparator(($exposedType$)key));
      }
      return this.uncheckedremoveNull(tail);
    }
    return false;
  }
  
#ENDIF
#IF OfDouble,OfFloat
  @Override public boolean contains(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,key?this::comparePos1:this::comparePos0);
  }
  @Override public boolean removeVal(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,key?this::comparePos1:this::comparePos0);
  }
#ENDIF
#IF OfDouble,OfFloat
  $TypeNameModifier$ToIntFunction$<E>$ getQueryComparator($exposedType$ key){
    return (k)->this.insertionCompare(key,k);
  }
  @Override public boolean contains(long key){
    final int tail;
    return (tail=this.tail)!=-1 && TypeUtil.checkCastTo$BoxedType$(key)&&super.uncheckedContainsMatch(this.head,tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  @Override public boolean removeVal(long key){
    final int tail;
    return (tail=this.tail)!=-1 && TypeUtil.checkCastTo$BoxedType$(key)&&super.uncheckedRemoveMatch(tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  abstract boolean uncheckedremoveNaN(int tail);
  abstract boolean uncheckedremovePosInf(int tail);
  abstract boolean uncheckedremoveNegInf(int tail);
#ENDIF
#IF OfDouble
  @Override public boolean contains(int key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  @Override public boolean removeVal(int key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  
  @Override public boolean removeVal(double key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==key){
        final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
        final long bits;
        if((bits=Double.doubleToRawLongBits(key))==0){
          queryComparator=this::comparePos0;
        }else if(bits==Long.MIN_VALUE){
          queryComparator=this::compareNeg0;
        }else{
          queryComparator=this.getQueryComparator(key);
        }
        return super.uncheckedRemoveMatch(tail,queryComparator);
      }
      return this.uncheckedremoveNaN(tail);
    }
    return false;
  }
  @Override public boolean removeVal(float key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==key){
        final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
        switch(Float.floatToRawIntBits(key)){
          case 0x7f800000:
            return this.uncheckedremovePosInf(tail);
          case 0xff800000:
            return this.uncheckedremoveNegInf(tail);
          case 0:
            queryComparator=this::comparePos0;
            break;
          case Integer.MIN_VALUE:
            queryComparator=this::compareNeg0;
            break;
          default:
            queryComparator=this.getQueryComparator(key);
        }
        return super.uncheckedRemoveMatch(tail,queryComparator);
      }
      return this.uncheckedremoveNaN(tail);
    }
    return false;
  }
  @Override public boolean remove(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
      if(key instanceof Double){
        final double d;
        if((d=(double)key)==d){
          final long bits;
          if((bits=Double.doubleToRawLongBits(d))==0){
            queryComparator=this::comparePos0;
          }else if(bits==Long.MIN_VALUE){
            queryComparator=this::compareNeg0;
          }else{
            queryComparator=this.getQueryComparator(d);
          }
        }else{
          return this.uncheckedremoveNaN(tail);
        }
        
      }else if(key instanceof Integer || key instanceof Byte || key instanceof Short){
        final int i;
        queryComparator=((i=((Number)key).intValue())==0)?this::comparePos0:this.getQueryComparator(i);
      }else if(key instanceof Long){
        final long l;
        if(!TypeUtil.checkCastToDouble(l=(long)key)){
          return false;
        }
        queryComparator=(l==0)?this::comparePos0:this.getQueryComparator(l);
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)==f){
          switch(Float.floatToRawIntBits(f)){
            case 0x7f800000:
              return this.uncheckedremovePosInf(tail);
            case 0xff800000:
              return this.uncheckedremoveNegInf(tail);
            case 0:
              queryComparator=this::comparePos0;
              break;
            case Integer.MIN_VALUE:
              queryComparator=this::compareNeg0;
              break;
            default:
              queryComparator=this.getQueryComparator(f);
          }
        }else{
          return this.uncheckedremoveNaN(tail);
        }
      }else if(key instanceof Character){
        final int i;
        queryComparator=((i=(char)key)==0)?this::comparePos0:this.getQueryComparator(i);
      }else if(key instanceof Boolean){
        queryComparator=((boolean)key)?this::comparePos1:this::comparePos0;
      }else{
        return false;
      }
      return super.uncheckedRemoveMatch(tail,queryComparator);
    }
    return false;
  }
#ENDIF
#IF OfFloat
  @Override public boolean contains(char key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  @Override public boolean removeVal(char key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  @Override public boolean contains(short key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  @Override public boolean removeVal(short key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  @Override public boolean contains(int key){
    final int tail;
    return (tail=this.tail)!=-1 && TypeUtil.checkCastToFloat(key) && super.uncheckedContainsMatch(this.head,tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  @Override public boolean removeVal(int key){
    final int tail;
    return (tail=this.tail)!=-1 && TypeUtil.checkCastToFloat(key) && super.uncheckedRemoveMatch(tail,key==0?this::comparePos0:this.getQueryComparator(key));
  }
  @Override public boolean removeVal(double key){
    final int tail;
    if((tail=this.tail)!=-1){
      final float f;
      if((f=(float)key)==f){
        final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
        switch(Float.floatToRawIntBits(f)){
          case 0x7f800000:
            return this.uncheckedremovePosInf(tail);
          case 0xff800000:
            return this.uncheckedremoveNegInf(tail);
          case 0:
            queryComparator=this::comparePos0;
            break;
          case Integer.MIN_VALUE:
            queryComparator=this::compareNeg0;
            break;
          default:
            queryComparator=this.getQueryComparator(f);
        }
        return super.uncheckedRemoveMatch(tail,queryComparator);
      }else if(f!=f){
        return this.uncheckedremoveNaN(tail);
      }
    }
    return false;
  }
  @Override public boolean removeVal(float key){
    final int tail;
    if((tail=this.tail)!=-1){
      if(key==key){
        final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
        switch(Float.floatToRawIntBits(key)){
          case 0x7f800000:
            return this.uncheckedremovePosInf(tail);
          case 0xff800000:
            return this.uncheckedremoveNegInf(tail);
          case 0:
            queryComparator=this::comparePos0;
            break;
          case Integer.MIN_VALUE:
            queryComparator=this::compareNeg0;
            break;
          default:
            queryComparator=this.getQueryComparator(key);
        }
        return super.uncheckedRemoveMatch(tail,queryComparator);
      }
      return this.uncheckedremoveNaN(tail);
    }
    return false;
  }
  @Override public boolean remove(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
      if(key instanceof Float){
       final float f;
        if((f=(float)key)==f){
          switch(Float.floatToRawIntBits(f)){
            case 0x7f800000:
              return this.uncheckedremovePosInf(tail);
            case 0xff800000:
              return this.uncheckedremoveNegInf(tail);
            case 0:
              queryComparator=this::comparePos0;
              break;
            case Integer.MIN_VALUE:
              queryComparator=this::compareNeg0;
              break;
            default:
              queryComparator=this.getQueryComparator(f);
          }
        }else{
          return this.uncheckedremoveNaN(tail);
        }
      }else if(key instanceof Integer){
        final int i;
        if(!TypeUtil.checkCastToFloat(i=(int)key)){
          return false;
        }
        queryComparator=(i==0)?this::comparePos0:this.getQueryComparator(i);
      }else if(key instanceof Long){
        final long l;
        if(!TypeUtil.checkCastToFloat(l=(long)key)){
          return false;
        }
        queryComparator=(l==0)?this::comparePos0:this.getQueryComparator(l);
      }else if(key instanceof Double){
        final double d;
        float f;
        if((d=(double)key)==(f=(float)d)){
          switch(Float.floatToRawIntBits(f)){
            case 0x7f800000:
              return this.uncheckedremovePosInf(tail);
            case 0xff800000:
              return this.uncheckedremoveNegInf(tail);
            case 0:
              queryComparator=this::comparePos0;
              break;
            case Integer.MIN_VALUE:
              queryComparator=this::compareNeg0;
              break;
            default:
              queryComparator=this.getQueryComparator(f);
          }
        }else if(f!=f){
          return this.uncheckedremoveNaN(tail);
        }else{
          return false;
        }
      }else if(key instanceof Byte || key instanceof Short){
        final int i;
        queryComparator=((i=((Number)key).shortValue())==0)?this::comparePos0:this.getQueryComparator(i);
      }else if(key instanceof Character){
        final int i;
        queryComparator=((i=(char)key)==0)?this::comparePos0:this.getQueryComparator(i);
      }else if(key instanceof Boolean){
        queryComparator=((boolean)key)?this::comparePos1:this::comparePos0;
      }else{
        return false;
      }
      return super.uncheckedRemoveMatch(tail,queryComparator);
    }
    return false;
  }
#ENDIF
#IF OfInt
  IntUnaryOperator getQueryComparator($exposedType$ key){
    return (k)->this.insertionCompare(key,k);
  }
  @Override public boolean contains(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator($queryCastBoolean$(key)));
  }
  @Override public boolean removeVal(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator($queryCastBoolean$(key)));
  }
  @Override public boolean contains(byte key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(byte key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(char key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(char key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(int key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(int key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(long key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=(int)key)==key && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
  }
  @Override public boolean removeVal(long key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=(int)key)==key && super.uncheckedRemoveMatch(tail,getQueryComparator(k));
  }
  @Override public boolean contains(float key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=(int)key)==(double)key && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
  }
  @Override public boolean removeVal(float key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=(int)key)==(double)key && super.uncheckedRemoveMatch(tail,getQueryComparator(k));
  }
  @Override public boolean contains(double key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=(int)key)==key && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
  }
  @Override public boolean removeVal(double key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=(int)key)==key && super.uncheckedRemoveMatch(tail,getQueryComparator(k));
  }
  @Override public boolean contains(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final int k;
      if(key instanceof Integer || key instanceof Byte || key instanceof Short){
        k=((Number)key).intValue();
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(k=(int)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(double)(k=(int)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(k=(int)d)){
          return false;
        }
      }else if(key instanceof Character){
        k=(char)key;
      }else if(key instanceof Boolean){
        k=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
    }
    return false;
  }
  @Override public boolean remove(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final int k;
      if(key instanceof Integer || key instanceof Byte || key instanceof Short){
        k=((Number)key).intValue();
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(k=(int)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(double)(k=(int)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(k=(int)d)){
          return false;
        }
      }else if(key instanceof Character){
        k=(char)key;
      }else if(key instanceof Boolean){
        k=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedRemoveMatch(tail,getQueryComparator(k));
    }
    return false;
  }
#ENDIF
#IF OfLong
  $TypeNameModifier$ToIntFunction$<E>$ getQueryComparator($exposedType$ key){
    return (k)->this.insertionCompare(key,k);
  }
  @Override public boolean contains(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator($queryCastBoolean$(key)));
  }
  @Override public boolean removeVal(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator($queryCastBoolean$(key)));
  }
  @Override public boolean contains(byte key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(byte key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(char key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(char key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(int key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(int key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(long key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(long key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(float key){
    final int tail;
    final long k;
    return (tail=this.tail)!=-1 && TypeUtil.floatEquals(key,k=(long)key) && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
  }
  @Override public boolean removeVal(float key){
    final int tail;
    final long k;
    return (tail=this.tail)!=-1 && TypeUtil.floatEquals(key,k=(long)key) && super.uncheckedRemoveMatch(tail,getQueryComparator(k));
  }
  @Override public boolean contains(double key){
    final int tail;
    final long k;
    return (tail=this.tail)!=-1 && TypeUtil.doubleEquals(key,k=(long)key) && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
  }
  @Override public boolean removeVal(double key){
    final int tail;
    final long k;
    return (tail=this.tail)!=-1 && TypeUtil.doubleEquals(key,k=(long)key) && super.uncheckedRemoveMatch(tail,getQueryComparator(k));
  }
  @Override public boolean contains(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final long k;
      if(key instanceof Long || key instanceof Integer || key instanceof Byte || key instanceof Short){
        k=((Number)key).longValue();
      }else if(key instanceof Float){
        final float f;
        if(!TypeUtil.floatEquals(f=(float)key,k=(long)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if(!TypeUtil.doubleEquals(d=(double)key,k=(long)d)){
          return false;
        }
      }else if(key instanceof Character){
        k=(char)key;
      }else if(key instanceof Boolean){
        k=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
    }
    return false;
  }
  @Override public boolean remove(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final long k;
      if(key instanceof Long || key instanceof Integer || key instanceof Byte || key instanceof Short){
        k=((Number)key).longValue();
      }else if(key instanceof Float){
        final float f;
        if(!TypeUtil.floatEquals(f=(float)key,k=(long)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if(!TypeUtil.doubleEquals(d=(double)key,k=(long)d)){
          return false;
        }
      }else if(key instanceof Character){
        k=(char)key;
      }else if(key instanceof Boolean){
        k=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedRemoveMatch(tail,getQueryComparator(k));
    }
    return false;
  }
#ENDIF
#IF OfShort
  IntUnaryOperator getQueryComparator(int key){
    return (k)->this.insertionCompare(key,k);
  }
  @Override public boolean contains(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator($queryCastBoolean$(key)));
  }
  @Override public boolean removeVal(boolean key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator($queryCastBoolean$(key)));
  }
  @Override public boolean contains(byte key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(byte key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(char key){
    final int tail;
    return key<=$BoxedType$.MAX_VALUE && (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(char key){
    final int tail;
    return key<=$BoxedType$.MAX_VALUE && (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(short key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(short key){
    final int tail;
    return (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(int key){
    final int tail;
    return key==($exposedType$)key && (tail=this.tail)!=-1 && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
  }
  @Override public boolean removeVal(int key){
    final int tail;
    return key==($exposedType$)key && (tail=this.tail)!=-1 && super.uncheckedRemoveMatch(tail,getQueryComparator(key));
  }
  @Override public boolean contains(long key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=($exposedType$)key)==key && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
  }
  @Override public boolean removeVal(long key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=($exposedType$)key)==key && super.uncheckedRemoveMatch(tail,getQueryComparator(k));
  }
  @Override public boolean contains(float key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=($exposedType$)key)==key && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
  }
  @Override public boolean removeVal(float key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=($exposedType$)key)==key && super.uncheckedRemoveMatch(tail,getQueryComparator(k));
  }
  @Override public boolean contains(double key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=($exposedType$)key)==key && super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
  }
  @Override public boolean removeVal(double key){
    final int tail,k;
    return (tail=this.tail)!=-1 && (k=($exposedType$)key)==key && super.uncheckedRemoveMatch(tail,getQueryComparator(k));
  }
  @Override public boolean contains(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final int k;
      if(key instanceof Short || key instanceof Byte){
        k=((Number)key).shortValue();
      }else if(key instanceof Integer){
        if((k=(int)key)!=($exposedType$)k){
          return false;
        }
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(k=($exposedType$)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(k=($exposedType$)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(k=($exposedType$)d)){
          return false;
        }
      }else if(key instanceof Character){
        if((k=(char)key)>$BoxedType$.MAX_VALUE){
          return false;
        }
      }else if(key instanceof Boolean){
        k=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedContainsMatch(this.head,tail,getQueryComparator(k));
    }
    return false;
  }
  @Override public boolean remove(Object key){
    final int tail;
    if((tail=this.tail)!=-1){
      final int k;
      if(key instanceof Short || key instanceof Byte){
        k=((Number)key).shortValue();
      }else if(key instanceof Integer){
        if((k=(int)key)!=($exposedType$)k){
          return false;
        }
      }else if(key instanceof Long){
        final long l;
        if((l=(long)key)!=(k=($exposedType$)l)){
          return false;
        }
      }else if(key instanceof Float){
        final float f;
        if((f=(float)key)!=(k=($exposedType$)f)){
          return false;
        }
      }else if(key instanceof Double){
        final double d;
        if((d=(double)key)!=(k=($exposedType$)d)){
          return false;
        }
      }else if(key instanceof Character){
        if((k=(char)key)>$BoxedType$.MAX_VALUE){
          return false;
        }
      }else if(key instanceof Boolean){
        k=$queryCastBoolean$((boolean)key);
      }else{
        return false;
      }
      return super.uncheckedRemoveMatch(tail,getQueryComparator(k));
    }
    return false;
  }
#ENDIF

#IF OfComparable
  public static class Ascending<E extends Comparable<E>> extends $ClassPrefix$NavigableSetImpl$<E>$ implements Cloneable
#ELSE
  public static class Ascending$<E>$ extends $ClassPrefix$NavigableSetImpl$<E>$ implements Cloneable
#ENDIF
  {
    #MACRO AscendingDescendingBody<Ascending>()
#IF OfDouble
    @Override public boolean contains(double key){
      final int tail;
      if((tail=this.tail)!=-1){
        if(key==key){
          final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
          final long bits;
          if((bits=Double.doubleToRawLongBits(key))==0){
            queryComparator=this::comparePos0;
          }else if(bits==Long.MIN_VALUE){
            queryComparator=this::compareNeg0;
          }else{
            queryComparator=super.getQueryComparator(key);
          }
          return super.uncheckedContainsMatch(this.head,tail,queryComparator);
        }
        return $BoxedType$.isNaN(arr[tail]);
      }
      return false;
    }
    @Override public boolean contains(float key){
      int tail;
      if((tail=this.tail)!=-1){
        if(key==key){
          final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
          switch(Float.floatToRawIntBits(key)){
            case 0x7f800000: //pos inf
              final $ArrayType$[] arr;
              return ((arr=this.arr)[tail]==$BoxedType$.POSITIVE_INFINITY) || (tail!=head && arr[tail==0?arr.length-1:tail-1]==$BoxedType$.POSITIVE_INFINITY);
            case 0xff800000:
              return this.arr[head]==$BoxedType$.NEGATIVE_INFINITY;
            case 0:
              queryComparator=this::comparePos0;
              break;
            case Integer.MIN_VALUE:
              queryComparator=this::compareNeg0;
              break;
            default:
              queryComparator=super.getQueryComparator(key);
          }
          return super.uncheckedContainsMatch(this.head,tail,queryComparator);
        }
        return $BoxedType$.isNaN(arr[tail]);
      }
      return false;
    }
    @Override public boolean contains(Object key){
      final int tail;
      if((tail=this.tail)!=-1){
        final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
        if(key instanceof Double){
          final double d;
          if((d=(double)key)==d){
            final long bits;
            if((bits=Double.doubleToRawLongBits(d))==0){
              queryComparator=this::comparePos0;
            }else if(bits==Long.MIN_VALUE){
              queryComparator=this::compareNeg0;
            }else{
              queryComparator=super.getQueryComparator(d);
            }
          }else{
            return $BoxedType$.isNaN(arr[tail]);
          }
        }else if(key instanceof Integer || key instanceof Byte || key instanceof Short){
          final int i;
          queryComparator=((i=((Number)key).intValue())==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Long){
          final long l;
          if(!TypeUtil.checkCastToDouble(l=(long)key)){
            return false;
          }
          queryComparator=l==0?this::comparePos0:super.getQueryComparator(l);
        }else if(key instanceof Float){
          final float f;
          if((f=(float)key)==f){
            switch(Float.floatToRawIntBits(f)){
              case 0xff800000:
                return arr[this.head]==$BoxedType$.NEGATIVE_INFINITY;
              case 0x7f800000:
                final $ArrayType$[] arr;
                return ((arr=this.arr)[tail]==$BoxedType$.POSITIVE_INFINITY)
                     ||(tail!=this.head && (arr[tail==0?arr.length-1:tail-1]==$BoxedType$.POSITIVE_INFINITY));
              case 0:
                queryComparator=this::comparePos0;
                break;
              case Integer.MIN_VALUE:
                queryComparator=this::compareNeg0;
                break;
              default:
                queryComparator=super.getQueryComparator(f);
            }
            
          }else{
            return $BoxedType$.isNaN(arr[tail]);
          }
          
        }else if(key instanceof Character){
          final int i;
          queryComparator=((i=(char)key)==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Boolean){
          queryComparator=((boolean)key)?this::comparePos1:this::comparePos0;
        }else{
          return false;
        }
        return super.uncheckedContainsMatch(this.head,tail,queryComparator);
      }
      return false;
    }
#ENDIF
#IF OfDouble,OfFloat
    @Override boolean uncheckedremoveNaN(int tail){
       final $ArrayType$[] arr;
       if($BoxedType$.isNaN((arr=this.arr)[tail])){
         if(tail==this.head){
           tail=-1;
         }else if(--tail==-1){
           tail=arr.length-1;
         }
         this.tail=tail;
         return true;
       } 
       return false;
    }
    @Override boolean uncheckedremovePosInf(int tail){
      final $ArrayType$[] arr;
      if((arr=this.arr)[tail]==$BoxedType$.POSITIVE_INFINITY){
        if(tail==this.head){
          tail=-1;
        }else if(--tail==-1){
          tail=arr.length-1;
        }
        this.tail=tail;
        return true;
      }
      if(tail!=this.head){
        if(--tail==-1){
          tail=arr.length-1;
        }
        if(arr[tail]==$BoxedType$.POSITIVE_INFINITY){
          arr[tail]=$BoxedType$.NaN;
          this.tail=tail;
          return true;
        }
      }
      return false;
    }
    @Override boolean uncheckedremoveNegInf(int tail){
      final $ArrayType$[] arr;
      int head;
      if((arr=this.arr)[head=this.head]==$BoxedType$.NEGATIVE_INFINITY){
        if(tail==head){
          this.tail=-1;
          
        }else{
          if(++head==arr.length){
            head=0;
          }
          this.head=head;
        }
        return true;
      }
      return false;
    }
    @Override int comparePos1($exposedType$ key){
      if(1>key){
        //insert hi;
        return 1;
      }
      if(1==key){
        return 0;
      }
      return -1;
    }
    @Override int comparePos0($exposedType$ key){
      if(0>key){
        //insert hi
        return 1;
      }
  #IF OfFloat
      switch(Float.floatToRawIntBits(key)){
        case 0: //pos0
          return 0;
        case Integer.MIN_VALUE: //neg0
          return 1;
        default:
      }
  #ELSE
      final long bits;
      if((bits=Double.doubleToRawLongBits(key))==0){ //pos0
        return 0;
      }
      if(bits==Long.MIN_VALUE){ //neg0
        return 1;
      }
  #ENDIF
      return -1; //0<key || key!=key so insert lo
    }
    @Override int compareNeg0($exposedType$ key){
      if(0>key){
        //insert hi
        return 1;
      }
  #IF OfFloat
      if(Float.floatToRawIntBits(key)==Integer.MIN_VALUE){
  #ELSE
      if(Double.doubleToRawLongBits(key)==Long.MIN_VALUE){
  #ENDIF
        return 0;
      }
      return -1; //0<key || key!=key so insert lo
    }
    @Override boolean uncheckedAddNaN(int tail){
      final $ArrayType$[] arr;
      if(!$BoxedType$.isNaN((arr=this.arr)[tail])){
        super.insertAtTail(arr,$BoxedType$.NaN,this.head,tail);
        return true;
      }
      return false;
    }
    @Override boolean uncheckedAddPosInf(int tail){
      $ArrayType$[] arr;
      final $ArrayType$ topVal;
      if((topVal=(arr=this.arr)[tail])!=$BoxedType$.POSITIVE_INFINITY){
        int head=this.head;
        if($BoxedType$.isNaN(topVal)){
          #MACRO AddJustBeforeTail($BoxedType$.NaN,$BoxedType$.POSITIVE_INFINITY)
          
        }else{
          super.insertAtTail(arr,$BoxedType$.POSITIVE_INFINITY,head,tail);
        }
        return true;
      }
      return false;
    }
    @Override boolean uncheckedAddNegInf(int tail){
      final $ArrayType$[] arr;
      final int head;
      if(((arr=this.arr)[head=this.head])!=$BoxedType$.NEGATIVE_INFINITY){
        super.insertAtHead(arr,$BoxedType$.NEGATIVE_INFINITY,head,tail);
        return true;
      }
      return false;
    }
#ENDIF
#IF OfFloat
    @Override public boolean contains(double key){
      final int tail;
      if((tail=this.tail)!=-1){
        final float f;
        if((f=(float)key)==f){
          final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
          switch(Float.floatToRawIntBits(f)){
            case 0x7f800000: //pos inf
              final $ArrayType$[] arr;
              return ((arr=this.arr)[tail]==$BoxedType$.POSITIVE_INFINITY) || (tail!=head && arr[tail==0?arr.length-1:tail-1]==$BoxedType$.POSITIVE_INFINITY);
            case 0xff800000:
              return this.arr[head]==$BoxedType$.NEGATIVE_INFINITY;
            case 0:
              queryComparator=this::comparePos0;
              break;
            case Integer.MIN_VALUE:
              queryComparator=this::compareNeg0;
              break;
            default:
              queryComparator=super.getQueryComparator(f);
          }
          return super.uncheckedContainsMatch(this.head,tail,queryComparator);
        }else if(f!=f){
          return $BoxedType$.isNaN(arr[tail]);
        }
      }
      return false;
    }
    @Override public boolean contains(float key){
      final int tail;
      if((tail=this.tail)!=-1){
        if(key==key){
          final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
          switch(Float.floatToRawIntBits(key)){
            case 0x7f800000: //pos inf
              final $ArrayType$[] arr;
              return ((arr=this.arr)[tail]==$BoxedType$.POSITIVE_INFINITY) || (tail!=head && arr[tail==0?arr.length-1:tail-1]==$BoxedType$.POSITIVE_INFINITY);
            case 0xff800000:
              return this.arr[head]==$BoxedType$.NEGATIVE_INFINITY;
            case 0:
              queryComparator=this::comparePos0;
              break;
            case Integer.MIN_VALUE:
              queryComparator=this::compareNeg0;
              break;
            default:
              queryComparator=super.getQueryComparator(key);
          }
          return super.uncheckedContainsMatch(this.head,tail,queryComparator);
        }
        return $BoxedType$.isNaN(arr[tail]);
      }
      return false;
    }
    @Override public boolean contains(Object key){
      final int tail;
      if((tail=this.tail)!=-1){
        final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
        if(key instanceof Float){
          final float f;
          if((f=(float)key)==f){
            switch(Float.floatToRawIntBits(f)){
              case 0xff800000:
                return arr[this.head]==$BoxedType$.NEGATIVE_INFINITY;
              case 0x7f800000:
                final $ArrayType$[] arr;
                return ((arr=this.arr)[tail]==$BoxedType$.POSITIVE_INFINITY)
                     ||(tail!=this.head && (arr[tail==0?arr.length-1:tail-1]==$BoxedType$.POSITIVE_INFINITY));
              case 0:
                queryComparator=this::comparePos0;
                break;
              case Integer.MIN_VALUE:
                queryComparator=this::compareNeg0;
                break;
              default:
                queryComparator=super.getQueryComparator(f);
            }
            
          }else{
            return $BoxedType$.isNaN(arr[tail]);
          }
        }else if(key instanceof Integer){
          final int i;
          if(!TypeUtil.checkCastToFloat(i=(int)key)){
            return false;
          }
          queryComparator=(i==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Long){
          final long l;
          if(!TypeUtil.checkCastToFloat(l=(long)key)){
            return false;
          }
          queryComparator=l==0?this::comparePos0:super.getQueryComparator(l);
        }else if(key instanceof Double){
          final double d;
          final float f;
          if((d=(double)key)==(f=(float)d)){
            switch(Float.floatToRawIntBits(f)){
              case 0xff800000:
                return arr[this.head]==$BoxedType$.NEGATIVE_INFINITY;
              case 0x7f800000:
                final $ArrayType$[] arr;
                return ((arr=this.arr)[tail]==$BoxedType$.POSITIVE_INFINITY)
                     ||(tail!=this.head && (arr[tail==0?arr.length-1:tail-1]==$BoxedType$.POSITIVE_INFINITY));
              case 0:
                queryComparator=this::comparePos0;
                break;
              case Integer.MIN_VALUE:
                queryComparator=this::compareNeg0;
                break;
              default:
                queryComparator=super.getQueryComparator(f);
            }
          }else{
            return $BoxedType$.isNaN(arr[tail]);
          }
        }else if(key instanceof Byte || key instanceof Short){
          final int i;
          queryComparator=((i=((Number)key).shortValue())==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Character){
          final int i;
          queryComparator=((i=(char)key)==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Boolean){
          queryComparator=((boolean)key)?this::comparePos1:this::comparePos0;
        }else{
          return false;
        }
        return super.uncheckedContainsMatch(this.head,tail,queryComparator);
      }
      return false;
    }
#ENDIF
#IF OfChar
    @Override boolean uncheckedAdd0(int tail){
      final $ArrayType$[] arr;
      final int head;
      if(((arr=this.arr)[head=this.head])!=0){
        super.insertAtHead(arr,($exposedType$)0,head,tail);
        return true;
      }
      return false;
    }
    @Override boolean uncheckedAdd1(int tail){
      int head;
      $ArrayType$[] arr;
      final $ArrayType$ bottomVal;
      if((bottomVal=(arr=this.arr)[head=this.head])!=1){
        if(bottomVal==0){
          #MACRO AddJustAfterHead(0,1)
        }else{
          super.insertAtHead(arr,($exposedType$)1,head,tail);
        }
        return true;
      }
      return false;
    }
    @Override boolean uncheckedcontains(int tail,boolean key){
      final var arr=this.arr;
      int head=this.head;
      if(key){
        switch(arr[head]){
          case 0:
            return head!=tail && arr[(++head==arr.length)?0:head]==1;
          case 1:
            return true;
          default:
        }
      }
      return arr[head]==0;
    }
    @Override boolean uncheckedremoveVal(int tail,boolean key){
      final var arr=this.arr;
      int head=this.head;
      if(key){
        switch(arr[head]){
          case 0:
            if(head!=tail && arr[(++head==arr.length)?(head=0):head]==1){
              arr[head]=0;
              this.head=head;
              return true;
            }
          default:
            return false;
          case 1:
        }
      }else if(arr[head]!=0){
        return false;
      }
      if(head==tail){
        this.tail=-1;
      }else{
        if(++head==arr.length){
          head=0;
        }
        this.head=head;
      }
      return true;
    }
    private static IntUnaryOperator getQueryComparator(int key){
      return (k)->Integer.signum(key-k);
    }
    @Override boolean uncheckedcontains(int tail,int key){
      switch(key){
        default:
          return super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
        case 1:
          {
            final $ArrayType$[] arr;
            int head;
            switch((arr=this.arr)[head=this.head]){
              case 0:
                return head!=tail && arr[(++head==arr.length)?0:head]==1;
              case 1:
                return true;
              default:
            }
            return false;
          }
        case 0:
          return arr[head]==0;
      }
    }
    @Override boolean uncheckedremoveVal(int tail,int key){
      final $ArrayType$[] arr;
      int head;
      switch(key){
        default:
          return super.uncheckedRemoveMatch(tail,getQueryComparator(key));
        case 1:
          switch((arr=this.arr)[head=this.head]){
            case 0:
              if(head!=tail && arr[(++head==arr.length)?(head=0):head]==1){
                arr[head]=0;
                this.head=head;
                return true;
              }
            default:
              return false;
            case 1:
          }
          break;
        case 0:
          if((arr=this.arr)[head=this.head]!=0){
            return false;
          }
      }
      if(head==tail){
        this.tail=-1;
      }else{
        if(++head==arr.length){
          head=0;
        }
        this.head=head;
      }
      return true;
    }
#ENDIF
#IF OfShort
    @Override int insertionCompare(int key1,int key2){
#ELSE
    @Override int insertionCompare($exposedType$ key1,$exposedType$ key2){
#ENDIF
#IF OfComparable
      return Integer.signum(-key2.compareTo(key1));
#ELSEIF OfDouble,OfFloat,OfLong,OfInt
      if(key1>key2){
        return 1;
      }
      if(key1==key2){
        return 0;
      }
      return -1;
#ELSEIF OfShort,OfChar
      return Integer.signum(key1-key2);
#ENDIF
    }
  }
#IF OfComparable
  public static class Descending<E extends Comparable<E>> extends $ClassPrefix$NavigableSetImpl$<E>$ implements Cloneable
#ELSE
  public static class Descending$<E>$ extends $ClassPrefix$NavigableSetImpl$<E>$ implements Cloneable
#ENDIF
  {
    #MACRO AscendingDescendingBody<Descending>()
#IF OfDouble,OfFloat
    @Override int comparePos1($exposedType$ key){
      if(1>key){
        return -1;
      }
      if(1==key){
        return 0;
      }
      return 1;
    }
    @Override int comparePos0($exposedType$ key){
      if(0>key){
        return -1;
      }
  #IF OfFloat
      switch(Float.floatToRawIntBits(key)){
        case 0: //pos0
          return 0;
        case Integer.MIN_VALUE: //neg0
          return -1;
        default:
      }
  #ELSE
      final long bits;
      if((bits=Double.doubleToRawLongBits(key))==0){ //pos0
        return 0;
      }else if(bits==Long.MIN_VALUE){ //neg0
        return -1;
      }
  #ENDIF
      return 1; //key>pos0 || key!=key
    }
    @Override int compareNeg0($exposedType$ key){
      if(0>key){
        return -1;
      }
  #IF OfFloat
      if(Float.floatToRawIntBits(key)==Integer.MIN_VALUE){
  #ELSE
      if(Double.doubleToRawLongBits(key)==Long.MIN_VALUE){
  #ENDIF
        return 0;
      }
      return 1; //key>neg0 || key!=key
    }
    @Override boolean uncheckedAddNaN(int tail){
      final $ArrayType$[] arr;
      final int head;
      if(!$BoxedType$.isNaN((arr=this.arr)[head=this.head])){
        super.insertAtHead(arr,$BoxedType$.NaN,head,tail);
        return true;
      }
      return false;
    }
    @Override boolean uncheckedAddPosInf(int tail){
      int head;
      $ArrayType$[] arr;
      final $ArrayType$ bottomVal;
      if((bottomVal=(arr=this.arr)[head=this.head])!=$BoxedType$.POSITIVE_INFINITY){
        if($BoxedType$.isNaN(bottomVal)){
          #MACRO AddJustAfterHead($BoxedType$.NaN,$BoxedType$.POSITIVE_INFINITY)
        }else{
          super.insertAtHead(arr,$BoxedType$.POSITIVE_INFINITY,head,tail);
        }
        return true;
      }
      return false;
    }
    @Override boolean uncheckedAddNegInf(int tail){
      final $ArrayType$[] arr;
      if(((arr=this.arr)[tail])!=$BoxedType$.NEGATIVE_INFINITY){
        super.insertAtTail(arr,$BoxedType$.NEGATIVE_INFINITY,this.head,tail);
        return true;
      }
      return false;
    }
#ENDIF
#IF OfChar
    @Override boolean uncheckedAdd0(int tail){
      final $ArrayType$[] arr;
      if(((arr=this.arr)[tail])!=0){
        super.insertAtTail(arr,($exposedType$)0,this.head,tail);
        return true;
      }
      return false;
    }
    @Override boolean uncheckedAdd1(int tail){
      $ArrayType$[] arr;
      final $ArrayType$ topVal;
      if((topVal=(arr=this.arr)[tail])!=1){
        int head=this.head;
        if(topVal==0){
          #MACRO AddJustBeforeTail(0,1)
        }else{
          super.insertAtTail(arr,($exposedType$)1,head,tail);
        }
        return true;
      }
      return false;
    }
    @Override boolean uncheckedcontains(int tail,boolean key){
      final var arr=this.arr;
      if(key){
        switch(arr[tail]){
          case 0:
            return this.head!=tail && arr[(tail==0)?arr.length-1:tail-1]==1;
          case 1:
            return true;
          default:
        }
        return false;
      }
      return arr[tail]==0;
    }
    @Override boolean uncheckedremoveVal(int tail,boolean key){
      final var arr=this.arr;
      if(key){
        switch(arr[tail]){
          case 0:
            if(head!=tail && arr[(--tail==-1)?(tail=arr.length-1):tail]==1){
              arr[tail]=0;
              this.tail=tail;
              return true;
            }
          default:
            return false;
          case 1:
        }
      }else if(arr[tail]!=0){
        return false;
      }
      if(this.head==tail){
        tail=-1;
      }else{
        if(--tail==-1){
          tail=arr.length-1;
        }
      }
      this.tail=tail;
      return true;
    }
    static IntUnaryOperator getQueryComparator(int key){
      return (k)->Integer.signum(k-key);
    }
    @Override boolean uncheckedcontains(int tail,int key){
      switch(key){
        default:
          return super.uncheckedContainsMatch(this.head,tail,getQueryComparator(key));
        case 1:
          {
            final $ArrayType$[] arr;
            switch((arr=this.arr)[tail]){
              case 0:
                return this.head!=tail && arr[(tail==0)?arr.length-1:tail-1]==1;
              case 1:
                return true;
              default:
            }
            return false;
          }
        case 0:
          return arr[tail]==0;
      }
    }
    
    @Override boolean uncheckedremoveVal(int tail,int key){
      final $ArrayType$[] arr;
      switch(key){
        default:
          return super.uncheckedRemoveMatch(tail,getQueryComparator(key));
        case 1:
          switch((arr=this.arr)[tail]){
            case 0:
              if(this.head!=tail && arr[(--tail==-1)?(tail=arr.length-1):tail]==1){
                arr[tail]=0;
                this.tail=tail;
                return true;
              }
            default:
              return false;
            case 1:
          }
          break;
        case 0:
          if((arr=this.arr)[tail]!=0){
            return false;
          }
      }
      if(this.head==tail){
        tail=-1;
      }else{
        if(--tail==-1){
          tail=arr.length-1;
        }
      }
      this.tail=tail;
      return true;
    }
    
#ENDIF
#IF OfDouble
    @Override public boolean contains(double key){
      final int tail;
      if((tail=this.tail)!=-1){
        if(key==key){
          final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
          final long bits;
          if((bits=Double.doubleToRawLongBits(key))==0){
            queryComparator=this::comparePos0;
          }else if(bits==Long.MIN_VALUE){
            queryComparator=this::compareNeg0;
          }else{
            queryComparator=super.getQueryComparator(key);
          }
          return super.uncheckedContainsMatch(this.head,tail,queryComparator);
        }
        return $BoxedType$.isNaN(arr[head]);
      }
      return false;
    }
    @Override public boolean contains(float key){
      int tail;
      if((tail=this.tail)!=-1){
        if(key==key){
          final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
          switch(Float.floatToRawIntBits(key)){
            case 0xff800000:
              return this.arr[tail]==$BoxedType$.NEGATIVE_INFINITY;
            case 0x7f800000: //pos inf
              final $ArrayType$[] arr;
              int head;
              return ((arr=this.arr)[head=this.head]==$BoxedType$.POSITIVE_INFINITY) || (tail!=head && arr[++head==arr.length?0:head]==$BoxedType$.POSITIVE_INFINITY);
            
            case 0:
              queryComparator=this::comparePos0;
              break;
            case Integer.MIN_VALUE:
              queryComparator=this::compareNeg0;
              break;
            default:
              queryComparator=super.getQueryComparator(key);
          }
          return super.uncheckedContainsMatch(this.head,tail,queryComparator);
        }
        return $BoxedType$.isNaN(arr[head]);
      }
      return false;
    }
    @Override public boolean contains(Object key){
      final int tail;
      if((tail=this.tail)!=-1){
        final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
        if(key instanceof Double){
          final double d;
          if((d=(double)key)==d){
            final long bits;
            if((bits=Double.doubleToRawLongBits(d))==0){
              queryComparator=this::comparePos0;
            }else if(bits==Long.MIN_VALUE){
              queryComparator=this::compareNeg0;
            }else{
              queryComparator=super.getQueryComparator(d);
            }
          }else{
            return $BoxedType$.isNaN(arr[head]);
          }
        }else if(key instanceof Integer || key instanceof Byte || key instanceof Short){
          final int i;
          queryComparator=((i=((Number)key).intValue())==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Long){
          final long l;
          if(!TypeUtil.checkCastToDouble(l=(long)key)){
            return false;
          }
          queryComparator=l==0?this::comparePos0:super.getQueryComparator(l);
        }else if(key instanceof Float){
          final float f;
          if((f=(float)key)==f){
            switch(Float.floatToRawIntBits(f)){
             case 0xff800000:
                return this.arr[tail]==$BoxedType$.NEGATIVE_INFINITY;
              case 0x7f800000: //pos inf
                final $ArrayType$[] arr;
                int head;
                return ((arr=this.arr)[head=this.head]==$BoxedType$.POSITIVE_INFINITY) || (tail!=head && arr[++head==arr.length?0:head]==$BoxedType$.POSITIVE_INFINITY);
              case 0:
                queryComparator=this::comparePos0;
                break;
              case Integer.MIN_VALUE:
                queryComparator=this::compareNeg0;
                break;
              default:
                queryComparator=super.getQueryComparator(f);
            }
            
          }else{
            return $BoxedType$.isNaN(arr[head]);
          }
          
        }else if(key instanceof Character){
          final int i;
          queryComparator=((i=(char)key)==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Boolean){
          queryComparator=((boolean)key)?this::comparePos1:this::comparePos0;
        }else{
          return false;
        }
        return super.uncheckedContainsMatch(this.head,tail,queryComparator);
      }
      return false;
    }
#ENDIF
#IF OfFloat
    @Override public boolean contains(double key){
      final int tail;
      if((tail=this.tail)!=-1){
        final float f;
        if((f=(float)key)==f){
          final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
          switch(Float.floatToRawIntBits(f)){
            case 0xff800000:
              return this.arr[tail]==$BoxedType$.NEGATIVE_INFINITY;
            case 0x7f800000: //pos inf
              final $ArrayType$[] arr;
              int head;
              return ((arr=this.arr)[head=this.head]==$BoxedType$.POSITIVE_INFINITY) || (tail!=head && arr[++head==arr.length?0:head]==$BoxedType$.POSITIVE_INFINITY);
            case 0:
              queryComparator=this::comparePos0;
              break;
            case Integer.MIN_VALUE:
              queryComparator=this::compareNeg0;
              break;
            default:
              queryComparator=super.getQueryComparator(f);
          }
          return super.uncheckedContainsMatch(this.head,tail,queryComparator);
        }else if(f!=f){
          return $BoxedType$.isNaN(arr[head]);
        }
      }
      return false;
    }
    @Override public boolean contains(float key){
      final int tail;
      if((tail=this.tail)!=-1){
        if(key==key){
          final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
          switch(Float.floatToRawIntBits(key)){
            case 0xff800000:
              return this.arr[tail]==$BoxedType$.NEGATIVE_INFINITY;
            case 0x7f800000: //pos inf
              final $ArrayType$[] arr;
              int head;
              return ((arr=this.arr)[head=this.head]==$BoxedType$.POSITIVE_INFINITY) || (tail!=head && arr[++head==arr.length?0:head]==$BoxedType$.POSITIVE_INFINITY);
            case 0:
              queryComparator=this::comparePos0;
              break;
            case Integer.MIN_VALUE:
              queryComparator=this::compareNeg0;
              break;
            default:
              queryComparator=super.getQueryComparator(key);
          }
          return super.uncheckedContainsMatch(this.head,tail,queryComparator);
        }
        return $BoxedType$.isNaN(arr[head]);
      }
      return false;
    }
    @Override public boolean contains(Object key){
      final int tail;
      if((tail=this.tail)!=-1){
        final $TypeNameModifier$ToIntFunction$<E>$ queryComparator;
        if(key instanceof Float){
          final float f;
          if((f=(float)key)==f){
            switch(Float.floatToRawIntBits(f)){
              case 0xff800000:
                return arr[tail]==$BoxedType$.NEGATIVE_INFINITY;
              case 0x7f800000:
                final $ArrayType$[] arr;
                int head;
                return ((arr=this.arr)[head=this.head]==$BoxedType$.POSITIVE_INFINITY)
                     ||(tail!=head && (arr[++head==arr.length?0:head]==$BoxedType$.POSITIVE_INFINITY));
              case 0:
                queryComparator=this::comparePos0;
                break;
              case Integer.MIN_VALUE:
                queryComparator=this::compareNeg0;
                break;
              default:
                queryComparator=super.getQueryComparator(f);
            }
            
          }else{
            return $BoxedType$.isNaN(arr[head]);
          }
        }else if(key instanceof Integer){
          final int i;
          if(!TypeUtil.checkCastToFloat(i=(int)key)){
            return false;
          }
          queryComparator=(i==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Long){
          final long l;
          if(!TypeUtil.checkCastToFloat(l=(long)key)){
            return false;
          }
          queryComparator=l==0?this::comparePos0:super.getQueryComparator(l);
        }else if(key instanceof Double){
          final double d;
          final float f;
          if((d=(double)key)==(f=(float)d)){
            switch(Float.floatToRawIntBits(f)){
              case 0xff800000:
                return arr[tail]==$BoxedType$.NEGATIVE_INFINITY;
              case 0x7f800000:
                final $ArrayType$[] arr;
                int head;
                return ((arr=this.arr)[head=this.head]==$BoxedType$.POSITIVE_INFINITY)
                     ||(tail!=head && (arr[++head==arr.length?0:head]==$BoxedType$.POSITIVE_INFINITY));
              case 0:
                queryComparator=this::comparePos0;
                break;
              case Integer.MIN_VALUE:
                queryComparator=this::compareNeg0;
                break;
              default:
                queryComparator=super.getQueryComparator(f);
            }
          }else{
            return $BoxedType$.isNaN(arr[head]);
          }
        }else if(key instanceof Byte || key instanceof Short){
          final int i;
          queryComparator=((i=((Number)key).shortValue())==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Character){
          final int i;
          queryComparator=((i=(char)key)==0)?this::comparePos0:super.getQueryComparator(i);
        }else if(key instanceof Boolean){
          queryComparator=((boolean)key)?this::comparePos1:this::comparePos0;
        }else{
          return false;
        }
        return super.uncheckedContainsMatch(this.head,tail,queryComparator);
      }
      return false;
    }
#ENDIF
#IF OfDouble,OfFloat
    @Override boolean uncheckedremoveNaN(int tail){
       final $ArrayType$[] arr;
       int head;
       if($BoxedType$.isNaN((arr=this.arr)[head=this.head])){
         if(tail==head){
           this.tail=-1;
         }else{
           if(++head==arr.length){
             head=0;
           }
           this.head=head;
         }
         return true;
       } 
       return false;
    }
    @Override boolean uncheckedremovePosInf(int tail){
      final $ArrayType$[] arr;
      int head;
      if((arr=this.arr)[head=this.head]==$BoxedType$.POSITIVE_INFINITY){
        if(tail==head){
          this.tail=-1;
        }else{
          if(++head==arr.length){
            head=0;
          }
          this.head=head;
        }
        return true;
      }
      if(tail!=head){
        if(++head==arr.length){
          head=0;
        }
        if(arr[head]==$BoxedType$.POSITIVE_INFINITY){
          arr[head]=$BoxedType$.NaN;
          this.head=head;
          return true;
        }
      }
      return false;
    }
    @Override boolean uncheckedremoveNegInf(int tail){
      final $ArrayType$[] arr;
      if((arr=this.arr)[tail]==$BoxedType$.NEGATIVE_INFINITY){
        if(tail==head){
          tail=-1;
        }else if(--tail==-1){
          tail=arr.length-1;
        }
        this.tail=tail;
        return true;
      }
      return false;
    }
#ENDIF
#IF OfShort
    @Override int insertionCompare(int key1,int key2){
#ELSE
    @Override int insertionCompare($exposedType$ key1,$exposedType$ key2){
#ENDIF
#IF OfComparable
      return Integer.signum(key2.compareTo(key1));
#ELSEIF OfDouble,OfFloat,OfLong,OfInt
      if(key1>key2){
        return -1;
      }
      if(key1==key2){
        return 0;
      }
      return 1;
#ELSEIF OfShort,OfChar
      return Integer.signum(key2-key1);
#ENDIF
    }
  }
}
#MACRODEF AscendingDescendingBody<DIRECTION>()
public DIRECTION(){
  super();
}
public DIRECTION(int head,$ArrayType$[] arr,int tail){
  super(head,arr,tail);
}
#MACRO HigherLowerCeilingFloorImpl<NATIVETYPE>($exposedType$,$defaultVal$,$exposedType$)
#IFNOT OfComparable
#MACRO HigherLowerCeilingFloorImpl<BOXEDTYPE>($BoxedType$,null,$exposedType$)
  #IFNOT OfDouble
#MACRO HigherLowerCeilingFloorImpl<Double>(double,Double.NaN,double)
    #IFNOT OfFloat
#MACRO HigherLowerCeilingFloorImpl<Float>(float,Float.NaN,float)
      #IFNOT OfLong
#MACRO HigherLowerCeilingFloorImpl<Long>(long,Long.MIN_VALUE,long)
        #IFNOT OfInt
#MACRO HigherLowerCeilingFloorImpl<Int>(int,Integer.MIN_VALUE,int)
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#IF OfComparable
@Override public OmniNavigableSet.OfRef<E> headSet($exposedType$ toElement){
#ELSE
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ headSet($exposedType$ toElement){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniNavigableSet.OfRef<E> headSet($exposedType$ toElement, boolean inclusive){
#ELSE
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ headSet($exposedType$ toElement, boolean inclusive){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniNavigableSet.OfRef<E> tailSet($exposedType$ fromElement){
#ELSE
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ tailSet($exposedType$ fromElement){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniNavigableSet.OfRef<E> tailSet($exposedType$ fromElement, boolean inclusive){
#ELSE
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ tailSet($exposedType$ fromElement, boolean inclusive){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniNavigableSet.OfRef<E> subSet($exposedType$ fromElement,$exposedType$ toElement){
#ELSE
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ subSet($exposedType$ fromElement,$exposedType$ toElement){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniNavigableSet.OfRef<E> subSet($exposedType$ fromElement, boolean fromInclusive, $exposedType$ toElement, boolean toInclusive){
#ELSE
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ subSet($exposedType$ fromElement, boolean fromInclusive, $exposedType$ toElement, boolean toInclusive){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniIterator.OfRef<E> descendingIterator(){
#ELSE
@Override public OmniIterator.Of$ClassPrefix$$<E>$ descendingIterator(){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IF OfComparable
@Override public OmniNavigableSet.OfRef<E> descendingSet(){
#ELSE
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ descendingSet(){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IFNOT OfComparable
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ headSet($BoxedType$ toElement){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ tailSet($BoxedType$ fromElement){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
@Override public OmniNavigableSet.Of$ClassPrefix$$<E>$ subSet($BoxedType$ fromElement,$BoxedType$ toElement){
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#ENDIF
#IF OfComparable
@SuppressWarnings("unchecked")
#ENDIF
@Override public Object clone(){
  int tail;
  if((tail=this.tail)!=-1){
    final $ArrayType$[] dst;
    final int head,cloneTail;
    int size;
    if((size=(++tail)-(head=this.head))>0){
      ArrCopy.uncheckedCopy(arr,head,dst=$NewArray$[size],0,size);
      cloneTail=size-1;
    }else{
      final $ArrayType$[] arr;
      dst=$NewArray$[size+=(arr=this.arr).length];
      cloneTail=size-1;
      ArrCopy.uncheckedCopy(arr,0,dst,size-=tail,tail);
      ArrCopy.uncheckedCopy(arr,head,dst,0,size);
    }
    return new DIRECTION$<E>$(0,dst,cloneTail);
  }
  return new DIRECTION$<E>$();
}
#IFSWITCH DIRECTION==Ascending
@Override public $TypeNameModifier$Comparator$<E>$ comparator(){
#IF OfComparable
  return Comparator.nullsLast(Comparable::compareTo);
#ELSE
  return $BoxedType$::compare;
#ENDIF
}

#ELSE
@Override public $TypeNameModifier$Comparator$<E>$ comparator(){
#IF OfComparable
  return Comparator.nullsFirst(Collections.reverseOrder());
#ELSE
  return $TypeNameModifier$Comparator::descendingCompare;
#ENDIF
}
#ENDIF
#IF OfComparable
@SuppressWarnings("unchecked")
@Override boolean uncheckedAddNull(int tail){
  //add at tail
  final $ArrayType$[] arr;
  #IFSWITCH DIRECTION==Ascending
  if((arr=this.arr)[tail]!=null){
    int head;
    switch(Integer.signum(++tail-(head=this.head))){
      case 0:
        //fragmented must grow
        int arrLength;
        final $ArrayType$[] tmp;
        ArrCopy.uncheckedCopy(arr,0,tmp=$NewArray$[head=OmniArray.growBy50Pct(arrLength=arr.length)],0,tail);
        ArrCopy.uncheckedCopy(arr,tail,tmp,head-=(arrLength-=tail),arrLength);
        this.head=head;
        this.arr=tmp;
        break;
      case 1:
        //nonfragmented
        if(tail==arr.length){
          if(0==head){
            //must grow
            ArrCopy.uncheckedCopy(arr,0,tmp=$NewArray$[head=OmniArray.growBy50Pct(tail)],0,tail);
            this.arr=tmp;
          }else{
            tail=0;
          }
        }
      default:
        //fragmented
    }
    this.tail=tail;
  #ELSE
  int head;
  if((arr=this.arr)[head=this.head]!=null){
    switch(Integer.signum(tail-(--head))){
      case 0:
        //fragmented must grow
        final $ArrayType$[] tmp;
        int arrLength;
        ArrCopy.uncheckedCopy(arr,0,tmp=$NewArray$[head=OmniArray.growBy50Pct(arrLength=arr.length)],0,++tail);
        ArrCopy.uncheckedCopy(arr,tail,tmp,head-=(arrLength-=tail),arrLength);
        --head;
        this.arr=tmp;
        break;
      default:
        //nonfragmented
        if(head==-1){
          if(tail==(head=arr.length-1)){
            //must grow
            this.tail=(head=OmniArray.growBy50Pct(++tail))-1;
            ArrCopy.uncheckedCopy(arr,0,tmp=$NewArray$[head],head-=tail,tail);
            --head;
            this.arr=tmp;
          }
        }
      case -1:
        //fragmented
    }
    this.head=head;
  #ENDIF
    return true;
  }
  return false;
}
@Override boolean uncheckedremoveNull(int tail){
  final $ArrayType$[] arr;
  #IFSWITCH DIRECTION==Ascending
  if((arr=this.arr)[tail]==null){
    if(tail==this.head){
  #ELSE
  int head;
  if((arr=this.arr)[head=this.head]==null){
    if(tail==head){
  #ENDIF
      tail=-1;
    }else if(--tail==-1){
      tail=arr.length-1;
    }
    this.tail=tail;
    return true;
  }
  return false;
}
#MACRO ObjectContainsRef(Object)
#MACRO ObjectContainsRef(Boolean)
#MACRO ObjectContainsRef(Byte)
#MACRO ObjectContainsRef(Character)
#MACRO ObjectContainsRef(Short)
#MACRO ObjectContainsRef(Integer)
#MACRO ObjectContainsRef(Long)
#MACRO ObjectContainsRef(Float)
#MACRO ObjectContainsRef(Double)
@Override $TypeNameModifier$ToIntFunction$<E>$ getQueryComparator($exposedType$ key){
  #IFSWITCH DIRECTION==Ascending
  return (k)->Integer.signum(-k.compareTo(key));
  #ELSE
  return (k)->Integer.signum(k.compareTo(key));
  #ENDIF
}
#ENDIF
#ENDDEF
#MACRODEF AddJustAfterHead(BOTTOMVAL,NEXTVAL)
//add just after head
int newHead;
switch(Integer.signum(tail-(newHead=head-1))){
  case 0:
    //fragmented must grow
    final $ArrayType$[] tmp;
    int arrLength;
    ArrCopy.uncheckedCopy(arr,0,tmp=$NewArray$[tail=OmniArray.growBy50Pct(arrLength=arr.length)],0,head);
    ArrCopy.semicheckedCopy(arr,head,tmp,head=tail-(arrLength-=(head+1)),arrLength);
    --head;
    newHead=head-1;
    this.arr=arr=tmp;
    break;
  default:
    //nonfragmented
    if(newHead==-1){
      if(tail==(newHead=(tail=arr.length)-1)){
        //must grow
        this.tail=(head=OmniArray.growBy50Pct(tail))-1;
        ArrCopy.semicheckedCopy(arr,0,arr=$NewArray$[head],head-=newHead,newHead);
        --head;
        this.arr=arr;
      }
      newHead=head-1;
    }
  case -1:
    //fragmented
}
arr[head]=NEXTVAL;
arr[newHead]=BOTTOMVAL;
this.head=newHead;
#ENDDEF
#MACRODEF AddJustBeforeTail(TOPVAL,NEXTVAL)
//add it before the tail
int newTail;
switch(Integer.signum((newTail=tail+1)-head)){
  case 0:
    //fragmented must grow
    final $ArrayType$[] tmp;
    int arrLength;
    ArrCopy.semicheckedCopy(arr,0,tmp=$NewArray$[head=OmniArray.growBy50Pct(arrLength=arr.length)],0,tail);
    ArrCopy.uncheckedCopy(arr,newTail,tmp,head-=(arrLength-=newTail),arrLength);
    this.head=head;
    this.arr=arr=tmp;
    break;
  default:
    //nonfragmented
    if(newTail==arr.length){
      if(head==0){
        //must grow
        ArrCopy.semicheckedCopy(arr,0,arr=$NewArray$[OmniArray.growBy50Pct(newTail)],0,tail);
        this.arr=arr;
      }else{
        newTail=0;
      }
    }
  case -1:
    //fragmented
}
arr[tail]=NEXTVAL;
arr[newTail]=TOPVAL;
this.tail=newTail;
#ENDDEF
#MACRODEF HigherLowerCeilingFloorImpl<TYPENAMEMODIFIER>(RETTYPE,DEFAULTVAL,PARAMTYPE)
#IFSWITCH TYPENAMEMODIFIER==NATIVETYPE
  #IF OfComparable
@SuppressWarnings("unchecked")
@Override public RETTYPE ceiling(PARAMTYPE val){
  #ELSE
@Override public RETTYPE PARAMTYPECeiling(PARAMTYPE val){
  #ENDIF
#ELSEIFSWITCH TYPENAMEMODIFIER==BOXEDTYPE
@Override public RETTYPE ceiling(PARAMTYPE val){
#ELSE
@Override public RETTYPE PARAMTYPECeiling(PARAMTYPE val){
#ENDIF
#IF OfComparable
  int tail;
  if(val!=null && (tail=this.tail)!=-1){
    final var arr=this.arr;
    int head;
    if((head=this.head)<=tail){
      //non-fragmented
      for(var mid=(head+tail)>>>1;;){
  #IFSWITCH DIRECTION==Ascending
        final $ArrayType$ tmp;
        if((tmp=arr[mid])==null){
          break;
        }
        switch(Integer.signum(tmp.compareTo(val))){
          case 0:
            return ($exposedType$)tmp;
          case -1:
            head=mid+1;
            break;
          default:
            tail=mid-1;
        }
        if((mid=(head+tail)>>>1)<head){
          return ($exposedType$)arr[head];
        }
  #ELSE
        
        //TODO
        throw new omni.util.NotYetImplementedException();
  #ENDIF
      }
    }else{
      //TODO
      throw new omni.util.NotYetImplementedException();
    }
  }
#ELSE
  //TODO
  throw new omni.util.NotYetImplementedException();
#ENDIF
  return DEFAULTVAL;
}
#IFSWITCH TYPENAMEMODIFIER==NATIVETYPE
  #IF OfComparable
@Override public RETTYPE floor(PARAMTYPE val){
  #ELSE
@Override public RETTYPE PARAMTYPEFloor(PARAMTYPE val){
  #ENDIF
#ELSEIFSWITCH TYPENAMEMODIFIER==BOXEDTYPE
@Override public RETTYPE floor(PARAMTYPE val){
#ELSE
@Override public RETTYPE PARAMTYPEFloor(PARAMTYPE val){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IFSWITCH TYPENAMEMODIFIER==NATIVETYPE
@Override public RETTYPE higher$TypeNameModifier$(PARAMTYPE val){
#ELSEIFSWITCH TYPENAMEMODIFIER==BOXEDTYPE
@Override public RETTYPE higher(PARAMTYPE val){
#ELSE
@Override public RETTYPE higherTYPENAMEMODIFIER(PARAMTYPE val){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#IFSWITCH TYPENAMEMODIFIER==NATIVETYPE
@Override public RETTYPE lower$TypeNameModifier$(PARAMTYPE val){
#ELSEIFSWITCH TYPENAMEMODIFIER==BOXEDTYPE
@Override public RETTYPE lower(PARAMTYPE val){
#ELSE
@Override public RETTYPE lowerTYPENAMEMODIFIER(PARAMTYPE val){
#ENDIF
  //TODO
  throw new omni.util.NotYetImplementedException();
}
#ENDDEF
#MACRODEF ObjectContainsRef(PARAMTYPE)
#IF OfComparable
@SuppressWarnings("unchecked")
@Override public boolean contains(PARAMTYPE key){
  final int tail;
  if((tail=this.tail)!=-1){
    if(key!=null){
      return super.uncheckedContainsMatch(this.head,tail,this.getQueryComparator(($exposedType$)key));
    }
  #IFSWITCH DIRECTION==Ascending
    return arr[tail]==null;
  #ELSE
    return arr[head]==null;
  #ENDIF
  }
  return false;
}
#ENDIF
#ENDDEF
