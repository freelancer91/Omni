#TYPEDEF OfBoolean
  packagename = ofboolean
  AbstractList = AbstractBooleanList
  <E> = 
  ArrayType = boolean
  DEFAULT_ARR = OmniArray.OfBoolean.DEFAULT_ARR
  Consumer = BooleanConsumer
  BoxedType = Boolean
  getMethod = getBoolean
  removeAtIndexMethod = removeBooleanAt
  exposedType = boolean
  castToDouble = TypeUtil.castToDouble
  castToFloat = TypeUtil.castToFloat
  castToLong = TypeUtil.castToLong
  castToInt = (int)TypeUtil.castToByte
  castToShort = (short)TypeUtil.castToByte
  castToChar = TypeUtil.castToChar
  castToByte = TypeUtil.castToByte
  Predicate = BooleanPredicate
  BoxedArrayType = Boolean
  DEFAULT_BOXED_ARR = OmniArray.OfBoolean.DEFAULT_BOXED_ARR
  queryParameterType = boolean
  queryCastBoolean = 
  queryCastRef = (boolean)
#ENDDEF
#TYPEDEF OfByte
  packagename = ofbyte
  AbstractList = AbstractByteList
  <E> = 
  ArrayType = byte
  DEFAULT_ARR = OmniArray.OfByte.DEFAULT_ARR
  Consumer = ByteConsumer
  BoxedType = Byte
  getMethod = getByte
  removeAtIndexMethod = removeByteAt
  exposedType = byte
  castToDouble = (double)
  castToFloat = (float)
  castToLong =(long)
  castToInt = (int)
  castToShort = (short)
  castToByte = (byte)
  Predicate = BytePredicate
  BoxedArrayType = Byte
  DEFAULT_BOXED_ARR = OmniArray.OfByte.DEFAULT_BOXED_ARR
  queryParameterType = int
  queryCastBoolean = TypeUtil.castToByte
  queryCastPrimitive = 
  queryCastRef = (byte)
#ENDDEF
#TYPEDEF OfChar
  packagename = ofchar
  AbstractList = AbstractCharList
  <E> = 
  ArrayType = char
  DEFAULT_ARR = OmniArray.OfChar.DEFAULT_ARR
  Consumer = CharConsumer
  BoxedType = Character
  getMethod = getChar
  removeAtIndexMethod = removeCharAt
  exposedType = char
  castToDouble = (double)
  castToFloat = (float)
  castToLong =(long)
  castToInt = (int)
  castToChar = (char)
  Predicate = CharPredicate
  BoxedArrayType = Character
  DEFAULT_BOXED_ARR = OmniArray.OfChar.DEFAULT_BOXED_ARR
  queryParameterType = int
  queryCastBoolean = TypeUtil.castToChar
  queryCastPrimitive = 
  queryCastRef = (char)
#ENDDEF
#TYPEDEF OfShort
  packagename = ofshort
  AbstractList = AbstractShortList
  <E> = 
  ArrayType = short
  DEFAULT_ARR = OmniArray.OfShort.DEFAULT_ARR
  Consumer = ShortConsumer
  BoxedType = Short
  getMethod = getShort
  removeAtIndexMethod = removeShortAt
  exposedType = short
  castToDouble = (double)
  castToFloat = (float)
  castToLong =(long)
  castToInt = (int)
  castToShort = (short)
  Predicate = ShortPredicate
  BoxedArrayType = Short
  DEFAULT_BOXED_ARR = OmniArray.OfShort.DEFAULT_BOXED_ARR
  queryParameterType = int
  queryCastBoolean = (short)TypeUtil.castToByte
  queryCastPrimitive = 
  queryCastRef = (short)
#ENDDEF
#TYPEDEF OfInt
  packagename = ofint
  AbstractList = AbstractIntList
  <E> = 
  ArrayType = int
  DEFAULT_ARR = OmniArray.OfInt.DEFAULT_ARR
  Consumer = IntConsumer
  BoxedType = Integer
  getMethod = getInt
  removeAtIndexMethod = removeIntAt
  exposedType = int
  castToDouble = (double)
  castToFloat = (float)
  castToLong =(long)
  castToInt = (int)
  Predicate = IntPredicate
  BoxedArrayType = Integer
  DEFAULT_BOXED_ARR = OmniArray.OfInt.DEFAULT_BOXED_ARR
  queryParameterType = int
  queryCastBoolean = (int)TypeUtil.castToByte
  queryCastPrimitive = 
  queryCastRef = (int)
#ENDDEF
#TYPEDEF OfLong
  packagename = oflong
  AbstractList = AbstractLongList
  <E> = 
  ArrayType = long
  DEFAULT_ARR = OmniArray.OfLong.DEFAULT_ARR
  Consumer = LongConsumer
  BoxedType = Long
  getMethod = getLong
  removeAtIndexMethod = removeLongAt
  exposedType = long
  castToDouble = (double)
  castToFloat = (float)
  castToLong =(long)
  Predicate = LongPredicate
  BoxedArrayType = Long
  DEFAULT_BOXED_ARR = OmniArray.OfLong.DEFAULT_BOXED_ARR
  queryParameterType = long
  queryCastBoolean = TypeUtil.castToLong
  queryCastPrimitive = 
  queryCastRef = (long)
#ENDDEF
#TYPEDEF OfFloat
  packagename = offloat
  AbstractList = AbstractFloatList
  <E> = 
  ArrayType = float
  DEFAULT_ARR = OmniArray.OfFloat.DEFAULT_ARR
  Consumer = FloatConsumer
  BoxedType = Float
  getMethod = getFloat
  removeAtIndexMethod = removeFloatAt
  exposedType = float
  castToDouble = (double)
  castToFloat = (float)
  Predicate = FloatPredicate
  BoxedArrayType = Float
  DEFAULT_BOXED_ARR = OmniArray.OfFloat.DEFAULT_BOXED_ARR
  queryParameterType = int
  TRUE_BITS = TypeUtil.FLT_TRUE_BITS
  convertToBits = Float.floatToRawIntBits
  queryCastPrimitive = 
  queryCastRef = (float)
#ENDDEF
#TYPEDEF OfDouble
  packagename = ofdouble
  AbstractList = AbstractDoubleList
  <E> = 
  ArrayType = double
  DEFAULT_ARR = OmniArray.OfDouble.DEFAULT_ARR
  Consumer = DoubleConsumer
  BoxedType = Double
  getMethod = getDouble
  removeAtIndexMethod = removeDoubleAt
  exposedType = double
  castToDouble = (double)
  Predicate = DoublePredicate
  BoxedArrayType = Double
  DEFAULT_BOXED_ARR = OmniArray.OfDouble.DEFAULT_BOXED_ARR
  queryParameterType = long
  TRUE_BITS = TypeUtil.DBL_TRUE_BITS
  convertToBits = Double.doubleToRawLongBits
  queryCastPrimitive = 
  queryCastRef = (double)
#ENDDEF
#TYPEDEF OfRef
  packagename = ofref
  AbstractList = AbstractRefList
  <E> = <E>
  ArrayType = Object
  DEFAULT_ARR = OmniArray.OfRef.DEFAULT_ARR
  Consumer = Consumer<? super E>
  BoxedType = E
  exposedType = E
  Predicate = Predicate<? super E>
  BoxedArrayType = Object
  DEFAULT_BOXED_ARR = OmniArray.OfRef.DEFAULT_ARR
  queryCastBoolean = OmniPred.OfRef.getEqualsPred
  queryCastPrimitive = OmniPred.OfRef.getEqualsPred
  queryCastRef = OmniPred.OfRef.getEqualsPred
#ENDDEF
package omni.impl.seq.arr.$packagename$;
import omni.impl.CheckedCollection;
import omni.impl.seq.$AbstractList$;
import omni.impl.seq.arr.ArrSeqUtil;
import omni.util.OmniArray;
import omni.util.ArrCopy;
import java.util.function.IntFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;
#IF OfRef
import java.util.Objects;
import omni.util.OmniPred;
#ELSE
  #IF OfDouble,OfLong,OfInt
import java.util.function.$Consumer$;
import java.util.function.$Predicate$;
  #ELSE
import omni.function.$Consumer$;
import omni.function.$Predicate$;
  #ENDIF
import omni.util.TypeUtil;
#ENDIF
#IFNOT OfBoolean
import omni.util.BitSetUtils;
#ENDIF  
abstract class AbstractSeq$<E>$ extends $AbstractList$$<E>$
{
  transient $ArrayType$[] arr;
  private AbstractSeq()
  {
    super();
    this.arr=$DEFAULT_ARR$;
  }
  private AbstractSeq(int capacity)
  {
    super();
    switch(capacity){
    default:
      this.arr=new $ArrayType$[capacity];
      return;
    case OmniArray.DEFAULT_ARR_SEQ_CAP:
      this.arr=$DEFAULT_ARR$;
    case 0:
    }
  }
  private AbstractSeq(int size,$ArrayType$[] arr)
  {
    super(size);
    this.arr=arr;
  }
#IFNOT OfRef
  @Override
  public $exposedType$ $getMethod$(int index)
  {
    return arr[index];
  }
  @Override
  public $exposedType$ set(int index,$exposedType$ val)
  {
    final $ArrayType$[] arr;
    final var oldVal=(arr=this.arr)[index];
    arr[index]=val;
    return oldVal;
  }
#ENDIF
#MACRODEF BasicQuery(retType,methodName,paramType,negRet,target,methodParams)
  public retType methodName(final paramType val)
  {
    final int size;
    if((size=this.size)!=0)
    {
      return target.uncheckedmethodName(methodParams);
    }
    return negRet;
  }
#ENDDEF
#IF OfRef
  #MACRO BasicQuery(boolean,contains,Boolean,false,ArrSeqUtil,arr\,0\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,contains,Byte,false,ArrSeqUtil,arr\,0\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,contains,Character,false,ArrSeqUtil,arr\,0\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,contains,Short,false,ArrSeqUtil,arr\,0\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,contains,Integer,false,ArrSeqUtil,arr\,0\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,contains,Long,false,ArrSeqUtil,arr\,0\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,contains,Float,false,ArrSeqUtil,arr\,0\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,contains,Double,false,ArrSeqUtil,arr\,0\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,indexOf,Boolean,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,indexOf,Byte,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,indexOf,Character,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,indexOf,Short,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,indexOf,Integer,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,indexOf,Long,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,indexOf,Float,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,indexOf,Double,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,search,Boolean,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,search,Byte,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,search,Character,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,search,Short,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,search,Integer,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,search,Long,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,search,Float,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(int,search,Double,-1,ArrSeqUtil,arr\,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,removeVal,Boolean,false,this,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,removeVal,Byte,false,this,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,removeVal,Character,false,this,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,removeVal,Short,false,this,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,removeVal,Integer,false,this,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,removeVal,Long,false,this,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,removeVal,Float,false,this,size\,OmniPred.OfRef.getEqualsPred(val))
  #MACRO BasicQuery(boolean,removeVal,Double,false,this,size\,OmniPred.OfRef.getEqualsPred(val))
#ENDIF
  public boolean remove(Object val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfRef
      if(val!=null)
      {
        return this.uncheckedremoveValNonNull(size,val);
      }
      return this.uncheckedremoveVal(size,Objects::isNull);
#ELSE
      if(val instanceof $BoxedType$)
      {
        return this.uncheckedremoveVal(size,$queryCastRef$(val));
      }
#ENDIF
    }
    return false;
  }
#MACRODEF QueryObject(retType,methodName,negRet,methodParams)
  public retType methodName(Object val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IFNOT OfRef
      if(val instanceof $BoxedType$)
#ENDIF
      {
        return ArrSeqUtil.uncheckedmethodName(arr,methodParams,$queryCastRef$(val));
      }
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryObject(boolean,contains,false,0\,size)
#MACRO QueryObject(int,indexOf,-1,size)
#MACRO QueryObject(int,search,-1,size)
#MACRODEF QueryBoolean(retType,methodName,target,negRet,methodParams)
  public retType methodName(boolean val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfDouble,OfFloat
      if(val)
      {
        return target.uncheckedmethodNameBits(methodParams,$TRUE_BITS$);
      }
      return target.uncheckedmethodName0(methodParams);
#ELSE
      return target.uncheckedmethodName(methodParams,$queryCastBoolean$(val));
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryBoolean(boolean,contains,ArrSeqUtil,false,arr\,0\,size)
#MACRO QueryBoolean(boolean,removeVal,this,false,size)
#MACRO QueryBoolean(int,indexOf,ArrSeqUtil,-1,arr\,size)
#MACRO QueryBoolean(int,search,ArrSeqUtil,-1,arr\,size)
#IF OfRef,OfByte
  #MACRO BasicQuery(boolean,contains,byte,false,ArrSeqUtil,arr\,0\,size\,\$queryCastPrimitive\$(val))
  #MACRO BasicQuery(boolean,removeVal,byte,false,this,size\,\$queryCastPrimitive\$(val))
  #MACRO BasicQuery(int,indexOf,byte,-1,ArrSeqUtil,arr\,size\,\$queryCastPrimitive\$(val))
  #MACRO BasicQuery(int,search,byte,-1,ArrSeqUtil,arr\,size\,\$queryCastPrimitive\$(val))
#ENDIF
#IFNOT OfDouble,OfLong,OfInt,OfBoolean
#MACRODEF QueryChar(retType,methodName,target,negRet,methodParams)
  public retType methodName(char val)
  {
#IF OfByte,OfShort
    if(val<=$BoxedType$.MAX_VALUE)
#ENDIF
    {
      final int size;
      if((size=this.size)!=0)
      {
#IF OfFloat
        return target.uncheckedmethodNameRawInt(methodParams,val);
#ELSE
        return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ENDIF
      }
    }
    return negRet;
  }
#ENDDEF
  #IFNOT OfFloat
    #MACRO QueryChar(boolean,contains,ArrSeqUtil,false,arr\,0\,size)
    #MACRO QueryChar(boolean,removeVal,this,false,size)
  #ENDIF
  #MACRO QueryChar(int,indexOf,ArrSeqUtil,-1,arr\,size)
  #MACRO QueryChar(int,search,ArrSeqUtil,-1,arr\,size)
#ENDIF
#IF OfRef,OfFloat,OfShort,OfChar
#MACRODEF QueryShort(retType,methodName,target,negRet,methodParams)
  public retType methodName(short val)
  {
#IF OfChar
    if(val>=0)
#ENDIF
    {
      final int size;
      if((size=this.size)!=0)
      {
#IF OfFloat
        return target.uncheckedmethodNameRawInt(methodParams,val);
#ELSE
        return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ENDIF
      }
    }
    return negRet;
  }
#ENDDEF
  #IFNOT OfFloat
    #IFNOT OfRef
  @Override
    #ENDIF
    #MACRO QueryShort(boolean,contains,ArrSeqUtil,false,arr\,0\,size)
    #IFNOT OfRef
  @Override
    #ENDIF
    #MACRO QueryShort(boolean,removeVal,this,false,size)
  #ENDIF
  #MACRO QueryShort(int,indexOf,ArrSeqUtil,-1,arr\,size)
  #MACRO QueryShort(int,search,ArrSeqUtil,-1,arr\,size)
#ENDIF
#MACRODEF QueryInt(retType,methodName,target,negRet,methodParams)
  public retType methodName(int val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfDouble,OfFloat
      if(val!=0)
      {
  #IF OfFloat
        if(TypeUtil.checkCastToFloat(val))
        {
          return target.uncheckedmethodNameBits(methodParams,$convertToBits$(val));
        }
  #ENDIF
      }
      else
      {
        return target.uncheckedmethodName0(methodParams);
      }
#ELSEIF OfBoolean
      final boolean v;
      switch(val){
        default:
          return negRet;
        case 0:
          v=false;
          break;
        case 1:
          v=true;
      }
      return target.uncheckedmethodName(methodParams,v);
#ELSE
  #IF OfShort,OfChar,OfByte
      if(val==($exposedType$)val)
  #ENDIF
      {
        return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
      }
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#IF OfDouble,OfLong,OfInt
  @Override
#ENDIF
#MACRO QueryInt(boolean,contains,ArrSeqUtil,false,arr\,0\,size)
#IF OfDouble,OfLong,OfInt
  @Override
#ENDIF
#MACRO QueryInt(boolean,removeVal,this,false,size)
#MACRO QueryInt(int,indexOf,ArrSeqUtil,-1,arr\,size)
#MACRO QueryInt(int,search,ArrSeqUtil,-1,arr\,size)
#MACRODEF QueryLong(retType,methodName,target,negRet,methodParams)
  public retType methodName(long val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfRef,OfLong
      return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ELSEIF OfDouble,OfFloat
      if(val!=0)
      {
        if(TypeUtil.checkCastTo$BoxedType$(val))
        {
          return target.uncheckedmethodNameBits(methodParams,$convertToBits$(val));
        }
      }
      else
      {
         return target.uncheckedmethodName0(methodParams);
      }
#ELSE
      final $exposedType$ v;
  #IF OfBoolean
      if(val==0){
        v=false;
      }else if(val==1){
        v=true;
      }else{
        return negRet;
      }
  #ELSE
      if(val==(v=($exposedType$)val))
  #ENDIF
      {
        return target.uncheckedmethodName(methodParams,v);
      }
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryLong(boolean,contains,ArrSeqUtil,false,arr\,0\,size)
#MACRO QueryLong(boolean,removeVal,this,false,size)
#MACRO QueryLong(int,indexOf,ArrSeqUtil,-1,arr\,size)
#MACRO QueryLong(int,search,ArrSeqUtil,-1,arr\,size)
#MACRODEF QueryFloat(retType,methodName,target,negRet,methodParams)
  public retType methodName(float val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfRef,OfFloat
      return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ELSEIF OfDouble
      if(val==val)
      {
        return target.uncheckedmethodNameBits(methodParams,$convertToBits$(val));
      }
      return target.uncheckedmethodNameNaN(methodParams);  
#ELSE
      final $exposedType$ v;
  #IF OfLong
      if(TypeUtil.floatEquals(val,v=(long)val))
  #ELSEIF OfInt
      if((double)val==(double)(v=(int)val))
  #ELSEIF OfBoolean
      switch(Float.floatToRawIntBits(val)){
        default:
          return negRet;
        case 0:
        case Integer.MIN_VALUE:
          v=false;
          break;
        case TypeUtil.FLT_TRUE_BITS:
          v=true;
      }
  #ELSE
      if(val==(v=($exposedType$)val))
  #ENDIF 
      {
        return target.uncheckedmethodName(methodParams,v);
      }
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryFloat(boolean,contains,ArrSeqUtil,false,arr\,0\,size)
#MACRO QueryFloat(boolean,removeVal,this,false,size)
#MACRO QueryFloat(int,indexOf,ArrSeqUtil,-1,arr\,size)
#MACRO QueryFloat(int,search,ArrSeqUtil,-1,arr\,size)
#MACRODEF QueryDouble(retType,methodName,target,negRet,methodParams)
  public retType methodName(double val)
  {
    final int size;
    if((size=this.size)!=0)
    {
#IF OfRef,OfDouble
      return target.uncheckedmethodName(methodParams,$queryCastPrimitive$(val));
#ELSE
      final $exposedType$ v;
  #IF OfFloat
      if(val==(v=($exposedType$)val))
      {
        return target.uncheckedmethodNameBits(methodParams,$convertToBits$(v));
      }
      else if(v!=v)
      {
        return target.uncheckedmethodNameNaN(methodParams);
      }
  #ELSE
    #IF OfBoolean
      final long bits;
      if((bits=Double.doubleToRawLongBits(val))==0||bits==Long.MIN_VALUE){
        v=false;
      }else if(bits==TypeUtil.DBL_TRUE_BITS){
        v=true;
      }else{
        return negRet;
      }
    #ELSE
      if(val==(v=($exposedType$)val))
    #ENDIF
      {
        return target.uncheckedmethodName(methodParams,v);
      }
  #ENDIF
#ENDIF
    }
    return negRet;
  }
#ENDDEF
#MACRO QueryDouble(boolean,contains,ArrSeqUtil,false,arr\,0\,size)
#MACRO QueryDouble(boolean,removeVal,this,false,size)
#MACRO QueryDouble(int,indexOf,ArrSeqUtil,-1,arr\,size)
#MACRO QueryDouble(int,search,ArrSeqUtil,-1,arr\,size)
  public void forEach($Consumer$ action)
  {
    final int size;
    if((size=this.size)!=0)
    {
      uncheckedForEach(size,action);
    }
  }
  abstract void uncheckedForEach(int size,$Consumer$ action);
  public boolean removeIf($Predicate$ filter)
  {
    final int size;
    return (size=this.size)!=0 && uncheckedRemoveIf(size,filter);
  }
  abstract boolean uncheckedRemoveIf(int size,$Predicate$ filter);
#IFNOT OfRef
  public void forEach(Consumer<? super $BoxedType$> action)
  {
    final int size;
    if((size=this.size)!=0)
    {
      uncheckedForEach(size,action::accept);
    }
  }
  public boolean removeIf(Predicate<? super $BoxedType$> filter)
  {
    final int size;
    return (size=this.size)!=0 && uncheckedRemoveIf(size,filter::test);
  }  
#ENDIF
  @Override
  public int hashCode()
  {
    final int size;
    if((size=this.size)!=0)
    {
      return uncheckedHashCode(size);
    }
    return 1;
  }
  abstract int uncheckedHashCode(int size);  
  @Override
  public String toString()
  {
    final int size;
    if((size=this.size)!=0){
      final StringBuilder builder;
      uncheckedToString(size,builder=new StringBuilder("["));
      return builder.append(']').toString();
    }
    return "[]";
  }
  abstract void uncheckedToString(int size,StringBuilder builder);
#MACRODEF Peek(retType,Suffix,emptyVal,cast)
  public retType peekSuffix()
  {
    final int size;
    if((size=this.size)!=0)
    {
      return cast(arr[size-1]);
    }
    return emptyVal;
  }
#ENDDEF
#IF OfRef
  @SuppressWarnings("unchecked")
#ENDIF
#MACRO Peek(\$BoxedType\$,,null,(\$BoxedType\$))
#IFNOT OfRef
  #MACRO Peek(double,Double,Double.NaN,\$castToDouble\$)
  #IFNOT OfDouble
    #MACRO Peek(float,Float,Float.NaN,\$castToFloat\$)
    #IFNOT OfFloat
      #MACRO Peek(long,Long,Long.MIN_VALUE,\$castToLong\$)
      #IFNOT OfLong
        #MACRO Peek(int,Int,Integer.MIN_VALUE,\$castToInt\$)
        #IFNOT OfInt,OfChar
          #MACRO Peek(short,Short,Short.MIN_VALUE,\$castToShort\$)
          #IFNOT OfShort
            #MACRO Peek(byte,Byte,Byte.MIN_VALUE,\$castToByte\$)
            #IFNOT OfByte
              #MACRO Peek(boolean,Boolean,false,(boolean))
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
      #IF OfChar,OfBoolean
        #MACRO Peek(char,Char,Character.MIN_VALUE,\$castToChar\$)
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  public void push($exposedType$ val)
  {
    final int size;
    if((size=this.size)!=0)
    {
      uncheckedAppend(val,size);
    }
    else
    {
      uncheckedInit(val);
    }
  }
  private $ArrayType$[] growInsert($ArrayType$[] arr,int index,int size){
    if(arr.length==size)
    {
      ArrCopy.semicheckedCopy(arr,0,arr=new $ArrayType$[OmniArray.growBy50Pct(size)],0,index);
      this.arr=arr;
    }
    return arr;
  }
  private void uncheckedAppend($exposedType$ val,int size){
    $ArrayType$[] arr;
    if((arr=this.arr).length==size)
    {
      ArrCopy.uncheckedCopy(arr,0,arr=new $ArrayType$[OmniArray.growBy50Pct(size)],0,size);
    }
    arr[size]=val;
    this.size=size+1;
  }
  private void uncheckedInit($exposedType$ val){
    $ArrayType$[] arr;
    if((arr=this.arr)==$DEFAULT_ARR$)
    {
      this.arr=arr=new $ArrayType$[OmniArray.DEFAULT_ARR_SEQ_CAP];
    }
    else if(arr==null)
    {
      this.arr=arr=new $ArrayType$[1];
    }
    arr[0]=val;
    size=1;
  }
  private void uncheckedInsert(int index,$exposedType$ val,int size){
    final int tailDist;
    if((tailDist=size-index)==0){
      uncheckedAppend(val,size);
    }else{
      $ArrayType$[] arr;
      ArrCopy.uncheckedCopy(arr=this.arr,index,arr=growInsert(arr,index,size),index+1,tailDist);
      arr[index]=val;
      this.size=size+1;
    }
  }
#IF OfRef
  abstract boolean uncheckedremoveVal(int size,Predicate<Object> pred);
  abstract boolean uncheckedremoveValNonNull(int size,Object nonNull);
#ELSEIF OfDouble,OfFloat
  abstract boolean uncheckedremoveVal0(int size);
  abstract boolean uncheckedremoveValBits(int size,$queryParameterType$ bits);
  abstract boolean uncheckedremoveValNaN(int size);
  private boolean uncheckedremoveVal(int size,$exposedType$ val)
  {
    if(val==val)
    {
      return uncheckedremoveValBits(size,$convertToBits$(val));
    }
    return uncheckedremoveValNaN(size);
  }
  #IF OfFloat
  @Override
  protected boolean containsRawInt(int val)
  {
    final int size;
    if((size=this.size)!=0)
    {
      return ArrSeqUtil.uncheckedcontainsRawInt(arr,0,size,val);
    }
    return false;
  }
  @Override
  protected boolean removeRawInt(int val)
  {
    final int size;
    if((size=this.size)!=0)
    {
       if(val!=0)
       {
         return uncheckedremoveValBits(size,$convertToBits$(val));
       }
       return uncheckedremoveVal0(size);
    }
    return false;
  }
  #ENDIF
#ELSE
  abstract boolean uncheckedremoveVal(int size,$queryParameterType$ val);
#ENDIF
#MACRODEF ToArray(retType,Name,defaultArr)
  public retType[] toNameArray()
  {
    final int size;
    if((size=this.size)!=0)
    {
      final retType[] dst;
      uncheckedCopyInto(dst=new retType[size],size);
      return dst;
    }
    return defaultArr;
  }
#ENDDEF
#MACRO ToArray(\$BoxedArrayType\$,,\$DEFAULT_BOXED_ARR\$)
  public <T> T[] toArray(IntFunction<T[]> arrConstructor){
    final int size;
    final T[] dst=arrConstructor.apply(size=this.size);
    if(size!=0){
      uncheckedCopyInto(dst,size);
    }
    return dst;
  }
  public <T> T[] toArray(T[] dst){
    final int size;
    if((size=this.size)!=0){
      uncheckedCopyInto(dst=OmniArray.uncheckedArrResize(size,dst),size);
    }else if(dst.length!=0){
      dst[0]=null;
    }
    return dst;
  }
  abstract void uncheckedCopyInto($BoxedArrayType$[] dst,int length);
#IFNOT OfRef
  #MACRO ToArray(double,Double,OmniArray.OfDouble.DEFAULT_ARR)
  abstract void uncheckedCopyInto(Object[] dst,int length);
  abstract void uncheckedCopyInto(double[] dst,int size);
  #IFNOT OfDouble
    #MACRO ToArray(float,Float,OmniArray.OfFloat.DEFAULT_ARR)
  abstract void uncheckedCopyInto(float[] dst,int size);
    #IFNOT OfFloat
      #MACRO ToArray(long,Long,OmniArray.OfLong.DEFAULT_ARR)
  abstract void uncheckedCopyInto(long[] dst,int size);
      #IFNOT OfLong
        #MACRO ToArray(int,Int,OmniArray.OfInt.DEFAULT_ARR)
  abstract void uncheckedCopyInto(int[] dst,int size);
        #IFNOT OfInt,OfChar
          #MACRO ToArray(short,Short,OmniArray.OfShort.DEFAULT_ARR)
  abstract void uncheckedCopyInto(short[] dst,int size);
          #IFNOT OfShort
            #MACRO ToArray(byte,Byte,OmniArray.OfByte.DEFAULT_ARR)
  abstract void uncheckedCopyInto(byte[] dst,int size);
            #IFNOT OfByte
              #MACRO ToArray(boolean,Boolean,OmniArray.OfBoolean.DEFAULT_ARR)
  abstract void uncheckedCopyInto(boolean[] dst,int size);
            #ENDIF     
          #ENDIF
        #ENDIF
        #IF OfChar,OfBoolean
          #MACRO ToArray(char,Char,OmniArray.OfChar.DEFAULT_ARR)
  abstract void uncheckedCopyInto(char[] dst,int size);
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#IF OfRef
  @Override
  protected int uncheckedlastIndexOf(int size,Predicate<Object> pred){
    return ArrSeqUtil.uncheckedlastIndexOf(arr,size,pred);
  }
  @Override
  protected int uncheckedlastIndexOfNonNull(int size,Object nonNull){
    return ArrSeqUtil.uncheckedlastIndexOf(arr,size,nonNull::equals);
  }
#ELSEIF OfDouble,OfFloat
  @Override
  protected int uncheckedlastIndexOf0(int size)
  {
    return ArrSeqUtil.uncheckedlastIndexOf0(arr,size);
  }
  @Override
  protected int uncheckedlastIndexOfBits(int size,$queryParameterType$ bits)
  {
    return ArrSeqUtil.uncheckedlastIndexOfBits(arr,size,bits);
  }
  @Override
  protected int uncheckedlastIndexOfNaN(int size)
  {
    return ArrSeqUtil.uncheckedlastIndexOfNaN(arr,size);
  }
#ELSE
  @Override
  protected int uncheckedlastIndexOf(int size,$queryParameterType$ val)
  {
    return ArrSeqUtil.uncheckedlastIndexOf(arr,size,val);
  }
#ENDIF
  $exposedType$ uncheckedPop(int newSize)
  {
    this.size=newSize;
#IF OfRef
    final $ArrayType$[] arr;
    @SuppressWarnings("unchecked") final var popped=($exposedType$)(arr=this.arr)[newSize];
    arr[newSize]=null;
    return popped;
#ELSE
    return arr[newSize];
#ENDIF
  }
  private int finalizeSubListBatchRemove($ArrayType$[] arr,int newBound,int oldBound){
    final int newRootSize,numRemoved;
#IF OfRef
    final int rootSize;
    size=newRootSize=(rootSize=size)-(numRemoved=oldBound-newBound);
#ELSE
    size=newRootSize=size-(numRemoved=oldBound-newBound);
#ENDIF
    ArrCopy.semicheckedCopy(arr,oldBound,arr,newBound,newRootSize-newBound);
#IF OfRef
    OmniArray.OfRef.nullifyRange(arr,newRootSize,rootSize-1);
#ENDIF
    return numRemoved;
  }
  static abstract class Checked$<E>$ extends AbstractSeq$<E>$
  {
    transient int modCount;
    Checked()
    {
      super();
    }
    Checked(int capacity)
    {
      super(capacity);
    }
    Checked(int size,$ArrayType$[] arr)
    {
      super(size,arr);
    }
#IFNOT OfRef
    @Override
#ENDIF
    public boolean add($exposedType$ val)
    {
      ++modCount;
      super.push(val);
      return true;
    }
#IFNOT OfRef
    @Override
    public $exposedType$ $removeAtIndexMethod$(int index)
    {
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      ++modCount;
      final $ArrayType$[] arr;
      final var removed=($exposedType$)(arr=this.arr)[index];
      ArrSeqUtil.eraseIndexHelper(arr,index,--size);
      this.size=size;
      return removed;
    }
#ENDIF
#IFNOT OfRef
    @Override
#ENDIF
    public void add(int index,$exposedType$ val)
    {
      CheckedCollection.checkLo(index);
      final int size;
      CheckedCollection.checkWriteHi(index,size=this.size);
      ++modCount;
      if(size!=0)
      {
        super.uncheckedInsert(index,val,size);
      }
      else
      {
        super.uncheckedInit(val);
      }
    }
    @Override
    public void clear()
    {
#IF OfRef
      final int size;
      if((size=this.size)!=0)
      {
        OmniArray.OfRef.nullifyRange(arr,0,size-1);
#ELSE
      if(size!=0)
      {
#ENDIF
        ++modCount;
        this.size=0;
      }
    }
    @Override
    public <T> T[] toArray(IntFunction<T[]> arrConstructor){
      return super.toArray(size->{
        final int modCount=this.modCount;
        try{
          return arrConstructor.apply(size);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      });
    }
#IF OfRef
    @Override
    public boolean contains(Object val)
    {
      final int size;
      if((size=this.size)!=0)
      {
        final var arr=this.arr;
        if(val!=null)
        {
          final int modCount=this.modCount;
          try
          {
            return ArrSeqUtil.uncheckedcontains(arr,0,size,val::equals);
          }
          finally
          {
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return ArrSeqUtil.uncheckedcontains(arr,0,size,Objects::isNull);
      }
      return false;
    }
    @SuppressWarnings("unchecked")
#ENDIF
    @Override
    boolean uncheckedRemoveIf(int size,$Predicate$ filter)
    {
      int srcOffset;
      final int modCount=this.modCount;
      try
      {
#IF OfBoolean
        final boolean[] arr;
        boolean v;
        if(filter.test(v=(arr=this.arr)[srcOffset=0]))
        {
          for(;;)
          {
            if(++srcOffset==size)
            {
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.size=0;
              break;
            }
            if(v^arr[srcOffset])
            {
              final boolean tmp=filter.test(v=!v);
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.size=tmp?0:ArrSeqUtil.pullSurvivorsDown(arr,0,srcOffset,size,v);
              break;
            }
          }
        }
        else
        {
          for(;;)
          {
            if(++srcOffset==size)
            {
              CheckedCollection.checkModCount(modCount,this.modCount);
              return false;
            }
            if(v^arr[srcOffset])
            {
              final boolean tmp=filter.test(!v);
              CheckedCollection.checkModCount(modCount,this.modCount);
              if(!tmp)
              {
                return false;
              }
              this.size=ArrSeqUtil.pullSurvivorsDown(arr,srcOffset,size,v);
              break;
            }
          }
        }
#ELSE
        srcOffset=0;
        final var arr=this.arr;
        for(;;)
        {
          if(filter.test(($exposedType$)arr[srcOffset]))
          {
            break;
          }
          if(++srcOffset==size)
          {
            CheckedCollection.checkModCount(modCount,this.modCount);
            return false;
          }
        }
        int dstOffset=srcOffset;
        for(;;)
        {
          if(++srcOffset==size)
          {
            CheckedCollection.checkModCount(modCount,this.modCount);
            break;
          }
          final $ArrayType$ v;
          if(!filter.test(($exposedType$)(v=arr[srcOffset])))
          {
            final long[] survivors;
            int numSurvivors;
            if((numSurvivors=size-++srcOffset)!=0)
            {
              numSurvivors=ArrSeqUtil.markSurvivors(arr,survivors=BitSetUtils.getBitSet(numSurvivors),srcOffset,size,filter);
              CheckedCollection.checkModCount(modCount,this.modCount);
              arr[dstOffset++]=v;
              if(numSurvivors!=0)
              {
                dstOffset=ArrSeqUtil.pullSurvivorsDown(arr,survivors,dstOffset,srcOffset,numSurvivors);
              }
            }
            else
            {
              CheckedCollection.checkModCount(modCount,this.modCount);
              arr[dstOffset++]=v;
            }
			break;
          }
        }
  #IF OfRef
        OmniArray.OfRef.nullifyRange(arr,dstOffset,--size);
        this.size=size;
  #ELSE
        this.size=size-1;
  #ENDIF
#ENDIF
      }
      catch(RuntimeException e)
      {
        throw CheckedCollection.checkModCount(modCount,this.modCount,e);
      }
      return true;
    }
    static abstract class AbstractBidirectionalItr$<E>$
    {
      transient int lastRet=-1;
      transient final Checked$<E>$ root;
      transient int cursor;
      transient int modCount;
      AbstractBidirectionalItr(Checked$<E>$ root)
      {
        this.root=root;
        this.modCount=root.modCount;
      }
      AbstractBidirectionalItr(Checked$<E>$ root,int cursor)
      {
        this.root=root;
        this.modCount=root.modCount;
        this.cursor=cursor;
      }
      public void add($exposedType$ val)
      {
        final Checked$<E>$ root;
        int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
        final int rootSize,cursor=this.cursor;
        if((rootSize=root.size)!=0)
        {
          ((AbstractSeq$<E>$)root).uncheckedInsert(cursor,val,rootSize);
        }
        else
        {
          ((AbstractSeq$<E>$)root).uncheckedInit(val);
        }
        root.modCount=++modCount;
        this.modCount=modCount;
        this.cursor=cursor+1;
        this.lastRet=-1;
      }
    }
    static abstract class AbstractSubList$<E>$ extends $AbstractList$$<E>$
    {
      private static $<E>$ void bubbleUpDecrementSize(AbstractSubList$<E>$ parent,int numToRemove)
      {
        while(parent!=null){
          parent.size-=numToRemove;
          ++parent.modCount;
          parent=parent.parent;
        }
      }
      private static $<E>$ void bubbleUpIncrementSize(AbstractSubList$<E>$ parent){
        while(parent!=null){
          ++parent.size;
          ++parent.modCount;
          parent=parent.parent;
        }
      }
      transient final Checked$<E>$ root;
      transient final AbstractSubList$<E>$ parent;
      transient final int rootOffset;
      transient int modCount;
      AbstractSubList(Checked$<E>$ root,AbstractSubList$<E>$ parent,int rootOffset,int size,int modCount)
      {
        super(size);
        this.root=root;
        this.parent=parent;
        this.rootOffset=rootOffset;
        this.modCount=modCount;
      }
      AbstractSubList(Checked$<E>$ root,int rootOffset,int size)
      {
        super(size);
        this.root=root;
        this.parent=null;
        this.rootOffset=rootOffset;
        this.modCount=root.modCount;
      }
#IF OfRef
      @Override
      protected int uncheckedlastIndexOf(int size,Predicate<Object> pred)
      {
        Checked<E> root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        int rootOffset;
        return ArrSeqUtil.uncheckedlastIndexOf(root.arr,rootOffset=this.rootOffset,rootOffset+size,pred);
      }
      @Override
      protected int uncheckedlastIndexOfNonNull(int size,Object nonNull)
      {
        final int modCount=this.modCount;
        final var root=this.root;
        try
        {
          int rootOffset;
          return ArrSeqUtil.uncheckedlastIndexOf(root.arr,rootOffset=this.rootOffset,rootOffset+size,
              nonNull::equals);
        }
        finally
        {
          CheckedCollection.checkModCount(modCount,root.modCount);
        }
      }
#ELSEIF OfDouble,OfFloat
      @Override
      protected int uncheckedlastIndexOf0(int size){
        Checked root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        final int rootOffset;
        return ArrSeqUtil.uncheckedlastIndexOf0(root.arr,rootOffset=this.rootOffset,rootOffset+size);
      }
      @Override
      protected int uncheckedlastIndexOfBits(int size,$queryParameterType$ bits){
        Checked root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        final int rootOffset;
        return ArrSeqUtil.uncheckedlastIndexOfBits(root.arr,rootOffset=this.rootOffset,rootOffset+size,bits);
      }
      @Override
      protected int uncheckedlastIndexOfNaN(int size){
        Checked root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        final int rootOffset;
        return ArrSeqUtil.uncheckedlastIndexOfNaN(root.arr,rootOffset=this.rootOffset,rootOffset+size);
      }
#ELSE
      @Override
      protected int uncheckedlastIndexOf(int size,$queryParameterType$ val){
        Checked root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        final int rootOffset;
        return ArrSeqUtil.uncheckedlastIndexOf(root.arr,rootOffset=this.rootOffset,rootOffset+size,val);
      }
#ENDIF
#IFNOT OfRef
      @Override
#ENDIF
      public boolean add($exposedType$ val)
      {
        final Checked$<E>$ root;
        int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
        final int rootSize;
        final int size=this.size;
        if((rootSize=root.size)!=0)
        {
          ((AbstractSeq$<E>$)root).uncheckedInsert(rootOffset+size,val,rootSize);
        }
        else
        {
          ((AbstractSeq$<E>$)root).uncheckedInit(val);
        }
        root.modCount=++modCount;
        this.modCount=modCount;
        bubbleUpIncrementSize(parent);
        this.size=size+1;
        return true;
      }
#IFNOT OfRef
      @Override
#ENDIF
      public void add(int index,$exposedType$ val)
      {
        final Checked$<E>$ root;
        int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
        CheckedCollection.checkLo(index);
        final int size;
        CheckedCollection.checkWriteHi(index,size=this.size);
        final int rootSize;
        if((rootSize=root.size)!=0)
        {
          ((AbstractSeq$<E>$)root).uncheckedInsert(rootOffset+index,val,rootSize);
        }
        else
        {
          ((AbstractSeq$<E>$)root).uncheckedInit(val);
        }
        root.modCount=++modCount;
        this.modCount=modCount;
        bubbleUpIncrementSize(parent);
        this.size=size+1;
      }
      @Override
      public void clear()
      {
        final var root=this.root;
        final int modCount=this.modCount;
        final int size;
        if((size=this.size)!=0)
        {
          CheckedCollection.checkModCount(modCount,root.modCount);
          this.modCount=modCount+1;
          this.size=0;
          bubbleUpDecrementSize(parent,size);
          final int newRootSize;
#IF OfRef 
          final int oldRootSize;
          root.size=newRootSize=(oldRootSize=root.size)-size;
#ELSE
          root.size=newRootSize=root.size-size;
#ENDIF
          final $ArrayType$[] arr;
          final int rootOffset;
          ArrCopy.semicheckedCopy(arr=root.arr,(rootOffset=this.rootOffset)+size,arr,rootOffset,newRootSize-rootOffset);
#IF OfRef
          OmniArray.OfRef.nullifyRange(arr,newRootSize,oldRootSize-1);
#ENDIF
        }
        else
        {
          CheckedCollection.checkModCount(modCount,root.modCount);
        }
      }
      @Override
      public boolean isEmpty()
      {
        CheckedCollection.checkModCount(this.modCount,root.modCount);
        return size==0;
      }
      @Override
      public int size()
      {
        CheckedCollection.checkModCount(this.modCount,root.modCount);
        return size;
      }
      public boolean removeIf($Predicate$ filter)
      {
        final int size;
        if((size=this.size)!=0)
        {
          return uncheckedRemoveIf(size,filter);
        }
        CheckedCollection.checkModCount(this.modCount,root.modCount);
        return false;
      }
#IFNOT OfRef
      public boolean removeIf(Predicate<? super $BoxedType$> filter)
      {
        final int size;
        if((size=this.size)!=0)
        {
          return uncheckedRemoveIf(size,filter::test);
        }
        CheckedCollection.checkModCount(this.modCount,root.modCount);
        return false;
      }
#ENDIF
#IF OfRef
      @SuppressWarnings("unchecked")
#ENDIF
      private boolean uncheckedRemoveIf(int size,$Predicate$ filter)
      {
        final Checked$<E>$ root=this.root;
        int modCount=this.modCount;
        int srcOffset;
        final int srcBound=(srcOffset=rootOffset)+size;
        int dstOffset;
        try
        {
#IF OfBoolean
          boolean v;
          final boolean[] arr;
          if(filter.test(v=(arr=root.arr)[srcOffset]))
          {
            dstOffset=srcOffset;
            for(;;)
            {
              if(++srcOffset==srcBound)
              {
                CheckedCollection.checkModCount(modCount,root.modCount);
                break;
              }
              if(v^arr[srcOffset])
              {
                final boolean tmp=filter.test(v=!v);
                CheckedCollection.checkModCount(modCount,root.modCount);
                if(!tmp)
                {
                  dstOffset=ArrSeqUtil.pullSurvivorsDown(arr,dstOffset,srcOffset,size,v);
                }
                break;
              }
            }
          }
          else
          {
            for(;;)
            {
              if(++srcOffset==srcBound)
              {
                CheckedCollection.checkModCount(modCount,root.modCount);
                return false;
              }
              if(v^arr[srcOffset])
              {
                final boolean tmp=filter.test(!v);
                CheckedCollection.checkModCount(modCount,root.modCount);
                if(!tmp)
                {
                  return false;
                }
                dstOffset=ArrSeqUtil.pullSurvivorsDown(arr,srcOffset,size,v);
                break;
              }
            }
          }
#ELSE
          final var arr=root.arr;
          for(;;)
          {
            if(filter.test(($exposedType$)arr[srcOffset]))
            {
              break;
            }
            if(++srcOffset==srcBound)
            {
              CheckedCollection.checkModCount(modCount,root.modCount);
              return false;
            }
          }
          dstOffset=srcOffset;
          for(;;)
          {
            if(++srcOffset==srcBound)
            {
              CheckedCollection.checkModCount(modCount,root.modCount);
              break;
            }
            final $ArrayType$ v;
            if(!filter.test(($exposedType$)(v=arr[srcOffset])))
            {
              final long[] survivors;
              int numSurvivors;
              if((numSurvivors=size-++srcOffset)!=0)
              {
                numSurvivors=ArrSeqUtil.markSurvivors(arr,survivors=BitSetUtils.getBitSet(numSurvivors),srcOffset,srcBound,filter);
                CheckedCollection.checkModCount(modCount,root.modCount);
                arr[dstOffset++]=v;
                if(numSurvivors!=0)
                {
                  dstOffset=ArrSeqUtil.pullSurvivorsDown(arr,survivors,dstOffset,srcOffset,numSurvivors);
                }
              }
              else
              {
                CheckedCollection.checkModCount(modCount,root.modCount);
                arr[dstOffset++]=v;
              }
			  break;
            }
          }
#ENDIF
          root.modCount=++modCount;
          this.modCount=modCount;
          this.size=size-(size=((AbstractSeq$<E>$)root).finalizeSubListBatchRemove(arr,dstOffset,srcBound));
          bubbleUpDecrementSize(parent,size);
        }
        catch(RuntimeException e)
        {
          throw CheckedCollection.checkModCount(modCount,root.modCount,e);
        }
        return true;
      }
      static abstract class AbstractBidirectionalItr$<E>$
      {
        transient final AbstractSubList$<E>$ parent;
        transient int cursor;
        transient int lastRet=-1;
        transient int modCount;
        AbstractBidirectionalItr(AbstractSubList$<E>$ parent,int modCount)
        {
          this.parent=parent;
          this.cursor=parent.rootOffset;
          this.modCount=modCount;
        }
        AbstractBidirectionalItr(AbstractSubList$<E>$ parent,int modCount,int cursor){
          this.parent=parent;
          this.cursor=cursor;
          this.modCount=modCount;
        }
        public void add($exposedType$ val)
        {
          final AbstractSubList$<E>$ parent;
          final Checked$<E>$ root;
          int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=(parent=this.parent).root).modCount);
          final int rootSize;
          final int cursor=this.cursor;
          if((rootSize=root.size)!=0){
            ((AbstractSeq$<E>$)root).uncheckedInsert(cursor,val,rootSize);
          }else{
            ((AbstractSeq$<E>$)root).uncheckedInit(val);
          }
          bubbleUpIncrementSize(parent.parent);
          parent.modCount=++modCount;
          root.modCount=modCount;
          ++parent.size;
          this.cursor=cursor+1;
          this.lastRet=-1;
        }
      }
    }
  }
  static abstract class Unchecked$<E>$ extends AbstractSeq$<E>$
  {
    Unchecked(){
      super();
    }
    Unchecked(int capacity){
      super(capacity);
    }
    Unchecked(int size,$ArrayType$[] arr){
      super(size,arr);
    }
#IFNOT OfRef
    @Override
#ENDIF
    public boolean add($exposedType$ val)
    {
      super.push(val);
      return true;
    }
#IFNOT OfRef
    @Override
#ENDIF
    public void add(int index,$exposedType$ val)
    {
      final int size;
      if((size=this.size)!=0)
      {
        super.uncheckedInsert(index,val,size);
      }
      else
      {
        super.uncheckedInit(val);
      }
    }
#IF OfRef
    @Override
    public void clear()
    {
      final int size;
      if((size=this.size)!=0)
      {
        OmniArray.OfRef.nullifyRange(arr,0,size-1);
        this.size=0;
      }
    }
#ENDIF
#IFNOT OfRef
    @Override
    public $exposedType$ $removeAtIndexMethod$(int index)
    {
      final $ArrayType$[] arr;
      final var removed=($exposedType$)(arr=this.arr)[index];
      ArrSeqUtil.eraseIndexHelper(arr,index,--size);
      return removed;
    }
#ENDIF
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    @Override
    boolean uncheckedRemoveIf(int size,$Predicate$ filter)
    {
      int srcOffset;
#IF OfBoolean
      boolean v;
      if(filter.test(v=arr[srcOffset=0]))
      {
        for(;;)
        {
          if(++srcOffset==size)
          {
            this.size=0;
            break;
          }
          if(v^arr[srcOffset])
          {
            this.size=filter.test(v=!v)?0:ArrSeqUtil.pullSurvivorsDown(arr,0,srcOffset,size,v);
            break;
          }
        }
      }
      else
      {
        for(;;)
        {
          if(++srcOffset==size)
          {
            return false;
          }
          if(v^arr[srcOffset])
          {
            if(!filter.test(!v))
            {
              return false;
            }
            this.size=ArrSeqUtil.pullSurvivorsDown(arr,srcOffset,size,v);
            break;
          }
        }
      }
#ELSE
      srcOffset=0;
      while(!filter.test(($exposedType$)arr[srcOffset]))
      {
        if(++srcOffset==size)
        {
          return false;
        }
      }
  #IF OfRef
      OmniArray.OfRef.nullifyRange(arr,srcOffset=ArrSeqUtil.pullSurvivorsDown(arr,srcOffset,--size,filter),size);
      this.size=srcOffset;
  #ELSE
      this.size=ArrSeqUtil.pullSurvivorsDown(arr,srcOffset,size-1,filter);
  #ENDIF
#ENDIF
      return true;
    }
    static abstract class AbstractBidirectionalItr$<E>${
      transient final Unchecked$<E>$ root;
      transient int cursor;
      transient int lastRet;
      AbstractBidirectionalItr(Unchecked$<E>$ root){
        this.root=root;
      }
      AbstractBidirectionalItr(Unchecked$<E>$ root,int cursor){
        this.root=root;
        this.cursor=cursor;
      }
      public void add($exposedType$ val){
        final AbstractSeq$<E>$ root;
        final int rootSize,cursor=this.cursor;
        if((rootSize=(root=this.root).size)!=0){
          root.uncheckedInsert(cursor,val,rootSize);
        }else{
          root.uncheckedInit(val);
        }
        this.cursor=cursor+1;
      }
    }
    static abstract class AbstractSubList$<E>$ extends $AbstractList$$<E>$
    {
      private static $<E>$ void bubbleUpDecrementSize(AbstractSubList$<E>$ parent,int numToRemove)
      {
        while(parent!=null)
        {
          parent.size-=numToRemove;
          parent=parent.parent;
        }
      }
      private static $<E>$ void bubbleUpIncrementSize(AbstractSubList$<E>$ parent)
      {
        while(parent!=null){
          ++parent.size;
          parent=parent.parent;
        }
      }
      static $<E>$ void bubbleUpDecrementSize(AbstractSubList$<E>$ parent){
        while(parent!=null){
          --parent.size;
          parent=parent.parent;
        }
      }
      transient final Unchecked$<E>$ root;
      transient final AbstractSubList$<E>$ parent;
      transient final int rootOffset;
      AbstractSubList(Unchecked$<E>$ root,AbstractSubList$<E>$ parent,int rootOffset,int size)
      {
        super(size);
        this.root=root;
        this.parent=parent;
        this.rootOffset=rootOffset;
      }
      AbstractSubList(Unchecked$<E>$ root,int rootOffset,int size)
      {
        super(size);
        this.root=root;
        this.parent=null;
        this.rootOffset=rootOffset;
      }
#IFNOT OfRef
      @Override
#ENDIF
      public boolean add($exposedType$ val)
      {
        final AbstractSeq$<E>$ root;
        final int rootSize;
        final int size=this.size;
        if((rootSize=(root=this.root).size)!=0){
          root.uncheckedInsert(size+rootOffset,val,rootSize);
        }else{
          root.uncheckedInit(val);
        }
        this.size=size+1;
        bubbleUpIncrementSize(parent);
        return true;
      }
#IFNOT OfRef
      @Override
#ENDIF
      public void add(int index,$exposedType$ val){
        final AbstractSeq$<E>$ root;
        final int rootSize;
        if((rootSize=(root=this.root).size)!=0){
          root.uncheckedInsert(index+rootOffset,val,rootSize);
        }else{
          root.uncheckedInit(val);
        }
        ++size;
        bubbleUpIncrementSize(parent);
      }
      @Override
      public void clear(){
        int size;
        if((size=this.size)!=0){
          this.size=0;
          bubbleUpDecrementSize(parent,size);
          final int newRootSize;
          final Unchecked$<E>$ root;
#IF OfRef
          final int oldRootSize;
          (root=this.root).size=newRootSize=(oldRootSize=root.size)-size;
#ELSE
          (root=this.root).size=newRootSize=root.size-size;
#ENDIF
          final $ArrayType$[] arr;
          ArrCopy.semicheckedCopy(arr=root.arr,size+(size=rootOffset),arr,size,newRootSize-size);
#IF OfRef
          OmniArray.OfRef.nullifyRange(arr,newRootSize,oldRootSize-1);
#ENDIF
        }
      }
      public boolean removeIf($Predicate$ filter)
      {
        final int size;
        return (size=this.size)!=0 && uncheckedRemoveIf(size,filter);
      }
#IFNOT OfRef
      public boolean removeIf(Predicate<? super $BoxedType$> filter)
      {
        final int size;
        return (size=this.size)!=0 && uncheckedRemoveIf(size,filter::test);
      }
#ENDIF
#IF OfRef
      @SuppressWarnings("unchecked")
#ENDIF
      private boolean uncheckedRemoveIf(int size,$Predicate$ filter)
      {
        final Unchecked$<E>$ root;
        int srcOffset;
        int srcBound=(srcOffset=rootOffset)+size;
#IF OfBoolean
        int dstOffset;
        final boolean[] arr;
        boolean v;
        if(filter.test(v=(arr=(root=this.root).arr)[srcOffset]))
        {
          dstOffset=srcOffset;
          for(;;)
          {
            if(++srcOffset==srcBound)
            {
              break;
            }
            if(v^arr[srcOffset])
            {
              if(!filter.test(v=!v))
              {
                dstOffset=ArrSeqUtil.pullSurvivorsDown(arr,dstOffset,srcOffset,srcBound,v);
              }
              break;
            }
          }
        }
        else
        {
          for(;;)
          {
            if(++srcOffset==srcBound)
            {
              return false;
            }
            if(v^arr[srcOffset])
            {
              if(!filter.test(!v))
              {
                return false;
              }
              dstOffset=ArrSeqUtil.pullSurvivorsDown(arr,srcOffset,srcBound,v);
              break;
            }
          }
        }
        this.size=size-(size=((AbstractSeq$<E>$)root).finalizeSubListBatchRemove(arr,dstOffset,srcBound));
#ELSE
        final var arr=(root=this.root).arr;
        while(!filter.test(($exposedType$)arr[srcOffset]))
        {
          if(++srcOffset==srcBound)
          {
            return false;
          }
        }
        this.size=size-(size=((AbstractSeq$<E>$)root).finalizeSubListBatchRemove(arr,ArrSeqUtil.pullSurvivorsDown(arr,srcOffset,srcBound-1,filter),srcBound));
#ENDIF
        bubbleUpDecrementSize(parent,size);
        return true;
      }
      static abstract class AbstractBidirectionalItr$<E>$
      {
        transient final AbstractSubList$<E>$ parent;
        transient int cursor;
        transient int lastRet;
        AbstractBidirectionalItr(AbstractSubList$<E>$ parent)
        {
          this.parent=parent;
          this.cursor=parent.rootOffset;
        }
        AbstractBidirectionalItr(AbstractSubList$<E>$ parent,int cursor)
        {
          this.parent=parent;
          this.cursor=cursor;
        }
        public void add($exposedType$ val)
        {
          final AbstractSubList$<E>$ parent;
          final AbstractSeq$<E>$ root;
          final int rootSize,cursor=this.cursor;
          if((rootSize=(root=(parent=this.parent).root).size)!=0){
            root.uncheckedInsert(cursor,val,rootSize);
          }else{
            root.uncheckedInit(val);
          }
          bubbleUpIncrementSize(parent.parent);
          ++parent.size;
          this.cursor=cursor+1;
        }
      }
    }
  }
}
