#TYPEDEF OfBoolean
  packagename = ofboolean
  PackageName = OfBoolean
  <E> = 
  ArrayType = boolean
  Consumer = BooleanConsumer
  BoxedType = Boolean
  exposedType = boolean
  queryParameterType = boolean
  Comparator = BooleanComparator
  UnaryOperator = BooleanPredicate
  getMethod = getBoolean
#ENDDEF
#TYPEDEF OfByte
  packagename = ofbyte
  PackageName = OfByte
  <E> = 
  ArrayType = byte
  Consumer = ByteConsumer
  BoxedType = Byte
  exposedType = byte
  queryParameterType = int
  Comparator = ByteComparator
  UnaryOperator = ByteUnaryOperator
  getMethod = getByte
#ENDDEF
#TYPEDEF OfChar
  packagename = ofchar
  PackageName = OfChar
  <E> = 
  ArrayType = char
  Consumer = CharConsumer
  BoxedType = Character
  exposedType = char
  queryParameterType = int
  Comparator = CharComparator
  UnaryOperator = CharUnaryOperator
  getMethod = getChar
#ENDDEF
#TYPEDEF OfShort
  packagename = ofshort
  PackageName = OfShort
  <E> = 
  ArrayType = short
  Consumer = ShortConsumer
  BoxedType = Short
  exposedType = short
  queryParameterType = int
  Comparator = ShortComparator
  UnaryOperator = ShortUnaryOperator
  getMethod = getShort
#ENDDEF
#TYPEDEF OfInt
  packagename = ofint
  PackageName = OfInt
  <E> = 
  ArrayType = int
  Consumer = IntConsumer
  BoxedType = Integer
  exposedType = int
  queryParameterType = int
  Comparator = IntBinaryOperator
  UnaryOperator = IntUnaryOperator
  getMethod = getInt
#ENDDEF
#TYPEDEF OfLong
  packagename = oflong
  PackageName = OfLong
  <E> = 
  ArrayType = long
  Consumer = LongConsumer
  BoxedType = Long
  exposedType = long
  queryParameterType = long
  Comparator = LongComparator
  UnaryOperator = LongUnaryOperator
  getMethod = getLong
#ENDDEF
#TYPEDEF OfFloat
  packagename = offloat
  PackageName = OfFloat
  <E> = 
  ArrayType = float
  Consumer = FloatConsumer
  BoxedType = Float
  exposedType = float
  queryParameterType = int
  convertToBits = Float.floatToRawIntBits
  Comparator = FloatComparator
  UnaryOperator = FloatUnaryOperator
  getMethod = getFloat
#ENDDEF
#TYPEDEF OfDouble
  packagename = ofdouble
  PackageName = OfDouble
  <E> = 
  ArrayType = double
  Consumer = DoubleConsumer
  BoxedType = Double
  exposedType = double
  queryParameterType = long
  convertToBits = Double.doubleToRawLongBits
  Comparator = DoubleComparator
  UnaryOperator = DoubleUnaryOperator
  getMethod = getDouble
#ENDDEF
#TYPEDEF OfRef
  packagename = ofref
  PackageName = OfRef
  <E> = <E>
  ArrayType = Object
  Consumer = Consumer<? super E>
  BoxedType = Object
  exposedType = E
  Comparator = Comparator<? super E>
  UnaryOperator = UnaryOperator<E>
  getMethod = get
#ENDDEF
package omni.impl.seq.arr.$packagename$;
import omni.api.OmniList;
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import omni.util.ArrCopy;
import omni.util.SortUtil;
import omni.impl.seq.arr.ArrSeqUtil;
#IF OfDouble,OfLong,OfInt
import java.util.function.$Consumer$;
import java.util.function.$UnaryOperator$;
#ELSEIF OfRef
import java.util.function.Predicate;
import java.util.function.Consumer;
#ELSE
import omni.function.$Consumer$;
import omni.function.$UnaryOperator$;
#ENDIF
import java.util.Comparator;
import java.util.function.UnaryOperator;
#IF OfInt
import java.util.function.IntBinaryOperator;
#ELSEIF OfDouble,OfFloat,OfLong,OfShort,OfChar,OfByte,OfBoolean
import omni.function.$Comparator$;
#ENDIF
import omni.impl.CheckedCollection;
public class CheckedList$<E>$ extends AbstractSeq.Checked$<E>$ implements OmniList.$PackageName$$<E>$
{
  CheckedList()
  {
    super();
  }
  CheckedList(int capacity)
  {
    super(capacity);
  }
  CheckedList(int size,$ArrayType$[] arr)
  {
    super(size,arr);
  }
  @Override
  public Object clone()
  {
    final $ArrayType$[] arr;
    final int size;
    if((size=this.size)!=0)
    {
      ArrCopy.uncheckedCopy(this.arr,0,arr=new $ArrayType$[size],0,size);
    }
    else
    {
      arr=null;
    }
    return new CheckedList$<E>$(size,arr);
  }
  @Override
  public boolean equals(Object val)
  {
    //TODO
    return false;
  }
  @Override
  public OmniIterator.$PackageName$$<E>$ iterator()
  {
    //TODO
    return null;
  }
  @Override
  public OmniListIterator.$PackageName$$<E>$ listIterator()
  {
    //TODO
    return null;
  }
  @Override
  public OmniListIterator.$PackageName$$<E>$ listIterator(int index)
  {
    //TODO
    return null;
  }
  @Override
  public OmniList.$PackageName$$<E>$ subList(int fromIndex,int toIndex)
  {
    //TODO
    return null;
  }
  @Override
  public void sort($Comparator$ sorter)
  {
    final int size;
    if((size=this.size)>1)
    {
      final int modCount=this.modCount;
      try
      {
        SortUtil.uncheckedsort(arr,0,size-1,sorter);
      }
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      this.modCount=modCount+1;
    }
  }
  @Override
  public void replaceAll($UnaryOperator$ operator)
  {
    final int size;
    if((size=this.size)!=0)
    {
      final int modCount=this.modCount;
      try
      {
        ArrSeqUtil.uncheckedReplaceAll(arr,0,size,operator);
      }
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      this.modCount=modCount+1;
    }
  }
  @Override
  public void put(int index,$exposedType$ val)
  {
    CheckedCollection.checkLo(index);
    CheckedCollection.checkReadHi(index,this.size);
    arr[index]=val;
  }
#MACRODEF arrcopyMethod(arrType)
  @Override
  void uncheckedCopyInto(arrType[] arr,int size)
  {
    ArrCopy.uncheckedCopy(this.arr,0,arr,0,size);
  }
#ENDDEF
#MACRO arrcopyMethod(\$BoxedType\$)
  @Override
  void uncheckedForEach(int size,$Consumer$ action)
  {
    final int modCount=this.modCount;
    try
    {
      ArrSeqUtil.uncheckedForwardForEach(arr,0,size,action);
    }
    finally
    {
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
  }
  @Override
  int uncheckedHashCode(int size)
  {
    final int modCount=this.modCount;
    try
    {
      return ArrSeqUtil.forwardHashCode(arr,0,size);
    }
    finally
    {
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
  }
  @Override
  void uncheckedToString(int size,StringBuilder builder)
  {
    final int modCount=this.modCount;
    try
    {
      ArrSeqUtil.forwardToString(arr,0,size,builder);
    }
    finally
    {
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
  }
#MACRODEF SortNoComparator(sortMethod)
  @Override
  public void sortMethod()
  {
    final int size;
    if((size=this.size)>1)
    {
#IF OfRef
      final int modCount=this.modCount;
      try
#ENDIF
      {
        SortUtil.uncheckedsortMethod(arr,0,size-1);
      }
#IF OfRef
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      this.modCount=modCount+1;
#ELSE
      ++this.modCount;
#ENDIF
    }
  }
#ENDDEF
#MACRO SortNoComparator(sort)
#MACRO SortNoComparator(reverseSort)
#IF OfRef
  @SuppressWarnings("unchecked")
#ENDIF
  @Override
  public $exposedType$ $getMethod$(int index)
  {
    CheckedCollection.checkLo(index);
    CheckedCollection.checkReadHi(index,this.size);
    return ($exposedType$)arr[index];
  }
  @Override
  public $exposedType$ set(int index,$exposedType$ val)
  {
    CheckedCollection.checkLo(index);
    CheckedCollection.checkReadHi(index,this.size);
    final $ArrayType$[] arr;
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    final var oldVal=($exposedType$)(arr=this.arr)[index];
    arr[index]=val;
    return oldVal;
  }
#IF OfRef
  @Override
  public E remove(int index)
  {
    CheckedCollection.checkLo(index);
    int size;
    CheckedCollection.checkReadHi(index,size=this.size);
    final Object[] arr;
    @SuppressWarnings("unchecked")
    final var removed=(E)(arr=this.arr)[index];
    ArrSeqUtil.eraseIndexHelper(arr,index,--size);
    this.size=size;
    return removed;
  }
#MACRODEF UncheckedRemoveVal(indexTest,Suffix,methodParams)
  @Override
  boolean uncheckedremoveValSuffix(methodParams)
  {
    final var arr=this.arr;
    int index;
    for(index=0,--size;indexTest(arr[index]);++index)
    {
      if(index==size)
      {
        return false;
      }
    }
    ++modCount;
    ArrSeqUtil.eraseIndexHelper(arr,index,size);
    this.size=size;
    return true;
  }
#ENDDEF
  #MACRO UncheckedRemoveVal(!pred.test,,int size\,Predicate<Object> pred)
  @Override
  boolean uncheckedremoveValNonNull(int size,Object nonNull){
    final var arr=this.arr;
    int modCount=this.modCount;
    int index;
    try
    {
      for(index=0,--size;!nonNull.equals(arr[index]);++index){
        if(index==size){ return false; }
      }
    }
    finally
    {
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
    ++modCount;
    ArrSeqUtil.eraseIndexHelper(arr,index,size);
    this.size=size;
    return true;
  }
  @Override
  protected int uncheckedlastIndexOfNonNull(int size,Object nonNull){
    final int modCount=this.modCount;
    try
    {
      return ArrSeqUtil.uncheckedlastIndexOf(arr,size,nonNull::equals);
    }
    finally
    {
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
  }
#ELSE
  @Override
  public void replaceAll(UnaryOperator<$BoxedType$> operator)
  {
    final int size;
    if((size=this.size)!=0)
    {
      final int modCount=this.modCount;
      try
      {
        ArrSeqUtil.uncheckedReplaceAll(arr,0,size,operator::apply);
      }
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      this.modCount=modCount+1;
    }
  }
  @Override
  public void sort(Comparator<? super $BoxedType$> sorter)
  {
    final int size;
    if((size=this.size)>1)
    {
      final int modCount=this.modCount;
      try
      {
        SortUtil.uncheckedsort(arr,0,size-1,sorter::compare);
      }
      finally
      {
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      this.modCount=modCount+1;
    }
  }
  #IF OfDouble,OfFloat
    #MACRO UncheckedRemoveVal(0!=,0,int size)
    #MACRO UncheckedRemoveVal(bits!=\$convertToBits\$,Bits,int size\,\$queryParameterType\$ bits)
    #MACRO UncheckedRemoveVal(!\$BoxedType\$.isNaN,NaN,int size)
  #ELSE
    #MACRO arrcopyMethod(long)
    #MACRO UncheckedRemoveVal(val!=,,int size\,\$queryParameterType\$ val)
    #IF OfInt,OfShort,OfChar,OfByte,OfBoolean
      #MACRO arrcopyMethod(int)
      #IF OfShort,OfByte,OfBoolean
        #MACRO arrcopyMethod(short)
        #IF OfByte,OfBoolean
          #MACRO arrcopyMethod(byte)
          #IF OfBoolean
            #MACRO arrcopyMethod(boolean)
          #ENDIF
        #ENDIF
      #ENDIF
      #IF OfChar,OfBoolean
        #MACRO arrcopyMethod(char)
      #ENDIF
    #ENDIF
  #ENDIF
  #MACRO arrcopyMethod(Object)
  #MACRO arrcopyMethod(double)
  #IF OfFloat,OfLong,OfInt,OfShort,OfChar,OfByte,OfBoolean
    #MACRO arrcopyMethod(float)
  #ENDIF
#ENDIF
}