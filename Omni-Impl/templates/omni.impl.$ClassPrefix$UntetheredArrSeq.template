#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl;
import omni.api.OmniCollection;
import omni.util.ArrCopy;
import omni.util.OmniArray;
#IF OfBoolean
import omni.util.TypeUtil;
#ENDIF
#IF OfChar,OfDouble,OfFloat,OfInt,OfLong,OfShort
import omni.function.$TypeNameModifier$Comparator;
#ENDIF
#IF OfRef
import java.util.Comparator;
#ENDIF
#IF OfBoolean,OfByte,OfChar,OfShort,OfFloat
import omni.function.$TypeNameModifier$Consumer;
import omni.function.$TypeNameModifier$Predicate;
#ENDIF
#IF OfInt,OfLong,OfDouble
import java.util.function.$TypeNameModifier$Consumer;
import java.util.function.$TypeNameModifier$Predicate;
#ENDIF
#IF OfLong,OfDouble,OfRef
import java.util.function.$TypeNameModifier$ToIntFunction;
#ENDIF
#IF OfFloat
import omni.function.$TypeNameModifier$ToIntFunction;
#ENDIF
#IF OfInt,OfShort,OfChar
import java.util.function.IntUnaryOperator;
#ENDIF
#IF OfRef
import java.util.function.Predicate;
import omni.api.OmniIterator;
import java.util.function.ToIntFunction;
#ENDIF
import java.util.function.Consumer;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
abstract class $ClassPrefix$UntetheredArrSeq<E> implements OmniCollection<E>,Externalizable
{
  $ArrayType$[] arr;
  int head;
  int tail;
  $ClassPrefix$UntetheredArrSeq(int head,$ArrayType$[] arr,int tail){
    super();
    this.arr=arr;
    this.head=head;
    this.tail=tail;
  }
  $ClassPrefix$UntetheredArrSeq(){
    super();
    this.tail=-1;
  }
  @Override public int size(){
    int tail;
    if((tail=this.tail+1)>0 && (tail-=this.head)<=0){
      tail+=arr.length;
    }
    return tail;
  }
  @Override public boolean isEmpty(){
    return this.tail==-1;
  }
  @Override public void clear(){
#IF OfRef
    final int tail;
    if((tail=this.tail)!=-1){
      final var arr=this.arr;
      int head;
      if((head=this.head)>tail){
        OmniArray.Of$ClassPrefix$.nullifyRange(arr,arr.length-1,head);
        head=0;
      }
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head);
    }
#ELSE
    this.tail=-1;
#ENDIF
  }

  public void addLast($exposedType$ val){
    var arr=this.arr;
    int tail;
    if((tail=this.tail)!=-1){
      int head;
      if((head=this.head)<=tail){
        if(++tail==arr.length && head==0){
          ArrCopy.uncheckedCopy(arr,0,arr=new $ArrayType$[OmniArray.growBy50Pct(tail)],0,tail);
          this.arr=arr;
        }
      }else if(++tail==head){
        this.head=0;
        final var tmp=new $ArrayType$[OmniArray.growBy50Pct(tail=arr.length)];
        final int copyLength;
        ArrCopy.uncheckedCopy(arr,head,tmp,0,copyLength=tail-head);
        ArrCopy.uncheckedCopy(arr,0,tmp,copyLength,head);
        this.arr=arr=tmp;
      }
      arr[tail]=val;
      this.tail=tail;
    }else{
      if(arr==null){
        this.arr=new $ArrayType$[]{val};
      }else{
        if(arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR){
          this.arr=arr=new $ArrayType$[OmniArray.DEFAULT_ARR_SEQ_CAP];
        }
        arr[0]=val;
      }
      this.head=0;
      this.tail=0;
    }
  }
  public void push($exposedType$ val){
    var arr=this.arr;
    int tail;
    if((tail=this.tail)!=-1){
      int head;
      if((head=this.head)<=tail){
        if(head==0 && tail==arr.length-1){
          final var tmp=new $ArrayType$[head=OmniArray.growBy50Pct(++tail)];
          this.tail=head-1;
          ArrCopy.uncheckedCopy(arr,0,tmp,head-=tail,tail);
          this.arr=arr=tmp;
        }
        --head;
      }else if(--head==tail){
        int arrLength;
        final var tmp=new $ArrayType$[head=OmniArray.growBy50Pct(arrLength=arr.length)];
        this.tail=head-1;
        ArrCopy.uncheckedCopy(arr,0,tmp,head-=(++tail),tail);
        ArrCopy.uncheckedCopy(arr,tail,tmp,head-=(arrLength-=tail),arrLength);
        this.arr=arr=tmp;
        --head;
      }
      arr[head]=val;
      this.head=head;
    }else{
      if(arr==null){
        this.arr=new $ArrayType$[]{val};
        this.head=0;
        this.tail=0;
      }else if(arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR){
        this.arr=arr=new $ArrayType$[OmniArray.DEFAULT_ARR_SEQ_CAP];
        arr[OmniArray.DEFAULT_ARR_SEQ_CAP-1]=val;
        this.head=OmniArray.DEFAULT_ARR_SEQ_CAP-1;
        this.tail=OmniArray.DEFAULT_ARR_SEQ_CAP-1;
      }else{
        arr[tail=arr.length-1]=val;
        this.tail=tail;
        this.head=tail;
      }
    }
  }
  @Override public void writeExternal(ObjectOutput out) throws IOException
  {
    int tail;
    if((tail=this.tail)!=-1){
#IF OfBoolean
      final $ArrayType$[] arr;
      int head;
      int word=TypeUtil.castToByte((arr=this.arr)[head=this.head]);
      int mask=1;
      int size;
      if((size=(tail+1)-head)<=0){
        out.writeInt((size+(size=arr.length))-1);
        for(;;){
          if(++head==size){
            head=0;
            break;
          }
          if((mask<<=1)==(1<<8)){
            out.writeByte(word);
            word=0;
            mask=1;
          }
          if(arr[head]){
            word|=mask;
          }
        }
      }else{
        out.writeInt(size-1);
      }
      for(;;){
        if(head==tail){
          out.writeByte(word);
          return;
        }
        if((mask<<=1)==(1<<8)){
          out.writeByte(word);
          word=0;
          mask=1;
        }
        if(arr[++head]){
          word|=mask;
        }
      }
#ELSE
      final var arr=this.arr;
      int size;
      final int head;
  #IF OfByte
      if((size=(++tail)-(head=this.head))<=0){
        out.writeInt((size+(size=arr.length))-1);
        out.write(arr,head,size-head);
        out.write(arr,0,tail);
      }else{
        out.writeInt(size-1);
        out.write(arr,head,size);
      }
  #ELSE
      if((size=(tail+1)-(head=this.head))<=0){
        out.writeInt((size+(size=arr.length-1)));
        OmniArray.Of$ClassPrefix$.writeArray(arr,head,size,out);
        OmniArray.Of$ClassPrefix$.writeArray(arr,0,tail,out);
      }else{
        out.writeInt(size-1);
        OmniArray.Of$ClassPrefix$.writeArray(arr,head,tail,out);
      }
  #ENDIF
#ENDIF
    }else{
      out.writeInt(-1);
    }
  }
  @Override public void readExternal(ObjectInput in) throws IOException
#IF OfRef
    ,ClassNotFoundException
#ENDIF
  {
    int tail;
    this.tail=tail=in.readInt();
    if(tail!=-1){
      this.head=0;
      final $ArrayType$[] arr;
#IF OfByte
      in.readFully(arr=new $ArrayType$[++tail],0,tail);
#ELSE
      OmniArray.Of$ClassPrefix$.readArray(arr=new $ArrayType$[tail+1],0,tail,in);
#ENDIF
      this.arr=arr;
    }
  }
#IF OfBoolean
  boolean uncheckedRemoveLastMatch(int tail,final boolean queryParam)
#ELSEIF OfByte,OfChar,OfShort,OfInt
  boolean uncheckedRemoveLastMatch(int tail,final int queryParam)
#ELSEIF OfLong
  boolean uncheckedRemoveLastMatch(int tail,final long queryParam)
#ELSEIF OfFloat
  boolean uncheckedRemoveLastMatch(int tail,final FloatPredicate queryParam)
#ELSEIF OfDouble
  boolean uncheckedRemoveLastMatch(int tail,final DoublePredicate queryParam)
#ELSEIF OfRef
  boolean uncheckedRemoveLastMatch(int tail,@SuppressWarnings("rawtypes") final Predicate queryParam)
#ENDIF
  {
    final int head;
    if((head=this.head)<=tail){
      return nonfragmentedRemoveLastMatch(head,tail,queryParam);
    }
    return fragmentedRemoveLastMatch(head,tail,queryParam);
  }
#IF OfBoolean
  boolean uncheckedRemoveFirstMatch(int tail,final boolean queryParam)
#ELSEIF OfByte,OfChar,OfShort,OfInt
  boolean uncheckedRemoveFirstMatch(int tail,final int queryParam)
#ELSEIF OfLong
  boolean uncheckedRemoveFirstMatch(int tail,final long queryParam)
#ELSEIF OfFloat
  boolean uncheckedRemoveFirstMatch(int tail,final FloatPredicate queryParam)
#ELSEIF OfDouble
  boolean uncheckedRemoveFirstMatch(int tail,final DoublePredicate queryParam)
#ELSEIF OfRef
  boolean uncheckedRemoveFirstMatch(int tail,@SuppressWarnings("rawtypes") final Predicate queryParam)
#ENDIF
  {
    final int head;
    if((head=this.head)<=tail){
      return nonfragmentedRemoveFirstMatch(head,tail,queryParam);
    }
    return fragmentedRemoveFirstMatch(head,tail,queryParam);
  }


#IF OfBoolean
  boolean nonfragmentedRemoveLastMatch(int head,int tail,final boolean searchVal)
#ELSEIF OfByte,OfChar,OfShort,OfInt
  boolean nonfragmentedRemoveLastMatch(int head,int tail,final int searchVal)
#ELSEIF OfLong
  boolean nonfragmentedRemoveLastMatch(int head,int tail,final long searchVal)
#ELSEIF OfFloat
  boolean nonfragmentedRemoveLastMatch(int head,int tail,final FloatPredicate tester)
#ELSEIF OfDouble
  boolean nonfragmentedRemoveLastMatch(int head,int tail,final DoublePredicate tester)
#ELSEIF OfRef
  @SuppressWarnings("unchecked")
  boolean nonfragmentedRemoveLastMatch(int head,int tail,@SuppressWarnings("rawtypes") final Predicate tester)
#ENDIF
  {
    final var arr=this.arr;
    //search the upper half of the structure
    int index;
    for(int mid=(head+(index=tail))>>>1;;)
    {
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[index]==searchVal)
#ELSE
      if(tester.test(arr[index]))
#ENDIF
      {
        //found the element;
        if(tail==head)
        {
          //remove the last element
          this.tail=-1;
        }
        else
        {
          //pull the tail down
          ArrCopy.semicheckedSelfCopy(arr,index,index+1,tail-index);
          this.tail=tail-1;
        }
#IF OfRef
        arr[tail]=null;
#ENDIF
        return true;
      }
      if(--index<mid){
        break;
      }
    }
    //search the lower half of the structure
    for(int headLength;(headLength=index-head)>=0;--index){
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[index]==searchVal)
#ELSE
      if(tester.test(arr[index]))
#ENDIF
      {
        //found the element, pull the head up
        ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headLength);
        this.head=tail;
#IF OfRef
        arr[head]=null;
#ENDIF
        return true;
      }
    }
    return false;
  }
#IF OfBoolean
  boolean fragmentedRemoveLastMatch(int head,int tail,final boolean searchVal)
#ELSEIF OfByte,OfChar,OfShort,OfInt
  boolean fragmentedRemoveLastMatch(int head,int tail,final int searchVal)
#ELSEIF OfLong
  boolean fragmentedRemoveLastMatch(int head,int tail,final long searchVal)
#ELSEIF OfFloat
  boolean fragmentedRemoveLastMatch(int head,int tail,final FloatPredicate tester)
#ELSEIF OfDouble
  boolean fragmentedRemoveLastMatch(int head,int tail,final DoublePredicate tester)
#ELSEIF OfRef
  @SuppressWarnings("unchecked")
  boolean fragmentedRemoveLastMatch(int head,int tail,@SuppressWarnings("rawtypes") final Predicate tester)
#ENDIF
  {
    final $ArrayType$[] arr;
    final int bound=(arr=this.arr).length-1;
    for(int index=tail;;){
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[index]==searchVal)
#ELSE
      if(tester.test(arr[index]))
#ENDIF
      {
        final int tailLength,headLength;
        if((tailLength=tail-index)<(headLength=bound-head)+index){
          if(tail==0){
            this.tail=bound;
          }else{
            ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailLength);
            this.tail=tail-1;
          }
#IF OfRef
          arr[tail]=null;
#ENDIF
        }else{
          ArrCopy.semicheckedCopy(arr,0,arr,1,index);
          arr[0]=arr[bound];
          if(headLength==0){
            this.head=0;
          }else{
            ArrCopy.uncheckedCopy(arr,head,arr,tail=head+1,headLength);
            this.head=tail;
          }
#IF OfRef
          arr[head]=null;
#ENDIF
        }
        return true;
      }
      if(--index==-1){
        break;
      }
    }
    for(int index=bound;;){
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[index]==searchVal)
#ELSE
      if(tester.test(arr[index]))
#ENDIF
      {
        final int tailLength,headLength;
        if((headLength=index-head)<(tailLength=bound-index)+tail)
        {
          if(head==bound){
            this.head=0;
          }else{
            ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headLength);
            this.head=tail;
          }
#IF OfRef
          arr[head]=null;
#ENDIF
        }
        else
        {
          ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailLength);
          arr[bound]=arr[0];
          if(tail==0){
            this.tail=bound;
          }else{
            ArrCopy.semicheckedSelfCopy(arr,0,1,tail);
            this.tail=tail-1;
          }
#IF OfRef
          arr[tail]=null;
#ENDIF
        }
        return true;
      }
      if(--index<head){
        break;
      }
    }
    return false;
  }
#IF OfBoolean
  boolean nonfragmentedRemoveFirstMatch(int head,int tail,final boolean searchVal)
#ELSEIF OfByte,OfChar,OfShort,OfInt
  boolean nonfragmentedRemoveFirstMatch(int head,int tail,final int searchVal)
#ELSEIF OfLong
  boolean nonfragmentedRemoveFirstMatch(int head,int tail,final long searchVal)
#ELSEIF OfFloat
  boolean nonfragmentedRemoveFirstMatch(int head,int tail,final FloatPredicate tester)
#ELSEIF OfDouble
  boolean nonfragmentedRemoveFirstMatch(int head,int tail,final DoublePredicate tester)
#ELSEIF OfRef
  @SuppressWarnings("unchecked")
  boolean nonfragmentedRemoveFirstMatch(int head,int tail,@SuppressWarnings("rawtypes") final Predicate tester)
#ENDIF
  {
    final var arr=this.arr;
    int index;
    //search the lower half of the structure
    for(int mid=((index=head)+tail)>>>1;;){
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[index]==searchVal)
#ELSE
      if(tester.test(arr[index]))
#ENDIF
      {
        //found the element
        if(tail==head)
        {
          //remove the last element
          this.tail=-1;
        }
        else
        {
          //pull the head up
          ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,index-head);
          this.head=tail;
        }
#IF OfRef
        arr[head]=null;
#ENDIF
        return true;
      }
      if(++index>mid)
      {
        break;
      }
    }
    //search the upper half of the structure
    for(int tailLength;(tailLength=tail-index)>=0;++index){
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[index]==searchVal)
#ELSE
      if(tester.test(arr[index]))
#ENDIF
      {
        //found the element, pull the tail down
        ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailLength);
#IF OfRef
        arr[tail]=null;
#ENDIF
        this.tail=tail-1;
        return true;
      }
    }
    return false;
  }
#IF OfBoolean
  boolean fragmentedRemoveFirstMatch(int head,int tail,final boolean searchVal)
#ELSEIF OfByte,OfChar,OfShort,OfInt
  boolean fragmentedRemoveFirstMatch(int head,int tail,final int searchVal)
#ELSEIF OfLong
  boolean fragmentedRemoveFirstMatch(int head,int tail,final long searchVal)
#ELSEIF OfFloat
  boolean fragmentedRemoveFirstMatch(int head,int tail,final FloatPredicate tester)
#ELSEIF OfDouble
  boolean fragmentedRemoveFirstMatch(int head,int tail,final DoublePredicate tester)
#ELSEIF OfRef
  @SuppressWarnings("unchecked")
  boolean fragmentedRemoveFirstMatch(int head,int tail,@SuppressWarnings("rawtypes") final Predicate tester)
#ENDIF
  {
    final $ArrayType$[] arr;
    final int bound=(arr=this.arr).length-1;
    for(int index=head;;){
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[index]==searchVal)
#ELSE
      if(tester.test(arr[index]))
#ENDIF
      {
        final int headLength,tailLength;
        if((headLength=index-head)<tail+(tailLength=bound-index))
        {
          if(head==bound){
            this.head=0;
          }else{
            ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headLength);
            this.head=tail;
          }
#IF OfRef
          arr[head]=null;
#ENDIF
        }
        else
        {
          ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailLength);
          arr[bound]=arr[0];
          if(tail==0)
          {
            this.tail=bound;
          }
          else
          {
            ArrCopy.uncheckedSelfCopy(arr,0,1,tail);
            this.tail=tail-1;
          }
#IF OfRef
          arr[tail]=null;
#ENDIF
        }
        return true;
      }
      if(++index>bound)
      {
        break;
      }
    }
    for(int index=0;;){
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[index]==searchVal)
#ELSE
      if(tester.test(arr[index]))
#ENDIF
      {
        final int headLength,tailLength;
        if((tailLength=tail-index)<(headLength=bound-head)+index)
        {
          if(tail==0){
            this.tail=bound;
          }else{
            ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailLength);
            this.tail=tail-1;
          }
#IF OfRef
          arr[tail]=null;
#ENDIF
        }
        else
        {
          ArrCopy.semicheckedCopy(arr,0,arr,1,index);
          arr[0]=arr[bound];
          if(headLength==0){
            this.head=0;
          }else{
            ArrCopy.uncheckedCopy(arr,head,arr,tail=head+1,headLength);
            this.head=tail;
          }
#IF OfRef
          arr[head]=null;
#ENDIF
        }
        return true;
      }
      if(++index>tail){
        break;
      }
    }
    return false;
  }

#IF OfBoolean
  int uncheckedSearch(int tail,final boolean searchVal)
#ELSEIF OfByte,OfChar,OfShort,OfInt
  int uncheckedSearch(int tail,final int searchVal)
#ELSEIF OfLong
  int uncheckedSearch(int tail,final long searchVal)
#ELSEIF OfFloat
  int uncheckedSearch(int tail,final FloatPredicate tester)
#ELSEIF OfDouble
  int uncheckedSearch(int tail,final DoublePredicate tester)
#ELSEIF OfRef
  @SuppressWarnings("unchecked")
  int uncheckedSearch(int tail,@SuppressWarnings("rawtypes") final Predicate tester)
#ENDIF
  {
    final var arr=this.arr;
    int count=1;
    int head;
    if((head=this.head)>tail){
      for(final int bound=arr.length;;)
      {
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
        if(arr[head]==searchVal)
#ELSE
        if(tester.test(arr[head]))
#ENDIF
        {
          return count;
        }
        ++count;
        if(++head==bound)
        {
          head=0;
          break;
        }
      }
    }
    for(;;)
    {
#IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[head]==searchVal)
#ELSE
      if(tester.test(arr[head]))
#ENDIF
      {
        return count;
      }
      if(head==tail)
      {
        return -1;
      }
      ++count;
      ++head;
    }
  }

#IF OfBoolean
  boolean uncheckedContainsMatch(int tail,final boolean searchVal)
#ELSEIF OfByte,OfChar,OfShort,OfInt
  boolean uncheckedContainsMatch(int tail,final int searchVal)
#ELSEIF OfLong
  boolean uncheckedContainsMatch(int tail,final long searchVal)
#ELSEIF OfFloat
  boolean uncheckedContainsMatch(int tail,final FloatPredicate tester)
#ELSEIF OfDouble
  boolean uncheckedContainsMatch(int tail,final DoublePredicate tester)
#ELSEIF OfRef
  @SuppressWarnings("unchecked")
  boolean uncheckedContainsMatch(int tail,@SuppressWarnings("rawtypes") final Predicate tester)
#ENDIF
  {
    final var arr=this.arr;
    int head;
    if((head=this.head)>tail)
    {
      for(;;)
      {
  #IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
        if(arr[tail]==searchVal)
  #ELSE
        if(tester.test(arr[tail]))
  #ENDIF
        {
          return true;
        }
        if(tail==0)
        {
          tail=arr.length-1;
          break;
        }
        --tail;
      }
    }
    for(;;)
    {
  #IF OfBoolean,OfByte,OfChar,OfShort,OfInt,OfLong
      if(arr[head]==searchVal)
  #ELSE
      if(tester.test(arr[head]))
  #ENDIF
      {
        return true;
      }
      if(head==tail)
      {
        return false;
      }
      ++head;
    }
  }
  
  
#IFNOT OfBoolean,OfByte
  void insertMiddle($exposedType$ key){
    $ArrayType$[] arr;
    if((arr=this.arr)==null){
      this.arr=new $ArrayType$[]{key};
      this.head=0;
      this.tail=0;
    }else if(arr==OmniArray.Of$ClassPrefix$.DEFAULT_ARR){
      this.arr=arr=new $ArrayType$[OmniArray.DEFAULT_ARR_SEQ_CAP];
      arr[OmniArray.DEFAULT_ARR_SEQ_CAP/2]=key;
      this.head=OmniArray.DEFAULT_ARR_SEQ_CAP/2;
      this.tail=OmniArray.DEFAULT_ARR_SEQ_CAP/2;
    }else{
      final int index;
      arr[index=(arr.length>>1)]=key;
      this.tail=index;
      this.head=index;
    }
  }
  #MACRO AddSetFunctions($TypeNameModifier$Comparator$<E>$,compare(key\,)
#IF OfChar,OfInt,OfShort
  #MACRO AddSetFunctions(IntUnaryOperator,applyAsInt()
#ELSE
  
  #MACRO AddSetFunctions($TypeNameModifier$ToIntFunction$<E>$,applyAsInt()
#ENDIF
#MACRODEF AddSetFunctions(COMPARATORTYPE,COMPARATORCALL)
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
boolean uncheckedAdd(int tail,$exposedType$ key,COMPARATORTYPE sorter)
{
  final var arr=this.arr;
  final int head;
  if(tail<(head=this.head))
  {
    switch(sorter.COMPARATORCALL($exposedType$)arr[0]))
    {
      case 0:
        return false;
      case -1:
        return fragmentedInsertLo(arr,head,tail,key,sorter);
      default:
        return fragmentedInsertHi(arr,head,tail,key,sorter);
    }
  }
  else
  {
    final int mid;
    switch(sorter.COMPARATORCALL($exposedType$)arr[mid=(head+tail)>>>1]))
    {
      case 0:
        return false;
      case -1:
        return nonfragmentedInsertLo(arr,head,mid-1,key,sorter);
      default:
        return nonfragmentedInsertHi(arr,mid+1,tail,key,sorter);
    }
  }
}
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
boolean fragmentedInsertHi($ArrayType$[] arr,int head,int tail,$exposedType$ key,COMPARATORTYPE sorter){
  int lo=1;
  int hi=tail;
  while(lo<=hi)
  {
    final int mid;
    switch(sorter.COMPARATORCALL($exposedType$)arr[ mid=(hi+lo)>>>1]))
    {
      case 0:
        return false;
      case -1:
        hi=mid-1;
        break;
      default:
        lo=mid+1;
    }
  }
  final int arrLength;
  final int headDist=(arrLength=arr.length)-head;
  if(++tail==head)
  {
    //must grow
    final $ArrayType$[] tmp;
    //allocate a new array and assign the key
    (tmp=new $ArrayType$[hi=OmniArray.growBy50Pct(arrLength)])[lo]=key;
    if(lo==0)
    {
      //inserting at index 0, copy the span from [0->tail] to the right one
      ArrCopy.uncheckedCopy(arr,0,tmp,1,tail);
    }
    else
    {
      //inserting at 0<index<=tail
      //copy [0->index]
      ArrCopy.uncheckedCopy(arr,0,tmp,0,lo);
      //copy [index->tail] but move it right one
      ArrCopy.semicheckedCopy(arr,lo,tmp,lo+1,tail-lo);
    }
    //copy the head span [head->arrBound]
    ArrCopy.uncheckedCopy(arr,head,tmp,(hi-=headDist),headDist);
    this.head=hi;
    this.tail=tail;
    this.arr=tmp;
  }
  else
  {
    int tailDist;
    if((tailDist=tail-lo)<=headDist+lo)
    {
      //shift the elements AFTER the insertion point right
      ArrCopy.semicheckedCopy(arr,lo,arr,lo+1,tailDist);
      this.tail=tail;
    }
    else
    {
      //shift the elements BEFORE the insertion point left (wrap around the break)
      ArrCopy.uncheckedSelfCopy(arr,tail=head-1,head,headDist);
      arr[arrLength-1]=arr[0];
      ArrCopy.semicheckedSelfCopy(arr,0,1,lo-1);
      this.head=tail;
    }
    arr[lo]=key;
  }
  return true;
}
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
boolean fragmentedInsertLo($ArrayType$[] arr,int head,int tail,$exposedType$ key,COMPARATORTYPE sorter){
  int arrBound;
  int hi=(arrBound=arr.length)-1;
  int lo=head;
  do
  {
    final int mid;
    switch(sorter.COMPARATORCALL($exposedType$)arr[mid=(hi+lo)>>>1]))
    {
      case 0:
        return false;
      case -1:
        hi=mid-1;
        break;
      default:
        lo=mid+1;
    }
  }while(lo<=hi);
  final int headDist=lo-head;
  if(++tail==head)
  {
    //must grow
    final $ArrayType$[] tmp;
    //Copy the span from [0->tail]
    ArrCopy.uncheckedCopy(arr,0,tmp=new $ArrayType$[hi=OmniArray.growBy50Pct(arrBound)],0,tail);
    //copy the span from [index->arrBound]
    ArrCopy.semicheckedCopy(arr,lo,tmp,hi-=(arrBound-=lo),arrBound);
    //insert the new key
    tmp[--hi]=key;
    //copy the span from [head->index]
    ArrCopy.semicheckedCopy(arr,head,tmp,hi-=headDist,headDist);
    this.head=hi;
    this.arr=tmp;
  }
  else
  {
    if(headDist<=((hi=(--arrBound)-lo)+(tail)))
    {
      //move the elements BEFORE the insertion point left
      ArrCopy.semicheckedSelfCopy(arr,tail=head-1,head,headDist);
      this.head=tail; 
    }
    else
    {
      //move the points AFTER the insertion point right (wrap around the break)
      ArrCopy.uncheckedCopy(arr,0,arr,1,tail);
      arr[0]=arr[arrBound];
      ArrCopy.semicheckedCopy(arr,lo,arr,lo+1,hi);
      this.tail=tail;
    }
    arr[lo]=key;
  }
  return true;
}
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
boolean nonfragmentedInsertLo($ArrayType$[] arr,int head,int hi,$exposedType$ key,COMPARATORTYPE sorter){
  int lo=head;
  while(lo<=hi)
  {
    final int mid;
    switch(sorter.COMPARATORCALL($exposedType$)arr[mid=(lo+hi)>>>1]))
    {
      case 0:
        return false;
      case -1:
        hi=mid-1;
        break;
      default:
        lo=mid+1;
    }
  }
  int headDist;
  if((headDist=lo-head)==0){
    //inserting at index==head
    if(--head==-1 && this.tail==(head=arr.length-1)){
      //must grow
      ArrCopy.uncheckedCopy(arr,0,arr=new $ArrayType$[headDist=OmniArray.growBy50Pct(++head)],lo=headDist-head,head);
      this.tail=headDist-1;
      this.head=--lo;
      arr[lo]=key;
      this.arr=arr;
    }else{
      arr[head]=key;
      this.head=head;
    }
  }else{
    if(head==0){
      if(this.tail==(head=arr.length-1)){
        //must grow
        final var tmp=new $ArrayType$[headDist=OmniArray.growBy50Pct(++head)];
        this.tail=headDist-1;
        ArrCopy.uncheckedCopy(arr,lo,tmp,head=headDist-(headDist=head-lo),headDist);
        tmp[--head]=key;
        ArrCopy.uncheckedCopy(arr,0,tmp,head-=lo,lo);
        this.arr=tmp;
      }else{
        arr[head]=arr[0];
        ArrCopy.semicheckedSelfCopy(arr,0,1,headDist-1);
        arr[lo]=key;
      }
      this.head=head;
    }else{
      ArrCopy.uncheckedSelfCopy(arr,hi=head-1,head,headDist);
      arr[lo]=key;
      this.head=hi;
    }
  }
  return true;
}
#IF OfRef
@SuppressWarnings("unchecked")
#ENDIF
boolean nonfragmentedInsertHi($ArrayType$[] arr,int lo,int tail,$exposedType$ key,COMPARATORTYPE sorter){
  int hi=tail;
  while(lo<=hi)
  {
    final int mid;
    switch(sorter.COMPARATORCALL($exposedType$)arr[mid=(lo+hi)>>>1]))
    {
      case 0:
        return false;
      case -1:
        hi=mid-1;
        break;
      default:
        lo=mid+1;
    }
  }
  int tailDist;
  if((tailDist=(++tail-lo))==0){
    //inserting at index==tail+1
    if(tail==arr.length && head==0){
      //must grow
      ArrCopy.uncheckedCopy(arr,0,arr=new $ArrayType$[head=OmniArray.growBy50Pct(tail)],0,tail);
      this.tail=tail;
      arr[lo]=key;
      this.arr=arr;
    }else{
      arr[0]=key;
      this.tail=0;
    }
  }else{
    if(tail==arr.length){
      if(this.head==0){
        //must grow
        final $ArrayType$[] tmp;
        ArrCopy.uncheckedCopy(arr,0,tmp=new $ArrayType$[hi=OmniArray.growBy50Pct(tail)],0,lo);
        tmp[lo]=key;
        ArrCopy.uncheckedCopy(arr,lo,tmp,lo+1,tailDist);
        this.tail=tail;
        this.arr=tmp;
      }else{
        arr[0]=arr[tail-1];
        ArrCopy.semicheckedCopy(arr,lo,arr,lo+1,tailDist-1);
        arr[lo]=key;
        this.tail=0;
      }
    }else{
      ArrCopy.uncheckedCopy(arr,lo,arr,lo+1,tailDist);
      arr[lo]=key;
      this.tail=tail;
    }
  }
  return true;
}
#ENDDEF

  
  #IF OfChar,OfShort,OfInt
  boolean nonfragmentedRemoveMatch(int head,int tail,final IntUnaryOperator comparator)
  #ELSEIF OfLong
  boolean nonfragmentedRemoveMatch(int head,int tail,final LongToIntFunction comparator)
  #ELSEIF OfFloat
  boolean nonfragmentedRemoveMatch(int head,int tail,final FloatToIntFunction comparator)
  #ELSEIF OfDouble
  boolean nonfragmentedRemoveMatch(int head,int tail,final DoubleToIntFunction comparator)
  #ELSEIF OfRef
  @SuppressWarnings("unchecked")
  boolean nonfragmentedRemoveMatch(int head,int tail,@SuppressWarnings("rawtypes") final ToIntFunction comparator)
  #ENDIF
  {
    final $ArrayType$[] arr;
    int mid;
    switch(comparator.applyAsInt((arr=this.arr)[mid=(head+tail)>>>1]))
    {
      default:
        //search the upper half of the structure (between mid and tail)
        if(++mid>tail || (mid=findIndex(arr,mid,tail,comparator))==-1)
        {
          return false;
        }
        //found the element, pull the tail down
        ArrCopy.semicheckedSelfCopy(arr,mid,mid+1,tail-mid);
  #IF OfRef
        arr[tail]=null;
  #ENDIF
        this.tail=tail-1;
        return true;
      case 0:
        //the value was found on the first attempt. Remove it.
        if(head==tail)
        {
          //the element is the last element
          this.tail=-1;
  #IF OfRef
          arr[head]=null;
  #ENDIF
          return true;
        }
        break;
      case 1:
        //search the lower half of the structure (between head and mid)
        if(--mid<head || (mid=findIndex(arr,head,mid,comparator))==-1)
        {
          return false;
        }
    }
    //found the element, pull the head up
    ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,mid-head);
    this.head=tail;
  #IF OfRef
    arr[head]=null;
  #ENDIF
    return true;
  }
  
  
  #IF OfChar,OfShort,OfInt
  boolean fragmentedRemoveMatch(int head,int tail,final IntUnaryOperator comparator)
  #ELSEIF OfLong
  boolean fragmentedRemoveMatch(int head,int tail,final LongToIntFunction comparator)
  #ELSEIF OfFloat
  boolean fragmentedRemoveMatch(int head,int tail,final FloatToIntFunction comparator)
  #ELSEIF OfDouble
  boolean fragmentedRemoveMatch(int head,int tail,final DoubleToIntFunction comparator)
  #ELSEIF OfRef
  @SuppressWarnings("unchecked")
  boolean fragmentedRemoveMatch(int head,int tail,@SuppressWarnings("rawtypes") final ToIntFunction comparator)
  #ENDIF
  {
    final $ArrayType$[] arr;
    switch(comparator.applyAsInt((arr=this.arr)[0]))
    {
      case 0:
        //found the element at index 0, remove it
        if(tail==0)
        {
          this.tail=arr.length-1;
        }
        else
        {
          //pull the tail down
          ArrCopy.uncheckedSelfCopy(arr,0,1,tail);
          this.tail=tail-1;
        }
        break;
      case 1:
        //search the lower half of the structure (between head and array.length)
        int index;
        if((index=findIndex(arr,head,tail=arr.length-1,comparator))==-1)
        {
          return false;
        }
        //found the element, pull the head up
        if(head==tail)
        {
          this.head=0;
        }
        else
        {
          ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,index-head);
          this.head=tail;
        }
  #IF OfRef
        arr[head]=null;
  #ENDIF
        return true;
      default:
        //search the upper half of the structure (between 0 and tail)
        if(tail==0 || (index=findIndex(arr,1,tail,comparator))==-1)
        {
          return false;
        }
        //found the element, pull the tail down
        ArrCopy.semicheckedSelfCopy(arr,index,index+1,tail-index);
        this.tail=tail-1;
    }
  #IF OfRef
    arr[tail]=null;
  #ENDIF
    return true;
  }

  #IF OfChar,OfShort,OfInt
  static int findIndex(final $ArrayType$[] arr,int head,int tail,final IntUnaryOperator comparator)
  #ELSEIF OfLong
  static int findIndex(final $ArrayType$[] arr,int head,int tail,final LongToIntFunction comparator)
  #ELSEIF OfFloat
  static int findIndex(final $ArrayType$[] arr,int head,int tail,final FloatToIntFunction comparator)
  #ELSEIF OfDouble
  static int findIndex(final $ArrayType$[] arr,int head,int tail,final DoubleToIntFunction comparator)
  #ELSEIF OfRef
  @SuppressWarnings("unchecked")
  static int findIndex(final $ArrayType$[] arr,int head,int tail,@SuppressWarnings("rawtypes") final ToIntFunction comparator)
  #ENDIF
  {
    do
    {
      final int mid;
      switch(comparator.applyAsInt(arr[mid=(head+tail)>>>1]))
      {
        case 0:
          return mid;
        case 1:
          tail=mid-1;
          break;
        default:
          head=mid+1;
      }
    }
    while(head<=tail);
    return -1;
  }
  

  #IF OfChar,OfShort,OfInt
  boolean uncheckedContainsMatch(int tail,final IntUnaryOperator comparator)
  #ELSEIF OfLong
  boolean uncheckedContainsMatch(int tail,final LongToIntFunction comparator)
  #ELSEIF OfFloat
  boolean uncheckedContainsMatch(int tail,final FloatToIntFunction comparator)
  #ELSEIF OfDouble
  boolean uncheckedContainsMatch(int tail,final DoubleToIntFunction comparator)
  #ELSEIF OfRef
  @SuppressWarnings("unchecked")
  boolean uncheckedContainsMatch(int tail,@SuppressWarnings("rawtypes") final ToIntFunction comparator)
  #ENDIF
  {
    final var arr=this.arr;
    int head;
    if((head=this.head)>tail)
    {
      //fragmented
      switch(comparator.applyAsInt(arr[0]))
      {
        case 0:
          return true;
        case 1:
          //search in the head span
          tail=arr.length-1;
          break;
        default:
          //search in the tail span
          if(tail==0)
          {
            return false;
          }
          head=1;
      }
    }
    return findIndex(arr,head,tail,comparator)!=-1;
  }
#ENDIF
  $ArrayType$ uncheckedRemoveLast(int tail){
    final $ArrayType$[] arr;
    final var ret=(arr=this.arr)[tail];
    #IF OfRef
    arr[tail]=null;
    #ENDIF
    switch(Integer.signum(tail-this.head))
    {
      case 0:
        this.tail=-1;
        return ret;
      case -1:
        //fragmented
        if(--tail==-1){
          tail=arr.length-1;
        }
        break;
      default:
        --tail;
    }
    this.tail=tail;
    return ret;
  }
  $ArrayType$ uncheckedRemoveFirst(int tail){
    int head;
    final $ArrayType$[] arr;
    final var ret=(arr=this.arr)[head=this.head];
    #IF OfRef
    arr[head]=null;
    #ENDIF
    switch(Integer.signum(tail-head))
    {
      case 0:
        this.tail=-1;
        return ret;
      case -1:
        //fragmented
        if(++head==arr.length){
          head=0;
        }
        break;
      default:
        ++head;
    }
    this.head=head;
    return ret;
  }
#IF OfRef
  @SuppressWarnings("unchecked")
#ENDIF
  void ascendingForEach(int tail,$TypeNameModifier$Consumer$<? super E>$ action){
    final var arr=this.arr;
    int head;
    if(tail<(head=this.head)){
      for(int bound=arr.length;;){
        action.accept(($exposedType$)arr[head]);
        if(++head==bound){
          head=0;
          break;
        }
      }
    }
    for(;;){
      action.accept(($exposedType$)arr[head]);
      if(head==tail){
        break;
      }
      ++head;
    }
  }
#IF OfRef
  @SuppressWarnings("unchecked")
#ENDIF
  void descendingForEach(int tail,$TypeNameModifier$Consumer$<? super E>$ action){
    final var arr=this.arr;
    int head;
    if(tail<(head=this.head)){
      for(;;){
        action.accept(($exposedType$)arr[tail]);
        if(tail==0){
          tail=arr.length-1;
          break;
        }
        --tail;
      }
    }
    for(;;){
      action.accept(($exposedType$)arr[tail]);
      if(tail==head){
        return;
      }
      --tail;
    }
  }


#IF OfBoolean
  void fragmentedRemoveIfHelper($ArrayType$[] arr,int head,int tail,$ArrayType$ retainThis){
    int count=1;
    for(;;){
      if(--tail==-1){
        tail=arr.length-1;
        if(arr[tail=arr.length-1]==retainThis){
          ++count;
        }
        nonfragmentedRemoveIfHelper(count,arr,head,tail,retainThis);
        break;
      }
      if(arr[tail]==retainThis){
        ++count;
      }
    }
  }
  void nonfragmentedRemoveIfHelper(int count,$ArrayType$[] arr,int head,int tail,$ArrayType$ retainThis){
    for(;;){
      if(tail==head){
        this.head=0;
        this.tail=count-1;
        OmniArray.Of$ClassPrefix$.fill(arr,0,count,retainThis);
        break;
      }
      if(arr[--tail]==retainThis){
        ++count;
      }
    }
  }
#ELSE
  #IF OfRef
  @SuppressWarnings("unchecked")
  #ENDIF
  private static $<E>$ int nonfragmentedPullDown(final $ArrayType$[] arr,int dst,int src,int bound,final $TypeNameModifier$Predicate$<? super E>$ filter){
    for(;src<=bound;++src){
      final $ArrayType$ tmp;
      if(!filter.test(($exposedType$)(tmp=arr[src]))){
        arr[dst++]=tmp;
      }
    }
    return dst;
  }
  #IF OfRef
  @SuppressWarnings("unchecked")
  #ENDIF
  boolean nonfragmentedRemoveIf(int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
    final $ArrayType$[] arr;
    if(filter.test(($exposedType$)(arr=this.arr)[head])){
      for(int src=head+1;head<=tail;++src){
        if(!filter.test(($exposedType$)arr[src])){
#IF OfRef
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,src-1,head);
#ENDIF
          this.head=src;
          while(++src<=tail){
            if(filter.test(($exposedType$)arr[src])){
#IF OfRef
              this.tail=(src=nonfragmentedPullDown(arr,src,src+1,tail,filter))-1;
              OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,src);
#ELSE
              this.tail=nonfragmentedPullDown(arr,src,src+1,tail,filter)-1;
#ENDIF
              break;
            }
          }
          return true;
        }
      }
      
#IF OfRef
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head);
#ENDIF
      this.tail=-1;
      return true;
    }else{
      while(++head<=tail){
        if(filter.test(($exposedType$)arr[head])){
          
#IF OfRef
          this.tail=(head=nonfragmentedPullDown(arr,head,head+1,tail,filter))-1;
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head);
#ELSE
          this.tail=nonfragmentedPullDown(arr,head,head+1,tail,filter)-1;
#ENDIF
          return true;
        }
      }
      return false;
    }
  }
  #IF OfRef
  @SuppressWarnings("unchecked")
  #ENDIF
  private static $<E>$ int fragmentedPullDown(final $ArrayType$[] arr,int src,int arrBound,int tail,final $TypeNameModifier$Predicate$<? super E>$ filter){
    int dst=nonfragmentedPullDown(arr,src,src+1,arrBound,filter);
    for(src=0;;++src){
      final $ArrayType$ tmp;
      if(!filter.test(($exposedType$)(tmp=arr[src]))){
        arr[dst]=tmp;
        if(dst==arrBound){
#IF OfRef
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,src=nonfragmentedPullDown(arr,0,src+1,tail,filter));
          return src-1;
#ELSE
          return nonfragmentedPullDown(arr,0,src+1,tail,filter)-1;
#ENDIF
        }
        ++dst;
      }
      if(src==tail){
#IF OfRef
        OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,0);
        OmniArray.Of$ClassPrefix$.nullifyRange(arr,arrBound,dst);
#ENDIF 
        return dst-1;
      }
    }
  }
  #IF OfRef
  @SuppressWarnings("unchecked")
  #ENDIF
  boolean fragmentedRemoveIf(int head,int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
    final $ArrayType$[] arr;
    if(filter.test(($exposedType$)(arr=this.arr)[head])){
      for(int bound=arr.length-1;;){
#IF OfRef
        arr[head]=null;
#ENDIF
        if(head==bound){
          break;
        }
        if(!filter.test(($exposedType$)arr[++head])){
          this.head=head;
          while(head!=bound){
            if(filter.test(($exposedType$)arr[++head])){
              this.tail=fragmentedPullDown(arr,head,bound,tail,filter);
              return true;
            }
          }
          for(head=0;!filter.test(($exposedType$)arr[head]);++head){
            if(head==tail){
              return true;
            }
          }
#IF OfRef
          this.tail=(head=nonfragmentedPullDown(arr,head,head+1,tail,filter))-1;
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head);
#ELSE
          this.tail=nonfragmentedPullDown(arr,head,head+1,tail,filter)-1;
#ENDIF
          return true;
        }
      }
      for(head=0;filter.test(($exposedType$)arr[head]);++head){
#IF OfRef
        arr[head]=null;
#ENDIF
        if(head==tail){
          this.tail=-1;
          return true;
        }
      }
      this.head=head;
      while(++head<=tail){
        if(filter.test(($exposedType$)arr[head])){
#IF OfRef
          this.tail=(head=nonfragmentedPullDown(arr,head,head+1,tail,filter))-1;
          OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head);
#ELSE
          this.tail=nonfragmentedPullDown(arr,head,head+1,tail,filter)-1;
#ENDIF
          break;
        }
      }
      return true;
    }else{
      for(int bound=arr.length-1;++head<=bound;){
        if(filter.test(($exposedType$)arr[head])){
          this.tail=fragmentedPullDown(arr,head,bound,tail,filter);
          return true;
        }
      }
      for(head=0;!filter.test(($exposedType$)arr[head]);++head){
        if(head==tail){
          return false;
        }
      }
      
#IF OfRef
      this.tail=(head=nonfragmentedPullDown(arr,head,head+1,tail,filter))-1;
      OmniArray.Of$ClassPrefix$.nullifyRange(arr,tail,head+1);
#ELSE
      this.tail=nonfragmentedPullDown(arr,head,head+1,tail,filter)-1;
#ENDIF
      return true;
    }
  }
#ENDIF
#IF OfRef
  @SuppressWarnings("unchecked")
#ENDIF
  boolean uncheckedRemoveIf(int tail,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfBoolean
    final $ArrayType$[] arr;
    $ArrayType$ firstVal;
    var head=this.head;
    if(filter.test(firstVal=(arr=this.arr)[tail])){
      switch(Integer.signum(tail-head)){
        case -1:
          while(--tail!=-1){
            if(arr[tail]^firstVal){
              if(filter.test(!firstVal)){
                this.tail=-1;
              }else{
                fragmentedRemoveIfHelper(arr,head,tail,!firstVal);
              }
              return true;
            }
          }
          tail=arr.length;
        default:
          do{
            if(arr[--tail]^firstVal){
              if(filter.test(!firstVal)){
                break;
              }
              nonfragmentedRemoveIfHelper(1,arr,head,tail,!firstVal);
              return true;
            }
          }while(tail!=head);
        case 0:
          this.tail=-1;
          break;
      }
      return true;
    }else{
      switch(Integer.signum(tail-head)){
        case -1:
          while(--tail!=-1){
            if(arr[tail]^firstVal){
              if(filter.test(!firstVal)){
                fragmentedRemoveIfHelper(arr,head,tail,firstVal);
                return true;
              }else{
                return false;
              }
            }
          }
          tail=arr.length;
        default:
          do{
            if(arr[--tail]^firstVal){
              if(filter.test(!firstVal)){
                nonfragmentedRemoveIfHelper(1,arr,head,tail,firstVal);
                return true;
              }
              break;
            }
          }while(tail!=head);
        case 0:
          return false;
      }
    }
#ELSE
    
    int head;
    switch(Integer.signum(tail-(head=this.head))){
      case -1:
      {
        return fragmentedRemoveIf(head,tail,filter);
      }
      case 0:
      {
        
#IF OfRef
        final $ArrayType$[] arr;
        if(filter.test(($exposedType$)(arr=this.arr)[head])){
          arr[head]=null;
#ELSE
        if(filter.test(($exposedType$)arr[head])){
#ENDIF

          this.tail=-1;
          return true;
        }
        return false;
      }
      default:
      {
        return nonfragmentedRemoveIf(head,tail,filter);
      }
    }
#ENDIF
  }
  
#IF OfRef
  static abstract class AbstractUntetheredArrSeqItr<E> implements OmniIterator.Of$ClassPrefix$$<E>${
#ELSE
  static abstract class AbstractUntetheredArrSeqItr<E> extends Abstract$TypeNameModifier$Itr$<E>${
#ENDIF
    transient final $ClassPrefix$UntetheredArrSeq<E> root;
    transient int index;
    transient int numLeft;
    AbstractUntetheredArrSeqItr($ClassPrefix$UntetheredArrSeq<E> root,int index,int numLeft){
      this.root=root;
      this.index=index;
      this.numLeft=numLeft;
    }
#IF OfRef
    public abstract Object clone();
#ENDIF
    public boolean hasNext(){
      return this.numLeft>0;
    }
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    public $exposedType$ next$TypeNameModifier$(){
      --numLeft;
      final $ArrayType$[] arr;
      final int index;
      iterateIndex(index=this.index,arr=this.root.arr);
      return ($exposedType$)arr[index];
    }
    public void remove(){
      final $ClassPrefix$UntetheredArrSeq<E> root;
      final int head;
      int tail;
      switch(Integer.signum((tail=(root=this.root).tail)-(head=root.head))){
        case -1:
          fragmentedRemove(root,head,tail);
          break;
        case 0:
#IF OfRef
          root.arr[tail]=null;
#ENDIF
          root.tail=-1;
          break;
        default:
          nonfragmentedRemove(root,head,tail);
      }
    }
    public void forEachRemaining($TypeNameModifier$Consumer$<? super E>$ action){
      if(numLeft!=0){
        uncheckedForEachRemaining(action);
      }
    }
#IFNOT OfRef
    public void forEachRemaining(Consumer<? super $BoxedType$> action){
      if(numLeft!=0){
        uncheckedForEachRemaining(action::accept);
      }
    }
#ENDIF
    abstract void iterateIndex(int index,final $ArrayType$[] arr);
    abstract void fragmentedRemove(final $ClassPrefix$UntetheredArrSeq<E> root,int head,int tail);
    abstract void nonfragmentedRemove(final $ClassPrefix$UntetheredArrSeq<E> root,int head,int tail);
    abstract void uncheckedForEachRemaining(final $TypeNameModifier$Consumer$<? super E>$ action);
  }
  static class AscendingUntetheredArrSeqItr<E> extends AbstractUntetheredArrSeqItr<E>{
    AscendingUntetheredArrSeqItr($ClassPrefix$UntetheredArrSeq<E> root,int index,int numLeft){
      super(root,index,numLeft);
    }
    @Override public Object clone(){
      return new AscendingUntetheredArrSeqItr<E>(root,index,numLeft);
    }
    @Override void iterateIndex(int index,final $ArrayType$[] arr){
      if(++index==arr.length){
        index=0;
      }
      this.index=index;
    }
    @Override void nonfragmentedRemove(final $ClassPrefix$UntetheredArrSeq<E> root,final int head,int tail){
      final var arr=root.arr;
      final int index,headLength,tailLength;
      if((headLength=(index=this.index-1)-head)<=(tailLength=tail-index)){
        ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headLength);
#IF OfRef
        arr[head]=null;
#ENDIF
        root.head=tail;
      }else{
        ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailLength);
#IF OfRef
        arr[tail]=null;
#ENDIF
        root.tail=tail-1;
        this.index=index;
      }
    }
    @Override void fragmentedRemove(final $ClassPrefix$UntetheredArrSeq<E> root,final int head,int tail){
      final var arr=root.arr;
      final int headLength;
      int index;
      if((index=this.index-1)==-1){
        if((headLength=(index=arr.length-1)-head)<=1+tail){
          if(headLength==0){
            root.head=0;
          }else{
            ArrCopy.uncheckedCopy(arr,head,arr,tail=head+1,headLength);
            root.head=tail;
          }
#IF OfRef
          arr[head]=null;
#ENDIF
        }else{
          arr[index]=arr[0];
          if(tail==0){
            root.tail=index;
          }else{
            ArrCopy.uncheckedSelfCopy(arr,0,1,tail);
            root.tail=tail-1;
          }
#IF OfRef
          arr[tail]=null;
#ENDIF
          this.index=index;
        }
      }else{
        int tailLength;
        if(index<head){
          if((headLength=arr.length-head-1)+index<(tailLength=tail-index)){
            ArrCopy.semicheckedCopy(arr,0,arr,1,index);
            arr[0]=arr[headLength+head];
            if(headLength==0){
              root.head=0;
            }else{
              ArrCopy.uncheckedCopy(arr,head,arr,tail=head+1,headLength);
              root.head=tail;
            }
#IF OfRef
            arr[head]=null;
#ENDIF
          }else{
            if(tail==0){
              root.tail=arr.length-1;
            }else{
              ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailLength);
              root.tail=tail-1;
            }
#IF OfRef
            arr[tail]=null;
#ENDIF
            this.index=index;
          }
        }else{
          if((headLength=index-head)<=(tailLength=arr.length-index)+tail){
            if(headLength+tailLength==1){
              root.head=0;
            }else{
              ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headLength);
              root.head=tail;
            }
#IF OfRef
            arr[head]=null;
#ENDIF
          }else{
            ArrCopy.semicheckedSelfCopy(arr,index,index+1,--tailLength);
            arr[tailLength+=index]=arr[0];
            if(tail==0){
              root.tail=tailLength;
            }else{
              ArrCopy.uncheckedSelfCopy(arr,0,1,tail);
              root.tail=tail-1;
            }
#IF OfRef
            arr[tail]=null;
#ENDIF
            this.index=index;
          }
        }
      }
    }
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    @Override void uncheckedForEachRemaining(final $TypeNameModifier$Consumer$<? super E>$ action){
      final $ClassPrefix$UntetheredArrSeq<E> root;
      final int tail;
      int index;
      final var arr=(root=this.root).arr;
      if((index=this.index)>(tail=root.tail)){
        for(int bound=arr.length;;){
          action.accept(($exposedType$)arr[index]);
          if(++index==bound){
            index=0;
            break;
          }
        }
      }
      do{
        action.accept(($exposedType$)arr[index]);
      }while(++index<=tail);
      this.index=index;
    }
  }
  static class DescendingUntetheredArrSeqItr<E> extends AbstractUntetheredArrSeqItr<E>{
    DescendingUntetheredArrSeqItr($ClassPrefix$UntetheredArrSeq<E> root,int index,int numLeft){
      super(root,index,numLeft);
    }
    @Override public Object clone(){
      return new AscendingUntetheredArrSeqItr<E>(root,index,numLeft);
    }
    @Override void iterateIndex(int index,final $ArrayType$[] arr){
      if(--index==-1){
        index=arr.length-1;
      }
      this.index=index;
    }
    @Override void nonfragmentedRemove(final $ClassPrefix$UntetheredArrSeq<E> root,final int head,int tail){
      final var arr=root.arr;
      final int index,headLength,tailLength;
      if((headLength=(index=this.index+1)-head)<=(tailLength=tail-index)){
        ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headLength);
#IF OfRef
        arr[head]=null;
#ENDIF
        root.head=tail;
        this.index=index;
      }else{
        ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailLength);
#IF OfRef
        arr[tail]=null;
#ENDIF
        root.tail=tail-1;
      }
    }
    @Override void fragmentedRemove(final $ClassPrefix$UntetheredArrSeq<E> root,final int head,int tail){
      final $ArrayType$[] arr;
      final int headLength;
      int index;
      if((index=this.index+1)==(arr=root.arr).length){
        if((headLength=index-head-1)<tail){
          arr[0]=arr[index-1];
          if(headLength==0){
            root.head=0;
          }else{
            ArrCopy.uncheckedCopy(arr,head,arr,tail=head+1,headLength);
            root.head=tail;
          }
#IF OfRef
          arr[head]=null;
#ENDIF
          this.index=0;
        }else{
          if(tail==0){
            root.tail=index-1;
          }else{
            ArrCopy.uncheckedSelfCopy(arr,0,1,tail);
            root.tail=tail-1;
          }
#IF OfRef
          arr[tail]=null;
#ENDIF
        }
      }else{
        int tailLength;
        if(index<head){
          if((headLength=arr.length-head-1)+index<(tailLength=tail-index)){
            ArrCopy.semicheckedCopy(arr,0,arr,1,index);
            arr[0]=arr[headLength+head];
            if(headLength==0){
              root.head=0;
            }else{
              ArrCopy.uncheckedCopy(arr,head,arr,tail=head+1,headLength);
              root.head=tail;
            }
#IF OfRef
            arr[head]=null;
#ENDIF
            this.index=index;
          }else{
            if(tail==0){
              root.tail=arr.length-1;
            }else{
              ArrCopy.semicheckedSelfCopy(arr,index,index+1,tailLength);
              root.tail=tail-1;
            }
#IF OfRef
            arr[tail]=null;
#ENDIF
          }
        }else{
          if((headLength=index-head)<=(tailLength=arr.length-index)+tail){
            if(headLength+tailLength==1){
              root.head=0;
            }else{
              ArrCopy.semicheckedCopy(arr,head,arr,tail=head+1,headLength);
              root.head=tail;
            }
#IF OfRef
            arr[head]=null;
#ENDIF
            this.index=index;
          }else{
            ArrCopy.semicheckedSelfCopy(arr,index,index+1,--tailLength);
            arr[tailLength+=index]=arr[0];
            if(tail==0){
              root.tail=tailLength;
            }else{
              ArrCopy.uncheckedSelfCopy(arr,0,1,tail);
              root.tail=tail-1;
            }
#IF OfRef
            arr[tail]=null;
#ENDIF
          }
        }
      }
    }
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    @Override void uncheckedForEachRemaining(final $TypeNameModifier$Consumer$<? super E>$ action){
      final $ClassPrefix$UntetheredArrSeq<E> root;
      final int head;
      int index;
      final var arr=(root=this.root).arr;
      if((index=this.index)<(head=root.head)){
        for(;;){
          action.accept(($exposedType$)arr[index]);
          if(--index==-1){
            index=arr.length-1;
            break;
          }
        }
      }
      do{
        action.accept(($exposedType$)arr[index]);
      }while(--index>=head);
      this.index=index;
    }
  }
}
