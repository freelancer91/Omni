#TYPEDEF OfBoolean
package omni.impl.set;
import omni.api.OmniNavigableSet;
import java.io.Serializable;
import java.io.Externalizable;
import java.util.Collection;
import omni.api.OmniCollection;
import omni.function.BooleanComparator;
import omni.function.BooleanConsumer;
import java.util.function.Consumer;
import omni.function.BooleanPredicate;
import java.util.function.Predicate;
import java.io.ObjectOutput;
import java.io.ObjectInput;
import java.io.IOException;
import java.util.function.IntFunction;
import omni.util.OmniArray;
import omni.api.OmniIterator;
import java.util.Set;
import omni.api.OmniSet;
import java.util.NoSuchElementException;
import omni.impl.AbstractBooleanItr;
import java.util.ConcurrentModificationException;
import omni.impl.CheckedCollection;
public class BooleanSetImpl extends AbstractBooleanSet implements Externalizable,Cloneable{
  transient int state;
  @Override public OmniNavigableSet.OfBoolean descendingSet(){
    return new DescendingView(this);
  }
  #MACRO Constructors<BooleanSetImpl>()
  #MACRO Comparator<Ascending>()
  #MACRO ToString<this,Ascending,Full>()
  #MACRO AccessMethods<this,Full,Ascending>()
  #MACRO EqualsMethod<this,Full>()
  #MACRO SizeClearHashCodeIsEmpty<this,Full>()
  #MACRO ForEach<this,Full,Ascending>(BooleanConsumer,true,false)
  #MACRO ForEach<this,Full,Ascending>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  #MACRO RemoveIf<this,Full>(BooleanPredicate,true,false)
  #MACRO RemoveIf<this,Full>(Predicate<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  #MACRO AddRemoveContains<this,Full,True>(10)
  #MACRO AddRemoveContains<this,Full,False>(01)
  #MACRO ToArray<this,Ascending,Full>()
  @Override public OmniIterator.OfBoolean iterator(){
    final int state;
    if((state=this.state)==0b00){
      return EMPTY_ITR;
    }
    return new UncheckedAscendingFullItr(this,state);
  }
  @Override public OmniIterator.OfBoolean descendingIterator(){
    final int state;
    if((state=this.state)==0b00){
      return EMPTY_ITR;
    }
    return new UncheckedDescendingFullItr(this,state);
  }
  #MACRO FirstAndLastBoolean<this,Ascending,False,Full>()
  #MACRO SubSetMethods<this,Full,Ascending,False>()
  public static class Checked extends BooleanSetImpl{
    #MACRO Constructors<Checked>()
    @Override public OmniNavigableSet.OfBoolean descendingSet(){
      return new DescendingView.Checked(this);
    }
    @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
      final int state=this.state;
      final T[] dst;
      try{
	      switch(state){
	        case 0b00:
	          return arrConstructor.apply(0);
	        case 0b01:
	          (dst=arrConstructor.apply(1))[0]=(T)Boolean.FALSE;
	          break;
	        case 0b10:
	          (dst=arrConstructor.apply(1))[0]=(T)Boolean.TRUE;
	          break;
	        default:
	          (dst=arrConstructor.apply(2))[0]=(T)Boolean.FALSE;
	          dst[1]=(T)Boolean.TRUE;
	      }
      }finally{
        CheckedCollection.checkModCount(state,this.state);
      }
      return dst;
    }
    @Override public void writeExternal(ObjectOutput oos) throws IOException{
      final int expectedState=this.state;
      try{
        super.writeExternal(oos);
      }finally{
        CheckedCollection.checkModCount(expectedState,this.state);
      }
    }
    @Override public OmniIterator.OfBoolean iterator(){
      final int state;
      if((state=this.state)==0b00){
        return EMPTY_ITR;
      }
      return new CheckedAscendingFullItr(this,state);
    }
    @Override public OmniIterator.OfBoolean descendingIterator(){
      final int state;
      if((state=this.state)==0b00){
        return EMPTY_ITR;
      }
      return new CheckedDescendingFullItr(this,state);
    }
    #MACRO FirstAndLastBoolean<this,Ascending,True,Full>()
    #MACRO SubSetMethods<this,Full,Ascending,True>()
  
  }
  public static class Descending extends BooleanSetImpl{
    #MACRO Constructors<Descending>()
    #MACRO Comparator<Descending>()
    #MACRO ToString<this,Descending,Full>()
    #MACRO ForEach<this,Full,Descending>(BooleanConsumer,true,false)
    #MACRO ForEach<this,Full,Descending>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
    #MACRO ToArray<this,Descending,Full>()
    #MACRO AccessMethods<this,Full,Descending>()
    @Override public OmniIterator.OfBoolean iterator(){
      final int state;
      if((state=this.state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedDescendingFullItr(this,state);
    }
    @Override public OmniIterator.OfBoolean descendingIterator(){
      final int state;
      if((state=this.state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedAscendingFullItr(this,state);
    }
    #MACRO FirstAndLastBoolean<this,Descending,False,Full>()
    @Override public OmniNavigableSet.OfBoolean descendingSet(){
      return new AscendingView(this);
    }
    #MACRO SubSetMethods<this,Full,Descending,False>()
    public static class Checked extends Descending{
      #MACRO Constructors<Checked>()
      @Override public OmniIterator.OfBoolean iterator(){
        final int state;
        if((state=this.state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedDescendingFullItr(this,state);
      }
      @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
	      final int state=this.state;
	      final T[] dst;
	      try{
		      switch(state){
		        case 0b00:
		          return arrConstructor.apply(0);
		        case 0b01:
		          (dst=arrConstructor.apply(1))[0]=(T)Boolean.FALSE;
		          break;
		        case 0b10:
		          (dst=arrConstructor.apply(1))[0]=(T)Boolean.TRUE;
		          break;
		        default:
		          (dst=arrConstructor.apply(2))[0]=(T)Boolean.TRUE;
		          dst[1]=(T)Boolean.FALSE;
		      }
	      }finally{
	        CheckedCollection.checkModCount(state,this.state);
	      }
	      return dst;
	    }
      @Override public void writeExternal(ObjectOutput oos) throws IOException{
        final int expectedState=this.state;
        try{
          super.writeExternal(oos);
        }finally{
          CheckedCollection.checkModCount(expectedState,this.state);
        }
      }
      @Override public OmniNavigableSet.OfBoolean descendingSet(){
        return new AscendingView.Checked(this);
      }
      @Override public OmniIterator.OfBoolean descendingIterator(){
        final int state;
        if((state=this.state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedAscendingFullItr(this,state);
      }
      #MACRO FirstAndLastBoolean<this,Descending,True,Full>()
      #MACRO SubSetMethods<this,Full,Descending,True>()
    }
  }
  @Override public void writeExternal(ObjectOutput oos) throws IOException{
    oos.writeByte(this.state);
  }
  @Override public void readExternal(ObjectInput ois) throws IOException{
    this.state=ois.readUnsignedByte();
  }
  private static boolean equalsFullState(Set<?> val){
    if(val.size()==2){
      if(val instanceof OmniSet){
        if(val instanceof AbstractBooleanSet){
          return true;
        }else if(val instanceof OmniSet.OfRef){
          final OmniSet.OfRef<?> that;
          return (that=(OmniSet.OfRef<?>)val).contains(false) && that.contains(true);
        }
      }else{
        return val.contains(Boolean.FALSE) && val.contains(Boolean.TRUE);
      }
    }
    return false;
  }
  private static boolean equalsTrueState(Set<?> val){
    if(val.size()==1){
      if(val instanceof OmniSet){
        if(val instanceof AbstractBooleanSet){
          return ((AbstractBooleanSet)val).containsTrue();
        }else if(val instanceof OmniSet.OfRef){
          return ((OmniSet.OfRef<?>)val).contains(true);
        }
      }else{
        return val.contains(Boolean.TRUE);
      }
    }
    return false;
  }
  private static boolean equalsFalseState(Set<?> val){
    if(val.size()==1){
      if(val instanceof OmniSet){
        if(val instanceof AbstractBooleanSet){
          return ((AbstractBooleanSet)val).containsFalse();
        }else if(val instanceof OmniSet.OfRef){
          return ((OmniSet.OfRef<?>)val).contains(false);
        }
      }else{
        return val.contains(Boolean.FALSE);
      }
    }
    return false;
  }
  
  private static abstract class AbstractFullView extends AbstractBooleanSet implements Serializable,Cloneable{
    private static final long serialVersionUID=1L;
    transient final BooleanSetImpl root;
    private AbstractFullView(BooleanSetImpl root){
      this.root=root;
    }
    #MACRO AddRemoveContains<root,Full,True>(10)
    #MACRO AddRemoveContains<root,Full,False>(01)
    #MACRO RemoveIf<root,Full>(BooleanPredicate,true,false)
    #MACRO RemoveIf<root,Full>(Predicate<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
    #MACRO SizeClearHashCodeIsEmpty<root,Full>()
    #MACRO EqualsMethod<root,Full>()
  }

  private static class DescendingView extends AbstractFullView{
    private static final long serialVersionUID=1L;
    private DescendingView(BooleanSetImpl root){
      super(root);
    }
    @Override public Object clone(){
      return new Descending(root.state);
    }
    private Object writeReplace(){
      return new Descending(root.state);
    }
    @Override public OmniNavigableSet.OfBoolean descendingSet(){
      return root;
    }
    #MACRO Comparator<Descending>()
    #MACRO ToArray<root,Descending,Full>()
    #MACRO ForEach<root,Full,Descending>(BooleanConsumer,true,false)
    #MACRO ForEach<root,Full,Descending>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
    #MACRO FirstAndLastBoolean<root,Descending,False,Full>()
    #MACRO ToString<root,Descending,Full>()
    #MACRO AccessMethods<root,Full,Descending>()
    @Override public OmniIterator.OfBoolean iterator(){
      final BooleanSetImpl root;
      final int rootState;
      if((rootState=(root=this.root).state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedDescendingFullItr(root,rootState);
    }
    @Override public OmniIterator.OfBoolean descendingIterator(){
      final BooleanSetImpl root;
      final int rootState;
      if((rootState=(root=this.root).state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedAscendingFullItr(root,rootState);
    }
    #MACRO SubSetMethods<root,Full,Descending,False>()
    private static class Checked extends DescendingView{
      private static final long serialVersionUID=1L;
      private Checked(BooleanSetImpl root){
        super(root);
      }
      @Override public OmniNavigableSet.OfBoolean descendingSet(){
        return root;
      }
      @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
         final BooleanSetImpl root;
	      final int state=(root=this.root).state;
	      final T[] dst;
	      try{
		      switch(state){
		        case 0b00:
		          return arrConstructor.apply(0);
		        case 0b01:
		          (dst=arrConstructor.apply(1))[0]=(T)Boolean.FALSE;
		          break;
		        case 0b10:
		          (dst=arrConstructor.apply(1))[0]=(T)Boolean.TRUE;
		          break;
		        default:
		          (dst=arrConstructor.apply(2))[0]=(T)Boolean.TRUE;
		          dst[1]=(T)Boolean.FALSE;
		      }
	      }finally{
	        CheckedCollection.checkModCount(state,root.state);
	      }
	      return dst;
	    }
      @Override public Object clone(){
        return new Descending.Checked(root.state);
      }
      private Object writeReplace(){
        return new Descending.Checked(root.state);
      }
      #MACRO FirstAndLastBoolean<root,Descending,True,Full>()
      @Override public OmniIterator.OfBoolean iterator(){
        final BooleanSetImpl root;
        final int rootState;
        if((rootState=(root=this.root).state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedDescendingFullItr(root,rootState);
      }
      @Override public OmniIterator.OfBoolean descendingIterator(){
        final BooleanSetImpl root;
        final int rootState;
        if((rootState=(root=this.root).state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedAscendingFullItr(root,rootState);
      }
      #MACRO SubSetMethods<root,Full,Descending,True>()
    }
  }
  
  private static class AscendingView extends AbstractFullView{
    private static final long serialVersionUID=1L;
    private AscendingView(BooleanSetImpl root){
      super(root);
    }
    @Override public Object clone(){
      return new BooleanSetImpl(root.state);
    }
    private Object writeReplace(){
      return new BooleanSetImpl(root.state);
    }
    #MACRO Comparator<Ascending>()
    #MACRO ToArray<root,Ascending,Full>()
    #MACRO ForEach<root,Full,Ascending>(BooleanConsumer,true,false)
    #MACRO ForEach<root,Full,Ascending>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
    #MACRO FirstAndLastBoolean<root,Ascending,False,Full>()
    #MACRO AccessMethods<root,Full,Ascending>()
    #MACRO ToString<root,Ascending,Full>()
    @Override public OmniIterator.OfBoolean iterator(){
      final BooleanSetImpl root;
      final int rootState;
      if((rootState=(root=this.root).state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedAscendingFullItr(root,rootState);
    }
    @Override public OmniIterator.OfBoolean descendingIterator(){
      final BooleanSetImpl root;
      final int rootState;
      if((rootState=(root=this.root).state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedDescendingFullItr(root,rootState);
    }
    
    @Override public OmniNavigableSet.OfBoolean descendingSet(){
      return root;
    }
    #MACRO SubSetMethods<root,Full,Ascending,False>()
    private static class Checked extends AscendingView{
      private static final long serialVersionUID=1L;
      private Checked(BooleanSetImpl root){
        super(root);
      }
      @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
         final BooleanSetImpl root;
	      final int state=(root=this.root).state;
	      final T[] dst;
	      try{
		      switch(state){
		        case 0b00:
		          return arrConstructor.apply(0);
		        case 0b01:
		          (dst=arrConstructor.apply(1))[0]=(T)Boolean.FALSE;
		          break;
		        case 0b10:
		          (dst=arrConstructor.apply(1))[0]=(T)Boolean.TRUE;
		          break;
		        default:
		          (dst=arrConstructor.apply(2))[0]=(T)Boolean.FALSE;
		          dst[1]=(T)Boolean.TRUE;
		      }
	      }finally{
	        CheckedCollection.checkModCount(state,root.state);
	      }
	      return dst;
	    }
      @Override public OmniNavigableSet.OfBoolean descendingSet(){
        return root;
      }
      @Override public Object clone(){
        return new BooleanSetImpl.Checked(root.state);
      }
      private Object writeReplace(){
        return new BooleanSetImpl.Checked(root.state);
      }
      #MACRO FirstAndLastBoolean<root,Ascending,True,Full>()
      @Override public OmniIterator.OfBoolean iterator(){
        final BooleanSetImpl root;
        final int rootState;
        if((rootState=(root=this.root).state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedAscendingFullItr(root,rootState);
      }
      @Override public OmniIterator.OfBoolean descendingIterator(){
        final BooleanSetImpl root;
        final int rootState;
        if((rootState=(root=this.root).state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedDescendingFullItr(root,rootState);
      }
      #MACRO SubSetMethods<root,Full,Ascending,True>()
    }
  }
  private static abstract class AbstractSingleView extends AbstractBooleanSet{
    transient final BooleanSetImpl root;
    private AbstractSingleView(BooleanSetImpl root){
      this.root=root;
    }
    #MACRO Comparator<Ascending>()
   
  }
  private static class UncheckedTrueView extends AbstractSingleView{
    private UncheckedTrueView(BooleanSetImpl root){
      super(root);
    }
    #MACRO AddRemoveContains<root,True,True>(10)
    #MACRO AddRemoveContains<root,True,False>(01)
    #MACRO RemoveIf<root,True>(BooleanPredicate,true,false)
    #MACRO RemoveIf<root,True>(Predicate<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
    #MACRO SizeClearHashCodeIsEmpty<root,True>()
    #MACRO EqualsMethod<root,True>()
    #MACRO ToArray<root,Ascending,True>()
    #MACRO ForEach<root,True,Ascending>(BooleanConsumer,true,false)
    #MACRO ForEach<root,True,Ascending>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
    #MACRO FirstAndLastBoolean<root,Ascending,False,True>()
    #MACRO ToString<root,Ascending,True>()
    #MACRO AccessMethods<root,True,Ascending>()
    @Override public OmniIterator.OfBoolean iterator(){
      final BooleanSetImpl root;
      if(((root=this.root).state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedTrueItr(root,0b1);
    }
    @Override public OmniIterator.OfBoolean descendingIterator(){
      final BooleanSetImpl root;
      if(((root=this.root).state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedTrueItr(root,0b1);
    }
    @Override public OmniNavigableSet.OfBoolean descendingSet(){
      return new UncheckedTrueView.Descending(root);
    }
    #MACRO SubSetMethods<root,True,Ascending,False>()
    private static class Descending extends UncheckedTrueView{
      private Descending(BooleanSetImpl root){
        super(root);
      }
      #MACRO Comparator<Descending>()
      @Override public OmniNavigableSet.OfBoolean descendingSet(){
        return new UncheckedTrueView(root);
      }
      #MACRO SubSetMethods<root,True,Descending,False>()
    }
    private static class Checked extends UncheckedTrueView{
      private Checked(BooleanSetImpl root){
        super(root);
      }
      #MACRO FirstAndLastBoolean<root,Ascending,True,True>()
      @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
        final BooleanSetImpl root;
        final int state;
        final T[] dst;
        final int size=(state=(root=this.root).state)>>>1;
        try{
          dst=arrConstructor.apply(size);
        }finally{
          CheckedCollection.checkModCount(state,root.state);
        }
        if(size!=0){
          dst[0]=(T)Boolean.TRUE;
        }
        return dst;
      }
      @Override public OmniIterator.OfBoolean iterator(){
        final BooleanSetImpl root;
        if(((root=this.root).state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedTrueItr(root,0b10);
      }
      @Override public OmniIterator.OfBoolean descendingIterator(){
        final BooleanSetImpl root;
        if(((root=this.root).state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedTrueItr(root,0b10);
      }
      @Override public OmniNavigableSet.OfBoolean descendingSet(){
        return new UncheckedTrueView.Checked.Descending(root);
      }
      #MACRO SubSetMethods<root,True,Ascending,True>()
      private static class Descending extends Checked{
        private Descending(BooleanSetImpl root){
          super(root);
        }
        #MACRO Comparator<Descending>()
        @Override public OmniNavigableSet.OfBoolean descendingSet(){
          return new UncheckedTrueView.Checked(root);
        }
        #MACRO SubSetMethods<root,True,Descending,True>()
        
      }
    }
  }
  private static class UncheckedFalseView extends AbstractSingleView{
    private UncheckedFalseView(BooleanSetImpl root){
      super(root);
    }
    #MACRO AddRemoveContains<root,False,True>(10)
    #MACRO AddRemoveContains<root,False,False>(01)
    #MACRO RemoveIf<root,False>(BooleanPredicate,true,false)
    #MACRO RemoveIf<root,False>(Predicate<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
    #MACRO SizeClearHashCodeIsEmpty<root,False>()
    #MACRO EqualsMethod<root,False>()
    #MACRO ToArray<root,Ascending,False>()
    #MACRO ForEach<root,False,Ascending>(BooleanConsumer,true,false)
    #MACRO ForEach<root,False,Ascending>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
    #MACRO FirstAndLastBoolean<root,Ascending,False,False>()
    #MACRO ToString<root,Ascending,False>()
    #MACRO AccessMethods<root,False,Ascending>()
    @Override public OmniIterator.OfBoolean iterator(){
      final BooleanSetImpl root;
      if(((root=this.root).state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedFalseItr(root,0b1);
    }
    @Override public OmniIterator.OfBoolean descendingIterator(){
      final BooleanSetImpl root;
      if(((root=this.root).state)==0b00){
        return EMPTY_ITR;
      }
      return new UncheckedFalseItr(root,0b1);
    }
    @Override public OmniNavigableSet.OfBoolean descendingSet(){
      return new UncheckedFalseView.Descending(root);
    }
    #MACRO SubSetMethods<root,False,Ascending,False>()
    
    private static class Descending extends UncheckedFalseView{
      private Descending(BooleanSetImpl root){
        super(root);
      }
      @Override public OmniNavigableSet.OfBoolean descendingSet(){
        return new UncheckedFalseView(root);
      }
      #MACRO Comparator<Descending>()
      #MACRO SubSetMethods<root,False,Descending,False>()
      
    }
    private static class Checked extends UncheckedFalseView{
      private Checked(BooleanSetImpl root){
        super(root);
      }
      #MACRO FirstAndLastBoolean<root,Ascending,True,False>()
      @Override public OmniNavigableSet.OfBoolean descendingSet(){
          return new UncheckedFalseView.Checked.Descending(root);
        }
      @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
        final BooleanSetImpl root;
        final int state;
        final T[] dst;
        final int size=(state=(root=this.root).state)&0b01;
        try{
          dst=arrConstructor.apply(size);
        }finally{
          CheckedCollection.checkModCount(state,root.state);
        }
        if(size!=0){
          dst[0]=(T)Boolean.FALSE;
        }
        return dst;
      }
      @Override public OmniIterator.OfBoolean iterator(){
        final BooleanSetImpl root;
        if(((root=this.root).state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedFalseItr(root,0b10);
      }
      @Override public OmniIterator.OfBoolean descendingIterator(){
        final BooleanSetImpl root;
        if(((root=this.root).state)==0b00){
          return EMPTY_ITR;
        }
        return new CheckedFalseItr(root,0b10);
      }
      #MACRO SubSetMethods<root,False,Ascending,True>()
      private static class Descending extends Checked{
        private Descending(BooleanSetImpl root){
          super(root);
        }
        #MACRO Comparator<Descending>()
        @Override public OmniNavigableSet.OfBoolean descendingSet(){
          return new UncheckedFalseView.Checked(root);
        }
        #MACRO SubSetMethods<root,False,Descending,True>()
        
      }
    }
  }
  private static class UncheckedAscendingFullItr extends AbstractBooleanItr{
    // valid itrStates
    // state | next        | forEachRemaining | expected root state | remove
    // 0b00  | undefined   | do nothing       | any                 | if root contains true, remove true, else remove false
    // 0b01  | false->0b00 | false            | 0b01                | undefined
    // 0b10  | true ->0b00 | true             | 0b11                | remove false
    // 0b11  | false->0b10 | false,true       | 0b11                | undefined

    transient final BooleanSetImpl root;
    transient int itrState;
    private UncheckedAscendingFullItr(BooleanSetImpl root,int itrState){
      this.root=root;
      this.itrState=itrState;
    }
    @Override public Object clone(){
      return new UncheckedAscendingFullItr(root,itrState);
    }
    #MACRO ItrHasNext<False,Ascending,Full>()
    #MACRO ItrNext<False,Ascending,Full>()
    #MACRO ItrRemove<False,Ascending,Full>()
    #MACRO ForEachRemaining<False,Ascending,Full>(BooleanConsumer,true,false)
    #MACRO ForEachRemaining<False,Ascending,Full>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  }

  private static class CheckedAscendingFullItr extends UncheckedAscendingFullItr{
    // valid itrStates
    // state | next         | forEachRemaining | expected root state  | remove
    // 0b000 | throw NSE    | do nothing       | 0b00 OR 0b01         | throw ISE
    // 0b001 | false->0b100 | false            | 0b01                 | throw ISE
    // 0b010 | true ->0b100 | true             | 0b10                 | throw ISE
    // 0b011 | false->0b110 | false,true       | 0b11                 | throw ISE
    // 0b100 | throw NSE    | do nothing       | 0b01 OR 0b10 OR 0b11 | if root contains true, remove true, else remove false
    // 0b110 | true ->0b100 | true             | 0b11                 | remove false
    transient int expectedRootState;
    private CheckedAscendingFullItr(BooleanSetImpl root,int itrState){
      super(root,itrState);
      this.expectedRootState=itrState;
    }
    @Override public Object clone(){
      return new CheckedAscendingFullItr(root,itrState);
    }
    #MACRO ItrHasNext<True,Ascending,Full>()
    #MACRO ItrNext<True,Ascending,Full>()
    #MACRO ItrRemove<True,Ascending,Full>()
    #MACRO ForEachRemaining<True,Ascending,Full>(BooleanConsumer,true,false)
    #MACRO ForEachRemaining<True,Ascending,Full>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  }
  private static class UncheckedDescendingFullItr extends UncheckedAscendingFullItr{
    // valid itrStates
    // state | next        | forEachRemaining | expected root state | remove
    // 0b00  | undefined   | do nothing       | any                 | if root contains false, remove false, else remove true
    // 0b01  | false->0b00 | false            | 0b11                | remove true
    // 0b10  | true ->0b00 | true             | 0b10                | undefined
    // 0b11  | true ->0b01 | true,false       | 0b11                | undefined
  
    private UncheckedDescendingFullItr(BooleanSetImpl root,int itrState){
      super(root,itrState);
    }
    @Override public Object clone(){
      return new UncheckedDescendingFullItr(root,itrState);
    }
    #MACRO ItrNext<False,Descending,Full>()
    #MACRO ItrRemove<False,Descending,Full>()
    #MACRO ForEachRemaining<False,Descending,Full>(BooleanConsumer,true,false)
    #MACRO ForEachRemaining<False,Descending,Full>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  }

  private static class CheckedDescendingFullItr extends CheckedAscendingFullItr{
    // valid itrStates
    // state | next         | forEachRemaining | expected root state  | remove
    // 0b000 | throw NSE    | do nothing       | 0b00 OR 0b10         | throw ISE
    // 0b001 | false->0b100 | false            | 0b01                 | throw ISE
    // 0b010 | true ->0b100 | true             | 0b10                 | throw ISE
    // 0b011 | true ->0b101 | true,false       | 0b11                 | throw ISE
    // 0b100 | throw NSE    | do nothing       | 0b01 OR 0b10 OR 0b11 | if root contains false, remove false, else remove true
    // 0b101 | false->0b100 | false            | 0b11                 | remove true
    private CheckedDescendingFullItr(BooleanSetImpl root,int itrState){
      super(root,itrState);
    }
    @Override public Object clone(){
      return new CheckedDescendingFullItr(root,itrState);
    }
    #MACRO ItrNext<True,Descending,Full>()
    #MACRO ItrRemove<True,Descending,Full>()
    #MACRO ForEachRemaining<True,Descending,Full>(BooleanConsumer,true,false)
    #MACRO ForEachRemaining<True,Descending,Full>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  }

  private static class UncheckedTrueItr extends UncheckedAscendingFullItr{
    // valid itrStates
    // state | previously returned | next return | nextBoolean post-state | remove      | forEachRemaining | expected root state
    // 0b0   | true                | undefined   | undefined              | remove true | do nothing       | 0b10 OR 0b01 OR 0b11 OR 0b00
    // 0b1   | undefined           | true        | 0b0                    | undefined   | true             | 0b10 OR 0b11

    private UncheckedTrueItr(BooleanSetImpl root,int itrState){
      super(root,itrState);
    }
    @Override public Object clone(){
      return new UncheckedTrueItr(root,itrState);
    }
    #MACRO ItrNext<False,Ascending,True>()
    #MACRO ItrRemove<False,Ascending,True>()
    #MACRO ForEachRemaining<False,Ascending,True>(BooleanConsumer,true,false)
    #MACRO ForEachRemaining<False,Ascending,True>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  }
  private static class UncheckedFalseItr extends UncheckedTrueItr{
    // valid itrStates
    // state | previously returned | next return | nextBoolean post-state | remove      | forEachRemaining | expected root state
    // 0b0   | false               | undefined   | undefined              | remove false| do nothing       | 0b10 OR 0b01 OR 0b11 OR 0b00
    // 0b1   | undefined           | false       | 0b0                    | undefined   | false            | 0b01 OR 0b11
    
    private UncheckedFalseItr(BooleanSetImpl root,int itrState){
      super(root,itrState);
    }
    @Override public Object clone(){
      return new UncheckedFalseItr(root,itrState);
    }
    #MACRO ItrNext<False,Ascending,False>()
    #MACRO ItrRemove<False,Ascending,False>()
    #MACRO ForEachRemaining<False,Ascending,False>(BooleanConsumer,true,false)
    #MACRO ForEachRemaining<False,Ascending,False>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  }

  private static class CheckedTrueItr extends UncheckedAscendingFullItr{
    // valid itrStates
    // state | previously returned | next return | nextBoolean post-state | remove      | remove post-state | forEachRemaining | forEachRemaining post-state | expected root state
    // 0b00  | undefined           | throw NSE   | 0b00                   | throw ISE   | 0b00              | do nothing       | 0b00                        | 0b00 OR 0b01
    // 0b01  | true                | throw NSE   | 0b01                   | remove true | 0b00              | do nothing       | 0b01                        | 0b10 OR 0b11
    // 0b10  | undefined           | return true | 0b01                   | throw ISE   | 0b10              | true             | 0b01                        | 0b10 OR 0b11
    
    private CheckedTrueItr(BooleanSetImpl root,int itrState){
      super(root,itrState);
    }
    @Override public Object clone(){
      return new CheckedTrueItr(root,itrState);
    }
    @Override public boolean hasNext(){
      return itrState==0b10;
    }
    #MACRO ItrNext<True,Ascending,True>()
    #MACRO ItrRemove<True,Ascending,True>()
    #MACRO ForEachRemaining<True,Ascending,True>(BooleanConsumer,true,false)
    #MACRO ForEachRemaining<True,Ascending,True>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  }
  private static class CheckedFalseItr extends CheckedTrueItr{
    // valid itrStates
    // state | previously returned | next return  | nextBoolean post-state | remove       | remove post-state | forEachRemaining | forEachRemaining post-state | expected root state
    // 0b00  | undefined           | throw NSE    | 0b00                   | throw ISE    | 0b00              | do nothing       | 0b00                        | 0b00 OR 0b10
    // 0b01  | false               | throw NSE    | 0b01                   | remove false | 0b00              | do nothing       | 0b01                        | 0b01 OR 0b11
    // 0b10  | undefined           | return false | 0b01                   | throw ISE    | 0b10              | false            | 0b01                        | 0b01 OR 0b11
    
    private CheckedFalseItr(BooleanSetImpl root,int itrState){
      super(root,itrState);
    }
    @Override public Object clone(){
      return new CheckedFalseItr(root,itrState);
    }
    #MACRO ItrNext<True,Ascending,False>()
    #MACRO ItrRemove<True,Ascending,False>()
    #MACRO ForEachRemaining<True,Ascending,False>(BooleanConsumer,true,false)
    #MACRO ForEachRemaining<True,Ascending,False>(Consumer<? super Boolean>,Boolean.TRUE,Boolean.FALSE)
  }
  
}
#MACRODEF AccessMethodsHelper<RETTYPE>(TRUEVAL,FALSEVAL,CLASSPREFIX,INPUTTYPE,DEFAULTVAL)
#IFSWITCH RETTYPE==Boolean
@Override public RETTYPE ceiling(INPUTTYPE val){
#ELSE
@Override public RETTYPE INPUTTYPECeiling(INPUTTYPE val){
#ENDIF
#IFSWITCH VIEW==Full
  #IFSWITCH SOURCE==this
    #IFSWITCH DIRECTION==Ascending
      #IFSWITCH RETTYPE==boolean,Boolean
  switch(SOURCE.state){
    case 0b11:
      return val;
    case 0b10:
      return TRUEVAL;
    default:
  }
  return DEFAULTVAL;
      #ELSEIFSWITCH RETTYPE==char
  switch(SOURCE.state){
   case 0b11:
     if(val==TRUEVAL){
       return TRUEVAL;
     }
     break;
   case 0b10:
     if(val<=TRUEVAL){
       return TRUEVAL;
     }
   default:
  }
  return DEFAULTVAL;
      #ELSEIFSWITCH RETTYPE==double,float
  switch(SOURCE.state){
  case 0b11:
    if(val<=FALSEVAL){
      return FALSEVAL;
    }
  case 0b10:
    if(val<=TRUEVAL){
      return TRUEVAL;
    }
    break;
  case 0b01:
    if(val<=FALSEVAL){
      return FALSEVAL;
    }
    break;
  default:
  }
  return DEFAULTVAL;
      #ELSE
  switch(SOURCE.state){
  case 0b11:
        #IFSWITCH RETTYPE==long
    switch(Long.signum(val-TRUEVAL)){
        #ELSE
    switch(Integer.signum(val-TRUEVAL)){
        #ENDIF
    case -1:
      return FALSEVAL;
    case 0:
      return TRUEVAL;
    default:
    }
    break;
  case 0b10:
    if(val<=TRUEVAL){
      return TRUEVAL;
    }
    break;
  case 0b01:
    if(val<=FALSEVAL){
      return FALSEVAL;
    }
  default:
  }
  return DEFAULTVAL;
      #ENDIF
    #ELSEIFSWITCH DIRECTION==Descending
      #IFSWITCH RETTYPE==Boolean
  return super.floor(val); 
      #ELSE
  return super.RETTYPEFloor(val);
      #ENDIF  
    #ENDIF
  #ELSEIFSWITCH SOURCE==root
    #IFSWITCH RETTYPE==Boolean
  return root.floor(val); 
    #ELSE
  return root.RETTYPEFloor(val);
    #ENDIF  
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean
  return (SOURCE.state&0b10)!=0;
    #ELSEIFSWITCH RETTYPE==Boolean
  if((SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL;
    #ELSE
  if(val<=TRUEVAL && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH RETTYPE==Boolean
  return super.floor(val);
    #ELSE
  return super.RETTYPEFloor(val);
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean,char
  return DEFAULTVAL;
    #ELSEIFSWITCH RETTYPE==Boolean
  if(!val && (SOURCE.state&0b01)!=0){
    return FALSEVAL;
  }
  return DEFAULTVAL;
    #ELSE
  if(val<=FALSEVAL && (SOURCE.state&0b01)!=0){
    return FALSEVAL;
  }
  return DEFAULTVAL;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH RETTYPE==Boolean
  return super.floor(val); 
    #ELSE
  return super.RETTYPEFloor(val);
    #ENDIF
  #ENDIF
#ENDIF
}
#IFSWITCH RETTYPE==Boolean
@Override public RETTYPE floor(INPUTTYPE val){
#ELSE
@Override public RETTYPE INPUTTYPEFloor(INPUTTYPE val){
#ENDIF
#IFSWITCH VIEW==Full
  #IFSWITCH SOURCE==this
    #IFSWITCH DIRECTION==Ascending
      #IFSWITCH RETTYPE==boolean
  return val && (SOURCE.state&0b10)!=0;
      #ELSEIFSWITCH RETTYPE==Boolean
  switch(SOURCE.state){
    case 0b11:
      return val;
    case 0b01:
      return FALSEVAL;
    case 0b10:
      if(val){
        return TRUEVAL;
      }
    case 0b00:
  }
  return DEFAULTVAL;
      #ELSEIFSWITCH RETTYPE==char
  if(val>FALSEVAL && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL;
      #ELSEIFSWITCH RETTYPE==float,double
  switch(SOURCE.state){
  case 0b11:
    if(val>=TRUEVAL){
      return TRUEVAL;
    }
  case 0b01:
    if(val>=FALSEVAL){
      return FALSEVAL;
    }
    break;
  case 0b10:
    if(val>=TRUEVAL){
      return TRUEVAL;
    }
  default:
  }
  return DEFAULTVAL;
      #ELSE
  switch(SOURCE.state){
  case 0b11:
        #IFSWITCH RETTYPE==long
    switch(Long.signum(val)){
        #ELSE
    switch(Integer.signum(val)){ 
        #ENDIF
    case 1:
      return TRUEVAL;
    case 0:
      return FALSEVAL;
    default:
    }
    break;
  case 0b01:
    if(val>=FALSEVAL){
      return FALSEVAL;
    }
    break;
  case 0b10:
    if(val>=TRUEVAL){
      return TRUEVAL;
    }
  default:
  }
  return DEFAULTVAL;
      #ENDIF
    #ELSEIFSWITCH DIRECTION==Descending
      #IFSWITCH RETTYPE==Boolean
  return super.ceiling(val); 
      #ELSE
  return super.RETTYPECeiling(val);
      #ENDIF  
    #ENDIF
  #ELSEIFSWITCH SOURCE==root
    #IFSWITCH RETTYPE==Boolean
  return root.ceiling(val); 
    #ELSE
  return root.RETTYPECeiling(val);
    #ENDIF  
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean
  return val && (SOURCE.state&0b10)!=0;
    #ELSEIFSWITCH RETTYPE==Boolean
  if(val && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL;
    #ELSE
   if(val>=TRUEVAL && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL; 
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH RETTYPE==Boolean
  return super.ceiling(val);
    #ELSE
  return super.RETTYPECeiling(val);
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean,char
  return DEFAULTVAL;
    #ELSEIFSWITCH RETTYPE==Boolean
  if((SOURCE.state&0b01)!=0){
    return FALSEVAL;
  }
  return DEFAULTVAL;  
    #ELSE
  if(val>=FALSEVAL && (SOURCE.state&0b01)!=0){
    return FALSEVAL;
  }
  return DEFAULTVAL;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH RETTYPE==Boolean
  return super.ceiling(val); 
    #ELSE
  return super.RETTYPECeiling(val);
    #ENDIF
  #ENDIF
#ENDIF
}
@Override public RETTYPE lowerCLASSPREFIX(INPUTTYPE val){
#IFSWITCH VIEW==Full
  #IFSWITCH SOURCE==this
    #IFSWITCH DIRECTION==Ascending
      #IFSWITCH RETTYPE==boolean
  return DEFAULTVAL;
      #ELSEIFSWITCH RETTYPE==Boolean
  if(val && (SOURCE.state&0b01)!=0){
    return FALSEVAL;
  }
  return DEFAULTVAL;
      #ELSEIFSWITCH RETTYPE==char
  if(val>TRUEVAL && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL;
      #ELSEIFSWITCH RETTYPE==float,double
  switch(SOURCE.state){
  case 0b11:
    if(val>TRUEVAL){
      return TRUEVAL;
    }
  case 0b01:
    if(val>FALSEVAL){
      return FALSEVAL;
    }
    break;
  case 0b10:
    if(val>TRUEVAL){
      return TRUEVAL;
    }
  default:
  }
  return DEFAULTVAL;
      #ELSE
  switch(SOURCE.state){
  case 0b11:
        #IFSWITCH RETTYPE==long
    switch(Long.signum(val-TRUEVAL)){
        #ELSE
    switch(Integer.signum(val-TRUEVAL)){    
        #ENDIF
    case 1:
      return TRUEVAL;
    case 0:
      return FALSEVAL;
    default:
    }
    break;
  case 0b01:
    if(val>FALSEVAL){
      return FALSEVAL;
    }
    break;
  case 0b10:
    if(val>TRUEVAL){
      return TRUEVAL;
    }
  default:
  }    
  return DEFAULTVAL;
      #ENDIF
    #ELSEIFSWITCH DIRECTION==Descending
  return super.higherCLASSPREFIX(val);
    #ENDIF
  #ELSEIFSWITCH SOURCE==root
  return SOURCE.higherCLASSPREFIX(val);
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean,Boolean
  return DEFAULTVAL;
    #ELSE
  if(val>TRUEVAL && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    return super.higherCLASSPREFIX(val);
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean,char
  return DEFAULTVAL;
    #ELSEIFSWITCH RETTYPE==Boolean
  if(val && (SOURCE.state&0b01)!=0){
    return FALSEVAL;
  }
  return DEFAULTVAL;
    #ELSE
  if(val>FALSEVAL && (SOURCE.state&0b01)!=0){
    return FALSEVAL;
  }  
  return DEFAULTVAL;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
  return super.higherCLASSPREFIX(val);
  #ENDIF
#ENDIF
}
@Override public RETTYPE higherCLASSPREFIX(INPUTTYPE val){
#IFSWITCH VIEW==Full
  #IFSWITCH SOURCE==this
    #IFSWITCH DIRECTION==Ascending
      #IFSWITCH RETTYPE==boolean
  return !val && (SOURCE.state&0b10)!=0;
      #ELSEIFSWITCH RETTYPE==Boolean
  if(!val && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL;
      #ELSEIFSWITCH RETTYPE==char
  if(val==FALSEVAL && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL;
      #ELSEIFSWITCH RETTYPE==float,double
  switch(SOURCE.state){
  case 0b11:
    if(val<FALSEVAL){
      return FALSEVAL;
    }
  case 0b10:
    if(val<TRUEVAL){
      return TRUEVAL;
    }
    break;
  case 0b01:
    if(val<FALSEVAL){
      return FALSEVAL;
    }
  default:
  }
  return DEFAULTVAL;
      #ELSE
  switch(SOURCE.state){
  case 0b11:
    #IFSWITCH RETTYPE==long
    switch(Long.signum(val)){
    #ELSE
    switch(Integer.signum(val)){
    #ENDIF
    case -1:
      return FALSEVAL;
    case 0:
      return TRUEVAL;
    default:
    }
    break;
  case 0b10:
    if(val<TRUEVAL){
      return TRUEVAL;
    }
    break;
  case 0b01:
    if(val<FALSEVAL){
      return FALSEVAL;
    }
  default:
  }
  return DEFAULTVAL;
      #ENDIF
    #ELSEIFSWITCH DIRECTION==Descending
  return super.lowerCLASSPREFIX(val);
    #ENDIF
  #ELSEIFSWITCH SOURCE==root
  return SOURCE.lowerCLASSPREFIX(val);
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean
  return !val && (SOURCE.state&0b10)!=0;
    #ELSEIFSWITCH RETTYPE==Boolean
  if(!val && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }
  return DEFAULTVAL;
    #ELSEIFSWITCH RETTYPE==char
  if(val==0 && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  }  
  return DEFAULTVAL;
    #ELSE
  if(val<TRUEVAL && (SOURCE.state&0b10)!=0){
    return TRUEVAL;
  } 
  return DEFAULTVAL;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
  return super.lowerCLASSPREFIX(val);
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean,Boolean,char
  return DEFAULTVAL;
    #ELSE
  if(val<FALSEVAL && (SOURCE.state&0b01)!=0){
    return FALSEVAL;
  } 
  return DEFAULTVAL;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
  return super.lowerCLASSPREFIX(val);
  #ENDIF
#ENDIF
}
@Override public RETTYPE pollFirstCLASSPREFIX(){
#IFSWITCH VIEW==Full
  #IFSWITCH SOURCE==this
    #IFSWITCH DIRECTION==Ascending
      #IFSWITCH RETTYPE==boolean,char
  switch(SOURCE.state){
    case 0b10:
      SOURCE.state=0b00;
      return TRUEVAL;
    case 0b11:
      SOURCE.state=0b10;
      break;
    case 0b01:
      SOURCE.state=0b00;
    default:
  }
  return DEFAULTVAL;
      #ELSE
  switch(SOURCE.state){
    default:
      return DEFAULTVAL;
    case 0b10:
      SOURCE.state=0b00;
      return TRUEVAL;
    case 0b11:
      SOURCE.state=0b10;
      break;
    case 0b01:
      SOURCE.state=0b00;
  }
  return FALSEVAL;  
      #ENDIF
    #ELSEIFSWITCH DIRECTION==Descending
  return super.pollLastCLASSPREFIX();
    #ENDIF
  #ELSEIFSWITCH SOURCE==root
  return root.pollLastCLASSPREFIX();
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&0b10)!=0){
    SOURCE.state=state-0b10;
    return TRUEVAL;
  }
  return DEFAULTVAL;
  #ELSEIFSWITCH DIRECTION==Descending
  return super.pollLastCLASSPREFIX();
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean,char
  SOURCE.state&=0b10;
  return DEFAULTVAL;
    #ELSE
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&0b01)!=0){
    SOURCE.state=state-0b01;
    return FALSEVAL;
  }
  return DEFAULTVAL;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
  return super.pollLastCLASSPREFIX();
  #ENDIF
#ENDIF
  
}
@Override public RETTYPE pollLastCLASSPREFIX(){
#IFSWITCH VIEW==Full
  #IFSWITCH SOURCE==this
    #IFSWITCH DIRECTION==Ascending
  switch(SOURCE.state){
    case 0b01:
      SOURCE.state=0b00;
    #IFNOTSWITCH RETTYPE==boolean,char
      return FALSEVAL;
    #ENDIF
    default:
      return DEFAULTVAL;
    case 0b10:
      SOURCE.state=0b00;
      break;
    case 0b11:
      SOURCE.state=0b01;
  }
  return TRUEVAL;
    #ELSEIFSWITCH DIRECTION==Descending
  return super.pollFirstCLASSPREFIX();
    #ENDIF
  #ELSEIFSWITCH SOURCE==root
  return SOURCE.pollFirstCLASSPREFIX();
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&0b10)!=0){
    SOURCE.state=state-0b10;
    return TRUEVAL;
  }
  return DEFAULTVAL;
  #ELSEIFSWITCH DIRECTION==Descending
  return super.pollFirstCLASSPREFIX();
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH RETTYPE==boolean,char
  SOURCE.state&=0b10;
  return DEFAULTVAL;
    #ELSE
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&0b01)!=0){
    SOURCE.state=state-0b01;
    return FALSEVAL;
  }
  return DEFAULTVAL;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
  return super.pollFirstCLASSPREFIX();
  #ENDIF
#ENDIF
}
#ENDDEF
#MACRODEF AccessMethods<SOURCE,VIEW,DIRECTION>()
#IFNOTSWITCH SOURCE==this,root
ERROR unknown source SOURCE
#ENDIF
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFSWITCH VIEW==True,False
  #IFNOTSWITCH SOURCE==root
ERROR the view VIEW cannot be matched with the source SOURCE
  #ENDIF
#ENDIF
#MACRO AccessMethodsHelper<Boolean>(Boolean.TRUE,Boolean.FALSE,,boolean,null)
#MACRO AccessMethodsHelper<boolean>(true,false,Boolean,boolean,false)
#MACRO AccessMethodsHelper<byte>(1,0,Byte,byte,Byte.MIN_VALUE)
#MACRO AccessMethodsHelper<char>(1,0,Char,char,Character.MIN_VALUE)
#MACRO AccessMethodsHelper<short>(1,0,Short,short,Short.MIN_VALUE)
#MACRO AccessMethodsHelper<int>(1,0,Int,int,Integer.MIN_VALUE)
#MACRO AccessMethodsHelper<long>(1L,0L,Long,long,Long.MIN_VALUE)
#MACRO AccessMethodsHelper<float>(1F,0F,Float,float,Float.NaN)
#MACRO AccessMethodsHelper<double>(1D,0D,Double,double,Double.NaN)
#ENDDEF
#MACRODEF FirstAndLastBoolean<SOURCE,DIRECTION,CHECKED,VIEW>()
#IFNOTSWITCH SOURCE==root,this
ERROR unknown source SOURCE
#ENDIF
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFNOTSWITCH CHECKED==True,False
ERROR unknown checked type CHECKED
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH SOURCE==root
ERROR the source SOURCE cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public boolean firstBoolean(){
#IFSWITCH VIEW==Full
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED==True
  switch(SOURCE.state){
    case 0b00:
      throw new NoSuchElementException();
    case 0b10:
      return true;
    default:
      return false;
  }
    #ELSEIFSWITCH CHECKED==False
  if(SOURCE.state==0b10){
    return true;
  }
  return false;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED==True
  switch(SOURCE.state){
    case 0b00:
      throw new NoSuchElementException();
    case 0b01:
      return false;
    default:
      return true;
  }
    #ELSEIFSWITCH CHECKED==False
  if(SOURCE.state==0b01){
    return false;
  }
  return true;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH CHECKED==True
  if((SOURCE.state&0b10)==0){
    throw new NoSuchElementException();
  }
  return true;
  #ELSEIFSWITCH CHECKED==False
  return true;
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH CHECKED==True
  if((SOURCE.state&0b01)==0){
    throw new NoSuchElementException();
  }
  return false;
  #ELSEIFSWITCH CHECKED==False
  return false;
  #ENDIF
#ENDIF
}
@Override public boolean lastBoolean(){
#IFSWITCH VIEW==Full
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED==True
  switch(SOURCE.state){
    case 0b00:
      throw new NoSuchElementException();
    case 0b01:
      return false;
    default:
      return true;
  }
    #ELSEIFSWITCH CHECKED==False
  if(SOURCE.state==0b01){
    return false;
  }
  return true;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED==True
  switch(SOURCE.state){
    case 0b00:
      throw new NoSuchElementException();
    case 0b10:
      return true;
    default:
      return false;
  }
    #ELSEIFSWITCH CHECKED==False
  if(SOURCE.state==0b10){
    return true;
  }
  return false;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH CHECKED==True
  if((SOURCE.state&0b10)==0){
    throw new NoSuchElementException();
  }
  return true;
  #ELSEIFSWITCH CHECKED==False
  return true;
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH CHECKED==True
  if((SOURCE.state&0b01)==0){
    throw new NoSuchElementException();
  }
  return false;
  #ELSEIFSWITCH CHECKED==False
  return false;
  #ENDIF
#ENDIF
}
#ENDDEF
#MACRODEF Comparator<DIRECTION>()
@Override public BooleanComparator comparator(){
#IFSWITCH DIRECTION==Ascending
  return Boolean::compare;
#ELSEIFSWITCH DIRECTION==Descending
  return BooleanComparator::descendingCompare;
#ENDIF
}
#ENDDEF
#MACRODEF ToString<SOURCE,DIRECTION,VIEW>()
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFNOTSWITCH SOURCE==this,root
ERROR unknown source SOURCE
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH SOURCE==root
ERROR the source SOURCE cannot be matched with the view VIEW
  #ENDIF
  #IFNOTSWITCH DIRECTION==Ascending
ERROR the direction DIRECTION cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public String toString(){
#IFSWITCH VIEW==Full
  switch(SOURCE.state){
    case 0b00:
      return "[]";
    case 0b01:
      return "[false]";
    case 0b10:
      return "[true]";
    default:
  #IFSWITCH DIRECTION==Ascending
      return "[false, true]";
  #ELSEIFSWITCH DIRECTION==Descending
      return "[true, false]";
  #ENDIF
  }
#ELSEIFSWITCH VIEW==True
  if((SOURCE.state&0b10)!=0){
    return "[true]";
  }
  return "[]";
#ELSEIFSWITCH VIEW==False
  if((SOURCE.state&0b01)!=0){
    return "[false]";
  }
  return "[]";
#ENDIF
}
#ENDDEF
#MACRODEF ToArray<SOURCE,DIRECTION,VIEW>()
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFNOTSWITCH SOURCE==this,root
ERROR unknown source SOURCE
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH SOURCE==root
ERROR the source SOURCE cannot be matched with the view VIEW
  #ENDIF
  #IFNOTSWITCH DIRECTION==Ascending
ERROR the direction DIRECTION cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@SuppressWarnings("unchecked")
@Override public <T> T[] toArray(T[] dst){
#IFSWITCH VIEW==Full
  switch(SOURCE.state){
  case 0b11:
  #IFSWITCH DIRECTION==Ascending
    (dst=OmniArray.uncheckedArrResize(2,dst))[0]=(T)Boolean.FALSE;
    dst[1]=(T)Boolean.TRUE;
  #ELSEIFSWITCH DIRECTION==Descending
    (dst=OmniArray.uncheckedArrResize(2,dst))[0]=(T)Boolean.TRUE;
    dst[1]=(T)Boolean.FALSE;
  #ENDIF
    break;
  case 0b10:
    (dst=OmniArray.uncheckedArrResize(1,dst))[0]=(T)Boolean.TRUE;
    break;
  case 0b01:
    (dst=OmniArray.uncheckedArrResize(1,dst))[0]=(T)Boolean.FALSE;
    break;
  default:
    if(dst.length!=0){
      dst[0]=null;
    }
  }
#ELSEIFSWITCH VIEW==True
  if((SOURCE.state&0b10)==0){
    if(dst.length!=0){
      dst[0]=null;
    }
  }else{
    (dst=OmniArray.uncheckedArrResize(1,dst))[0]=(T)Boolean.TRUE;
  }
#ELSEIFSWITCH VIEW==False
  if((SOURCE.state&0b01)==0){
    if(dst.length!=0){
      dst[0]=null;
    }
  }else{
    (dst=OmniArray.uncheckedArrResize(1,dst))[0]=(T)Boolean.FALSE;
  }
#ENDIF
  return dst;
}
@SuppressWarnings("unchecked")
@Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
#IFSWITCH VIEW==Full
  final T[] dst;
  switch(SOURCE.state){
  case 0b11:
  #IFSWITCH DIRECTION==Ascending
    (dst=arrConstructor.apply(2))[0]=(T)Boolean.FALSE;
    dst[1]=(T)Boolean.TRUE;
  #ELSEIFSWITCH DIRECTION==Descending
    (dst=arrConstructor.apply(2))[0]=(T)Boolean.TRUE;
    dst[1]=(T)Boolean.FALSE;
  #ENDIF
    break;
  case 0b10:
    (dst=arrConstructor.apply(1))[0]=(T)Boolean.TRUE;
    break;
  case 0b01:
    (dst=arrConstructor.apply(1))[0]=(T)Boolean.FALSE;
    break;
  default:
    return arrConstructor.apply(0);
  }
  return dst;
#ELSEIFSWITCH VIEW==True
  if((SOURCE.state&0b10)==0){
    return arrConstructor.apply(0);
  }else{
    final T[] dst;
    (dst=arrConstructor.apply(1))[0]=(T)Boolean.TRUE;
    return dst;
  }
#ELSEIFSWITCH VIEW==False
  if((SOURCE.state&0b01)==0){
    return arrConstructor.apply(0);
  }else{
    final T[] dst;
    (dst=arrConstructor.apply(1))[0]=(T)Boolean.FALSE;
    return dst;
  }
#ENDIF
}
#MACRO ToArrayHelper(,Boolean.TRUE,Boolean.FALSE,Boolean,OmniArray.OfBoolean.DEFAULT_BOXED_ARR)
#MACRO ToArrayHelper(Boolean,true,false,boolean,OmniArray.OfBoolean.DEFAULT_ARR)
#MACRO ToArrayHelper(Byte,(byte)1,(byte)0,byte,OmniArray.OfByte.DEFAULT_ARR)
#MACRO ToArrayHelper(Char,(char)1,(char)0,char,OmniArray.OfChar.DEFAULT_ARR)
#MACRO ToArrayHelper(Short,(short)1,(short)0,short,OmniArray.OfShort.DEFAULT_ARR)
#MACRO ToArrayHelper(Int,1,0,int,OmniArray.OfInt.DEFAULT_ARR)
#MACRO ToArrayHelper(Long,1L,0L,long,OmniArray.OfLong.DEFAULT_ARR)
#MACRO ToArrayHelper(Float,1F,0F,float,OmniArray.OfFloat.DEFAULT_ARR)
#MACRO ToArrayHelper(Double,1D,0D,double,OmniArray.OfDouble.DEFAULT_ARR)
#ENDDEF
#MACRODEF ToArrayHelper(CLASSPREFIX,TRUEVAL,FALSEVAL,RETTYPE,DEFAULTARR)
@Override public RETTYPE[] toCLASSPREFIXArray(){
#IFSWITCH VIEW==Full
  switch(SOURCE.state){
    case 0b00:
      return DEFAULTARR;
    case 0b01:
      return new RETTYPE[]{FALSEVAL};
    case 0b10:
      return new RETTYPE[]{TRUEVAL};
    default:
  #IFSWITCH DIRECTION==Ascending
      return new RETTYPE[]{FALSEVAL,TRUEVAL};
  #ELSEIFSWITCH DIRECTION==Descending
      return new RETTYPE[]{TRUEVAL,FALSEVAL};
  #ENDIF
  }
#ELSEIFSWITCH VIEW==True
  if((SOURCE.state&0b10)!=0){
    return new RETTYPE[]{TRUEVAL};
  }
  return DEFAULTARR;
#ELSEIFSWITCH VIEW==False
  if((SOURCE.state&0b01)!=0){
    return new RETTYPE[]{FALSEVAL};
  }
  return DEFAULTARR;
#ENDIF
}
#ENDDEF
#MACRODEF AddRemoveContains<SOURCE,VIEW,NAME>(STATE)
#IFNOTSWITCH SOURCE==this,root
ERROR unknown source SOURCE
#ENDIF
#IFNOTSWITCH NAME==True,False
ERROR unknown name NAME
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH SOURCE==root
ERROR the source SOURCE cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override boolean addNAME(){
#IFSWITCH VIEW==Full
  final int state;
  #IFSWITCH SOURCE==this
  if(((state=SOURCE.state)&0bSTATE)==0){
  #ELSEIFSWITCH SOURCE==root
  final BooleanSetImpl SOURCE;
  if(((state=(SOURCE=this.SOURCE).state)&0bSTATE)==0){
  #ENDIF
    SOURCE.state=state+0bSTATE;
    return true;
  }
  return false;
#ELSEIFSWITCH VIEW==True
  #IFSWITCH NAME==True
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&(STATE))==0){
    SOURCE.state=state+STATE;
    return true;
  }
  return false;
  #ELSEIFSWITCH NAME==False
  throw new IllegalArgumentException("out of bounds");
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH NAME==True
  throw new IllegalArgumentException("out of bounds");
  #ELSEIFSWITCH NAME==False
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&(STATE))==0){
    SOURCE.state=state+STATE;
    return true;
  }
  return false;
  #ENDIF
#ENDIF
}
@Override boolean containsNAME(){
#IFSWITCH VIEW==Full
  return (SOURCE.state&0bSTATE)!=0;
#ELSEIFSWITCH VIEW==True
  #IFSWITCH NAME==True
  return (SOURCE.state&0bSTATE)!=0;
  #ELSEIFSWITCH NAME==False
  return false;
  #ELSE
ERROR unknown name NAME
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH NAME==True
  return false;
  #ELSEIFSWITCH NAME==False
  return (SOURCE.state&0bSTATE)!=0;
  #ELSE
ERROR unknown name NAME
  #ENDIF
#ELSEIFSWITCH VIEW==Empty
  return false;
#ELSE
ERROR unknown view VIEW
#ENDIF
}
@Override boolean removeNAME(){
#IFSWITCH VIEW==Full
  final int state;
  #IFSWITCH SOURCE==this
  if(((state=SOURCE.state)&0bSTATE)!=0){
  #ELSEIFSWITCH SOURCE==root
  final BooleanSetImpl SOURCE;
  if(((state=(SOURCE=this.SOURCE).state)&0bSTATE)!=0){
  #ENDIF
    SOURCE.state=state-0bSTATE;
    return true;
  }
  return false;
#ELSEIFSWITCH VIEW==True
  #IFSWITCH NAME==True
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&(STATE))!=0){
    SOURCE.state=state-STATE;
    return true;
  }
  return false;
  #ELSEIFSWITCH NAME==False
  return false;
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH NAME==True
  return false;
  #ELSEIFSWITCH NAME==False
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&(STATE))!=0){
    SOURCE.state=state-STATE;
    return true;
  }
  return false;
  #ENDIF
#ENDIF
}
#ENDDEF


#MACRODEF SubSetMethods<SOURCE,VIEW,DIRECTION,CHECKED_TYPE>()
#IFNOTSWITCH SOURCE==this,root
ERROR unknown source SOURCE
#ENDIF
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFNOTSWITCH CHECKED_TYPE==True,False
ERROR unknown checked type CHECKED_TYPE
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH SOURCE==root
ERROR the source SOURCE cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public OmniNavigableSet.OfBoolean tailSet(boolean fromElement){
#IFSWITCH VIEW==Full
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement){
    return new UncheckedTrueView.Checked(SOURCE);
  }
  return this;
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement){
    return new UncheckedTrueView(SOURCE);
  }
  return this;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement){
    return this;
  }
  return new UncheckedFalseView.Checked.Descending(SOURCE);
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement){
    return this;
  }
  return new UncheckedFalseView.Descending(SOURCE);
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement){
    return this;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  return this;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement){
    return this;
  }
  return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement){
    return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
  }
  return this;
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement){
    return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
  }
  return this;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(!fromElement){
    return this;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  return this;
    #ENDIF
  #ENDIF
#ENDIF
}
@Override public OmniNavigableSet.OfBoolean tailSet(boolean fromElement,boolean inclusive){
#IFSWITCH VIEW==Full
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement==inclusive){
    return new UncheckedTrueView.Checked(SOURCE);
  }else if(fromElement){
    return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_TAIL;
  }
  return this;
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement==inclusive){
    return new UncheckedTrueView(SOURCE);
  }else if(fromElement){
    return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
  }
  return this;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement^inclusive){
    return new UncheckedFalseView.Checked.Descending(SOURCE);
  }else if(fromElement){
    return this;
  }
  return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_TAIL;
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement^inclusive){
    return new UncheckedFalseView.Descending(SOURCE);
  }else if(fromElement){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement==inclusive){
    return this;
  }else if(fromElement){
    return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_TAIL;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement==inclusive){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement^inclusive){
    return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
  }else if(fromElement){
    return this;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement^inclusive){
    return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
  }
  return this;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement==inclusive){
    return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
  }else if(inclusive){
    return this;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement==inclusive){
    return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
  }
  return this;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement^inclusive){
    return this;
  }else if(!fromElement){
    return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_TAIL;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement^inclusive){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
    #ENDIF
  #ENDIF
#ENDIF
}
@Override public OmniNavigableSet.OfBoolean headSet(boolean toElement){
#IFSWITCH VIEW==Full
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement){
    return this;
  }
  return new UncheckedFalseView.Checked(SOURCE);
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement){
    return this;
  }
  return new UncheckedFalseView(SOURCE);
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement){
    return new UncheckedTrueView.Checked.Descending(SOURCE);
  }
  return this;
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement){
    return new UncheckedTrueView.Descending(SOURCE);
  }
  return this;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement){
    return this;
  }
  return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement){
    return this;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  return this;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(!toElement){
    return this;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  return this;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement){
    return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
  }
  return this;
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement){
    return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
  }
  return this;
    #ENDIF
  #ENDIF
#ENDIF
}
@Override public OmniNavigableSet.OfBoolean headSet(boolean toElement,boolean inclusive){
#IFSWITCH VIEW==Full
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement ^ inclusive){
    return new UncheckedFalseView.Checked(SOURCE);
  }else if(toElement){
    return this;
  }else{
    return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_HEAD;
  }
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement ^ inclusive){
    return new UncheckedFalseView(SOURCE);
  }else if(toElement){
    return this;
  }else{
    return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
  } 
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement==inclusive){
    return new UncheckedTrueView.Checked.Descending(SOURCE);
  }else if(toElement){
    return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_HEAD;
  }else{
    return this;
  }
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement==inclusive){
    return new UncheckedTrueView.Descending(SOURCE);
  }else if(toElement){
    return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
  }else{
    return this;
  }  
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement^inclusive){
    return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
  }else if(toElement){
    return this;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement && inclusive){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement==inclusive){
    return this;
  }else if(toElement){
    return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_HEAD;
  }
  throw new IllegalArgumentException("out of bounds");
  
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement==inclusive){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement^inclusive){
    return this;
  }else if(!toElement){
    return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_HEAD;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement^inclusive){
    return this;
  }  
  return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement==inclusive){
    return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
  }else if(inclusive){
    return this;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement==inclusive){
    return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
  }  
  return this;
    #ENDIF
  #ENDIF
#ENDIF
}
@Override public OmniNavigableSet.OfBoolean subSet(boolean fromElement,boolean toElement){
#IFSWITCH VIEW==Full
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement){
    if(toElement){
      return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
    }else{
      return new UncheckedTrueView.Checked(SOURCE);
    }
  }else{
    if(toElement){
      return new UncheckedFalseView.Checked(SOURCE);
    }else{
      return this;
    }
  }
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement){
    if(toElement){
      return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    }else{
      return new UncheckedTrueView(SOURCE);
    }
  }else{
    if(toElement){
      return new UncheckedFalseView(SOURCE);
    }else{
      return this;
    }
  } 
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement){
    if(toElement){
      return new UncheckedTrueView.Checked.Descending(SOURCE);
    }else{
      return this;
    }
  }else{
    if(toElement){
      return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
    }else{
      return new UncheckedFalseView.Checked.Descending(SOURCE);
    }
  }
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement){
    if(toElement){
      return new UncheckedTrueView.Descending(SOURCE);
    }else{
      return this;
    }
  }else{
    if(toElement){
      return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
    }else{
      return new UncheckedFalseView.Descending(SOURCE);
    }
  }  
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement){
    if(toElement){
      return this;
    }else{
      return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
    }
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement && toElement){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement){
    if(fromElement){
      return this;
    }else{
      return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
    }
  }
  throw new IllegalArgumentException("out of bounds"); 
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement && toElement){
    return this;
  } 
  return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(!toElement){
    if(fromElement){
      return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
    }else{
      return this;
    }
  }
  throw new IllegalArgumentException("out of bounds"); 
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(!toElement && !fromElement){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(!fromElement){
    if(toElement){
      return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
    }else{
      return this;
    }
  }
  throw new IllegalArgumentException("out of bounds"); 
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(!fromElement && !toElement){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
    #ENDIF
  #ENDIF
#ENDIF
}
@Override public OmniNavigableSet.OfBoolean subSet(boolean fromElement,boolean fromInclusive,boolean toElement,boolean toInclusive){
#IFSWITCH VIEW==Full
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement==fromInclusive){
    if(toElement^toInclusive){
      return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
    }else if(toElement){
      return new UncheckedTrueView.Checked(SOURCE);
    }
  }else if(toElement^toInclusive){
    if(fromInclusive){
      return new UncheckedFalseView.Checked(SOURCE);
    }
  }else{
    if(toElement){
      if(fromElement){
        return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_TAIL;
      }else{
        return this;
      }
    }else if(fromElement){
      return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_HEAD;
    }
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement==fromInclusive){
    if(toElement && toInclusive){
      return new UncheckedTrueView(SOURCE);
    }
  }else if(toElement^toInclusive){
    if(fromInclusive){
      return new UncheckedFalseView(SOURCE);
    }
  }else if(toElement && !fromElement){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement^fromInclusive){
    if(toElement==toInclusive){
      return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
    }else if(toInclusive){
      return new UncheckedFalseView.Checked.Descending(SOURCE);
    }
  }else if(toElement==toInclusive){
    if(fromElement){
      return new UncheckedTrueView.Checked.Descending(SOURCE);
    }
  }else if(fromInclusive){
    if(toElement){
      return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_HEAD;
    }else{
      return this;
    }
  }else if(toInclusive){
    return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_TAIL;
  }
  throw new IllegalArgumentException("out of bounds");  
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement^fromInclusive){
    if(toInclusive && !toElement){
      return new UncheckedFalseView.Descending(SOURCE);
    }
  }else if(fromElement){
    if(toElement==toInclusive){
      return new UncheckedTrueView.Descending(SOURCE);
    }else if(toInclusive){
      return this;
    }
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement==fromInclusive){
    if(toElement^toInclusive){
      return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
    }else if(toElement){
      return this;
    }
  }else if(fromElement && toElement && toInclusive){
    return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_TAIL;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toElement && toInclusive && fromElement==fromInclusive){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement==toInclusive){
    if(fromElement^fromInclusive){
      return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
    }else if(fromElement){
      return this;
    }
  }else if(toElement && fromElement && fromInclusive){
    return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_HEAD;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromElement && fromInclusive && toElement==toInclusive){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH DIRECTION==Ascending
    #IFSWITCH CHECKED_TYPE==True
  if(toElement ^ toInclusive){
    if(fromElement==fromInclusive){
      return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_MIDDLE;
    }else if(fromInclusive){
      return this;
    }
  }else if(!toInclusive && fromInclusive && !fromElement){
    return AbstractBooleanSet.CHECKED_EMPTY_ASCENDING_HEAD;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(fromInclusive && !fromElement && toElement^toInclusive){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_ASCENDING;
    #ENDIF
  #ELSEIFSWITCH DIRECTION==Descending
    #IFSWITCH CHECKED_TYPE==True
  if(fromElement^fromInclusive){
    if(toElement==toInclusive){
      return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_MIDDLE;
    }else if(toInclusive){
      return this;
    }
  }else if(!fromElement && toInclusive && !toElement){
    return AbstractBooleanSet.CHECKED_EMPTY_DESCENDING_TAIL;
  }
  throw new IllegalArgumentException("out of bounds");
    #ELSEIFSWITCH CHECKED_TYPE==False
  if(toInclusive && !toElement && fromElement^fromInclusive){
    return this;
  }
  return AbstractBooleanSet.UNCHECKED_EMPTY_DESCENDING;    
    #ENDIF
  #ENDIF
#ENDIF
}
#ENDDEF
#MACRODEF RemoveIf<SOURCE,VIEW>(PREDICATE,TRUEVAL,FALSEVAL)
#IFNOTSWITCH SOURCE==root,this
ERROR unknown source SOURCE
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH SOURCE==root
ERROR source SOURCE cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public boolean removeIf(PREDICATE filter){
#IFSWITCH VIEW==Full
  #IFSWITCH SOURCE==root
  final BooleanSetImpl SOURCE;
  switch((SOURCE=this.SOURCE).state){
  #ELSEIFSWITCH SOURCE==this
  switch(SOURCE.state){
  #ENDIF
    case 0b11:
      if(filter.test(FALSEVAL)){
        if(filter.test(TRUEVAL)){
          break;
        }else{
          SOURCE.state=0b10;
          return true;
        }
      }else if(filter.test(TRUEVAL)){
        SOURCE.state=0b01;
        return true;
      }
      return false;
    case 0b10:
      if(filter.test(TRUEVAL)){
        break;
      }
      return false;
    case 0b01:
      if(filter.test(FALSEVAL)){
        break;
      }
    default:
      return false;
  }
  SOURCE.state=0b00;
  return true;
#ELSEIFSWITCH VIEW==True
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&0b10)!=0 && filter.test(TRUEVAL)){
    SOURCE.state=state-0b10;
    return true;
  }
  return false;
#ELSEIFSWITCH VIEW==False
  final BooleanSetImpl SOURCE;
  final int state;
  if(((state=(SOURCE=this.SOURCE).state)&0b01)!=0 && filter.test(FALSEVAL)){
    SOURCE.state=state-0b01;
    return true;
  }
  return false;
#ENDIF
}
#ENDDEF
#MACRODEF ForEach<SOURCE,VIEW,DIRECTION>(CONSUMER,TRUEVAL,FALSEVAL)
#IFNOTSWITCH VIEW==Full,True,False
ERROR unknown view VIEW
#ENDIF
#IFNOTSWITCH SOURCE==root,this
ERROR unknown source SOURCE
#ENDIF
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH SOURCE==root
ERROR the source SOURCE cannot be matched with the view VIEW
  #ENDIF
  #IFNOTSWITCH DIRECTION==Ascending
ERROR the direction DIRECTION cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public void forEach(CONSUMER action){
#IFSWITCH VIEW==Full
  switch(SOURCE.state){
    case 0b11:
  #IFSWITCH DIRECTION==Ascending
      action.accept(FALSEVAL);
    case 0b10:
      action.accept(TRUEVAL);
      break;
    case 0b01:
      action.accept(FALSEVAL);
  #ELSEIFSWITCH DIRECTION==Descending
      action.accept(TRUEVAL);
    case 0b01:
      action.accept(FALSEVAL);
      break;
    case 0b10:
      action.accept(TRUEVAL);
  #ENDIF
    default:
  }
#ELSEIFSWITCH VIEW==True
  if((SOURCE.state&0b10)!=0){
    action.accept(TRUEVAL);
  }
#ELSEIFSWITCH VIEW==False
  if((SOURCE.state&0b01)!=0){
    action.accept(FALSEVAL);
  }
#ENDIF
}
#ENDDEF
#MACRODEF ItrRemove<CHECKED,DIRECTION,VIEW>()
#IFNOTSWITCH VIEW==Full,True,False
ERROR unknown view VIEW
#ENDIF
#IFNOTSWITCH CHECKED==True,False
ERROR unknown checked type CHECKED
#ENDIF
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH DIRECTION==Ascending
ERROR the direction DIRECTION cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public void remove(){
#IFSWITCH VIEW==Full
  #IFSWITCH CHECKED==True
    final int itrState;
    if(((itrState=this.itrState)&0b100)!=0){
      final BooleanSetImpl root;
      int rootState;
      CheckedCollection.checkModCount(rootState=expectedRootState,(root=this.root).state);
      if(itrState==0b100){
        if(rootState==0b11){
    #IFSWITCH DIRECTION==Ascending
          root.state=0b01;
          this.expectedRootState=0b01;
    #ELSEIFSWITCH DIRECTION==Descending
          root.state=0b10;
          this.expectedRootState=0b10;
    #ENDIF
        }else{
          root.state=0b00;
          this.expectedRootState=0b00;
        }
        this.itrState=0b000;
      }else{
    #IFSWITCH DIRECTION==Ascending
        this.itrState=0b010;
        root.state=rootState&=0b10;
    #ELSEIFSWITCH DIRECTION==Descending
        this.itrState=0b001;
        root.state=rootState&=0b01;
    #ENDIF
        this.expectedRootState=rootState;
      }
      return;
    }
    throw new IllegalStateException();
  #ELSEIFSWITCH CHECKED==False
  if(itrState==0){
    final BooleanSetImpl root;
    final int rootState;
    #IFSWITCH DIRECTION==Ascending
    (root=this.root).state=(rootState=root.state)-((rootState&0b10)==0?0b01:0b10);
  }else{
    root.state=0b10;
    #ELSEIFSWITCH DIRECTION==Descending
    (root=this.root).state=(rootState=root.state)-((rootState&0b01)==0?0b10:0b01);
  }else{
    root.state=0b01;
    #ENDIF
  }
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH CHECKED==True
  final BooleanSetImpl root;
  final int rootState;
  switch((itrState<<1)|((rootState=(root=this.root).state)>>>1)){
  default:
    throw new IllegalStateException();
  case 0b010:
    throw new ConcurrentModificationException();
  case 0b011:
    root.state=rootState-0b10;
    itrState=0b00;
  }
  #ELSEIFSWITCH CHECKED==False
  root.state&=0b01;
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH CHECKED==True
  final BooleanSetImpl root;
  final int rootState;
  switch((itrState<<1)|((rootState=(root=this.root).state)&1)){
  default:
    throw new IllegalStateException();
  case 0b010:
    throw new ConcurrentModificationException();
  case 0b011:
    root.state=rootState-0b01;
    itrState=0b00;
  }
  #ELSEIFSWITCH CHECKED==False
  root.state&=0b10;
  #ENDIF
#ENDIF
}
#ENDDEF
#MACRODEF ForEachRemaining<CHECKED,DIRECTION,VIEW>(CONSUMER,TRUEVAL,FALSEVAL)
#IFNOTSWITCH VIEW==Full,True,False
ERROR unknown view VIEW
#ENDIF
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFNOTSWITCH CHECKED==True,False
ERROR unknown checked type CHECKED
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH DIRECTION==Ascending
ERROR the direction DIRECTION cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public void forEachRemaining(CONSUMER action){
#IFSWITCH VIEW==Full
  #IFSWITCH CHECKED==True
  final int itrState=this.itrState;
  try{
	  switch(itrState&0b11){
	    default:
	      return;
    #IFSWITCH DIRECTION==Ascending
        case 0b11:
          action.accept(FALSEVAL);
        case 0b10:
          action.accept(TRUEVAL);
          break;
        case 0b01:
          action.accept(FALSEVAL);
    #ELSEIFSWITCH DIRECTION==Descending
        case 0b11:
          action.accept(TRUEVAL);
        case 0b01:
          action.accept(FALSEVAL);
          break;
        case 0b10:
          action.accept(TRUEVAL);
    #ENDIF
	  }
	  CheckedCollection.checkModCount(expectedRootState,root.state,itrState,this.itrState);
  }catch(ConcurrentModificationException e){
    throw e;
  }catch(RuntimeException e){
    CheckedCollection.checkModCount(expectedRootState,root.state,itrState,this.itrState,e);
  }
  this.itrState=0b100;
  #ELSEIFSWITCH CHECKED==False
  switch(itrState){
    default:
      return;
    case 0b11:
    #IFSWITCH DIRECTION==Ascending
      action.accept(FALSEVAL);
    case 0b10:
      action.accept(TRUEVAL);
      break;
    case 0b01:
      action.accept(FALSEVAL);
    #ELSEIFSWITCH DIRECTION==Descending
      action.accept(TRUEVAL);
    case 0b01:
      action.accept(FALSEVAL);
      break;
    case 0b10:
      action.accept(TRUEVAL);
    #ENDIF
  }
  this.itrState=0b00;
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH CHECKED==True
  switch((itrState<<1)|(root.state>>>1)){
  default:
    throw new ConcurrentModificationException();
  case 0b101:
    action.accept(TRUEVAL);
    itrState=0b01;
  case 0b000:
  case 0b011:
  }
  #ELSEIFSWITCH CHECKED==False
  if(itrState==0b1){
    action.accept(TRUEVAL);
    itrState=0b0;
  }
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH CHECKED==True
  switch((itrState<<1)|(root.state&0b01)){
  default:
    throw new ConcurrentModificationException();
  case 0b101:
    action.accept(FALSEVAL);
    itrState=0b01;
  case 0b000:
  case 0b011:
  }
  #ELSEIFSWITCH CHECKED==False
  if(itrState==0b1){
    action.accept(FALSEVAL);
    itrState=0b0;
  }
  #ENDIF
#ENDIF
}
#ENDDEF
#MACRODEF ItrHasNext<CHECKED,DIRECTION,VIEW>()
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFNOTSWITCH CHECKED==True,False
ERROR unknown checked type CHECKED
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH DIRECTION==Ascending
ERROR the direction DIRECTION cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public boolean hasNext(){
#IFSWITCH VIEW==Full
  #IFSWITCH CHECKED==True
  return (this.itrState&0b11)!=0;
  #ELSEIFSWITCH CHECKED==False
  return this.itrState!=0;
  #ENDIF
#ENDIF
}
#ENDDEF
#MACRODEF ItrNext<CHECKED,DIRECTION,VIEW>()
#IFNOTSWITCH DIRECTION==Ascending,Descending
ERROR unknown direction DIRECTION
#ENDIF
#IFNOTSWITCH CHECKED==True,False
ERROR unknown checked type CHECKED
#ENDIF
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH DIRECTION==Ascending
ERROR the direction DIRECTION cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public boolean nextBoolean(){
#IFSWITCH VIEW==Full
  #IFSWITCH CHECKED==True
  CheckedCollection.checkModCount(expectedRootState,this.root.state);
  switch(itrState&0b11){
    default:
      throw new NoSuchElementException();
    case 0b01:
      this.itrState=0b100;
      return false;
    case 0b10:
      this.itrState=0b100;
      return true;
    case 0b11:
    #IFSWITCH DIRECTION==Ascending
      this.itrState=0b110;
      return false; 
    #ELSEIFSWITCH DIRECTION==Descending
      this.itrState=0b101;
      return true;
    #ENDIF
  }
  #ELSEIFSWITCH CHECKED==False
    #IFSWITCH DIRECTION==Ascending
  switch(this.itrState){
    case 0b11:
      this.itrState=0b10;
      break;
    case 0b10:
      this.itrState=0b00;
      return true;
    default:
      this.itrState=0b00;
  } 
  return false;
    #ELSEIFSWITCH DIRECTION==Descending
  switch(this.itrState){
    case 0b11:
      this.itrState=0b01;
      break;
    case 0b01:
      this.itrState=0b00;
      return false;
    default:
      this.itrState=0b00;
      break;
  } 
  return true;
    #ENDIF
  #ENDIF
#ELSEIFSWITCH VIEW==True
  #IFSWITCH CHECKED==True
  switch((itrState<<1)|(root.state>>>1)){
  case 0b000:
  case 0b011:
    throw new NoSuchElementException();
  default:
    throw new ConcurrentModificationException();
  case 0b101:
  }
  itrState=0b01;
  return true;
  #ELSEIFSWITCH CHECKED==False
  itrState=0b0;
  return true;
  #ENDIF
#ELSEIFSWITCH VIEW==False
  #IFSWITCH CHECKED==True
  switch((itrState<<1)|(root.state&0b01)){
  case 0b000:
  case 0b011:
    throw new NoSuchElementException();
  default:
    throw new ConcurrentModificationException();
  case 0b101:
  }
  itrState=0b01;
  return false;
  #ELSEIFSWITCH CHECKED==False
  itrState=0b0;
  return false;
  #ENDIF
#ENDIF
}
#ENDDEF
#MACRODEF SizeClearHashCodeIsEmpty<SOURCE,VIEW>()
#IFNOTSWITCH VIEW==Full
  #IFNOTSWITCH SOURCE==root
ERROR the source SOURCE cannot be matched with the view VIEW
  #ENDIF
#ENDIF
@Override public int size(){
#IFSWITCH VIEW==Full
  switch(SOURCE.state){
    case 0b00:
      return 0;
    case 0b01:
    case 0b10:
      return 1;
    default:
      return 2;
  }
#ELSEIFSWITCH VIEW==True
  return SOURCE.state>>>1;
#ELSEIFSWITCH VIEW==False
  return SOURCE.state&0b01;
#ENDIF
}
@Override public void clear(){
#IFSWITCH VIEW==Full
  SOURCE.state=0b00;
#ELSEIFSWITCH VIEW==True
  SOURCE.state&=0b01;
#ELSEIFSWITCH VIEW==False
  SOURCE.state&=0b10;
#ENDIF
}
@Override public int hashCode(){
#IFSWITCH VIEW==Full
  switch(SOURCE.state){
    case 0b00:
      return 0;
    case 0b01:
      return 1237;
    case 0b10:
      return 1231;
    default:
      return 1231+1237;
  }
#ELSEIFSWITCH VIEW==True
  if((SOURCE.state&0b10)==0){
    return 0;
  }
  return 1231;
#ELSEIFSWITCH VIEW==False
  if((SOURCE.state&0b01)==0){
    return 0;
  }
  return 1237;
#ENDIF
}
@Override public boolean isEmpty(){
#IFSWITCH VIEW==Full
  return SOURCE.state==0b00;
#ELSEIFSWITCH VIEW==True
  return (SOURCE.state&0b10)==0;
#ELSEIFSWITCH VIEW==False
  return (SOURCE.state&0b01)==0;
#ELSEIFSWITCH VIEW==Empty
  return true;
#ELSE
ERROR unknown view VIEW
#ENDIF
}
#ENDDEF
#MACRODEF EqualsMethod<SOURCE,VIEW>()
@Override public boolean equals(Object val){
#IFSWITCH VIEW==Full
  #IFSWITCH SOURCE==this
if(val==this){
  #ELSEIFSWITCH SOURCE==root
if(val==this||val==root){
  #ELSE
ERROR unknown source SOURCE
  #ENDIF
#ELSE
if(val==this){
#ENDIF
    return true;
  }
  if(val instanceof Set){
#IFSWITCH VIEW==Full
    switch(SOURCE.state){
      case 0b00:
        return ((Set<?>)val).isEmpty();
      case 0b01:
        return equalsFalseState((Set<?>)val);
      case 0b10:
        return equalsTrueState((Set<?>)val);
      default:
        return equalsFullState((Set<?>)val);
    }
#ELSEIFSWITCH VIEW==True
    if(((root.state)&0b01)==0){
      return ((Set<?>)val).isEmpty();
    }
    return equalsTrueState((Set<?>)val);
#ELSEIFSWITCH VIEW==False
    if(((root.state)&0b01)==0){
      return ((Set<?>)val).isEmpty();
    }
    return equalsFalseState((Set<?>)val);
#ELSEIFSWITCH VIEW==Empty
    return ((Set<?>)val).isEmpty();
#ELSE
ERROR unknown view VIEW
#ENDIF
  }
  return false;
}
#ENDDEF
#MACRODEF Constructors<NAME>()
private static final long serialVersionUID=1L;
public NAME(){
  super();
}
public NAME(BooleanSetImpl that){
#IFSWITCH NAME==BooleanSetImpl
  this.state=that.state;
#ELSE
  super(that);
#ENDIF
}
public NAME(OmniCollection.OfBoolean that){
#IFSWITCH NAME==BooleanSetImpl
  super();
  //TODO optimize
  this.addAll(that);
#ELSE
  super(that);
#ENDIF
}
public NAME(OmniCollection.OfRef<? extends Boolean> that){
#IFSWITCH NAME==BooleanSetImpl
  super();
  //TODO optimize
  this.addAll(that);
#ELSE
  super(that);
#ENDIF
}
public NAME(Collection<? extends Boolean> that){
#IFSWITCH NAME==BooleanSetImpl
  super();
  //TODO optimize
  this.addAll(that);
#ELSE
  super(that);
#ENDIF
}
NAME(int state){
#IFSWITCH NAME==BooleanSetImpl
  super();
  this.state=state;
#ELSE
  super(state);
#ENDIF
}
@Override public Object clone(){
  return new NAME(this.state);
}
#ENDDEF
