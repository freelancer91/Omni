#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.api.OmniList;
import omni.api.OmniDeque;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.Comparator;
import java.util.function.UnaryOperator;
import omni.util.OmniArray;
import java.util.function.IntFunction;
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import omni.impl.CheckedCollection;
import java.util.NoSuchElementException;
#IFNOT OfBoolean
import omni.util.BitSetUtils;
#ENDIF
#IFNOT OfRef
import omni.util.TypeUtil;
import omni.impl.Abstract$ClassPrefix$Itr;
#ENDIF
#IF OfRef
import java.util.Objects;
import omni.util.OmniPred;
#ELSEIF OfDouble,OfFloat
import omni.util.HashUtils;
#ENDIF
#IF OfInt
import java.util.function.$Comparator$;
#ELSEIFNOT OfRef
import omni.function.$Comparator$;
#ENDIF
#IF OfDouble,OfLong,OfInt
import java.util.function.$TypeNameModifier$Consumer;
import java.util.function.$TypeNameModifier$Predicate;
import java.util.function.$UnaryOperator$;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Predicate;
import omni.function.$TypeNameModifier$Consumer;
  #IFNOT OfBoolean
import omni.function.$UnaryOperator$;
  #ENDIF
#ENDIF
#IFNOT OfBoolean
import omni.util.SortUtil;
#ENDIF
#IF OfRef
public abstract class $ClassPrefix$DblLnkSeq$<E>$ extends AbstractSeq implements OmniList.Of$ClassPrefix$$<E>$
#ELSE
public abstract class $ClassPrefix$DblLnkSeq$<E>$ extends Abstract$ClassPrefix$List$<E>$ implements OmniList.Of$ClassPrefix$$<E>$
#ENDIF
{
  #MACRO StaticQueryMethods(contains)
  #MACRO StaticQueryMethods(indexOf)
  #MACRO StaticQueryMethods(lastIndexOf)
  #MACRO StaticQueryMethods(search)
#IF OfDouble,OfFloat
  #MACRO StaticDoubleFloatQuery(boolean,contains,,Node$<E>$ tail\,$exposedType$ val,val==,NaN,\,tail)
  #MACRO StaticDoubleFloatQuery(int,indexOf,,Node$<E>$ tail\,$exposedType$ val,val==,NaN,\,tail)
  #MACRO StaticDoubleFloatQuery(int,lastIndexOf,,int size\,$exposedType$ val,val==,NaN,\,size)
  #MACRO StaticDoubleFloatQuery(int,search,,$exposedType$ val,val==,NaN,)
  #IF OfFloat
  #MACRO StaticDoubleFloatQuery(boolean,contains,RawInt,Node$<E>$ tail\,int val,0!=,0,\,tail)
  #MACRO StaticDoubleFloatQuery(int,indexOf,RawInt,Node$<E>$ tail\,int val,0!=,0,\,tail)
  #MACRO StaticDoubleFloatQuery(int,lastIndexOf,RawInt,int size\,int val,0!=,0,\,size)
  #MACRO StaticDoubleFloatQuery(int,search,RawInt,int val,0!=,0,);
  #ENDIF
#ENDIF
  transient Node$<E>$ head;
  transient Node$<E>$ tail;
  private $ClassPrefix$DblLnkSeq()
  {
    super();
  }
  private $ClassPrefix$DblLnkSeq(Node$<E>$ onlyNode)
  {
    super(1);
    privateInit(onlyNode);
  }
  private $ClassPrefix$DblLnkSeq(Node$<E>$ head,int size,Node$<E>$ tail)
  {
    super(size);
    this.head=head;
    this.tail=tail;
  }
  #MACRO ProxyAdd(@Override,boolean,add,$exposedType$,addLast,return true;)
  #MACRO ProxyAdd(,void,addFirst,$exposedType$,push,)
  #MACRO ProxyAdd(,boolean,offer,$exposedType$,addLast,return true;)
  #MACRO ProxyAdd(,boolean,offerLast,$exposedType$,addLast,return true;)
  #MACRO ProxyAdd(,boolean,offerFirst,$exposedType$,push,return true;)
#IFNOT OfRef
  #MACRO ProxyAdd(,void,addFirst,$BoxedType$,push,)
  #MACRO ProxyAdd(,void,addLast,$BoxedType$,addLast,)
  #MACRO ProxyAdd(,boolean,offer,$BoxedType$,addLast,return true;)
  #MACRO ProxyAdd(,boolean,offerLast,$BoxedType$,addLast,return true;)
  #MACRO ProxyAdd(,boolean,offerFirst,$BoxedType$,push,return true;)
  #MACRO ProxyAdd(,void,push,$BoxedType$,push,)
#ENDIF
  #MACRO Push(addLast,tail)
  #MACRO Push(push,head)
  #MACRO ProxyGet(,$BoxedType$,getFirst,$elementMethod$)
  #MACRO ProxyGet(,$BoxedType$,remove,pop$TypeNameModifier$)
  #MACRO ProxyGet(,$BoxedType$,removeFirst,pop$TypeNameModifier$)
#IF OfRef
  #MACRO ProxyGet(,$exposedType$,peekFirst$TypeNameModifier$,peek$TypeNameModifier$)
  #MACRO ProxyGet(,$exposedType$,pollFirst$TypeNameModifier$,poll$TypeNameModifier$)
#ELSE
  #MACRO ProxyGet(,$BoxedType$,peekFirst,peek)
  #MACRO ProxyGet(,$BoxedType$,pollFirst,poll)
  #MACRO ProxyGet(,$BoxedType$,pop,pop$TypeNameModifier$)
  #MACRO ProxyGet(,$BoxedType$,removeLast,removeLast$TypeNameModifier$)
  #MACRO ProxyGet(,$BoxedType$,get,$elementMethod$)
  #MACRO ProxyGet(,$BoxedType$,element,$elementMethod$)
  #MACRO ProxyGet(,$BoxedType$,getLast,getLast$TypeNameModifier$)
#ENDIF
  #MACRO PeekMethods(,head)
  #MACRO PeekMethods(Last,tail)
  #MACRO PollMethods(privatechophead(head);,,head,,)
  #MACRO PollMethods(privatechoptail(tail);,Last,tail,,)
  public $exposedType$ $elementMethod$()
  {
    return head.val;
  }
  public $exposedType$ getLast$TypeNameModifier$()
  {
    return tail.val;
  }
  public $exposedType$ pop$TypeNameModifier$()
  {
    --this.size;
    Node$<E>$ head;
    privatechophead(head=this.head);
    return head.val;
  }
  public $exposedType$ removeLast$TypeNameModifier$()
  {
    --this.size;
    Node$<E>$ tail;
    privatechoptail(tail=this.tail);
    return tail.val;
  }
  public void clear()
  {
    this.size=0;
    (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(null);
  }
  #MACRO QueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,head,contains,false,$ClassPrefix$DblLnkSeq,head\\,tail,,@Override)
  #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,head,indexOf,-1,$ClassPrefix$DblLnkSeq,head\\,tail,,@Override)
  #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,tail,lastIndexOf,-1,$ClassPrefix$DblLnkSeq,tail\\,size,,@Override)
  #MACRO QueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,head,search,-1,$ClassPrefix$DblLnkSeq,head,,)
  #MACRO RootQueryObject(boolean,head,contains,false,head\,tail,@Override)
  #MACRO RootQueryObject(int,head,indexOf,-1,head\,tail,@Override)
  #MACRO RootQueryObject(int,tail,lastIndexOf,-1,tail\,size,@Override)
  #MACRO RootQueryObject(int,head,search,-1,head,)
#IF OfFloat
  #MACRO BasicQuery(protected,head,boolean,containsRawInt,int,false,$ClassPrefix$DblLnkSeq,head\,tail\,val,,@Override)
#ENDIF
  #MACRO ForEachMethods(RootForEach)
  @Override
  public $exposedType$ get$TypeNameModifier$(int index)
  {
    return privateGetNode(index,size-index).val;
  }
  abstract void initHelper($exposedType$ val);
  @Override
  public int hashCode()
  {
    #MACRO HashCode()
  }
  @Override
  public void put(int index,$exposedType$ val)
  {
    privateGetNode(index,size-index).val=val;
  }
  public final boolean removeFirstOccurrence(final Object val)
  {
    return remove(val);
  }
  #MACRO RootReplaceAll($UnaryOperator$$<E>$,operator)
#IFNOT OfRef
  #MACRO RootReplaceAll(UnaryOperator<$BoxedType$>,operator::apply)
#ENDIF
  #MACRO RootSortNoComparator(reverseSort)
  #MACRO RootSortNoComparator(sort)
  #MACRO RootSortComparator($Comparator$$<? super E>$,sorter)
#IFNOT OfRef
  #MACRO RootSortComparator(Comparator<? super $BoxedType$>,sorter::compare)
#ENDIF
  @Override
  public $exposedType$ set(final int index,final $exposedType$ val)
  {
    final Node$<E>$ node;
    final var oldVal=(node=privateGetNode(index,size-index)).val;
    node.val=val;
    return oldVal;
  }
  #MACRO ToArrayMethods(,head.uncheckedCopyForward(dst=new retType[size]\\,0\\,size);)
  @Override
  public <T> T[] toArray(final IntFunction<T[]> arrConstructor)
  {
    final int size;
    final T[] dst=arrConstructor.apply(size=this.size);
    if(size!=0)
    {
      head.uncheckedCopyForward(dst,0,size);
    }
    return dst;
  }
  @Override
  public <T> T[] toArray(T[] dst)
  {
    final int size;
    if((size=this.size)!=0)
    {
      head.uncheckedCopyForward(dst=OmniArray.uncheckedArrResize(size,dst),0,size);
    }
    else if(dst.length!=0)
    {
      dst[0]=null;
    }
    return dst;
  }
  @Override
  public String toString()
  {
    #MACRO ToString()
  }
  private void privateInit(Node$<E>$ onlyNode)
  {
    this.head=onlyNode;
    this.tail=onlyNode;
  }
  private void uncheckedAddHelper(int headDist,int newSize,$exposedType$ val)
  {
    this.size=newSize;
    if(headDist==0)
    {
      this.head=new Node$<E>$(val,this.head);
    }
    else
    {
      if((newSize-=headDist)==0)
      {
        this.tail=new Node$<E>$(this.tail,val);
      }
      else
      {
        Node$<E>$ before,after;
        #MACRO InsertNode(this,before,after,headDist,newSize)
        new Node$<E>$(before,val,after);
      }
    }
  }
  private void privatesettail(Node$<E>$ newTail)
  {
    this.tail=newTail;
    newTail.next=null;
  }
  private void privatesethead(Node$<E>$ newHead)
  {
    this.head=newHead;
    newHead.prev=null;
  }
  private void privatechoptail(Node$<E>$ oldTail)
  {
    this.tail=oldTail=oldTail.prev;
    oldTail.next=null;
  }
  private void privatechophead(Node$<E>$ oldHead)
  {
    this.head=oldHead=oldHead.next;
    oldHead.prev=null;
  }
  private Node$<E>$ removeAtIndexHelper(int headDist,int newSize)
  {
    Node$<E>$ node;
    this.size=newSize;
    if(headDist==0)
    {
      privatechophead(node=this.head);
    }
    else
    {
      if((newSize-=headDist)==0)
      {
        privatechoptail(node=this.tail);
      }
      else
      {
        if(headDist<=newSize)
        {
          Node$<E>$ before;
          (before=this.head.iterateForward(headDist-1)).joinnext((node=before.next).next);
        }
        else
        {
          Node$<E>$ after;
          (node=(after=this.tail.iterateReverse(newSize-1)).prev).prev.joinnext(after);
        }
      }
    }
    return node;
  }
  private void subSeqInsertHelper(Node$<E>$ newNode,int index)
  {
    final int tailDist;
    final Node$<E>$ before,after;
    if(index<=(tailDist=this.size-index))
    {
      after=(before=this.head.iterateForward(index-1)).next;
    }
    else
    {
      before=(after=this.tail.iterateReverse(tailDist-1)).prev;
    }
    before.joinnext(newNode);
    newNode.joinnext(after);
  }
  #MACRO RootCollapseEnd(private,head,tail,next)
  #MACRO RootCollapseEnd(,tail,head,prev)
#IF OfBoolean
  boolean collapseBody(Node$<E>$ head,Node$<E>$ tail,$ArrayType$ retainThis,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    Node$<E>$ prev;
    while((head=(prev=head).next)!=tail)
    {
      if(head.val^retainThis)
      {
        if(!filter.test(!retainThis))
        {
          break;
        }
        int numRemoved;
        for(numRemoved=1;(head=head.next)!=tail;++numRemoved)
        {
          if(head.val==retainThis)
          {
            numRemoved+=head.collapseBodyHelper(tail,retainThis);
            break;
          }
        }
        prev.joinnext(head);
        size-=numRemoved;
        return true;
      }
    }
    return false;
  }
  void findNewHead(Node$<E>$ head,$ArrayType$ removeThis,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    final Node$<E>$ tail;
    if((tail=this.tail)!=head)
    {
      if(removeThis==tail.val)
      {
        collapseHeadAndTail(head,tail,filter,removeThis);
        return;
      }
      else if(!filter.test(removeThis=!removeThis))
      {
        collapsehead(head.next,tail,removeThis);
        return;
      }
    }
    (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(null);
    this.size=0;
  }
  private void collapseHeadAndTail(Node$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ removeThis)
  {
    for(int numRemoved=2;(head=head.next)!=tail;++numRemoved)
    {
      if(head.val^removeThis)
      {
        if(!filter.test(!removeThis))
        {
          while((tail=tail.prev)!=head)
          {
            if(tail.val^removeThis)
            {
              numRemoved+=head.collapseBodyHelper(tail,!removeThis);
              break;
            }
            ++numRemoved;
          }
          (($ClassPrefix$DblLnkSeq$<E>$)this).privatesethead(head);
          (($ClassPrefix$DblLnkSeq$<E>$)this).privatesettail(tail);
          size-=numRemoved;
          return;
        }
        break;
      }
    }
    (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(null);
    this.size=0;
  }
#ELSE
  boolean collapseBody(Node$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    Node$<E>$ prev;
    while((head=(prev=head).next)!=tail)
    {
      if(filter.test(head.val))
      {
        int numRemoved;
        for(numRemoved=1;(head=head.next)!=tail;++numRemoved)
        {
          if(!filter.test(head.val))
          {
            numRemoved+=head.collapseBodyHelper(tail,filter);
            break;
          }
        }
        prev.joinnext(head);
        size-=numRemoved;
        return true;
      }
    }
    return false;
  }
  void findNewHead(Node$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    final Node$<E>$ tail;
    if((tail=this.tail)!=head)
    {
      if(filter.test(tail.val))
      {
        collapseHeadAndTail(head,tail,filter);
      }
      else
      {
        collapsehead(head.next,tail,filter);
      }
    }
    else
    {
      (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(null);
      this.size=0;
    }
  }
  private void collapseHeadAndTail(Node$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
    for(int numRemoved=2;(head=head.next)!=tail;++numRemoved)
    {
      if(!filter.test(head.val))
      {
        while((tail=tail.prev)!=head)
        {
          if(!filter.test(tail.val))
          {
            numRemoved+=head.collapseBodyHelper(tail,filter);
            break;
          }
          ++numRemoved;
        }
        (($ClassPrefix$DblLnkSeq$<E>$)this).privatesethead(head);
        (($ClassPrefix$DblLnkSeq$<E>$)this).privatesettail(tail);
        size-=numRemoved;
        return;
      }
    }
    (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(null);
    this.size=0;
  }
#ENDIF
  private boolean uncheckedRemoveIf(Node$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter)
  {
#IF OfBoolean
    final var tail=this.tail;
    $ArrayType$ v;
    if(filter.test(v=head.val))
    {
      findNewHead(head,v,filter);
      return true;
    }
    else if(head!=tail)
    {
      if(v==tail.val)
      {
        return collapseBody(head,tail,v,filter);
      }
      else if(filter.test(!v))
      {
        collapsetail(head,tail,v);
        return true;
      }
    }
    return false;
#ELSE
    if(filter.test(head.val))
    {
      findNewHead(head,filter);
    }
    else
    {
      final Node$<E>$ tail;
      if(head==(tail=this.tail))
      {
        return false;
      }
      if(!filter.test(tail.val))
      {
        return collapseBody(head,tail,filter);
      }
      collapsetail(head,tail,filter);
    }
    return true;
#ENDIF
  }
  private Node$<E>$ privateGetNode(int headDist,int tailDist)
  {
    if(headDist<=tailDist)
    {
      return head.iterateForward(headDist);
    }
    return tail.iterateReverse(tailDist-1);
  }
  private Node$<E>$ getItrNode(int headDist,int tailDist)
  {
    if(tailDist==0)
    {
      return null;
    }
    return privateGetNode(headDist,tailDist);
  }
  public static class Checked$<E>$ extends $ClassPrefix$DblLnkSeq$<E>$ implements OmniDeque.Of$ClassPrefix$$<E>$
  {
    transient int modCount;
    public Checked()
    {
      super();
    }
    public Checked(Node$<E>$ onlyNode)
    {
      super(onlyNode);
    }
    public Checked(Node$<E>$ head,int size,Node$<E>$ tail)
    {
      super(head,size,tail);
    }
    @Override
    public Object clone()
    {
      #MACRO CloneImpl(Checked)
    }
    public void clear()
    {
      if(this.size!=0)
      {
        ++this.modCount;
        super.privateInit(null);
        this.size=0;
      }
    }
    #MACRO RootSubListMethods(,this\,null)
    @Override
    void initHelper($exposedType$ val)
    {
      ++this.modCount;
      this.size=1;
      super.privateInit(new Node$<E>$(val));
    }
    #MACRO PushEndHelper(head,++this.modCount;,val\,this.head)
    #MACRO PushEndHelper(tail,++this.modCount;,this.tail\,val)
    @Override
    public $exposedType$ $elementMethod$()
    {
      Node$<E>$ head;
      if((head=this.head)!=null)
      {
        return head.val;
      }
      throw new NoSuchElementException();
    }
    @Override
    public $exposedType$ getLast$TypeNameModifier$()
    {
      Node$<E>$ tail;
      if((tail=this.tail)!=null)
      {
        return tail.val;
      }
      throw new NoSuchElementException();
    }
    @Override
    public $exposedType$ pop$TypeNameModifier$()
    {
      final int size;
      if((size=this.size)!=0)
      {
        this.size=size-1;
        ++this.modCount;
        Node$<E>$ head;
        (($ClassPrefix$DblLnkSeq$<E>$)this).privatechophead(head=this.head);
        return head.val;
      }
      throw new NoSuchElementException();
    }
    @Override
    public $exposedType$ removeLast$TypeNameModifier$()
    {
      final int size;
      if((size=this.size)!=0)
      {
        this.size=size-1;
        ++this.modCount;
        Node$<E>$ tail;
        (($ClassPrefix$DblLnkSeq$<E>$)this).privatechoptail(tail=this.tail);
        return tail.val;
      }
      throw new NoSuchElementException();
    }
    @Override
    public $exposedType$ get$TypeNameModifier$(int index)
    {
      CheckedCollection.checkLo(index);
      final int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      return super.privateGetNode(index,size-index).val;
    }
#IF OfRef
    @Override
    public int hashCode()
    {
      final Node$<E>$ head;
      if((head=this.head)!=null)
      {
        #MACRO TryCheckModCount(this,return head.uncheckedForwardHashCode(this.tail);)
      }
      return 1;
    }
    @Override
    public String toString()
    {
      final Node$<E>$ head;
      if((head=this.head)!=null)
      {
        final StringBuilder builder=new StringBuilder("[");
        #MACRO TryCheckModCount(this,head.uncheckedForwardToString(tail\,builder);)
        return builder.append(']').toString();
      }
      return "[]";
    }
    #MACRO CheckedQueryObject(int,indexOf,head,\\,tail,\,tail,-1)
    #MACRO CheckedQueryObject(int,lastIndexOf,tail,\\,size,\,size,-1)
    #MACRO CheckedQueryObject(int,search,head,,,-1)
    #MACRO CheckedQueryObject(boolean,contains,head,\\,tail,\,tail,false)
#ENDIF
    @Override
    public $exposedType$ set(final int index,final $exposedType$ val)
    {
      CheckedCollection.checkLo(index);
      final int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      final Node$<E>$ node;
      final var oldVal=(node=super.privateGetNode(index,size-index)).val;
      node.val=val;
      return oldVal;
    }
    @Override
    public <T> T[] toArray(final IntFunction<T[]> arrConstructor)
    {
      return super.toArray(size->
      {
        #MACRO TryCheckModCount(this, return arrConstructor.apply(size);)
      });
    }
    #MACRO ForEachMethods(CheckedRootForEach)
    #MACRO PollMethods((($ClassPrefix$DblLnkSeq$<E>$)this).privatechophead(head);,,head,++this.modCount;,@Override)
    #MACRO PollMethods((($ClassPrefix$DblLnkSeq$<E>$)this).privatechoptail(tail);,Last,tail,++this.modCount;,@Override)
    @Override
    public void add(int index,$exposedType$ val)
    {
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkWriteHi(index,size=this.size);
      ++modCount;
      if(++size!=1)
      {
        super.uncheckedAddHelper(index,size,val);
      }
      else
      {
        this.size=1;
        super.privateInit(new Node$<E>$(val));
      }
    }
    @Override
    public $exposedType$ $removeAtIndexMethod$(int index)
    {
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      ++this.modCount;
      Node$<E>$ node;
      if(--size!=0)
      {
        node=super.removeAtIndexHelper(index,size);
      }
      else
      {
        node=this.head;
        this.size=0;
        super.privateInit(null);
      }
      return node.val;
    }
    @Override
    public boolean equals(Object val)
    {
      //TODO implements equals method
      return false;
    }
    @Override
    public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
    {
      return new AscendingItr$<E>$(this);
    }
    @Override
    public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
    {
      return new BidirectionalItr$<E>$(this);
    }
    @Override
    public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index)
    {
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkWriteHi(index,size=this.size);
      return new BidirectionalItr$<E>$(this,(size-=index)==0?null:super.privateGetNode(index,size),index);
    }
    @Override
    public OmniIterator.Of$ClassPrefix$$<E>$ descendingIterator()
    {
      return new DescendingItr$<E>$(this);
    }
    @Override
    public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
    {
      int size;
      CheckedCollection.checkSubListRange(fromIndex,toIndex,size=this.size);
      size-=toIndex;
      int subListSize;
      switch(subListSize=toIndex-fromIndex)
      {
      default:
        return getDefaultSubList(fromIndex,subListSize,size);
      case 1:
        return getSubList1(fromIndex,size);
      case 0:
        return getEmptySubList(fromIndex,size);
      }
    }
    @Override
    public void put(int index,$exposedType$ val)
    {
      CheckedCollection.checkLo(index);
      final int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      super.privateGetNode(index,size-index).val=val;
    }
    #MACRO CheckedRootReplaceAll($UnaryOperator$$<E>$,operator)
#IFNOT OfRef
    #MACRO CheckedRootReplaceAll(UnaryOperator<$BoxedType$>,operator::apply)
#ENDIF
    #MACRO CheckedRootSortNoComparator(reverseSort)
    #MACRO CheckedRootSortNoComparator(sort)
    #MACRO CheckedRootSortComparator($Comparator$$<? super E>$,sorter)
#IFNOT OfRef
    #MACRO CheckedRootSortComparator(Comparator<? super $BoxedType$>,sorter::compare)
#ENDIF
    #MACRO CheckedRootRemoveMethods(#IF OfRef\\,OfShort\\,OfChar\\,OfByte,remove,removeVal,head,tail,next)
    #MACRO CheckedRootRemoveMethods(#IFNOT OfDouble\\,OfLong\\,OfInt\\,OfBoolean,removeLastOccurrence,removeLastOccurrence,tail,head,prev)
    #MACRO RootDoubleAndFloatQueries()
#IF OfBoolean
    private boolean collapseBody(int modCount,Node$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ retainThis)
    {
      Node$<E>$ prev;
      while((head=(prev=head).next)!=tail)
      {
        if(head.val^retainThis)
        {
          if(!filter.test(!retainThis))
          {
            break;
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
          int numRemoved;
          for(numRemoved=1;(head=head.next)!=tail;++numRemoved)
          {
            if(head.val==retainThis)
            {
              numRemoved+=head.collapseBodyHelper(tail,retainThis);
              break;
            }
          }
          prev.joinnext(head);
          size-=numRemoved;
          return true;
        }
      }
      CheckedCollection.checkModCount(modCount,this.modCount);
      return false;
    }
    private void collapseHeadAndTail(int modCount,Node$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ removeThis)
    {
      for(int numRemoved=2;(head=head.next)!=tail;++numRemoved)
      {
        if(head.val^removeThis)
        {
          if(!filter.test(!removeThis))
          {
            CheckedCollection.checkModCount(modCount,this.modCount);
            this.modCount=modCount+1;
            while((tail=tail.prev)!=head)
            {
              if(tail.val^removeThis)
              {
                numRemoved+=head.collapseBodyHelper(tail,!removeThis);
                break;
              }
              ++numRemoved;
            }
            (($ClassPrefix$DblLnkSeq$<E>$)this).privatesethead(head);
            (($ClassPrefix$DblLnkSeq$<E>$)this).privatesettail(tail);
            size-=numRemoved;
            return;
          }
          break;
        }
      }
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount+1;
      super.clear();
    }
#ELSE
    private void collapseHeadAndTail(int modCount,Node$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
    {
      int oldSize=this.size;
      int numConsumed=2;
      for(;;)
      {
        if(numConsumed==oldSize)
        {
          CheckedCollection.checkModCount(modCount,this.modCount);
          super.clear();
          return;
        }
        ++numConsumed;
        if(!filter.test((head=head.next).val))
        {
          for(;;)
          {
            if(numConsumed==oldSize)
            {
               CheckedCollection.checkModCount(modCount,this.modCount);
               this.size=1;
               tail=head;
               break;
            }
            ++numConsumed;
            if(!filter.test((tail=tail.prev).val))
            {
              size=(oldSize-=numConsumed)+1-head.collapseBodyHelper(new ModCountChecker(modCount),oldSize,tail,filter);
              break;
            }
          }
          (($ClassPrefix$DblLnkSeq$<E>$)this).privatesethead(head);
          (($ClassPrefix$DblLnkSeq$<E>$)this).privatesettail(tail);
          return;
        }
      }
    }
    private boolean collapseBody(int modCount,Node$<E>$ prev,Node$<E>$ next,$TypeNameModifier$Predicate$<? super E>$ filter)
    {
      int numLeft=size;
      int numConsumed=2;
      for(Node$<E>$ before;numConsumed!=numLeft;prev=before)
      {
        ++numConsumed;
        if(filter.test((before=prev.next).val))
        {
          int newSize=numConsumed-1;
          for(Node$<E>$ after;;next=after,++newSize)
          {
            if(numConsumed==numLeft)
            {
              CheckedCollection.checkModCount(modCount,this.modCount);
              break;
            }
            ++numConsumed;
            if(filter.test((after=next.prev).val))
            {
              long[] survivorSet;
              if((numLeft-=numConsumed)!=0&&(numLeft=(before=before.next).markSurvivors(numLeft,survivorSet=BitSetUtils.getBitSet(numLeft),filter))!=0)
              {
                CheckedCollection.checkModCount(modCount,this.modCount);
                newSize+=numLeft;
                prev=prev.retainSurvivors(before,numLeft,survivorSet);
              }
              else
              {
                CheckedCollection.checkModCount(modCount,this.modCount);
              }
              break;
            }
          }
          prev.joinnext(next);
          this.modCount=modCount+1;
          this.size=newSize;
          return true;
        }
      }
      CheckedCollection.checkModCount(modCount,this.modCount);
      return false;
    }
    #MACRO CheckedRootCollapseEnd(head,tail,next)
    #MACRO CheckedRootCollapseEnd(tail,head,prev)
#ENDIF
    private boolean uncheckedRemoveIf(Node$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter)
    {
      final int modCount=this.modCount;
      try
      {
        final var tail=this.tail;
#IF OfBoolean
        $ArrayType$ v;
        if(filter.test(v=head.val))
        {
          if(head!=tail)
          {
            if(v==tail.val)
            {
              collapseHeadAndTail(modCount,head,tail,filter,v);
            }
            else if(filter.test(v=!v))
            {
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.modCount=modCount+1;
              super.clear();
            }
            else
            {
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.modCount=modCount+1;
              super.collapsehead(head,tail,v);
            }
          }
          else
          {
            CheckedCollection.checkModCount(modCount,this.modCount);
            this.modCount=modCount+1;
            super.clear();
          }
          return true;
        }
        else if(head!=tail)
        {
          if(v==tail.val)
          {
            return collapseBody(modCount,head,tail,filter,v);
          }
          else if(filter.test(!v))
          {
            CheckedCollection.checkModCount(modCount,this.modCount);
            this.modCount=modCount+1;
            super.collapsetail(head,tail,v);
            return true;
          }
        }
#ELSE
        if(filter.test(head.val))
        {
          if(head==tail)
          {
            CheckedCollection.checkModCount(modCount,this.modCount);
            super.clear();
          }
          else if(filter.test(tail.val))
          {
            collapseHeadAndTail(modCount,head,tail,filter);
          }
          else
          {
            collapsehead(modCount,head,tail,filter);
          }
          this.modCount=modCount+1;
          return true;
        }
        else if(head!=tail)
        {
          if(filter.test(tail.val))
          {
            collapsetail(modCount,head,tail,filter);
            this.modCount=modCount+1;
            return true;
          }
          return collapseBody(modCount,head,tail,filter);
        }
#ENDIF
      }
      catch(final RuntimeException e)
      {
        throw CheckedCollection.checkModCount(modCount,this.modCount,e);
      }
      CheckedCollection.checkModCount(modCount,this.modCount);
      return false;
    }
    #MACRO RootRemoveIf($TypeNameModifier$Predicate$<? super E>$,filter,this);
#IFNOT OfRef
    #MACRO RootRemoveIf(Predicate<? super $BoxedType$>,filter::test,this)
#ENDIF
    private static class SubList$<E>$ extends $ClassPrefix$DblLnkSeq$<E>$
    {
#IF OfRef
      private static class AscendingItr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
      private static class AscendingItr$<E>$ extends Abstract$ClassPrefix$Itr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ENDIF
      {
        transient final SubList$<E>$ parent;
        transient Node$<E>$ cursor;
        transient Node$<E>$ lastRet;
        transient int modCount;
        AscendingItr(SubList$<E>$ parent)
        {
          this.parent=parent;
          this.cursor=parent.head;
          this.modCount=parent.modCount;
        }
        AscendingItr(SubList$<E>$ parent,Node$<E>$ cursor)
        {
          this.parent=parent;
          this.cursor=cursor;
          this.modCount=parent.modCount;
        }
        #MACRO ForEachMethods(CheckedSubAscendingItrForEach)
        @Override
        public boolean hasNext()
        {
          return cursor!=null;
        }
        @Override
        public $exposedType$ next$TypeNameModifier$()
        {
          final SubList$<E>$ parent;
          CheckedCollection.checkModCount(modCount,(parent=this.parent).root.modCount);
          Node$<E>$ cursor;
          if((cursor=this.cursor)!=null)
          {
            if(cursor==parent.tail)
            {
              this.cursor=null;
            }
            else
            {
              this.cursor=cursor.next;
            }
            this.lastRet=cursor;
            return cursor.val;
          }
          throw new NoSuchElementException();
        }
        @Override
        public void remove()
        {
          parent.ascItrRemove(this);
          this.lastRet=null;
        }
      }
      private static class BidirectionalItr$<E>$ extends AscendingItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>$
      {
        private transient int nextIndex;
        private BidirectionalItr(SubList$<E>$ parent)
        {
          super(parent);
        }
        private BidirectionalItr(SubList$<E>$ parent,Node$<E>$ cursor,int nextIndex)
        {
          super(parent,cursor);
          this.nextIndex=nextIndex;
        }
        @Override
        public void add($exposedType$ val)
        {
          int modCount;
          final Checked$<E>$ root;
          final SubList$<E>$ parent;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=(parent=this.parent).root).modCount);
          root.modCount=++modCount;
          final int nextIndex=this.nextIndex++;
          int size;
          if((size=parent.size++)!=0)
          {
            if(nextIndex==0)
            {
              parent.prependHelper(val);
            }
            else if(nextIndex==size)
            {
              parent.appendHelper(val);
            }
            else
            {
              Node$<E>$ cursor;
              parent.insertHelper((cursor=this.cursor).prev,val,cursor);
            }
          }
          else
          {
            parent.initHelper(root,val);
          }
          ++root.size;
          this.modCount=modCount;
          this.lastRet=null;
        }
        #MACRO ForEachMethods(CheckedSubBidirectionalItrForEach)
        @Override
        public boolean hasPrevious()
        {
          return nextIndex!=0;
        }
        @Override
        public $exposedType$ next$TypeNameModifier$()
        {
          final SubList$<E>$ parent;
          CheckedCollection.checkModCount(modCount,(parent=this.parent).root.modCount);
          Node$<E>$ cursor;
          if((cursor=this.cursor)!=null)
          {
            if(cursor==parent.tail)
            {
              this.cursor=null;
            }
            else
            {
              this.cursor=cursor.next;
            }
            ++nextIndex;
            this.lastRet=cursor;
            return cursor.val;
          }
          throw new NoSuchElementException();
        }
        @Override
        public int nextIndex()
        {
          return this.nextIndex;
        }
        @Override
        public $exposedType$ previous$TypeNameModifier$()
        {
          CheckedCollection.checkModCount(modCount,parent.root.modCount);
          int nextIndex;
          if((nextIndex=this.nextIndex)!=0)
          {
            this.nextIndex=nextIndex-1;
            Node$<E>$ cursor;
            this.cursor=cursor=this.cursor.prev;
            this.lastRet=cursor;
            return cursor.val;
          }
          throw new NoSuchElementException();
        }
        @Override
        public int previousIndex()
        {
          return this.nextIndex-1;
        }
        @Override
        public void remove()
        {
          this.parent.bidirectItrRemove(this);
          this.lastRet=null;
        }
        @Override
        public void set($exposedType$ val)
        {
          Node$<E>$ lastRet;
          if((lastRet=this.lastRet)!=null)
          {
            CheckedCollection.checkModCount(modCount,parent.root.modCount);
            lastRet.val=val;
            return;
          }
          throw new IllegalStateException();
        }
      }
      
      transient int modCount;
      transient final Checked$<E>$ root;
      transient final SubList$<E>$ parent;
      SubList(Checked$<E>$ root,SubList$<E>$ parent)
      {
        super();
        this.root=root;
        this.parent=parent;
        this.modCount=root.modCount;
      }
      SubList(Checked$<E>$ root,SubList$<E>$ parent,Node$<E>$ onlyNode)
      {
        super(onlyNode);
        this.root=root;
        this.parent=parent;
        this.modCount=root.modCount;
      }
      SubList(Checked$<E>$ root,SubList$<E>$ parent,Node$<E>$ head,int size,Node$<E>$ tail)
      {
        super(head,size,tail);
        this.root=root;
        this.parent=parent;
        this.modCount=root.modCount;
      }
      @Override
      public int size()
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        return this.size;
      }
      @Override
      public boolean isEmpty()
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        return this.size==0;
      }
      @Override
      public boolean remove(Object val)
      {
        final Node$<E>$ head;
        if((head=this.head)!=null)
        {
#IF OfRef
          if(val!=null)
          {
            return uncheckedremoveValNonNull(head,val);
          }
          return uncheckedremoveVal(head,Objects::isNull);
#ELSE
          if(val instanceof $BoxedType$)
          {
            return uncheckedremoveVal(head,$queryCastRef$(val));
          }
#ENDIF
        }
        CheckedCollection.checkModCount(modCount,root.modCount);
        return false;
      }
#IF OfDouble,OfFloat
      private boolean uncheckedremoveVal(Node$<E>$ head,$exposedType$ val)
      {
        if(val==val)
        {
          return uncheckedremoveValBits(head,$convertToBits$(val));
        }
        return uncheckedremoveValNaN(head);
      }
  #IF OfFloat
      @Override
      protected boolean removeValRawInt(int val)
      {
        Node$<E>$ head;
        if((head=this.head)!=null)
        {
          if(val!=0)
          {
            return uncheckedremoveValBits(head,$convertToBits$(val));
          }
          return uncheckedremoveVal0(head);
        }
        CheckedCollection.checkModCount(modCount,root.modCount);
        return false;
      }
  #ENDIF
#ENDIF
      #MACRO QueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,head,removeVal,false,this,head,CheckedCollection.checkModCount(modCount\\,root.modCount);,@Override)
      #MACRO RootFindNewHead(int modCount\,,modCount\,, #MACRO CheckRootModCountAndIncrement2(),(($ClassPrefix$DblLnkSeq$<E>$)root))
      #MACRO RootCollapseHeadAndTail(int modCount\,,CheckedCollection.checkModCount(modCount\,root.modCount);,root.new ModCountChecker(modCount)\,oldSize-numConsumed\,,root.modCount=modCount+1;)
#IF OfBoolean
      boolean removeIfHelper(int modCount,Node$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ retainThis)
      {
        final Node$<E>$ tail;
        if(curr!=(tail=this.tail))
        {
          if(retainThis==tail.val)
          {
            return collapseBody(modCount,curr,tail,filter,retainThis);
          }
          if(filter.test(!retainThis))
          {
            rootCollapsetail(modCount,curr,tail,retainThis);
            return true;
          }
        }
        CheckedCollection.checkModCount(modCount,root.modCount);
        return false;
      }
      private boolean collapseBody(int modCount,Node$<E>$ prev,Node$<E>$ next,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ retainThis)
      {
        final var root=this.root;
        for(Node$<E>$ curr;(curr=prev.next)!=next;prev=curr)
        {
          if(curr.val^retainThis)
          {
            if(!filter.test(!retainThis))
            {
              break;
            }
            CheckedCollection.checkModCount(modCount,root.modCount);
            root.modCount=modCount+1;
            int numRemoved;
            for(numRemoved=1;(curr=curr.next)!=next;++numRemoved)
            {
              if(curr.val==retainThis)
              {
                numRemoved+=curr.collapseBodyHelper(next,retainThis);
                break;
              }
            }
            prev.joinnext(curr);
            bubbleUpdecrementSize(numRemoved);
            root.size-=numRemoved;
            return true;
          }
        }
        CheckedCollection.checkModCount(modCount,root.modCount);
        return false;
      }
#ELSE
      private boolean collapseBody(int modCount,Node$<E>$ prev,Node$<E>$ next,$TypeNameModifier$Predicate$<? super E>$ filter)
      {
        final int oldSize=size;
        int numConsumed=2;
        final var root=this.root;
        for(Node$<E>$ before;numConsumed!=oldSize;prev=before)
        {
          ++numConsumed;
          if(filter.test((before=prev.next).val))
          {
            int numRemoved=1;
            for(Node$<E>$ after;;next=after)
            {
              if(numConsumed==oldSize)
              {
                CheckedCollection.checkModCount(modCount,root.modCount);
                break;
              }
              ++numConsumed;
              if(filter.test((after=prev.next).val))
              {
                ++numRemoved;
                long[] survivorSet;
                int numLeft,numSurvivors;
                if((numLeft=oldSize-numConsumed)!=0&&(numSurvivors=(before=before.next).markSurvivors(numLeft,survivorSet=BitSetUtils.getBitSet(numLeft),filter))!=0)
                {
                  CheckedCollection.checkModCount(modCount,root.modCount);
                  numRemoved+=numLeft-numSurvivors;
                  prev=prev.retainSurvivors(before,numSurvivors,survivorSet);
                }
                else
                {
                  CheckedCollection.checkModCount(modCount,root.modCount);
                  numRemoved+=oldSize;
                }
                break;
              }
            }
            prev.joinnext(next);
            root.modCount=modCount+1;
            bubbleUpdecrementSize(numRemoved);
            root.size-=numRemoved;
            return true;
          }
        }
        CheckedCollection.checkModCount(modCount,root.modCount);
        return false;
      }
      boolean removeIfHelper(int modCount,Node$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter)
      {
        final Node$<E>$ tail;
        if(curr!=(tail=this.tail))
        {
          if(filter.test(tail.val))
          {
            rootCollapsetail(modCount,curr,tail,filter);
            return true;
          }
          return collapseBody(modCount,curr,tail,filter);
        }
        CheckedCollection.checkModCount(modCount,root.modCount);
        return false;
      }
#ENDIF
      #MACRO SubListCollapseEnd(prefix,tail,head,tailCandidate,next,prev,int modCount\,,#MACRO CheckRootModCountAndIncrement2(),CheckedCollection.checkModCount(modCount\,root.modCount);,root.new ModCountChecker(modCount)\,oldSize-numConsumed\,,root.modCount=modCount+1;)
      #MACRO SubListCollapseEnd(suffix,head,headCandidate,tail,prev,next,int modCount\,,#MACRO CheckRootModCountAndIncrement2(),CheckedCollection.checkModCount(modCount\,root.modCount);,root.new ModCountChecker(modCount)\,oldSize-numConsumed\,,root.modCount=modCount+1;)
      private void privateCollapseHeadAndTail(int size,Node$<E>$ head,Node$<E>$ tail)
      {
        ++this.modCount;
        this.size=size;
        this.head=head;
        this.tail=tail;
      }
      int getParentOffset()
      {
        return 0;
      }
      @Override
      public void add(int index,$exposedType$ val)
      {
        final int modCount;
        final Checked$<E>$ root;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
        CheckedCollection.checkLo(index);
        int size;
        CheckedCollection.checkWriteHi(index,size=this.size);
        ++root.size;
        root.modCount=modCount+1;
        if(size!=0)
        #MACRO SubListIndexModify(RootPushHead,RootPushTail,RootPushInit,SubListInsertBody)
      }
      @Override
      public $exposedType$ $removeAtIndexMethod$(int index)
      {
        final int modCount;
        final Checked$<E>$ root;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
        CheckedCollection.checkLo(index);
        int size;
        CheckedCollection.checkReadHi(index,size=this.size);
        root.modCount=modCount+1;
        --root.size;
        Node$<E>$ node;
        if(--size!=0)
        #MACRO SubListIndexModify(RootRemoveHead,RootRemoveTail,RootRemoveClear,SubListRemoveBody)
        return node.val;
      }
      @Override
      void initHelper($exposedType$ val)
      {
        #MACRO CheckRootModCountAndIncrement1()
        root.size=1;
        Node$<E>$ newNode;
        (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(newNode=new Node$<E>$(val));
        bubbleUpinit(newNode);
      }
      #MACRO BasicCheckedSubListPushHelper(head,val\,oldhead)
      #MACRO BasicCheckedSubListPushHelper(tail,oldtail\,val)
      @Override
      public void clear()
      {
        CheckedCollection.checkModCount(this.modCount,root.modCount);
        if(size!=0)
        {
          ((SubList$<E>$)this).clearRoot();
        }
      }
      @Override
      public $exposedType$ get$TypeNameModifier$(int index)
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        CheckedCollection.checkLo(index);
        final int size;
        CheckedCollection.checkReadHi(index,size=this.size);
        return super.privateGetNode(index,size-index).val;
      }
      @Override
      public int hashCode()
      {
#IF OfRef
        #MACRO TryCheckModCount(root,#MACRO HashCode())
#ELSE
        CheckedCollection.checkModCount(modCount,root.modCount);
        return super.hashCode();
#ENDIF
      }
      @Override
      public String toString()
      {
#IF OfRef
        #MACRO TryCheckModCount(root,#MACRO ToString())
#ELSE
        CheckedCollection.checkModCount(modCount,root.modCount);
        return super.toString();
#ENDIF
      }
      #MACRO CheckedSubListQueryObject(boolean,contains)
      #MACRO CheckedSubListQueryObject(int,indexOf)
      #MACRO CheckedSubListQueryObject(int,lastIndexOf)
      @Override
      public $exposedType$ set(int index,$exposedType$ val)
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        CheckedCollection.checkLo(index);
        final int size;
        CheckedCollection.checkReadHi(index,size=this.size);
        final Node$<E>$ node;
        final var oldVal=(node=super.privateGetNode(index,size-index)).val;
        node.val=val;
        return oldVal;
      }
      @Override
      public <T> T[] toArray(T[] arr)
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        return super.toArray(arr);
      }
      @Override
      public <T> T[] toArray(final IntFunction<T[]> arrConstructor)
      {
        return super.toArray(size->
        {
          #MACRO TryCheckModCount(root,return arrConstructor.apply(size);)
        });
      }
#IF OfFloat
      #MACRO CheckedSubListQuery(boolean,containsRawInt,int)
#ENDIF
      #MACRO CheckedSubListQueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,contains)
      #MACRO CheckedSubListQueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,indexOf)
      #MACRO CheckedSubListQueryMethods(#IFNOT OfDouble\,OfLong\,OfInt\,OfBoolean,int,lastIndexOf)
      #MACRO ForEachMethods(CheckedSubListForEach)
      @Override
      public void put(int index,$exposedType$ val)
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        CheckedCollection.checkLo(index);
        final int size;
        CheckedCollection.checkReadHi(index,size=this.size);
        super.privateGetNode(index,size-index).val=val;
      }
      #MACRO CheckedSubListReplaceAll($UnaryOperator$$<E>$,operator)
#IFNOT OfRef
      #MACRO CheckedSubListReplaceAll(UnaryOperator<$BoxedType$>,operator::apply)
#ENDIF
      #MACRO CheckedSubListSortNoComparator(sort)
      #MACRO CheckedSubListSortNoComparator(reverseSort)
      #MACRO CheckedSubListSortComparator($Comparator$$<? super E>$,sorter)
#IFNOT OfRef
      #MACRO CheckedSubListSortComparator(Comparator<? super $BoxedType$>,sorter::compare)
#ENDIF
      #MACRO ToArrayMethods(CheckedCollection.checkModCount(modCount\\,root.modCount);,head.uncheckedCopyForward(dst=new retType[size]\\,0\\,size);)
      @Override
      public boolean equals(Object val)
      {
        //TODO implements equals method
        return false;
      }
      @Override
      public Object clone()
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        #MACRO CloneImpl(Checked)
      }
      @Override
      public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
      {
        final Checked$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        int size;
        CheckedCollection.checkSubListRange(fromIndex,toIndex,size=this.size);
        size-=toIndex;
        int subListSize;
        switch(subListSize=toIndex-fromIndex)
        {
        default:
          return getDefaultSubList(root,fromIndex,subListSize,size);
        case 1:
          return getSubList1(root,fromIndex,size);
        case 0:
          return getEmptySubList(root,fromIndex,size);
        }
      }
      #MACRO RootSubListMethods(Checked$<E>$ root\,,root\,this)
      @Override
      public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        return new AscendingItr$<E>$(this);
      }
      @Override
      public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        return new BidirectionalItr$<E>$(this);
      }
      @Override
      public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index)
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        CheckedCollection.checkLo(index);
        int size;
        CheckedCollection.checkWriteHi(index,size=this.size);
        return new BidirectionalItr$<E>$(this,super.getItrNode(index,size-index),index);
      }
      #MACRO BubbleUpDoWhile(incrementModCount,,++curr.modCount)
      #MACRO BubbleUpMethods(++curr.modCount;)
      private void clearRoot()
      {
        Checked$<E>$ root;
        ++(root=this.root).modCount;
        root.size=0;
        (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
        bubbleUpclearRoot();
      }
      private void clearPrefix(int numRemoved)
      {
        Node$<E>$ oldtail;
        Node$<E>$ newhead=(oldtail=this.tail).next;
        final Checked$<E>$ root;
        ++(root=this.root).modCount;
        root.size-=numRemoved;
        (($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(newhead);
        bubbleUpclearPrefix(oldtail,newhead,numRemoved);
      }
      private void clearSuffix(int numRemoved)
      {
        Node$<E>$ oldhead;
        Node$<E>$ newtail=(oldhead=this.head).prev;
        final Checked$<E>$ root;
        ++(root=this.root).modCount;
        root.size-=numRemoved;
        (($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(newtail);
        bubbleUpclearSuffix(oldhead,newtail,numRemoved);
      }
      private void clearBody(int numRemoved)
      {
        final Checked$<E>$ root;
        ++(root=this.root).modCount;
        root.size-=numRemoved;
        bubbleUpclearBody(this.head,this.tail,numRemoved);
      }
      #MACRO CheckedSubListRemoveIf($TypeNameModifier$Predicate$<? super E>$,filter)
#IFNOT OfRef
      #MACRO CheckedSubListRemoveIf(Predicate<? super $BoxedType$>,filter::test)
#ENDIF
      private boolean uncheckedRemoveIf(Node$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter)
      {
        final int modCount=this.modCount;
        try
        {
#IF OfBoolean
          $ArrayType$ v;
          if(filter.test(v=head.val))
          {
            findNewHead(modCount,head,filter,v);
            return true;
          }
          return removeIfHelper(modCount,head,filter,v);
#ELSE
          if(filter.test(head.val))
          {
            findNewHead(modCount,head,filter);
            return true;
          }
          return removeIfHelper(modCount,head,filter);
#ENDIF
        }
        catch(final RuntimeException e)
        {
          throw CheckedCollection.checkModCount(modCount,root.modCount,e);
        }
      }
      private void uncheckedItrRemove(Node$<E>$ lastRet)
      {
        #MACRO RootUncheckedItrRemoveImpl()
      }
      #MACRO CheckedItrRemoveMethods(,lastRet)
      #MACRO SubListRemoveFirstHelper(,int modCount\,,#MACRO CheckRootModCountAndIncrement2(),RootClearOnlyNode,RootChopHead)
      #MACRO SubListRemoveValHelperMethods(,int modCount\\,,CheckedCollection.checkModCount(modCount\\,root.modCount);,root.modCount=modCount+1;,bubbleUprootchoptail(prev);root.tail=prev;prev.next=null)
#IF OfRef
      private boolean uncheckedremoveValNonNull(Node$<E>$ head,Object nonNull)
      {
        final int modCount=this.modCount;
        try
        {
          if(!nonNull.equals(head.val))
          {
            return uncheckedremoveValHelper(modCount,head,nonNull::equals);
          }
          removeFirstHelper(modCount,head);
          return true;
        }
        catch(final RuntimeException e)
        {
          throw CheckedCollection.checkModCount(modCount,root.modCount,e);
        }
      }
#ENDIF
      #MACRO RootAddHelperMethods(Checked,++this.modCount;)
      #MACRO SubListRemoveValMethods(CheckedSubListRemoveVal)
      private static class PrefixList$<E>$ extends SubList$<E>$
      {
        PrefixList(Checked$<E>$ root,SubList$<E>$ parent)
        {
          super(root,parent);
        }
        PrefixList(Checked$<E>$ root,SubList$<E>$ parent,Node$<E>$ onlyNode)
        {
          super(root,parent,onlyNode);
        }
        PrefixList(Checked$<E>$ root,SubList$<E>$ parent,Node$<E>$ head,int size,Node$<E>$ tail)
        {
          super(root,parent,head,size,tail);
        }
        #MACRO SubListRemoveValHelperMethods(@Override,int modCount\\,,CheckedCollection.checkModCount(modCount\\,root.modCount);,root.modCount=modCount+1;,((SubList$<E>$)this).bubbleUpprefixchoptail(curr\\,prev))
        #MACRO CheckedPrefixSuffixInitHelper(head,val\,root.head)
        #MACRO PrefixSuffixPushHelper(tail,oldtail=this.tail\,val\,oldtail.next,++curr.modCount;,#MACRO CheckRootModCountAndIncrement1())
        #MACRO SubListClear(CheckedCollection.checkModCount(modCount\,root.modCount);,clearPrefix(size))
        @Override
        public void add(int index,$exposedType$ val)
        {
          final int modCount;
          final Checked$<E>$ root;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          CheckedCollection.checkLo(index);
          int size;
          CheckedCollection.checkWriteHi(index,size=this.size);
          ++root.size;
          root.modCount=modCount+1;
          if(size!=0)
          #MACRO SubListIndexModify(RootPushHead,PrefixPushTail,PrefixPushInit,SubListInsertBody)
        }
        @Override
        public $exposedType$ $removeAtIndexMethod$(int index)
        {
          final int modCount;
          final Checked$<E>$ root;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          CheckedCollection.checkLo(index);
          int size;
          CheckedCollection.checkReadHi(index,size=this.size);
          root.modCount=modCount+1;
          --root.size;
          Node$<E>$ node;
          if(--size!=0)
          #MACRO SubListIndexModify(RootRemoveHead,PrefixRemoveTail,PrefixRemoveClear,SubListRemoveBody)
          return node.val;
        }
        @Override
        void appendHelper($exposedType$ val)
        {
          ++this.modCount;
          #MACRO PrependAppendHelperImpl(tail,oldtail=tail\,val\,oldtail.next,prefix)
        }   
        @Override
        void initHelper(Checked$<E>$ root,$exposedType$ val)
        {
          #MACRO PrefixSuffixInitHelperImpl(after,head,prev)
        }
        #MACRO PrefixSuffixCollapseHeadAndTail(int modCount\,,final var root=this.root;,CheckedCollection.checkModCount(modCount\,root.modCount);,Prefix,head,tail,next,prev,head,tailCandidate,root.new ModCountChecker(modCount)\,oldSize-numConsumed\,,root.modCount=modCount+1;,root.head=head;)
        #MACRO PrefixFindNewHead(int modCount\,,modCount\,,#MACRO CheckRootModCountAndIncrement2())
        @Override
#IF OfBoolean
        boolean removeIfHelper(int modCount,Node$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ retainThis)
#ELSE
        boolean removeIfHelper(int modCount,Node$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter)
#ENDIF
        {
          final Node$<E>$ tail;
          if(curr!=(tail=this.tail))
          {
#IF OfBoolean
            if(tail.val==retainThis)
            {
              return super.collapseBody(modCount,curr,tail,filter,retainThis);
            }
            if(filter.test(!retainThis))
            {
              super.prefixCollapsetail(modCount,curr,tail,retainThis);
#ELSE
            if(filter.test(tail.val))
            {
              super.prefixCollapsetail(modCount,curr,tail,filter);
#ENDIF
              return true;
            }
          }
          CheckedCollection.checkModCount(modCount,root.modCount);
          return false;
        }
        #MACRO CheckedItrRemoveMethods(@Override,lastRet\,root)
        private void uncheckedItrRemove(Node$<E>$ lastRet,Checked$<E>$ root)
        {
          #MACRO PrefixUncheckedItrRemoveImpl()
        }
      }
      private static class SuffixList$<E>$ extends SubList$<E>$
      {
        SuffixList(Checked$<E>$ root,SubList$<E>$ parent)
        {
          super(root,parent);
        }
        SuffixList(Checked$<E>$ root,SubList$<E>$ parent,Node$<E>$ onlyNode)
        {
          super(root,parent,onlyNode);
        }
        SuffixList(Checked$<E>$ root,SubList$<E>$ parent,Node$<E>$ head,int size,Node$<E>$ tail)
        {
          super(root,parent,head,size,tail);
        }
        #MACRO CheckedPrefixSuffixInitHelper(tail,root.tail\,val)
        #MACRO PrefixSuffixPushHelper(head,(oldhead=this.head).prev\,val\,oldhead,++curr.modCount;,#MACRO CheckRootModCountAndIncrement1())
        #MACRO SubListClear(CheckedCollection.checkModCount(modCount\,root.modCount);,clearSuffix(size))
        @Override
        public void add(int index,$exposedType$ val)
        {
          final int modCount;
          final Checked$<E>$ root;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          CheckedCollection.checkLo(index);
          int size;
          CheckedCollection.checkWriteHi(index,size=this.size);
          ++root.size;
          root.modCount=modCount+1;
          if(size!=0)
          #MACRO SubListIndexModify(SuffixPushHead,RootPushTail,SuffixPushInit,SubListInsertBody)
        }
        @Override
        public $exposedType$ $removeAtIndexMethod$(int index)
        {
          final int modCount;
          final Checked$<E>$ root;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          CheckedCollection.checkLo(index);
          int size;
          CheckedCollection.checkReadHi(index,size=this.size);
          root.modCount=modCount+1;
          --root.size;
          Node$<E>$ node;
          if(--size!=0)
          #MACRO SubListIndexModify(SuffixRemoveHead,RootRemoveTail,SuffixRemoveClear,SubListRemoveBody)
          return node.val;
        }
        #MACRO SuffixFindNewHead(int modCount\,,modCount\,,#MACRO CheckRootModCountAndIncrement2())
        #MACRO PrefixSuffixCollapseHeadAndTail(int modCount\,,final var root=this.root;,CheckedCollection.checkModCount(modCount\,root.modCount);,Suffix,tail,head,prev,next,headCandidate,tail,root.new ModCountChecker(modCount)\,oldSize-numConsumed\,,root.modCount=modCount+1;,root.tail=tail;)
        #MACRO SubListRemoveFirstHelper(@Override,int modCount\,,#MACRO CheckRootModCountAndIncrement2(),SuffixClearOnlyNode,SuffixChopHead)
        #MACRO CheckedItrRemoveMethods(@Override,lastRet\,root)
        private void uncheckedItrRemove(Node$<E>$ lastRet,Checked$<E>$ root)
        {
          #MACRO SuffixUncheckedItrRemoveImpl()
        }
        @Override
        void prependHelper($exposedType$ val)
        {
          ++this.modCount;
          #MACRO PrependAppendHelperImpl(head,(oldhead=head).prev\,val\,oldhead,suffix)
        }
        @Override
        void initHelper(Checked$<E>$ root,$exposedType$ val)
        {
          #MACRO PrefixSuffixInitHelperImpl(before,tail,next)
        }
      }
      private static class BodyList$<E>$ extends PrefixList$<E>$
      {
        private transient final int parentOffset;
        BodyList(Checked$<E>$ root,SubList$<E>$ parent,int parentOffset)
        {
          super(root,parent);
          this.parentOffset=parentOffset;
        }
        BodyList(Checked$<E>$ root,SubList$<E>$ parent,Node$<E>$ onlyNode,int parentOffset)
        {
          super(root,parent,onlyNode);
          this.parentOffset=parentOffset;
        }
        BodyList(Checked$<E>$ root,SubList$<E>$ parent,Node$<E>$ head,int size,Node$<E>$ tail,int parentOffset)
        {
          super(root,parent,head,size,tail);
          this.parentOffset=parentOffset;
        }
        #MACRO SubListRemoveFirstHelper(@Override,int modCount\,,#MACRO CheckRootModCountAndIncrement2(),BodyClearOnlyNode,SuffixChopHead)
        @Override
        int getParentOffset()
        {
          return this.parentOffset;
        }
        @Override
        public void add(int index,$exposedType$ val)
        {
          final int modCount;
          final Checked$<E>$ root;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          CheckedCollection.checkLo(index);
          int size;
          CheckedCollection.checkWriteHi(index,size=this.size);
          ++root.size;
          root.modCount=modCount+1;
          if(size!=0)
          #MACRO SubListIndexModify(SuffixPushHead,PrefixPushTail,BodyPushInit,SubListInsertBody)
        }
        @Override
        public $exposedType$ $removeAtIndexMethod$(int index)
        {
          final Checked$<E>$ root;
          final int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
          CheckedCollection.checkLo(index);
          int size;
          CheckedCollection.checkReadHi(index,size=this.size);
          root.modCount=modCount+1;
          --root.size;
          Node$<E>$ node;
          if(--size!=0)
          #MACRO SubListIndexModify(SuffixRemoveHead,PrefixRemoveTail,BodyRemoveClear,SubListRemoveBody)
          return node.val;
        }
        #MACRO BubbleUpInitBody(++curr.modCount;)
        @Override
        void initHelper($exposedType$ val)
        {
          #MACRO CheckRootModCountAndIncrement1()
          ++root.size;
          bubbleUpinit(new Node$<E>$(val));
        }
        @Override
        void prependHelper($exposedType$ val)
        {
          ++this.modCount;
          #MACRO PrependAppendHelperImpl(head,(oldhead=head).prev\,val\,oldhead,suffix)
        }
        @Override
        void initHelper(Checked$<E>$ root,$exposedType$ val)
        {
          #MACRO BodyInitHelperImpl()
        }
        #MACRO PrefixSuffixPushHelper(head,(oldhead=this.head).prev\,val\,oldhead,++curr.modCount;,#MACRO CheckRootModCountAndIncrement1())
        #MACRO SubListClear(CheckedCollection.checkModCount(modCount\,root.modCount);,clearBody(size))
        #MACRO BodyBubbleUpCollapseHeadAndTail(++curr.modCount;)
        #MACRO BodyCollapseHeadAndTail(int modCount\,,CheckedCollection.checkModCount(modCount\,root.modCount);,root.modCount=modCount+1;,root.new ModCountChecker(modCount)\,oldSize-numConsumed\,)
        #MACRO BodyFindNewHead(int modCount\,,modCount\,,#MACRO CheckRootModCountAndIncrement2())
        #MACRO CheckedItrRemoveMethods(@Override,lastRet)
        private void uncheckedItrRemove(Node$<E>$ lastRet)
        {
          #MACRO BodyUncheckedItrRemoveImpl()
        }
      }
    }
#IFNOT OfBoolean
    private class ModCountChecker extends CheckedCollection.AbstractModCountChecker
    {
      public ModCountChecker(int expectedModCount)
      {
        super(expectedModCount);
      }
      @Override protected int getActualModCount()
      {
        return modCount;
      }
    }
#ENDIF
#IF OfRef
    private static class AscendingItr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
    private static class AscendingItr$<E>$ extends Abstract$ClassPrefix$Itr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ENDIF
    {
      transient final Checked$<E>$ root;
      transient Node$<E>$ cursor;
      transient Node$<E>$ lastRet;
      transient int modCount;
      AscendingItr(Checked$<E>$ root)
      {
        this.root=root;
        this.cursor=root.head;
        this.modCount=root.modCount;
      }
      AscendingItr(Checked$<E>$ root,Node$<E>$ cursor)
      {
        this.root=root;
        this.cursor=cursor;
        this.modCount=root.modCount;
      }
      #MACRO ForEachMethods(CheckedRootAscendingItrForEach)
      @Override
      public boolean hasNext()
      {
        return cursor!=null;
      }
      @Override
      public $exposedType$ next$TypeNameModifier$()
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        Node$<E>$ cursor;
        if((cursor=this.cursor)!=null)
        {
          this.cursor=iterate(cursor);
          this.lastRet=cursor;
          return cursor.val;
        }
        throw new NoSuchElementException();
      }
      @Override
      public void remove()
      {
        Node$<E>$ lastRet;
        if((lastRet=this.lastRet)!=null)
        {
            int modCount;
            final Checked$<E>$ root;
            CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
            root.modCount=++modCount;
            this.modCount=modCount;
            uncheckedRemove(lastRet,root);
            this.lastRet=null;
            return;
        }
        throw new IllegalStateException();
      }
      Node$<E>$ iterate(Node$<E>$ cursor)
      {
        return cursor.next;
      }
      Node$<E>$ uncheckedForEach(Node$<E>$ cursor,Checked$<E>$ root,$TypeNameModifier$Consumer$<? super E>$ action)
      {
        cursor.uncheckedForEachForward(cursor=root.tail,action);
        return cursor;
      }
      void uncheckedRemove(Node$<E>$ lastRet,Checked$<E>$ root)
      {
        if(--root.size==0)
        {
          (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
        }
        else if(lastRet==root.head)
        {
          (($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(cursor);
        }
        else if(lastRet==root.tail)
        {
          (($ClassPrefix$DblLnkSeq$<E>$)root).privatechoptail(lastRet);
        }
        else
        {
          lastRet.prev.joinnext(cursor);
        }
      }
    }
    private static class DescendingItr$<E>$ extends AscendingItr$<E>$
    {
      DescendingItr(Checked$<E>$ root)
      {
        super(root,root.tail);
      }
      @Override
      Node$<E>$ iterate(Node$<E>$ cursor)
      {
        return cursor.prev;
      }
      @Override
      Node$<E>$ uncheckedForEach(Node$<E>$ cursor,Checked$<E>$ root,$TypeNameModifier$Consumer$<? super E>$ action)
      {
        cursor.uncheckedForEachReverse(action);
        return root.head;
      }
      @Override
      void uncheckedRemove(Node$<E>$ lastRet,Checked$<E>$ root)
      {
        if(--root.size==0)
        {
          (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
        }
        else if(lastRet==root.head)
        {
          (($ClassPrefix$DblLnkSeq$<E>$)root).privatechophead(lastRet);
        }
        else if(lastRet==root.tail)
        {
          (($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(cursor);
        }
        else
        {
          cursor.joinnext(lastRet.next);
        }
      }
    }
    private static class BidirectionalItr$<E>$ extends AscendingItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>$
    {
      private transient int nextIndex;
      BidirectionalItr(Checked$<E>$ root)
      {
        super(root);
      }
      BidirectionalItr(Checked$<E>$ root,Node$<E>$ cursor,int index)
      {
        super(root,cursor);
        this.nextIndex=index;
      }
      public void add($exposedType$ val)
      {
        int modCount;
        final Checked$<E>$ root;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
        root.modCount=++modCount;
        this.modCount=modCount;
        if(++root.size!=1)
        {
          Node$<E>$ cursor;
          if((cursor=this.cursor)==null)
          {
            root.tail=new Node$<E>$(root.tail,val);
          }
          else if(cursor==root.head)
          {
            root.head=new Node$<E>$(val,cursor);
          }
          else
          {
            new Node$<E>$(cursor.prev,val,cursor);
          }
        }
        else
        {
          (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(new Node$<E>$(val));
        }
        ++nextIndex;
        lastRet=null;
      }
      #MACRO ForEachMethods(CheckedRootBidirectionalItrForEach)
      @Override
      public boolean hasPrevious()
      {
        return this.nextIndex!=0;
      }
      @Override
      public $exposedType$ next$TypeNameModifier$()
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        Node$<E>$ cursor;
        if((cursor=this.cursor)!=null)
        {
          ++nextIndex;
          this.cursor=cursor.next;
          lastRet=cursor;
          return cursor.val;
        }
        throw new NoSuchElementException();
      }
      @Override
      public int nextIndex()
      {
        return this.nextIndex;
      }
      @Override
      public $exposedType$ previous$TypeNameModifier$()
      {
        CheckedCollection.checkModCount(modCount,root.modCount);
        int nextIndex;
        if((nextIndex=this.nextIndex)!=0)
        {
          this.nextIndex=nextIndex-1;
          Node$<E>$ cursor;
          this.cursor=cursor=this.cursor.prev;
          lastRet=cursor;
          return cursor.val;
        }
        throw new NoSuchElementException();
      }
      @Override
      public int previousIndex()
      {
        return this.nextIndex-1;
      }
      @Override
      public void set($exposedType$ val)
      {
        Node$<E>$ lastRet;
        if((lastRet=this.lastRet)!=null)
        {
          CheckedCollection.checkModCount(modCount,root.modCount);
          lastRet.val=val;
          return;
        }
        throw new IllegalStateException();
      }
      @Override
      void uncheckedRemove(Node$<E>$ lastRet,Checked$<E>$ root)
      {
        if(--root.size!=0)
        {
          Node$<E>$ cursor;
          if(lastRet!=(cursor=this.cursor))
          {
            --nextIndex;
            if(lastRet==root.head)
            {
              (($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(cursor);
            }
            else if(lastRet==root.tail)
            {
              (($ClassPrefix$DblLnkSeq$<E>$)root).privatechoptail(lastRet);
            }
            else
            {
              lastRet.prev.joinnext(cursor);
            }
          }
          else
          {
            if(lastRet==root.head)
            {
              (($ClassPrefix$DblLnkSeq$<E>$)root).privatechophead(lastRet);
            }
            else if(lastRet==root.tail)
            {
              (($ClassPrefix$DblLnkSeq$<E>$)root).privatechoptail(lastRet);
            }
            else
            {
              lastRet.prev.joinnext(lastRet.next);
            }
          }
        }
        else
        {
          (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
          if(lastRet!=cursor)
          {
            --nextIndex;
          }
        }
      }
    }
  }
  static class Node$<E>$
  {
    transient Node$<E>$ prev;
    transient $exposedType$ val;
    transient Node$<E>$ next;
    Node($exposedType$ val)
    {
      this.val=val;
    }
    Node(Node$<E>$ prev,$exposedType$ val)
    {
      this.prev=prev;
      this.val=val;
      prev.joinnext(this);
    }
    Node($exposedType$ val,Node$<E>$ next)
    {
      this.val=val;
      this.next=next;
      joinnext(next);
    }
    Node(Node$<E>$ prev,$exposedType$ val,Node$<E>$ next)
    {
      this.prev=prev;
      this.val=val;
      this.next=next;
      prev.joinnext(this);
      joinnext(next);
    }
#IF OfBoolean
    private int collapseBodyHelper(Node$<E>$ next,$ArrayType$ retainThis)
    {
      int numRemoved=0;
      for(Node$<E>$ curr,prev=this;(curr=prev.next)!=next;prev=curr)
      {
        if(curr.val^retainThis)
        {
          do
          {
            ++numRemoved;
            if((curr=curr.next)==next)
            {
              prev.joinnext(next);
              return numRemoved;
            }
          }
          while(curr.val^retainThis);
          prev.joinnext(curr);
        }
      }
      return numRemoved;
    }
#ELSE
    private int collapseBodyHelper(Checked$<E>$.ModCountChecker modCountChecker,int numLeft,Node$<E>$ next,$TypeNameModifier$Predicate$<? super E>$ filter)
    {
      int numRemoved=0;
      for(Node$<E>$ before,prev=this;;prev=before)
      {
        if(numLeft==0)
        {
          modCountChecker.checkModCount();
          break;
        }
        --numLeft;
        if(filter.test((before=prev.next).val))
        {
          ++numRemoved;
          for(Node$<E>$ after;;next=after)
          {
            if(numLeft==0)
            {
              modCountChecker.checkModCount();
              break;
            }
            --numLeft;
            if(filter.test((after=next.prev).val))
            {
              ++numRemoved;
              long[] survivorSet;
              int numSurvivors;
              if(numLeft!=0&&(numSurvivors=(before=before.next).markSurvivors(numLeft,survivorSet=BitSetUtils.getBitSet(numLeft),filter))!=0)
              {
                modCountChecker.checkModCount();
                numRemoved+=numLeft-numSurvivors;
                prev=prev.retainSurvivors(before,numSurvivors,survivorSet);
              }
              else
              {
                numRemoved+=numLeft;
                modCountChecker.checkModCount();
              }
              break;
            }
          }
          prev.joinnext(next);
          break;
        }
      }
      return numRemoved;
    }
    private int markSurvivors(int numLeft,long[] survivorSet,$TypeNameModifier$Predicate$<? super E>$ filter)
    {
      long survivorWord;
      var begin=this;
      for(int survivorOffset=0,numSurvivors=0;;survivorSet[survivorOffset++]=survivorWord)
      {
        survivorWord=0L;
        long marker=1L;
        do
        {
          if(!filter.test(begin.val))
          {
            survivorWord|=marker;
            ++numSurvivors;
          }
          if(--numLeft==0)
          {
            survivorSet[survivorOffset]=survivorWord;
            return numSurvivors;
          }
          begin=begin.next;
        }
        while((marker<<=1)!=0);
      }
    }
    private Node$<E>$ retainSurvivors(Node$<E>$ curr,int numSurvivors,long[] survivorSet)
    {
      var lastKnownSurvivor=this;
      for(int survivorOffset=0;;++survivorOffset)
      {
        long survivorWord;
        int runLength;
        curr=curr.iterateForward(runLength=Long.numberOfTrailingZeros(survivorWord=survivorSet[survivorOffset]));
        if(runLength!=64)
        {
          lastKnownSurvivor.joinnext(lastKnownSurvivor=curr);
          runLength=Long.numberOfTrailingZeros(~(survivorWord>>>=runLength));
          do
          {
            lastKnownSurvivor=lastKnownSurvivor.uncheckedIterateForward(runLength);
            if((numSurvivors-=runLength)==0)
            {
              return lastKnownSurvivor;
            }
            else if(runLength==64)
            {
              survivorWord=survivorSet[survivorOffset++];
            }
          }
          while((runLength=Long.numberOfTrailingZeros(~(survivorWord>>>=runLength)))!=0);
          curr=lastKnownSurvivor;
        }
      }
    }
    private int collapseBodyHelper(Node$<E>$ next,$TypeNameModifier$Predicate$<? super E>$ filter)
    {
      int numRemoved=0;
      for(Node$<E>$ curr,prev=this;(curr=prev.next)!=next;prev=curr)
      {
        if(filter.test(curr.val))
        {
          do
          {
            ++numRemoved;
            if((curr=curr.next)==next)
            {
              prev.joinnext(next);
              return numRemoved;
            }
          }
          while(filter.test(curr.val));
          prev.joinnext(curr);
        }
      }
      return numRemoved;
  }
#ENDIF
    private void joinnext(Node$<E>$ next)
    {
      this.next=next;
      next.prev=this;
    }
    private void joinprev(Node$<E>$ prev)
    {
      this.prev=prev;
      prev.next=this;
    }
    private Node$<E>$ iterateForward(int dist)
    {
      if(dist!=0)
      {
        return uncheckedIterateForward(dist);
      }
      return this;
    }
    private Node$<E>$ iterateReverse(int dist)
    {
      if(dist!=0)
      {
        return uncheckedIterateReverse(dist);
      }
      return this;
    }
    private void uncheckedForEachForward(Node$<E>$ end,$TypeNameModifier$Consumer$<? super E>$ action)
    {
      for(var curr=this;;curr=curr.next)
      {
        action.accept(curr.val);
        if(curr==end)
        {
          return;
        }
      }
    }
    private void uncheckedForEachReverse($TypeNameModifier$Consumer$<? super E>$ action)
    {
      for(var curr=this;;)
      {
        action.accept(curr.val);
        if((curr=curr.prev)==null)
        {
          return;
        }
      }
    }
    private int uncheckedForwardHashCode(Node$<E>$ end)
    {
      int hash=31+$hashCodeMethod$(this.val);
      for(var curr=this;curr!=end;hash=hash*31+$hashCodeMethod$((curr=curr.next).val))
      {  
      }
      return hash;
    }
    private void uncheckedForwardToString(Node$<E>$ end,StringBuilder builder)
    {
      Node$<E>$ curr;
      for(builder.append((curr=this).val);curr!=end;builder.append(',').append(' ').append((curr=curr.next).val))
      {
      }
    }
    private Node$<E>$ uncheckedIterateForward(int dist)
    {
      var curr=next;
      while(--dist!=0)
      {
        curr=curr.next;
      }
      return curr;
    }
    private Node$<E>$ uncheckedIterateReverse(int dist)
    {
      var curr=prev;
      while(--dist!=0)
      {
        curr=curr.prev;
      }
      return curr;
    }
    private void uncheckedReplaceAll(Node$<E>$ end,$UnaryOperator$$<E>$ operator)
    {
      for(var curr=this;;curr=curr.next)
      {
        curr.val=operator.$applyMethod$(curr.val);
        if(curr==end)
        {
          return;
        }
      }
    }
    
#IF OfBoolean
    private void uncheckedSortHelper(Node$<E>$ end,$ArrayType$ firstVal)
    {
      int endValCounter=1;
      for(Node$<E>$ curr=this.next;curr!=end;curr=curr.next)
      {
        if(curr.val^firstVal)
        {
          ++endValCounter;
        }
      }
      for(final $ArrayType$ endVal=!firstVal;;end=end.prev)
      {
        end.val=endVal;
        if(--endValCounter==0)
        {
          do
          {
            (end=end.prev).val=firstVal;
          }
          while(end!=this);
          return;
        }
      }
    }
#ENDIF
#MACRODEF UncheckedSort<MethodName>()
#IFSWITCH MethodName==comparatorSort
  #IF OfBoolean
private void uncheckedMethodName(Node$<E>$ end,$Comparator$$<? super E>$ sorter)
{
  $ArrayType$ firstVal=this.val;
  Node$<E>$ newBegin;
  int endValCounter=1;
  for(newBegin=this.next;newBegin.val==firstVal;newBegin=newBegin.next,++endValCounter)
  {
    if(newBegin==end)
    {
      //already sorted
      return;
    }
  }
  switch(Integer.signum(sorter.compare(firstVal,!firstVal)))
  {
    case -1:
      for(Node$<E>$ newEnd=end;newEnd!=newBegin;newEnd=newEnd.prev)
      {
        if(newEnd.val==firstVal)
        {
          newBegin.uncheckedSortHelper(newEnd,firstVal);
          return;
        }
      }
      //already sorted
    case 0:
      //unsorted comparator
      return;
    default:
      while(newBegin!=end)
      {
        if((newBegin=newBegin.next).val==firstVal)
        {
          ++endValCounter;
        }
      }
      for(;;end=end.prev)
      {
        end.val=firstVal;
        if(--endValCounter==0)
        {
          do
          {
            (end=end.prev).val=!firstVal;
          }
          while(end!=this);
          return;
        }
      }
  }
}
  #ELSE
private void uncheckedMethodName(int size,Node$<E>$ end,$Comparator$$<? super E>$ sorter)
{
  $ArrayType$[] tmpArr;
  uncheckedCopyForward(tmpArr=new $ArrayType$[size],0,size);
  SortUtil.uncheckedMethodName(tmpArr,0,size-1,sorter);
  copyFromArray(tmpArr,0,size);
}
  #ENDIF
#ELSE
  #IF OfBoolean
private void uncheckedMethodName(Node$<E>$ end)
{
  var begin=this;
    #IFSWITCH MethodName==sort
  while(!begin.val)
    #ELSE
  while(begin.val)
    #ENDIF
  {
    if((begin=begin.next)==end)
    {
      //already sorted
      return;
    }
  }
    #IFSWITCH MethodName==sort
  while(end.val)
    #ELSE
  while(!end.val)
    #ENDIF
  {
    end=end.prev;
  }
  if(begin==end)
  {
    //already sorted
    return;
  }
    #IFSWITCH MethodName==sort
  begin.uncheckedSortHelper(end,false);
    #ELSE
  begin.uncheckedSortHelper(end,true);
    #ENDIF
}
  #ELSE
    #IF OfByte
private void insertMethodName(Node$<E>$ end)
{
  for(Node$<E>$ i=this,j=i;i!=end;j=(i=i.next))
  {
    final $ArrayType$ ai=i.next.val;
    $ArrayType$ aj;
    #MACRO WhileLessThan(ai,aj=j.val)
    {
      j.next.val=aj;
      if((j=j.prev)==this)
      {
        break;
      }
    }
    j.next.val=ai;
  }
}
    #ENDIF
    #IF OfChar,OfByte,OfShort
private void countingMethodName(Node$<E>$ end)
{
  int[] count=new int[($BoxedType$.MAX_VALUE+1)-$BoxedType$.MIN_VALUE];
  for(Node$<E>$ i=this;;i=i.next)
  {
        #IF OfChar
    ++count[i.val];
        #ELSE
    ++count[i.val-$BoxedType$.MIN_VALUE];
        #ENDIF
    if(i==end)
    {
      break;
    }
  }
      #IFSWITCH MethodName==sort
  for(int i=($BoxedType$.MAX_VALUE+1)-$BoxedType$.MIN_VALUE;;)
  {
    int s;
    while((s=count[--i])==0){}
      #ELSE
  for(int i=-1;;)
  {
    int s;
    while((s=count[++i])==0){}
      #ENDIF
      #IF OfChar
    $ArrayType$ value=($ArrayType$)i;
      #ELSE
    $ArrayType$ value=($ArrayType$)(i+$BoxedType$.MIN_VALUE);
      #ENDIF
    for(;;end=end.prev)
    {
      end.val=value;
      if(end==this)
      {
        return;
      }
      if(--s==0)
      {
        break;
      }
    }
  }
}
    #ENDIF
private void uncheckedMethodName(int size,Node$<E>$ end)
{
    #IF OfByte
  if(size<31)
  {
    insertMethodName(end);
  }
  else
  {
    countingMethodName(end);
  }
    #ELSEIF OfChar,OfShort
  if(size<3200)
  {
    //doSort
    $ArrayType$[] tmpArr;
    uncheckedCopyForward(tmpArr=new $ArrayType$[size],0,size);
    SortUtil.doMethodName(tmpArr,0,size-1);
    copyFromArray(tmpArr,0,size);
  }
  else
  {
    countingMethodName(end);
  }
    #ELSE
  $ArrayType$[] tmpArr;
  uncheckedCopyForward(tmpArr=new $ArrayType$[size],0,size);
  SortUtil.uncheckedMethodName(tmpArr,0,size-1);
  copyFromArray(tmpArr,0,size);
    #ENDIF
}
  #ENDIF
#ENDIF
#ENDDEF
#IFNOT OfBoolean
  #IF OfRef
    @SuppressWarnings("unchecked")
  #ENDIF
    private void copyFromArray($ArrayType$[] src,int srcOffset,int length)
    {
      for(Node$<E>$ curr=this;;++srcOffset,curr=curr.next)
      {
        curr.val=($exposedType$)src[srcOffset];
        if(--length==0)
        {
          return;
        }
      }
    }
#ENDIF
    #MACRO UncheckedSort<sort>()
    #MACRO UncheckedSort<reverseSort>()
    #MACRO UncheckedSort<comparatorSort>()
    #MACRO UncheckedCopyForwardToArray($ArrayType$,($ArrayType$))
#IFNOT OfRef
    #MACRO UncheckedCopyForwardToArray(Object,)
    #MACRO UncheckedCopyForwardToArray($BoxedType$,($BoxedType$))
  #IFNOT OfDouble
    #MACRO UncheckedCopyForwardToArray(double,$castToDouble$)
    #IFNOT OfFloat
    #MACRO UncheckedCopyForwardToArray(float,$castToFloat$)
      #IFNOT OfLong
    #MACRO UncheckedCopyForwardToArray(long,$castToLong$)
        #IFNOT OfInt
    #MACRO UncheckedCopyForwardToArray(int,$castToInt$)
          #IFNOT OfShort,OfChar
    #MACRO UncheckedCopyForwardToArray(short,$castToShort$)
            #IFNOT OfByte
    #MACRO UncheckedCopyForwardToArray(byte,$castToByte$)
    #MACRO UncheckedCopyForwardToArray(char,$castToChar$)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  }
  public static class Unchecked$<E>$ extends $ClassPrefix$DblLnkSeq$<E>$ implements OmniDeque.Of$ClassPrefix$$<E>$
  {
    public Unchecked()
    {
      super();
    }
    public Unchecked(Node$<E>$ onlyNode)
    {
      super(onlyNode);
    }
    public Unchecked(Node$<E>$ head,int size,Node$<E>$ tail)
    {
      super(head,size,tail);
    }
    #MACRO RootRemoveIf($TypeNameModifier$Predicate$<? super E>$,filter,super);
#IFNOT OfRef
    #MACRO RootRemoveIf(Predicate<? super $BoxedType$>,filter::test,super)
#ENDIF
    @Override
    void initHelper($exposedType$ val)
    {
      this.size=1;
      (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(new Node$<E>$(val));
    }
    @Override
    public void add(int index,$exposedType$ val)
    {
      int size;
      if((size=this.size)!=0)
      {
        super.uncheckedAddHelper(index,size+1,val);
      }
      else
      {
        this.size=1;
        (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(new Node$<E>$(val));
      }
    }
    @Override
    public $exposedType$ $removeAtIndexMethod$(int index)
    {
      Node$<E>$ node;
      int size;
      if((size=this.size)!=1)
      {
        node=super.removeAtIndexHelper(index,size-1);
      }
      else
      {
        node=this.head;
        this.size=0;
        (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(null);
      }
      return node.val;
    }
    #MACRO UncheckedRootRemoveMethods(#IF OfRef\\,OfShort\\,OfChar\\,OfByte,remove,removeVal,head,tail,next,prev)
    #MACRO UncheckedRootRemoveMethods(#IFNOT OfDouble\\,OfLong\\,OfInt\\,OfBoolean,removeLastOccurrence,removeLastOccurrence,tail,head,prev,next)
    #MACRO PushEndHelper(head,,val\,this.head)
    #MACRO PushEndHelper(tail,,this.tail\,val)
    @Override
    public Object clone()
    {
      #MACRO CloneImpl(Unchecked)
    }
    #MACRO RootDoubleAndFloatQueries()
    @Override
    public boolean equals(Object val)
    {
      //TODO implements equals method
      return false;
    }
    @Override
    public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
    {
      return new AscendingItr$<E>$(this);
    }
    @Override
    public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
    {
      return new BidirectionalItr$<E>$(this);
    }
    @Override
    public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index)
    {
      final int tailDist;
      return new BidirectionalItr$<E>$(this,(tailDist=size-index)==0?null:super.privateGetNode(index,tailDist),index);
    }
    @Override
    public OmniIterator.Of$ClassPrefix$$<E>$ descendingIterator()
    {
      return new DescendingItr$<E>$(this);
    }
    @Override
    public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
    {
      final int tailDist=size-toIndex;
      int subListSize;
      switch(subListSize=toIndex-fromIndex)
      {
      default:
        return getDefaultSubList(fromIndex,subListSize,tailDist);
      case 1:
        return getSubList1(fromIndex,tailDist);
      case 0:
        return getEmptySubList(fromIndex,tailDist);
      }
    }
    #MACRO RootSubListMethods(,this\,null)
#IF OfRef
    private static class AscendingItr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
    private static class AscendingItr$<E>$ extends Abstract$ClassPrefix$Itr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ENDIF
    {
      transient final Unchecked$<E>$ root;
      transient Node$<E>$ cursor;
      AscendingItr(Unchecked$<E>$ root)
      {
        this.root=root;
        cursor=root.head;
      }
      AscendingItr(Unchecked$<E>$ root,Node$<E>$ cursor)
      {
        this.root=root;
        this.cursor=cursor;
      }
      #MACRO ForEachMethods(UncheckedRootAscendingItrForEach)
      @Override
      public boolean hasNext()
      {
        return cursor!=null;
      }
      @Override
      public $exposedType$ next$TypeNameModifier$()
      {
        Node$<E>$ lastRet;
        cursor=(lastRet=cursor).next;
        return lastRet.val;
      }
      @Override
      public void remove()
      {
        final $ClassPrefix$DblLnkSeq$<E>$ root;
        if(--(root=this.root).size!=0)
        {
          Node$<E>$ cursor;
          if((cursor=this.cursor)!=null)
          {
            Node$<E>$ lastRet;
            if((lastRet=cursor.prev)==root.head)
            {
              root.privatesethead(cursor);
            }
            else
            {
              lastRet.prev.joinnext(cursor);
            }
          }
          else
          {
            root.privatechoptail(root.tail);
          }
        }
        else
        {
          root.privateInit(null);
        }
      }
    }
    private static class DescendingItr$<E>$ extends AscendingItr$<E>$
    {
      DescendingItr(Unchecked$<E>$ root)
      {
        super(root,root.tail);
      }
      #MACRO ForEachMethods(UncheckedRootDescendingItrForEach)
      @Override public $exposedType$ next$TypeNameModifier$()
      {
        Node$<E>$ lastRet;
        cursor=(lastRet=cursor).prev;
        return lastRet.val;
      }
      @Override public void remove()
      {
        final $ClassPrefix$DblLnkSeq$<E>$ root;
        if(--(root=this.root).size!=0)
        {
          Node$<E>$ cursor;
          if((cursor=this.cursor)!=null)
          {
            Node$<E>$ lastRet;
            if((lastRet=cursor.next)==root.tail)
            {
              root.privatesettail(cursor);
            }
            else
            {
              cursor.joinnext(lastRet.next);
            }
          }
          else
          {
            root.privatechophead(root.head);
          }
        }
        else
        {
          root.privateInit(null);
        }
      }
    }
    static class BidirectionalItr$<E>$ extends AscendingItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>$
    {
      private transient Node$<E>$ lastRet;
      private transient int nextIndex;
      BidirectionalItr(Unchecked$<E>$ root)
      {
        super(root);
      }
      BidirectionalItr(Unchecked$<E>$ root,Node$<E>$ cursor,int nextIndex)
      {
        super(root,cursor);
        this.nextIndex=nextIndex;
      }
      @Override
      public void add($exposedType$ val)
      {
        final $ClassPrefix$DblLnkSeq$<E>$ root;
        if(++(root=this.root).size!=1)
        {
          Node$<E>$ cursor;
          if((cursor=this.cursor)==null)
          {
            root.tail=new Node$<E>$(root.tail,val);
          }
          else if(cursor==root.head)
          {
            root.head=new Node$<E>$(val,cursor);
          }
          else
          {
            new Node$<E>$(cursor.prev,val,cursor);
          }
        }
        else
        {
          root.privateInit(new Node$<E>$(val));
        }
        ++nextIndex;
        lastRet=null;
      }
      #MACRO ForEachMethods(UncheckedRootBidirectionalItrForEach)
      @Override
      public boolean hasPrevious()
      {
        return nextIndex!=0;
      }
      @Override
      public $exposedType$ next$TypeNameModifier$()
      {
        Node$<E>$ lastRet;
        this.lastRet=lastRet=cursor;
        cursor=lastRet.next;
        ++nextIndex;
        return lastRet.val;
      }
      @Override
      public int nextIndex()
      {
        return nextIndex;
      }
      @Override
      public $exposedType$ previous$TypeNameModifier$()
      {
        Node$<E>$ lastRet;
        this.lastRet=lastRet=cursor.prev;
        cursor=lastRet;
        --nextIndex;
        return lastRet.val;
      }
      @Override
      public int previousIndex()
      {
        return nextIndex-1;
      }
      @Override
      public void remove()
      {
        final var lastRet=this.lastRet;
        final $ClassPrefix$DblLnkSeq$<E>$ root;
        if(--(root=this.root).size!=0)
        {
          Node$<E>$ cursor;
          if(lastRet!=(cursor=this.cursor))
          {
            --nextIndex;
            if(lastRet==root.head)
            {
              root.privatesethead(cursor);
            }
            else if(lastRet==root.tail)
            {
              root.privatechoptail(lastRet);
            }
            else
            {
              lastRet.prev.joinnext(cursor);
            }
          }
          else
          {
            if(lastRet==root.head)
            {
              root.privatechophead(lastRet);
            }
            else if(lastRet==root.tail)
            {
              root.privatechoptail(lastRet);
            }
            else
            {
              lastRet.prev.joinnext(lastRet.next);
            }
          }
        }
        else
        {
          root.privateInit(null);
          if(lastRet!=cursor)
          {
            --nextIndex;
          }
        }
        this.lastRet=null;
      }
      @Override
      public void set($exposedType$ val)
      {
        lastRet.val=val;
      }
    }
    private static class SubList$<E>$ extends $ClassPrefix$DblLnkSeq$<E>$
    {
      transient final Unchecked$<E>$ root;
      transient final SubList$<E>$ parent;
      SubList(Unchecked$<E>$ root,SubList$<E>$ parent)
      {
        super();
        this.root=root;
        this.parent=parent;
      }
      SubList(Unchecked$<E>$ root,SubList$<E>$ parent,Node$<E>$ onlyNode)
      {
        super(onlyNode);
        this.root=root;
        this.parent=parent;
      }
      SubList(Unchecked$<E>$ root,SubList$<E>$ parent,Node$<E>$ head,int size,Node$<E>$ tail)
      {
        super(head,size,tail);
        this.root=root;
        this.parent=parent;
      }
      @Override
      public void clear()
      {
        if(size!=0)
        {
          ((SubList$<E>$)this).clearRoot();
        }
      }
      int getParentOffset()
      {
        return 0;
      }
      @Override
      public boolean remove(final Object val)
      {
        final Node$<E>$ head;
        if((head=this.head)!=null)
        {
#IFNOT OfRef
          if(val instanceof $BoxedType$)
#ENDIF
          {
            return uncheckedremoveVal(head,$queryCastRef$(val));
          }
        }
        return false;
      }
#IF OfDouble,OfFloat
      private boolean uncheckedremoveVal(Node$<E>$ head,$exposedType$ val)
      {
        if(val==val)
        {
          return uncheckedremoveValBits(head,$convertToBits$(val));
        }
        return uncheckedremoveValNaN(head);
      }
  #IF OfFloat
      @Override
      protected boolean removeValRawInt(int val)
      {
        final Node$<E>$ head;
        if((head=this.head)!=null)
        {
          if(val!=0)
          {
            return uncheckedremoveValBits(head,$convertToBits$(val));
          }
          return uncheckedremoveVal0(head);
        }
        return false;
      }
  #ENDIF
#ENDIF
      #MACRO QueryMethods(#IF OfRef\,OfShort\,OfChar\,OfByte,boolean,head,removeVal,false,this,head,,@Override)
      @Override
      public void add(int index,$exposedType$ val)
      {
        final Unchecked$<E>$ root;
        ++(root=this.root).size;
        int size;
        if((size=this.size)!=0)
        #MACRO SubListIndexModify(RootPushHead,RootPushTail,RootPushInit,SubListInsertBody)
      }
#IF OfRef
      private static class AscendingItr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
      private static class AscendingItr$<E>$ extends Abstract$ClassPrefix$Itr$<E>$ implements OmniIterator.Of$ClassPrefix$$<E>$
#ENDIF
      {
        transient final SubList$<E>$ parent;
        transient Node$<E>$ cursor;
        AscendingItr(SubList$<E>$ parent)
        {
          this.parent=parent;
          cursor=parent.head;
        }
        AscendingItr(SubList$<E>$ parent,Node$<E>$ cursor)
        {
          this.parent=parent;
          this.cursor=cursor;
        }
        #MACRO ForEachMethods(UncheckedSubAscendingItrForEach)
        @Override
        public boolean hasNext()
        {
          return this.cursor!=null;
        }
        @Override
        public $exposedType$ next$TypeNameModifier$()
        {
          Node$<E>$ cursor;
          if((cursor=this.cursor)==parent.tail)
          {
            this.cursor=null;
          }
          else
          {
            this.cursor=cursor.next;
          }
          return cursor.val;
        }
        @Override
        public void remove()
        {
          parent.ascItrRemove(cursor);
        }
      }
      private static class BidirectionalItr$<E>$ extends AscendingItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>$
      {
        private transient int nextIndex;
        private transient Node$<E>$ lastRet;
        private BidirectionalItr(SubList$<E>$ parent)
        {
          super(parent);
        }
        private BidirectionalItr(SubList$<E>$ parent,Node$<E>$ cursor,int nextIndex)
        {
          super(parent,cursor);
          this.nextIndex=nextIndex;
        }
        @Override
        public void add($exposedType$ val)
        {
          final int nextIndex=this.nextIndex++;
          int size;
          final SubList$<E>$ parent;
          final var root=(parent=this.parent).root;
          if((size=parent.size++)!=0)
          {
            if(nextIndex==0)
            {
              parent.prependHelper(val);
            }
            else if(nextIndex==size)
            {
              parent.appendHelper(val);
            }
            else
            {
              Node$<E>$ cursor;
              parent.insertHelper((cursor=this.cursor).prev,val,cursor);
            }
          }
          else
          {
            parent.initHelper(root,val);
          }
        }
        #MACRO ForEachMethods(UncheckedSubBidirectionalItrForEach)
        @Override
        public boolean hasPrevious()
        {
          return nextIndex!=0;
        }
        @Override
        public $exposedType$ next$TypeNameModifier$()
        {
          Node$<E>$ cursor;
          if((cursor=this.cursor)==parent.tail)
          {
            this.cursor=null;
          }
          else
          {
            this.cursor=cursor.next;
          }
          ++nextIndex;
          lastRet=cursor;
          return cursor.val;
        }
        @Override
        public int nextIndex()
        {
          return nextIndex;
        }
        @Override
        public $exposedType$ previous$TypeNameModifier$()
        {
          Node$<E>$ lastRet;
          this.lastRet=lastRet=cursor.prev;
          cursor=lastRet;
          --nextIndex;
          return lastRet.val;
        }
        @Override
        public int previousIndex()
        {
          return nextIndex-1;
        }
        @Override
        public void remove()
        {
          Node$<E>$ lastRet;
          parent.bidirectItrRemove(lastRet=this.lastRet);
          if(lastRet!=cursor)
          {
            --nextIndex;
          }
          this.lastRet=null;
        }
        @Override
        public void set($exposedType$ val)
        {
          lastRet.val=val;
        }
      }
      @Override
      void initHelper($exposedType$ val)
      {
        $ClassPrefix$DblLnkSeq$<E>$ root;
        (root=this.root).size=1;
        Node$<E>$ newNode;
        root.privateInit(newNode=new Node$<E>$(val));
        bubbleUpinit(newNode);
      }
      #MACRO SubListRemoveFirstHelper(,,final var root=this.root;,RootClearOnlyNode,RootChopHead)
      #MACRO BasicUncheckedSubListPushHelper(head,val\,oldhead)
      #MACRO BasicUncheckedSubListPushHelper(tail,oldtail\,val)
      private void privateCollapseHeadAndTail(int size,Node$<E>$ head,Node$<E>$ tail)
      {
        this.size=size;
        this.head=head;
        this.tail=tail;
      }
      @Override
      public $exposedType$ $removeAtIndexMethod$(int index)
      {
        Unchecked$<E>$ root;
        --(root=this.root).size;
        Node$<E>$ node;
        int size;
        if((size=--this.size)!=0)
        #MACRO SubListIndexModify(RootRemoveHead,RootRemoveTail,RootRemoveClear,SubListRemoveBody)
        return node.val;
      }
      #MACRO BubbleUpMethods( )
      @Override
      public boolean equals(Object val)
      {
        //TODO implements equals method
        return false;
      }
      @Override
      public Object clone()
      {
        #MACRO CloneImpl(Unchecked)
      }
      @Override
      public OmniIterator.Of$ClassPrefix$$<E>$ iterator()
      {
        return new AscendingItr$<E>$(this);
      }
      @Override
      public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator()
      {
        return new BidirectionalItr$<E>$(this);
      }
      @Override
      public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index)
      {
        return new BidirectionalItr$<E>$(this,super.getItrNode(index,size-index),index);
      }
      #MACRO SubListRemoveValHelperMethods(,,,,bubbleUprootchoptail(prev);root.tail=prev;prev.next=null)
      
      @Override
      public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
      {
        final int tailDist=size-toIndex;
        int subListSize;
        switch(subListSize=toIndex-fromIndex)
        {
        default:
          return getDefaultSubList(root,fromIndex,subListSize,tailDist);
        case 1:
          return getSubList1(root,fromIndex,tailDist);
        case 0:
          return getEmptySubList(root,fromIndex,tailDist);
        }
      }
      #MACRO RootRemoveIf($TypeNameModifier$Predicate$<? super E>$,filter,this);
#IFNOT OfRef
      #MACRO RootRemoveIf(Predicate<? super $BoxedType$>,filter::test,this)
#ENDIF
      private boolean uncheckedRemoveIf(Node$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter)
      {
#IF OfBoolean
        $ArrayType$ v;
        if(filter.test(v=head.val))
        {
          findNewHead(head,filter,v);
          return true;
        }
        final Node$<E>$ tail;
        if(head!=(tail=this.tail))
        {
          if(v==tail.val)
          {
            return collapseBody(head,tail,filter,v);
          }
          if(filter.test(!v))
          {
            collapseTail(head,tail,v);
            return true;
          }
        }
#ELSE
        if(filter.test(head.val))
        {
          findNewHead(head,filter);
          return true;
        }
        final Node$<E>$ tail;
        if(head!=(tail=this.tail))
        {
          if(!filter.test(tail.val))
          {
            return collapseBody(head,tail,filter);
          }
          collapseTail(head,tail,filter);
          return true;
        }
#ENDIF
        return false;
      }
      #MACRO RootSubListMethods(Unchecked$<E>$ root\,,root\,this)
      #MACRO RootCollapseHeadAndTail(,,,)
     
      #MACRO SubListCollapseEnd(suffix,head,headCandidate,tail,prev,next,,,,,)
      private void clearRoot()
      {
        final $ClassPrefix$DblLnkSeq$<E>$ root;
        (root=this.root).size=0;
        root.privateInit(null);
        bubbleUpclearRoot();
      }
      private void clearPrefix(int numRemoved)
      {
        Node$<E>$ oldtail;
        Node$<E>$ newhead=(oldtail=this.tail).next;
        final $ClassPrefix$DblLnkSeq$<E>$ root;
        (root=this.root).size-=numRemoved;
        root.privatesethead(newhead);
        bubbleUpclearPrefix(oldtail,newhead,numRemoved);
      }
      private void clearSuffix(int numRemoved)
      {
        Node$<E>$ oldhead;
        Node$<E>$ newtail=(oldhead=this.head).prev;
        final $ClassPrefix$DblLnkSeq$<E>$ root;
        (root=this.root).size-=numRemoved;
        root.size-=numRemoved;
        root.privatesettail(newtail);
        bubbleUpclearSuffix(oldhead,newtail,numRemoved);
      }
      private void clearBody(int numRemoved)
      {
        root.size-=numRemoved;
        bubbleUpclearBody(this.head,this.tail,numRemoved);
      }
      #MACRO RootFindNewHead(,,,final $ClassPrefix$DblLnkSeq$<E>$ root;(root=this.root))
      
#IF OfBoolean
      void collapseTail(Node$<E>$ head,Node$<E>$ tail,$ArrayType$ retainThis)
#ELSE
      void collapseTail(Node$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
#ENDIF
      {
        int numRemoved;
        for(numRemoved=1;(tail=tail.prev)!=head;++numRemoved)
        {
#IF OfBoolean
          if(tail.val==retainThis)
          {
            numRemoved+=head.collapseBodyHelper(tail,retainThis);
#ELSE
          if(!filter.test(tail.val))
          {
            numRemoved+=head.collapseBodyHelper(tail,filter);
#ENDIF
            break;
          }
        }
        bubbleUprootCollapsetail(numRemoved,tail);
        final $ClassPrefix$DblLnkSeq$<E>$ root;
        (root=this.root).privatesettail(tail);
        root.size-=numRemoved;
      }

#IF OfBoolean
      boolean collapseBody(Node$<E>$ prev,Node$<E>$ next,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ retainThis)
#ELSE
      @Override
      boolean collapseBody(Node$<E>$ prev,Node$<E>$ next,$TypeNameModifier$Predicate$<? super E>$ filter)
#ENDIF
      {
        for(Node$<E>$ curr;(curr=prev.next)!=next;prev=curr)
        {
#IF OfBoolean
          if(curr.val^retainThis)
          {
            if(!filter.test(!retainThis))
            {
              break;
            }
#ELSE
          if(filter.test(curr.val))
          {
#ENDIF
            int numRemoved;
            for(numRemoved=1;(curr=curr.next)!=tail;++numRemoved)
            {
#IF OfBoolean
              if(curr.val==retainThis)
              {
                numRemoved+=curr.collapseBodyHelper(next,retainThis);
#ELSE
              if(!filter.test(curr.val))
              {
                numRemoved+=curr.collapseBodyHelper(next,filter);
#ENDIF
                break;
              }
            }
            prev.joinnext(curr);
            bubbleUpdecrementSize(numRemoved);
            root.size-=numRemoved;
            return true;
          }
        }
        return false;
      }
      #MACRO SubListRemoveValMethods(UncheckedSubListRemoveVal)

      #MACRO RootAddHelperMethods(Unchecked,)


      void ascItrRemove(Node$<E>$ cursor)
      {
        final Unchecked$<E>$ root;
        --(root=this.root).size;
        if(cursor!=null)
        {
          Node$<E>$ lastRet;
          if((lastRet=cursor.prev)==head)
          {
            ((SubList$<E>$)this).bubbleUprootchophead(cursor);
            (($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(cursor);
          }
          else
          {
            ((SubList$<E>$)this).bubbleUpdecrementSize();
            lastRet.prev.joinnext(cursor);
          }
        }
        else
        {
          if(size==1)
          {
            ((SubList$<E>$)this).bubbleUpclearRoot();
            (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
          }
          else
          {
            ((SubList$<E>$)this).bubbleUprootchoptail(cursor=tail.prev);
            (($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(cursor);
          }
        }
      }
      void bidirectItrRemove(Node$<E>$ lastRet)
      {
        final Unchecked$<E>$ root;
        --(root=this.root).size;
        #MACRO RootUncheckedItrRemoveImpl()
      }
      private static class PrefixList$<E>$ extends SubList$<E>$
      {
        PrefixList(Unchecked$<E>$ root,SubList$<E>$ parent)
        {
          super(root,parent);
        }
        PrefixList(Unchecked$<E>$ root,SubList$<E>$ parent,Node$<E>$ onlyNode)
        {
          super(root,parent,onlyNode);
        }
        PrefixList(Unchecked$<E>$ root,SubList$<E>$ parent,Node$<E>$ head,int size,Node$<E>$ tail)
        {
          super(root,parent,head,size,tail);
        }
        @Override
        public void add(int index,$exposedType$ val)
        {
          final Unchecked$<E>$ root;
          ++(root=this.root).size;
          int size;
          if((size=this.size)!=0)
          #MACRO SubListIndexModify(RootPushHead,PrefixPushTail,PrefixPushInit,SubListInsertBody)
        }
        @Override
        void appendHelper($exposedType$ val)
        {
          #MACRO PrependAppendHelperImpl(tail,oldtail=tail\,val\,oldtail.next,prefix)
        }   
        @Override
        void initHelper(Unchecked$<E>$ root,$exposedType$ val)
        {
          #MACRO PrefixSuffixInitHelperImpl(after,head,prev)
        }
        #MACRO PrefixSuffixPushHelper(tail,oldtail=this.tail\,val\,oldtail.next,,)
        #MACRO UncheckedPrefixSuffixInitHelper(head,val\,root.head)
        #MACRO SubListClear(,clearPrefix(size))
        #MACRO PrefixFindNewHead(,,)
        #MACRO PrefixSuffixCollapseHeadAndTail(,,,Prefix,head,tail,next,prev,head,tailCandidate,,,final Unchecked$<E>$ root;(root=this.root).head=head;)
        #MACRO SubListRemoveValHelperMethods(@Override,,,,((SubList$<E>$)this).bubbleUpprefixchoptail(curr\\,prev))
        @Override
#IF OfBoolean
        void collapseTail(Node$<E>$ head,Node$<E>$ tail,$ArrayType$ retainThis)
#ELSE
        void collapseTail(Node$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
#ENDIF
        {
          final int oldSize=this.size;
          int numConsumed=2;
          var tailCandidate=tail.prev;
          for(;;tailCandidate=tailCandidate.prev)
          {
            if(numConsumed==oldSize)
            {
              --numConsumed;
              break;
            }
            ++numConsumed;
#IF OfBoolean
            if(tailCandidate.val==retainThis)
            {
              numConsumed-=2-head.collapseBodyHelper(tailCandidate,retainThis);
#ELSE       
            if(!filter.test(tailCandidate.val))
            {
              numConsumed-=2-head.collapseBodyHelper(tailCandidate,filter);
#ENDIF
              break;
            }
          }
          ((SubList$<E>$)this).bubbleUpprefixCollapsetail(numConsumed,tail,tailCandidate);
          tailCandidate.joinnext(tail.next);
          root.size-=numConsumed;
        }
        @Override
        public $exposedType$ $removeAtIndexMethod$(int index)
        {
          Unchecked$<E>$ root;
          --(root=this.root).size;
          Node$<E>$ node;
          int size;
          if((size=--this.size)!=0)
          #MACRO SubListIndexModify(RootRemoveHead,PrefixRemoveTail,PrefixRemoveClear,SubListRemoveBody)
          return node.val;
        }
        @Override
        public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
        {
          int subListSize;
          switch(subListSize=toIndex-fromIndex)
          {
          default:
            return getDefaultSubList(root,fromIndex,subListSize,size-toIndex);
          case 1:
            return getSubList1(root,fromIndex,size-toIndex);
          case 0:
            return getEmptySubList(root,fromIndex);
          }
        }
        private OmniList.Of$ClassPrefix$$<E>$ getDefaultSubList(Unchecked$<E>$ root,int headDist,int subListSize,int tailDist)
        {
          Node$<E>$ subListHead=head,subListTail=tail;
          if(headDist==0)
          {
            return new SubList.PrefixList$<E>$(root,this,subListHead,subListSize,tailDist<=subListSize?subListTail.iterateReverse(tailDist):subListHead.uncheckedIterateForward(subListSize));
          }
          if(headDist<=tailDist)
          {
            subListHead=subListHead.uncheckedIterateForward(headDist);
            subListTail=tailDist<=subListSize?subListTail.iterateReverse(tailDist):subListHead.uncheckedIterateForward(subListSize);
          }
          else
          {
            subListTail=subListTail.iterateReverse(tailDist);
            subListHead=headDist<=subListSize?subListHead.uncheckedIterateForward(headDist):subListTail.uncheckedIterateReverse(subListSize);
          }
          return new SubList.BodyList$<E>$(root,this,subListHead,subListSize,subListTail,headDist);
        }
        private OmniList.Of$ClassPrefix$$<E>$ getEmptySubList(Unchecked$<E>$ root,int headDist)
        {
          if(headDist==0)
          {
            return new SubList.PrefixList$<E>$(root,this);
          }
          return new SubList.BodyList$<E>$(root,this,headDist);
        }
        private OmniList.Of$ClassPrefix$$<E>$ getSubList1(Unchecked$<E>$ root,int headDist,int tailDist)
        {
          if(headDist==0)
          {
            return new SubList.PrefixList$<E>$(root,this,head);
          }
          return new SubList.BodyList$<E>$(root,this,tailDist<headDist?tail.iterateReverse(tailDist):head.uncheckedIterateForward(headDist),headDist);
        }
        @Override
        void ascItrRemove(Node$<E>$ cursor)
        {
          final Unchecked$<E>$ root;
          --(root=this.root).size;
          if(cursor!=null)
          {
            Node$<E>$ lastRet;
            if((lastRet=cursor.prev)==head)
            {
              ((SubList$<E>$)this).bubbleUprootchophead(cursor);
            }
            else
            {
              ((SubList$<E>$)this).bubbleUpdecrementSize();
              lastRet.prev.joinnext(cursor);
              return;
            }
          }
          else
          {
            cursor=tail;
            if(size==1)
            {
              ((SubList$<E>$)this).bubbleUpclearPrefix(cursor,cursor=cursor.next,1);
            }
            else
            {
              ((SubList$<E>$)this).bubbleUpprefixchoptail(cursor,cursor.prev);
              return;
            }
          }
          (($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(cursor);
        }
        @Override
        void bidirectItrRemove(Node$<E>$ lastRet)
        {
          final Unchecked$<E>$ root;
          --(root=this.root).size;
          #MACRO PrefixUncheckedItrRemoveImpl()
        }
      }
      private static class SuffixList$<E>$ extends SubList$<E>$
      {
        SuffixList(Unchecked$<E>$ root,SubList$<E>$ parent)
        {
          super(root,parent);
        }
        SuffixList(Unchecked$<E>$ root,SubList$<E>$ parent,Node$<E>$ onlyNode)
        {
          super(root,parent,onlyNode);
        }
        SuffixList(Unchecked$<E>$ root,SubList$<E>$ parent,Node$<E>$ head,int size,Node$<E>$ tail)
        {
          super(root,parent,head,size,tail);
        }
        @Override
        public void add(int index,$exposedType$ val)
        {
          final Unchecked$<E>$ root;
          ++(root=this.root).size;
          int size;
          if((size=this.size)!=0)
          #MACRO SubListIndexModify(SuffixPushHead,RootPushTail,SuffixPushInit,SubListInsertBody)
        }
        #MACRO SubListRemoveFirstHelper(@Override,,final var root=this.root;,SuffixClearOnlyNode,SuffixChopHead)
        #MACRO UncheckedPrefixSuffixInitHelper(tail,root.tail\,val)
        #MACRO PrefixSuffixPushHelper(head,(oldhead=this.head).prev\,val\,oldhead,,)
        #MACRO SubListClear(,clearSuffix(size))
        #MACRO SuffixFindNewHead(,,)
        #MACRO PrefixSuffixCollapseHeadAndTail(,,,Suffix,tail,head,prev,next,headCandidate,tail,,,final Unchecked$<E>$ root;(root=this.root).tail=tail;)
        @Override
        public $exposedType$ $removeAtIndexMethod$(int index)
        {
          Unchecked$<E>$ root;
          --(root=this.root).size;
          Node$<E>$ node;
          int size;
          if((size=--this.size)!=0)
          #MACRO SubListIndexModify(SuffixRemoveHead,RootRemoveTail,SuffixRemoveClear,SubListRemoveBody)
          return node.val;
        }
        @Override
        public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
        {
          final int tailDist=size-toIndex;
          int subListSize;
          switch(subListSize=toIndex-fromIndex)
          {
          default:
            return getDefaultSubList(root,fromIndex,subListSize,tailDist);
          case 1:
            return getSubList1(root,fromIndex,tailDist);
          case 0:
            return getEmptySubList(root,fromIndex,tailDist);
          }
        }
        @Override
        void initHelper(Unchecked$<E>$ root,$exposedType$ val)
        {
          #MACRO PrefixSuffixInitHelperImpl(before,tail,next)
        }
        @Override
        void prependHelper($exposedType$ val)
        {
          #MACRO PrependAppendHelperImpl(head,(oldhead=head).prev\,val\,oldhead,suffix)
        }
        private OmniList.Of$ClassPrefix$$<E>$ getDefaultSubList(Unchecked$<E>$ root,int headDist,int subListSize,int tailDist)
        {
          Node$<E>$ subListHead=head,subListTail=tail;
          if(tailDist==0)
          {
            return new SubList.SuffixList$<E>$(root,this,headDist<=subListSize?subListHead.iterateForward(headDist):subListTail.uncheckedIterateReverse(subListSize));
          }
          if(tailDist<=headDist)
          {
            subListTail=subListTail.uncheckedIterateReverse(tailDist);
            subListHead=headDist<=subListSize?subListHead.iterateForward(headDist):subListTail.uncheckedIterateReverse(subListSize);
          }
          else
          {
            subListHead=subListHead.iterateForward(headDist);
            subListTail=tailDist<=subListSize?subListTail.uncheckedIterateReverse(tailDist):subListHead.uncheckedIterateForward(subListSize);
          }
          return new SubList.BodyList$<E>$(root,this,subListHead,subListSize,subListTail,headDist);
        }
        private OmniList.Of$ClassPrefix$$<E>$ getEmptySubList(Unchecked$<E>$ root,int headDist,int tailDist)
        {
          if(tailDist==0)
          {
            return new SubList.PrefixList$<E>$(root,this);
          }
          return new SubList.BodyList$<E>$(root,this,headDist);
        }
        private OmniList.Of$ClassPrefix$$<E>$ getSubList1(Unchecked$<E>$ root,int headDist,int tailDist)
        {
          if(tailDist==0)
          {
            return new SubList.SuffixList$<E>$(root,this,tail);
          }
          return new SubList.BodyList$<E>$(root,this,(($ClassPrefix$DblLnkSeq$<E>$)this).privateGetNode(headDist,tailDist),headDist);
        }
        @Override
        void ascItrRemove(Node$<E>$ cursor)
        {
          final Unchecked$<E>$ root;
          --(root=this.root).size;
          if(cursor!=null)
          {
            Node$<E>$ lastRet;
            if((lastRet=cursor.prev)==head)
            {
              ((SubList$<E>$)this).bubbleUpsuffixchophead(lastRet,cursor);
            }
            else
            {
              ((SubList$<E>$)this).bubbleUpdecrementSize();
              lastRet.prev.joinnext(cursor);
            }
          }
          else
          {
            if(size==1)
            {
              ((SubList$<E>$)this).bubbleUpclearSuffix(cursor=tail,cursor=cursor.prev,1);
            }
            else
            {
              ((SubList$<E>$)this).bubbleUprootchoptail(cursor=tail.prev);
            }
            (($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(cursor);
          }
        }
        @Override
        void bidirectItrRemove(Node$<E>$ lastRet)
        {
          final Unchecked$<E>$ root;
          --(root=this.root).size;
          #MACRO SuffixUncheckedItrRemoveImpl()
        }
      }
      private static class BodyList$<E>$ extends PrefixList$<E>$
      {
        private transient final int parentOffset;
        BodyList(Unchecked$<E>$ root,SubList$<E>$ parent,int parentOffset)
        {
          super(root,parent);
          this.parentOffset=parentOffset;
        }
        BodyList(Unchecked$<E>$ root,SubList$<E>$ parent,Node$<E>$ onlyNode,int parentOffset)
        {
          super(root,parent,onlyNode);
          this.parentOffset=parentOffset;
        }
        BodyList(Unchecked$<E>$ root,SubList$<E>$ parent,Node$<E>$ head,int size,Node$<E>$ tail,int parentOffset)
        {
          super(root,parent,head,size,tail);
          this.parentOffset=parentOffset;
        }
        @Override
        public void add(int index,$exposedType$ val)
        {
          ++root.size;
          int size;
          if((size=this.size)!=0)
          #MACRO SubListIndexModify(SuffixPushHead,PrefixPushTail,BodyPushInit,SubListInsertBody)
        }
        #MACRO SubListRemoveFirstHelper(@Override,,,BodyClearOnlyNode,SuffixChopHead)
        #MACRO BodyBubbleUpCollapseHeadAndTail( )
        #MACRO BodyCollapseHeadAndTail(,,,)
        #MACRO BodyFindNewHead(,,)
        #MACRO PrefixSuffixPushHelper(head,(oldhead=this.head).prev\,val\,oldhead,,)
        #MACRO BubbleUpInitBody( )
        #MACRO SubListClear(,clearBody(size))
        @Override
        void initHelper($exposedType$ val)
        {
          ++root.size;
          bubbleUpinit(new Node$<E>$(val));
        }

        @Override
        void prependHelper($exposedType$ val)
        {
          #MACRO PrependAppendHelperImpl(head,(oldhead=head).prev\,val\,oldhead,suffix)
        }

        @Override
        void initHelper(Unchecked$<E>$ root,$exposedType$ val)
        {
          #MACRO BodyInitHelperImpl()
        }
        @Override
        public $exposedType$ $removeAtIndexMethod$(int index)
        {
          --root.size;
          Node$<E>$ node;
          int size;
          if((size=--this.size)!=0)
          #MACRO SubListIndexModify(SuffixRemoveHead,PrefixRemoveTail,BodyRemoveClear,SubListRemoveBody)
          return node.val;
        }
        @Override
        public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex)
        {
          int subListSize;
          switch(subListSize=toIndex-fromIndex)
          {
          default:
            return getDefaultSubList(root,fromIndex,subListSize,size-toIndex);
          case 1:
            return getSubList1(root,fromIndex,size-toIndex);
          case 0:
            return getEmptySubList(root,fromIndex);
          }
        }
        @Override
        int getParentOffset()
        {
          return parentOffset;
        }
        private OmniList.Of$ClassPrefix$$<E>$ getDefaultSubList(Unchecked$<E>$ root,int headDist,int subListSize,int tailDist)
        {
          Node$<E>$ subListHead,subListTail;
          if(headDist<=tailDist)
          {
            subListHead=head.iterateForward(headDist);
            subListTail=tailDist<subListSize?tail.iterateReverse(tailDist):subListHead.uncheckedIterateForward(subListSize);
          }
          else
          {
            subListTail=tail.iterateReverse(tailDist);
            subListHead=headDist<subListSize?head.iterateForward(headDist):subListTail.uncheckedIterateReverse(subListSize);
          }
          return new SubList.BodyList$<E>$(root,this,subListHead,subListSize,subListTail,headDist);
        }
        private OmniList.Of$ClassPrefix$$<E>$ getEmptySubList(Unchecked$<E>$ root,int headDist)
        {
          return new SubList.BodyList$<E>$(root,this,headDist);
        }
        private OmniList.Of$ClassPrefix$$<E>$ getSubList1(Unchecked$<E>$ root,int headDist,int tailDist)
        {
          return new SubList.BodyList$<E>$(root,this,(($ClassPrefix$DblLnkSeq$<E>$)this).privateGetNode(headDist,tailDist),headDist);
        }
        @Override 
        void ascItrRemove(Node$<E>$ cursor)
        {
          --root.size;
          if(cursor!=null)
          {
            Node$<E>$ lastRet;
            if((lastRet=cursor.prev)==head)
            {
              ((SubList$<E>$)this).bubbleUpsuffixchophead(lastRet,cursor);
            }
            else
            {
              ((SubList$<E>$)this).bubbleUpdecrementSize();
              lastRet.prev.joinnext(cursor);
            }
          }
          else
          {
            cursor=tail;
            if(size==1)
            {
              ((SubList$<E>$)this).bubbleUpclearBody(cursor,cursor,1);
            }
            else
            {
              ((SubList$<E>$)this).bubbleUpprefixchoptail(cursor,cursor.prev);
            }
          }
        }
        @Override
        void bidirectItrRemove(Node$<E>$ lastRet)
        {
          --root.size;
          #MACRO BodyUncheckedItrRemoveImpl()
        }
      }

    }
  }
}
#MACRODEF Push(methodName,node)
abstract void pushnodeHelper(Node$<E>$ oldnode,$exposedType$ val);
public void methodName(final $exposedType$ val)
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
    pushnodeHelper(node,val);
  }
  else
  {
    initHelper(val);
  }
}
#ENDDEF
#MACRODEF RootQueryObject(retType,node,methodName,negRet,methodParams,override)
override
public retType methodName(final Object val)
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
#IFNOT OfRef
    if(val instanceof $BoxedType$)
#ENDIF
    {
      return $ClassPrefix$DblLnkSeq.uncheckedmethodName(methodParams,$queryCastRef$(val));
    }
  }
  return negRet;
}
#ENDDEF
#MACRODEF CheckedRootRemoveMethods(IFSTATEMENT,methodName,uncheckedMethodName,node,end,next)
@Override
public boolean methodName(Object val)
{
  Node$<E>$ node;
  if((node=this.node)!=null)
  {
#IF OfRef
    if(val!=null)
    {
      return uncheckeduncheckedMethodNameNonNull(node,val);
    }
    return uncheckeduncheckedMethodName(node,Objects::isNull);
#ELSE
    if(val instanceof $BoxedType$)
    {
      return uncheckeduncheckedMethodName(node,$queryCastRef$(val));
    }
#ENDIF
  }
  return false;
}
#IF OfRef
private boolean uncheckeduncheckedMethodNameNonNull(Node$<E>$ node,Object nonNull)
{
  int modCount=this.modCount;
  try
  {
    if(!nonNull.equals(node.val))
    {
      Node$<E>$ lastVisited;
      do
      {
        if((node=(lastVisited=node).next)==null)
        {
          CheckedCollection.checkModCount(modCount,this.modCount);
          return false;
        }
      }
      while(!nonNull.equals(node.val));
      --this.size;
      if(node==end)
      {
        (($ClassPrefix$DblLnkSeq$<E>$)this).privatesetend(lastVisited);
      }
      else
      {
        lastVisited.joinnext(node.next);
      }
    }
    else
    {
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount+1;
      if(--this.size==0)
      {
        (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(null);
      }
      else
      {
        (($ClassPrefix$DblLnkSeq$<E>$)this).privatechopnode(node);
      }
    }
  }
  catch(final RuntimeException e)
  {
    throw CheckedCollection.checkModCount(modCount,this.modCount,e);
  }
  return true;
}
#MACRO RootRemoveFirstHelper(uncheckedMethodName,node,\,Predicate<Object> pred,!pred.test,end,next,++this.modCount;)
#ENDIF
#MACRO RootRemoveFirstHelpers(uncheckedMethodName,node,end,next,++this.modCount;)
#MACRO QueryMethods(IFSTATEMENT,boolean,node,uncheckedMethodName,false,this,node,,@Override)
#ENDDEF
#MACRODEF CheckedSubListRemoveIf(Predicate,filterParam)
@Override
public boolean removeIf(Predicate filter)
{
  final Node$<E>$ head;
  if((head=this.head)!=null)
  {
    return uncheckedRemoveIf(head,filterParam);
  }
  CheckedCollection.checkModCount(modCount,root.modCount);
  return false;
}
#ENDDEF
#MACRODEF UncheckedRootRemoveMethods(IFSTATEMENT,methodName,uncheckedMethodName,node,end,next,prev)
@Override
public boolean methodName(Object val)
{
  Node$<E>$ node;
  if((node=this.node)!=null)
  {
#IFNOT OfRef
    if(val instanceof $BoxedType$)
#ENDIF
    {
      return uncheckeduncheckedMethodName(node,$queryCastRef$(val));
    }
  }
  return false;
}
#IF OfRef
#MACRO RootRemoveFirstHelper(uncheckedMethodName,node,\,Predicate<Object> pred,!pred.test,end,next,)
#ENDIF
#MACRO RootRemoveFirstHelpers(uncheckedMethodName,node,end,next,)
#MACRO QueryMethods(IFSTATEMENT,boolean,node,uncheckedMethodName,false,this,node,,@Override)
#ENDDEF
#MACRODEF Poll(popCall,retType,methodName,node,cast,defaultVal,incrementModCount,override)
override
public retType methodName()
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
    incrementModCount
    --this.size;
    popCall
    return cast(node.val);
  }
  return defaultVal;
}
#ENDDEF
#MACRODEF PollMethods(popCall,Suffix,node,incrementModCount,override)
#MACRO Poll(popCall,$exposedType$,pollSuffix$TypeNameModifier$,node,($exposedType$),$defaultVal$,incrementModCount,override)
#IFNOT OfRef
#MACRO Poll(popCall,$BoxedType$,pollSuffix,node,,null,incrementModCount,override)
  #IFNOT OfDouble
#MACRO Poll(popCall,double,pollSuffixDouble,node,$castToDouble$,Double.NaN,incrementModCount,override)
    #IFNOT OfFloat
#MACRO Poll(popCall,float,pollSuffixFloat,node,$castToFloat$,Float.NaN,incrementModCount,override)
      #IFNOT OfLong
#MACRO Poll(popCall,long,pollSuffixLong,node,$castToLong$,Long.MIN_VALUE,incrementModCount,override)
        #IFNOT OfInt
#MACRO Poll(popCall,int,pollSuffixInt,node,$castToInt$,Integer.MIN_VALUE,incrementModCount,override)
          #IFNOT OfChar,OfShort
#MACRO Poll(popCall,short,pollSuffixShort,node,$castToShort$,Short.MIN_VALUE,incrementModCount,override)
            #IFNOT OfByte
#MACRO Poll(popCall,byte,pollSuffixByte,node,$castToByte$,Byte.MIN_VALUE,incrementModCount,override)
#MACRO Poll(popCall,char,pollSuffixChar,node,$castToChar$,Character.MIN_VALUE,incrementModCount,override)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF ToArray(uncheckedMethodCall,retType,Name,defaultArr,checkModCount)
@Override
public retType[] toNameArray()
{
  checkModCount
  final int size;
  if((size=this.size)!=0)
  {
    final retType[] dst;
    uncheckedMethodCall
    return dst;
  }
  return defaultArr;
}
#ENDDEF
#MACRODEF ToArrayMethods(checkedModCount,uncheckedMethodCalls)
  #MACRO ToArray(uncheckedMethodCalls,$ArrayType$,$TypeNameModifier$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR,checkedModCount)
#IFNOT OfRef
  #MACRO ToArray(uncheckedMethodCalls,$BoxedType$,,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR,checkedModCount)
  #IFNOT OfDouble
  #MACRO ToArray(uncheckedMethodCalls,double,Double,OmniArray.OfDouble.DEFAULT_ARR,checkedModCount)
    #IFNOT OfFloat
  #MACRO ToArray(uncheckedMethodCalls,float,Float,OmniArray.OfFloat.DEFAULT_ARR,checkedModCount)
      #IFNOT OfLong
  #MACRO ToArray(uncheckedMethodCalls,long,Long,OmniArray.OfLong.DEFAULT_ARR,checkedModCount)
        #IFNOT OfInt
  #MACRO ToArray(uncheckedMethodCalls,int,Int,OmniArray.OfInt.DEFAULT_ARR,checkedModCount)
          #IFNOT OfChar,OfShort
  #MACRO ToArray(uncheckedMethodCalls,short,Short,OmniArray.OfShort.DEFAULT_ARR,checkedModCount)
            #IFNOT OfByte
  #MACRO ToArray(uncheckedMethodCalls,byte,Byte,OmniArray.OfByte.DEFAULT_ARR,checkedModCount)
  #MACRO ToArray(uncheckedMethodCalls,char,Char,OmniArray.OfChar.DEFAULT_ARR,checkedModCount)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF ForEachMethods(MacroName)
#MACRO MacroName($TypeNameModifier$Consumer$<? super E>$,action)
#IFNOT OfRef
#MACRO MacroName(Consumer<? super $BoxedType$>,($TypeNameModifier$Consumer$<? super E>$)action::accept)
#ENDIF
#ENDDEF
#MACRODEF RootForEach(Consumer,consumerParam)
@Override
public void forEach(final Consumer action)
{
  final Node$<E>$ head;
  if((head=this.head)!=null)
  {
    head.uncheckedForEachForward(this.tail,consumerParam);
  }
}
#ENDDEF
#MACRODEF CheckedRootForEach(Consumer,consumerParam)
@Override
public void forEach(final Consumer action)
{
  final Node$<E>$ head;
  if((head=this.head)!=null)
  {
    #MACRO TryCheckModCount(this,head.uncheckedForEachForward(this.tail\,consumerParam);)
  }
}
#ENDDEF
#MACRODEF RootSortComparator(Comparator,sorterParam)
@Override
public void sort(Comparator sorter)
{
#IF OfBoolean
  final Node$<E>$ head,tail;
  if((head=this.head)!=(tail=this.tail))
  {
    head.uncheckedcomparatorSort(tail,sorterParam);
#ELSE
  final int size;
  if((size=this.size)>1)
  {
    head.uncheckedcomparatorSort(size,tail,sorterParam);
#ENDIF
  }
}
#ENDDEF
#MACRODEF RootSortNoComparator(sortMethod)
@Override
public void sortMethod()
{
#IF OfBoolean
  final Node$<E>$ head,tail;
  if((head=this.head)!=(tail=this.tail))
  {
    head.uncheckedsortMethod(tail);
#ELSE
  final int size;
  if((size=this.size)>1)
  {
    head.uncheckedsortMethod(size,tail);
#ENDIF
  }
}
#ENDDEF
#MACRODEF CheckedRootSortComparator(Comparator,sorterParam)
@Override
public void sort(Comparator sorter)
{
#IF OfBoolean
  final Node$<E>$ head,tail;
  if((head=this.head)!=(tail=this.tail))
  {
    #MACRO TryCheckModCount(this,head.uncheckedcomparatorSort(tail\,sorterParam);)
#ELSE
  final int size;
  if((size=this.size)>1)
  {
    #MACRO TryCheckModCount(this,head.uncheckedcomparatorSort(size\,tail\,sorterParam);)
#ENDIF
    this.modCount=modCount+1;
  }
}
#ENDDEF
#MACRODEF CheckedRootSortNoComparator(sortMethod)
@Override
public void sortMethod()
{
#IF OfBoolean
  final Node$<E>$ head,tail;
  if((head=this.head)!=(tail=this.head))
  {
    head.uncheckedsortMethod(tail);
    ++this.modCount;
#ELSE
  final int size;
  if((size=this.size)>1)
  {
  #IF OfRef
    #MACRO TryCheckModCount(this, head.uncheckedsortMethod(size\,tail);)
    this.modCount=modCount+1;
  #ELSE
    head.uncheckedsortMethod(size,tail);
    ++this.modCount;
  #ENDIF
#ENDIF
  }
}
#ENDDEF
#MACRODEF RootReplaceAll(UnaryOperator,operatorParam)
@Override
public void replaceAll(UnaryOperator operator)
{
  Node$<E>$ head;
  if((head=this.head)!=null)
  {
    head.uncheckedReplaceAll(this.tail,operatorParam);
  }
}
#ENDDEF
#MACRODEF CheckedRootReplaceAll(UnaryOperator,operatorParam)
@Override
public void replaceAll(UnaryOperator operator)
{
  Node$<E>$ head;
  if((head=this.head)!=null)
  {
    #MACRO TryCheckModCount(this,head.uncheckedReplaceAll(this.tail\,operatorParam);)
    this.modCount=modCount+1;
  }
}
#ENDDEF
#MACRODEF UncheckedSubAscendingItrForEach(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  Node$<E>$ cursor;
  if((cursor=this.cursor)!=null)
  {
    cursor.uncheckedForEachForward(parent.tail,consumerParam);
    this.cursor=null;
  }
}
#ENDDEF
#MACRODEF UncheckedSubBidirectionalItrForEach(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  Node$<E>$ cursor;
  if((cursor=this.cursor)!=null)
  {
    SubList$<E>$ parent;
    cursor.uncheckedForEachForward(cursor=(parent=this.parent).tail,consumerParam);
    nextIndex=parent.size;
    this.cursor=null;
    lastRet=cursor;
  }
}
#ENDDEF
#MACRODEF CheckedSubBidirectionalItrForEach(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  Node$<E>$ cursor;
  if((cursor=this.cursor)!=null)
  {
    final var parent=this.parent;
    #MACRO TryCheckModCount(parent.root,cursor.uncheckedForEachForward(cursor=parent.tail\,consumerParam);)
    this.nextIndex=parent.size;
    this.cursor=null;
    this.lastRet=cursor;
  }
}
#ENDDEF
#MACRODEF CheckedSubAscendingItrForEach(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  Node$<E>$ cursor;
  if((cursor=this.cursor)!=null)
  {
    final var parent=this.parent;
    #MACRO TryCheckModCount(parent.root,cursor.uncheckedForEachForward(cursor=parent.tail\,consumerParam);)
    this.cursor=null;
    this.lastRet=cursor;
  }
}
#ENDDEF
#MACRODEF UncheckedRootAscendingItrForEach(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  Node$<E>$ cursor;
  if((cursor=this.cursor)!=null)
  {
    cursor.uncheckedForEachForward(root.tail,consumerParam);
    this.cursor=null;
  }
}
#ENDDEF
#MACRODEF UncheckedRootDescendingItrForEach(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  Node$<E>$ cursor;
  if((cursor=this.cursor)!=null)
  {
    cursor.uncheckedForEachReverse(consumerParam);
    this.cursor=null;
  }
}
#ENDDEF
#MACRODEF UncheckedRootBidirectionalItrForEach(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  Node$<E>$ cursor;
  if((cursor=this.cursor)!=null)
  {
    Node$<E>$ bound;
    Unchecked$<E>$ root;
    cursor.uncheckedForEachForward(bound=(root=this.root).tail,consumerParam);
    this.cursor=null;
    lastRet=bound;
    nextIndex=root.size;
  }
}
#ENDDEF
#MACRODEF CheckedRootAscendingItrForEach(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  Node$<E>$ cursor;
  if((cursor=this.cursor)!=null)
  {
    final var root=this.root;
    #MACRO TryCheckModCount(root,cursor=uncheckedForEach(cursor\,root\,consumerParam);)
    this.cursor=null;
    this.lastRet=cursor;
  }
}
#ENDDEF
#MACRODEF CheckedRootBidirectionalItrForEach(Consumer,consumerParam)
@Override
public void forEachRemaining(Consumer action)
{
  Node$<E>$ cursor;
  if((cursor=this.cursor)!=null)
  {
    final var root=this.root;
    #MACRO TryCheckModCount(root,cursor.uncheckedForEachForward(cursor=root.tail\,consumerParam);)
    this.nextIndex=root.size;
    this.cursor=null;
    lastRet=null;
  }
}
#ENDDEF
#MACRODEF ProxyGet(override,retType,methodName,callee)
override
public final retType methodName()
{
  return callee();
}
#ENDDEF
#MACRODEF RootSubListMethods(sigParams,methodParams)
private OmniList.Of$ClassPrefix$$<E>$ getDefaultSubList(sigParamsint headDist,int subListSize,int tailDist)
{
  final Node$<E>$ subListHead=head;
  Node$<E>$ subListTail=tail;
  if(tailDist==0)
  {
    if(headDist==0)
    {
      return new SubList$<E>$(methodParams,subListHead,subListSize,subListTail);
    }
    return new SubList.SuffixList$<E>$(methodParams,headDist<=subListSize?subListHead.uncheckedIterateForward(headDist):subListTail.uncheckedIterateReverse(subListSize),subListSize,subListTail);
  }
  subListTail=tailDist<=subListSize?subListTail.uncheckedIterateReverse(tailDist):subListHead.uncheckedIterateForward(subListSize);
  if(headDist==0)
  {
    return new SubList.PrefixList$<E>$(methodParams,subListHead,subListSize,subListTail);
  }
  return new SubList.BodyList$<E>$(methodParams,headDist<=subListSize?subListHead.uncheckedIterateForward(headDist):subListTail.uncheckedIterateReverse(subListSize),subListSize,subListTail,headDist);
}
private OmniList.Of$ClassPrefix$$<E>$ getEmptySubList(sigParamsint headDist,int tailDist)
{
  if(tailDist==0)
  {
    if(headDist==0)
    {
      return new SubList$<E>$(methodParams);
    }
    return new SubList.SuffixList$<E>$(methodParams);
  }
  else if(headDist==0)
  {
    return new SubList.PrefixList$<E>$(methodParams);
  }
  return new SubList.BodyList$<E>$(methodParams,headDist);
}
private OmniList.Of$ClassPrefix$$<E>$ getSubList1(sigParamsint headDist,int tailDist)
{
  if(tailDist==0)
  {
    if(headDist==0)
    {
      return new SubList$<E>$(methodParams,head);
    }
    return new SubList.SuffixList$<E>$(methodParams,tail);
  }
  else if(headDist==0)
  {
    return new SubList.PrefixList$<E>$(methodParams,head);
  }
  return new SubList.BodyList$<E>$(methodParams,(($ClassPrefix$DblLnkSeq$<E>$)this).privateGetNode(headDist,tailDist),headDist);
}
#ENDDEF
#MACRODEF Staticcontains(Suffix,param,indexTest)
private static $<E>$ boolean uncheckedcontainsSuffix(Node$<E>$ begin,Node$<E>$ endparam)
{
  while(indexTest(begin.val))
  {
    if(begin==end)
    {
      return false;
    }
    begin=begin.next;
  }
  return true;
}
#ENDDEF
#MACRODEF Staticsearch(Suffix,param,indexTest)
private static $<E>$ int uncheckedsearchSuffix(Node$<E>$ beginparam)
{
  int index=1;
  while(indexTest(begin.val))
  {
    if((begin=begin.next)==null)
    {
      return -1;
    }
    ++index;
  }
  return index;
}
#ENDDEF
#MACRODEF StaticindexOf(Suffix,param,indexTest)
private static $<E>$ int uncheckedindexOfSuffix(Node$<E>$ begin,Node$<E>$ endparam)
{
  int index=0;
  while(indexTest(begin.val))
  {
    if((begin=begin.next)==null)
    {
      return -1;
    }
    ++index;
  }
  return index;
}
#ENDDEF
#MACRODEF StaticlastIndexOf(Suffix,param,indexTest)
private static $<E>$ int uncheckedlastIndexOfSuffix(Node$<E>$ end,int sizeparam)
{
  while(indexTest(end.val) && --size!=0)
  {
    end=end.prev;
  }
  return size-1;
}
#ENDDEF
#MACRODEF StaticQueryMethods(methodName)
#IF OfRef
#MACRO StaticmethodName(,\,Predicate<Object> pred,!pred.test)
#ELSEIF OfDouble,OfFloat
#MACRO StaticmethodName(0,,0!=)
#MACRO StaticmethodName(Bits,\,$queryParameterType$ bits,bits!=$convertToBits$)
#MACRO StaticmethodName(NaN,,!$BoxedType$.isNaN)
#ELSEIF OfBoolean
#MACRO StaticmethodName(,\,$queryParameterType$ val,val^)
#ELSE
#MACRO StaticmethodName(,\,$queryParameterType$ val,val!=)
#ENDIF
#ENDDEF
#MACRODEF StaticDoubleFloatQuery(retType,methodName,Suffix1,sigParams,test,Suffix2,tailParam)
private static retType uncheckedmethodNameSuffix1(Node$<E>$ head,sigParams)
{
  if(test(val))
  {
    return $ClassPrefix$DblLnkSeq.uncheckedmethodNameBits(headtailParam,$convertToBits$(val));
  }
  return $ClassPrefix$DblLnkSeq.uncheckedmethodNameSuffix2(headtailParam);
}
#ENDDEF
#MACRODEF ProxyAdd(override,retType,methodName,sigType,callee,optionalReturnLine)
override
public final retType methodName(final sigType val)
{
  callee(($exposedType$)val);
  optionalReturnLine
}
#ENDDEF
#MACRODEF BasicQuery(access,node,retType,methodName,paramType,negRet,target,methodParams,checkModCount,override)
override
access retType methodName(final paramType val)
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
    return target.uncheckedmethodName(methodParams);
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryBoolean(retType,node,methodName,negRet,target,methodParams,checkModCount,override)
override
public retType methodName(final boolean val)
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
#IF OfDouble,OfFloat
    if(val)
    {
      return target.uncheckedmethodNameBits(methodParams,$TRUE_BITS$);
    }
    return target.uncheckedmethodName0(methodParams);
#ELSE
    return target.uncheckedmethodName(methodParams,$queryCastBoolean$(val));
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryChar(retType,node,methodName,negRet,target,boundParam,checkModCount,override)
override
public retType methodName(final char val)
{
#IF OfByte,OfShort
  if(val<=$BoxedType$.MAX_VALUE)
#ENDIF
  {
    final Node$<E>$ node;
    if((node=this.node)!=null)
    {
#IF OfFloat
      return target.uncheckedmethodNameRawInt(boundParam,val);
#ELSE
      return target.uncheckedmethodName(boundParam,$queryCastPrimitive$(val));
#ENDIF
    }
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryShort(retType,node,methodName,negRet,target,boundParam,checkModCount,override)
override
public retType methodName(final short val)
{
#IF OfChar
  if(val>=0)
#ENDIF
  {
    final Node$<E>$ node;
    if((node=this.node)!=null)
    {
#IF OfFloat
      return target.uncheckedmethodNameRawInt(boundParam,val);
#ELSE
      return target.uncheckedmethodName(boundParam,$queryCastPrimitive$(val));
#ENDIF
    }
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryInt(retType,node,methodName,negRet,target,boundParam,checkModCount,override)
override
public retType methodName(final int val)
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
#IF OfDouble,OfFloat
    if(val!=0)
    {
  #IF OfFloat
      if(TypeUtil.checkCastToFloat(val))
  #ENDIF
      {
        return target.uncheckedmethodNameBits(boundParam,$convertToBits$(val));
      }
    }
    else
    {
      return target.uncheckedmethodName0(boundParam);
    }
#ELSEIF OfBoolean
    final boolean v;
    switch(val)
    {
      default:
        checkModCount
        return negRet;
      case 0:
        v=false;
        break;
      case 1:
        v=true;
    }
    return target.uncheckedmethodName(boundParam,v);
#ELSE
  #IF OfShort,OfChar,OfByte
    if(val==($exposedType$)val)
  #ENDIF
    {
      return target.uncheckedmethodName(boundParam,$queryCastPrimitive$(val));
    }
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryLong(retType,node,methodName,negRet,target,boundParam,checkModCount,override)
override
public retType methodName(final long val)
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
#IF OfRef,OfLong
    return target.uncheckedmethodName(boundParam,$queryCastPrimitive$(val));
#ELSEIF OfDouble,OfFloat
    if(val!=0)
    {
      if(TypeUtil.checkCastTo$BoxedType$(val))
      {
        return target.uncheckedmethodNameBits(boundParam,$convertToBits$(val));
      }
    }
    else
    {
      return target.uncheckedmethodName0(boundParam);
    }
#ELSE
    final $exposedType$ v;
  #IF OfBoolean
    if(val==0)
    {
      v=false;
    }
    else if(val==1)
    {
      v=true;
    }
    else
    {
      checkModCount
      return negRet;
    }
  #ELSE
    if(val==(v=($exposedType$)val))
  #ENDIF
    {
      return target.uncheckedmethodName(boundParam,v);
    }
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryFloat(retType,node,methodName,negRet,target,boundParam,checkModCount,override)
override
public retType methodName(final float val)
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
#IF OfRef,OfFloat
    return target.uncheckedmethodName(boundParam,$queryCastPrimitive$(val));
#ELSEIF OfDouble
    if(val==val)
    {
      return target.uncheckedmethodNameBits(boundParam,$convertToBits$(val));
    }
    return target.uncheckedmethodNameNaN(boundParam);
#ELSE
    final $exposedType$ v;
  #IF OfLong
    if(TypeUtil.floatEquals(val,v=(long)val))
  #ELSEIF OfInt
    if((double)val==(double)(v=(int)val))
  #ELSEIF OfBoolean
    switch(Float.floatToRawIntBits(val))
    {
      default:
        checkModCount
        return negRet;
      case 0:
      case Integer.MIN_VALUE:
        v=false;
        break;
      case TypeUtil.FLT_TRUE_BITS:
        v=true;
    }
  #ELSE
    if(val==(v=($exposedType$)val))
  #ENDIF
    {
      return target.uncheckedmethodName(boundParam,v);
    }
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF QueryDouble(retType,node,methodName,negRet,target,boundParam,checkModCount,override)
override
public retType methodName(final double val)
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
#IF OfRef,OfDouble
    return target.uncheckedmethodName(boundParam,$queryCastPrimitive$(val));
#ELSE
    final $exposedType$ v;
  #IF OfFloat
    if(val==(v=($exposedType$)val))
    {
      return target.uncheckedmethodNameBits(boundParam,$convertToBits$(v));
    }
    else if(v!=v)
    {
      return target.uncheckedmethodNameNaN(boundParam);
    }
  #ELSE
    #IF OfBoolean
    final long bits;
    if((bits=Double.doubleToRawLongBits(val))==0||bits==Long.MIN_VALUE)
    {
      v=false;
    }
    else if(bits==TypeUtil.DBL_TRUE_BITS)
    {
      v=true;
    }
    else
    {
      checkModCount
      return negRet;
    }
    #ELSE
    if(val==(v=($exposedType$)val))
    #ENDIF
    {
      return target.uncheckedmethodName(boundParam,v);
    }
  #ENDIF
#ENDIF
  }
  checkModCount
  return negRet;
}
#ENDDEF
#MACRODEF CheckedSubListQuery(retType,methodName,paramType)
@Override
public retType methodName(final paramType val)
{
  CheckedCollection.checkModCount(modCount,root.modCount);
  return super.methodName(val);
}
#ENDDEF
#MACRODEF CheckedSubListQueryMethods(IFSTATEMENT,retType,methodName)
#MACRO CheckedSubListQuery(retType,methodName,boolean)
#MACRO CheckedSubListQuery(retType,methodName,int)
#MACRO CheckedSubListQuery(retType,methodName,long)
#MACRO CheckedSubListQuery(retType,methodName,float)
#MACRO CheckedSubListQuery(retType,methodName,double)
#IF OfRef,OfByte
#MACRO CheckedSubListQuery(retType,methodName,byte)
#ENDIF
IFSTATEMENT
#MACRO CheckedSubListQuery(retType,methodName,char)
  #IFNOT OfByte
#MACRO CheckedSubListQuery(retType,methodName,short)
  #ENDIF
#ENDIF
#IF OfRef
#MACRO CheckedSubListQuery(retType,methodName,Boolean)
#MACRO CheckedSubListQuery(retType,methodName,Byte)
#MACRO CheckedSubListQuery(retType,methodName,Character)
#MACRO CheckedSubListQuery(retType,methodName,Short)
#MACRO CheckedSubListQuery(retType,methodName,Integer)
#MACRO CheckedSubListQuery(retType,methodName,Long)
#MACRO CheckedSubListQuery(retType,methodName,Float)
#MACRO CheckedSubListQuery(retType,methodName,Double)
#ENDIF
#ENDDEF
#MACRODEF QueryMethods(IFSTATEMENT,retType,node,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryBoolean(retType,node,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryInt(retType,node,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryLong(retType,node,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryFloat(retType,node,methodName,negRet,target,methodParams,checkModCount,override)
#MACRO QueryDouble(retType,node,methodName,negRet,target,methodParams,checkModCount,override)
#IF OfRef,OfByte
#MACRO BasicQuery(public,node,retType,methodName,byte,negRet,target,methodParams\,$queryCastPrimitive$(val),checkModCount,override)
#ENDIF
IFSTATEMENT
#MACRO QueryChar(retType,node,methodName,negRet,target,methodParams,checkModCount,override)
  #IFNOT OfByte
#MACRO QueryShort(retType,node,methodName,negRet,target,methodParams,checkModCount,override)
  #ENDIF
#ENDIF
#IF OfRef
#MACRO BasicQuery(public,node,retType,methodName,Boolean,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,node,retType,methodName,Byte,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,node,retType,methodName,Character,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,node,retType,methodName,Short,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,node,retType,methodName,Integer,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,node,retType,methodName,Long,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,node,retType,methodName,Float,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#MACRO BasicQuery(public,node,retType,methodName,Double,negRet,target,methodParams\,OmniPred.OfRef.getEqualsPred(val),checkModCount,override)
#ENDIF
#ENDDEF
#MACRODEF CheckedSubListQueryObject(retType,methodName)
@Override
public retType methodName(final Object val)
{
  #MACRO TryCheckModCount(root,return super.methodName(val);)
}
#ENDDEF
#MACRODEF Peek(retType,methodName,node,cast,defaultVal)
public retType methodName()
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
    return cast(node.val);
  }
  return defaultVal;
}
#ENDDEF
#MACRODEF PeekMethods(Suffix,node)
#MACRO Peek($exposedType$,peekSuffix$TypeNameModifier$,node,($exposedType$),$defaultVal$)
#IFNOT OfRef
#MACRO Peek($BoxedType$,peekSuffix,node,,null)
  #IFNOT OfDouble
#MACRO Peek(double,peekSuffixDouble,node,$castToDouble$,Double.NaN)
    #IFNOT OfFloat
#MACRO Peek(float,peekSuffixFloat,node,$castToFloat$,Float.NaN)
      #IFNOT OfLong
#MACRO Peek(long,peekSuffixLong,node,$castToLong$,Long.MIN_VALUE)
        #IFNOT OfInt
#MACRO Peek(int,peekSuffixInt,node,$castToInt$,Integer.MIN_VALUE)
          #IFNOT OfChar,OfShort
#MACRO Peek(short,peekSuffixShort,node,$castToShort$,Short.MIN_VALUE)
            #IFNOT OfByte
#MACRO Peek(byte,peekSuffixByte,node,$castToByte$,Byte.MIN_VALUE)
#MACRO Peek(char,peekSuffixChar,node,$castToChar$,Character.MIN_VALUE)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF CheckedQueryObject(retType,methodName,node,checkedMethodParam,methodParam,negRet)
@Override
public retType methodName(final Object val)
{
  final Node$<E>$ node;
  if((node=this.node)!=null)
  {
    if(val!=null)
    {
      #MACRO TryCheckModCount(this,return $ClassPrefix$DblLnkSeq.uncheckedmethodName(nodecheckedMethodParam\,val::equals);)
    }
    return $ClassPrefix$DblLnkSeq.uncheckedmethodName(nodemethodParam,Objects::isNull);
  }
  return negRet;
}
#ENDDEF
#MACRODEF UncheckedCopyForwardToArray(arrType,cast)
private void uncheckedCopyForward(arrType[] dst,int dstOffset,int length)
{
  for(var src=this;;++dstOffset,src=src.next)
  {
    dst[dstOffset]=cast(src.val);
    if(--length==0)
    {
      return;
    }
  }
}
#ENDDEF
#MACRODEF SubListClear(CheckModCount,bubbleUpcall)
@Override
public void clear()
{
  CheckModCount
  final int size;
  if((size=this.size)!=0)
  {
    ((SubList$<E>$)this).bubbleUpcall;
  }
}
#ENDDEF
#MACRODEF PrefixSuffixPushHelper(node,constructorCallParams,incrementModCount,GetRootMacro)
#MACRO BubbleUpDoIfWhile(pushnode,Node$<E>$ oldnode\,Node$<E>$ newNode,incrementSize(),curr.node==oldnode,incrementModCount++curr.size;curr.node=newNode)
@Override
void pushnodeHelper(Node$<E>$ oldnode,$exposedType$ val)
{
  GetRootMacro
  ++root.size;
  bubbleUppushnode(oldnode,new Node$<E>$(constructorCallParams));
}
#ENDDEF
#MACRODEF CheckRootModCountAndIncrement2()
final Checked$<E>$ root;
CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
root.modCount=modCount+1;
#ENDDEF
#MACRODEF CheckRootModCountAndIncrement1()
final Checked$<E>$ root;
final int modCount;
CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
root.modCount=modCount+1;
#ENDDEF
#MACRODEF UncheckedPrefixSuffixInitHelper(node,constructorParams)
#MACRO BubbleUpDoIfWhile(init,Node$<E>$ newNode,pushnode(newNode),curr.size!=0,curr.size=1;curr.head=newNode;curr.tail=newNode)
@Override
void initHelper($exposedType$ val)
{
  final Unchecked$<E>$ root;
  ++(root=this.root).size;
  Node$<E>$ newNode;
  root.node=newNode=new Node$<E>$(constructorParams);
  bubbleUpinit(newNode);
}
#ENDDEF
#MACRODEF CheckedPrefixSuffixInitHelper(node,constructorParams)
#MACRO BubbleUpDoIfWhile(init,Node$<E>$ newNode,pushnode(newNode),curr.size!=0,++curr.modCount;curr.size=1;curr.head=newNode;curr.tail=newNode)
@Override
void initHelper($exposedType$ val)
{
  #MACRO CheckRootModCountAndIncrement1()
  ++root.size;
  Node$<E>$ newNode;
  root.node=newNode=new Node$<E>$(constructorParams);
  bubbleUpinit(newNode);
}
#ENDDEF
#MACRODEF BasicUncheckedSubListPushHelper(node,constructorCallParams)
@Override
void pushnodeHelper(Node$<E>$ oldnode,$exposedType$ val)
{
  final Unchecked$<E>$ root;
  ++(root=this.root).size;
  Node$<E>$ newNode;
  root.node=newNode=new Node$<E>$(constructorCallParams);
  bubbleUppushnode(newNode);
}
#MACRO BubbleUpDoWhile(pushnode,Node$<E>$ newnode,++curr.size;curr.node=newnode)
#ENDDEF
#MACRODEF BasicCheckedSubListPushHelper(node,constructorCallParams)
@Override
void pushnodeHelper(Node$<E>$ oldnode,$exposedType$ val)
{
  #MACRO CheckRootModCountAndIncrement1()
  ++root.size;
  Node$<E>$ newNode;
  root.node=newNode=new Node$<E>$(constructorCallParams);
  bubbleUppushnode(newNode);
}
#MACRO BubbleUpDoWhile(pushnode,Node$<E>$ newnode,++curr.modCount;++curr.size;curr.node=newnode)
#ENDDEF
#MACRODEF PushEndHelper(node,incrementModCount,constructorCallParams)
@Override
void pushnodeHelper(Node$<E>$ oldnode,$exposedType$ val)
{
  incrementModCount
  ++this.size;
  this.node=new Node$<E>$(constructorCallParams);
}
#ENDDEF
#MACRODEF CheckedSubListForEach(Consumer,actionParam)
@Override
public void forEach(Consumer action)
{
  #MACRO TryCheckModCount(root,super.forEach(actionParam);)
}
#ENDDEF
#MACRODEF CheckedSubListSortComparator(Comparator,sorterParam)
@Override
public void sort(Comparator sorter)
{

  Checked$<E>$ root=this.root;
  #IF OfBoolean
  #MACRO TryCheckModCount(root,final Node$<E>$ head\,tail;if((head=this.head)==(tail=this.tail)){return;}head.uncheckedcomparatorSort(tail\,sorterParam);)
  #ELSE
  #MACRO TryCheckModCount(root,final int size;if((size=this.size)<2){return;}head.uncheckedcomparatorSort(size\,tail\,sorterParam);)
  #ENDIF
  root.modCount=modCount+1;
  ((SubList$<E>$)this).bubbleUpincrementModCount();
}
#ENDDEF
#MACRODEF CheckedSubListReplaceAll(UnaryOperator,operatorParam)
@Override
public void replaceAll(UnaryOperator operator)
{
  final Checked$<E>$ root=this.root;
  #MACRO TryCheckModCount(root,Node$<E>$ head;if((head=this.head)==null){return;}head.uncheckedReplaceAll(tail\,operatorParam);)
  root.modCount=modCount+1;
  ((SubList$<E>$)this).bubbleUpincrementModCount();
}
#ENDDEF
#MACRODEF CheckedSubListSortNoComparator(methodName)
@Override
public void methodName()
{
#IF OfRef
  final Checked$<E>$ root=this.root;
  #MACRO TryCheckModCount(root,int size;if((size=this.size)<2){return;}head.uncheckedmethodName(size\,tail);)
#ELSE
  int modCount;
  Checked$<E>$ root;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
  #IF OfBoolean
  final Node$<E>$ head,tail;
  if((head=this.head)==(tail=this.tail))
  {
    return;
  }
  head.uncheckedmethodName(tail);
  #ELSE
  int size;
  if((size=this.size)<2)
  {
    return;
  }
  head.uncheckedmethodName(size,tail);
  #ENDIF
#ENDIF
  root.modCount=modCount+1;
  this.bubbleUpincrementModCount();
}
#ENDDEF
#MACRODEF RootRemoveFirstHelper(methodName,node,methodParam,test,end,next,incrementModCount)
private boolean uncheckedmethodName(Node$<E>$ nodemethodParam)
{
  if(test(node.val))
  {
    Node$<E>$ lastVisited;
    do
    {
      if((node=(lastVisited=node).next)==null)
      {
        return false;
      }
    }
    while(test(node.val));
    --this.size;
    if(node==end)
    {
      (($ClassPrefix$DblLnkSeq$<E>$)this).privatesetend(lastVisited);
    }
    else
    {
      lastVisited.joinnext(node.next);
    }
  }
  else
  {
    if(--this.size==0)
    {
      (($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(null);
    }
    else
    {
      (($ClassPrefix$DblLnkSeq$<E>$)this).privatechopnode(node);
    }
  }
  incrementModCount
  return true;
}
#ENDDEF
#MACRODEF RootRemoveFirstHelpers(methodName,node,end,next,incrementModCount)
#IF OfDouble,OfFloat
#MACRO RootRemoveFirstHelper(methodNameBits,node,\,$queryParameterType$ bits,bits!=$convertToBits$,end,next,incrementModCount)
#MACRO RootRemoveFirstHelper(methodName0,node,,0!=,end,next,incrementModCount)
#MACRO RootRemoveFirstHelper(methodNameNaN,node,,!$BoxedType$.isNaN,end,next,incrementModCount)
#ELSEIF OfBoolean
#MACRO RootRemoveFirstHelper(methodName,node,\,$queryParameterType$ val,val^,end,next,incrementModCount)
#ELSEIFNOT OfRef
#MACRO RootRemoveFirstHelper(methodName,node,\,$queryParameterType$ val,val!=,end,next,incrementModCount)
#ENDIF
#ENDDEF
#MACRODEF RootDoubleAndFloatQueries()
#IF OfDouble,OfFloat
private boolean uncheckedremoveVal(Node$<E>$ head,$exposedType$ val)
{
  if(val==val)
  {
    return uncheckedremoveValBits(head,$convertToBits$(val));
  }
  return uncheckedremoveValNaN(head);
}
private boolean uncheckedremoveLastOccurrence(Node$<E>$ tail,$exposedType$ val)
{
  if(val==val)
  {
    return uncheckedremoveLastOccurrenceBits(tail,$convertToBits$(val));
  }
  return uncheckedremoveLastOccurrenceNaN(tail);
}
  #IF OfFloat
@Override
protected boolean removeValRawInt(int val)
{
  Node$<E>$ head;
  if((head=this.head)!=null)
  {
    if(val!=0)
    {
      return uncheckedremoveValBits(head,$convertToBits$(val));
    }
    return uncheckedremoveVal0(head);
  }
  return false;
}
private boolean uncheckedremoveLastOccurrenceRawInt(Node$<E>$ tail,int val)
{
  if(val!=0)
  {
    return uncheckedremoveLastOccurrenceBits(tail,$convertToBits$(val));
  }
  return uncheckedremoveLastOccurrence0(tail);
}
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF HashCode()
final Node$<E>$ head;
if((head=this.head)!=null)
{
  return head.uncheckedForwardHashCode(this.tail);
}
return 1;
#ENDDEF
#MACRODEF ToString()
final Node$<E>$ head;
if((head=this.head)!=null)
{
  final StringBuilder builder;
  head.uncheckedForwardToString(tail,builder=new StringBuilder("["));
  return builder.append(']').toString();
}
return "[]";
#ENDDEF
#MACRODEF TryCheckModCount(modCountSource,InternalCode)
int modCount=this.modCount;
try
{
  InternalCode
}
finally
{
  CheckedCollection.checkModCount(modCount,modCountSource.modCount);
}
#ENDDEF
#MACRODEF RootRemoveIf(Predicate,filterParam,target)
@Override
public boolean removeIf(Predicate filter)
{
  final Node$<E>$ head;
  return (head=this.head)!=null && target.uncheckedRemoveIf(head,filterParam);
}
#ENDDEF
#MACRODEF BubbleUpDoIfWhile(methodName,params,postCall,test,lines)
private void bubbleUpmethodName(params)
{
  SubList$<E>$ curr=this;
  do
  {
    lines;
    if((curr=curr.parent)==null)
    {
      return;
    }
  }
  while(test);
  curr.bubbleUppostCall;
}
#ENDDEF
#MACRODEF BubbleUpDoWhile(methodName,params,lines)
private void bubbleUpmethodName(params)
{
  SubList$<E>$ curr=this;
  do
  {
    lines;
  }
  while((curr=curr.parent)!=null);
}
#ENDDEF
#MACRODEF BubbleUpWhileIf(methodName,params,postCall,test,lines)
private void bubbleUpmethodName(params)
{
  SubList$<E>$ curr=this;
  while(test)
  {
    lines;
    if((curr=curr.parent)==null)
    {
      return;
    }
  }
  curr.bubbleUppostCall;
}
#ENDDEF
#MACRODEF CheckedRootCollapseEnd(beginNode,endNode,next)
private void collapsebeginNode(int modCount,Node$<E>$ beginNode,Node$<E>$ endNode,$TypeNameModifier$Predicate$<? super E>$ filter)
{
  int oldSize,numConsumed;
  for(beginNode=beginNode.next,oldSize=this.size,numConsumed=2;;)
  {
    if(numConsumed==oldSize)
    {
      CheckedCollection.checkModCount(modCount,this.modCount);
      size=1;
      break;
    }
    ++numConsumed;
    if(!filter.test(beginNode.val))
    {
      size=(oldSize-=numConsumed)+1-head.collapseBodyHelper(new ModCountChecker(modCount),oldSize,tail,filter);
      break;
    }
    (($ClassPrefix$DblLnkSeq$<E>$)this).privatesetbeginNode(beginNode);
  }
}
#ENDDEF
#MACRODEF SubListCollapseEnd(prefix,beginNode,newHead,newTail,prev,next,modCountSigParam,IncrementModCountMacro,CheckModCount,ModCountCheckerParam,IncrementRootModCount)
#IF OfBoolean
private void prefixCollapsebeginNode(modCountSigParamNode$<E>$ oldHead,Node$<E>$ oldTail,$ArrayType$ removeThis)
{
  IncrementModCountMacro
  final int oldSize=this.size;
  int numConsumed=2;
  var beginNodeCandidate=beginNode.next;
  for(;;beginNodeCandidate=beginNodeCandidate.next)
  {
    if(numConsumed==oldSize)
    {
      --numConsumed;
      break;
    }
    ++numConsumed;
    if(beginNodeCandidate.val^removeThis)
    {
      numConsumed-=2-newHead.collapseBodyHelper(newTail,!removeThis);
      break;
    }
  }
#ELSE
private void prefixCollapsebeginNode(modCountSigParamNode$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
{
  final int oldSize=this.size;
  int numConsumed=2;
  final var root=this.root;
  var beginNodeCandidate=beginNode.next;
  for(;;beginNodeCandidate=beginNodeCandidate.next)
  {
    if(numConsumed==oldSize)
    {
      CheckModCount
      --numConsumed;
      break;
    }
    ++numConsumed;
    if(!filter.test(beginNodeCandidate.val))
    {
      numConsumed-=2-newHead.collapseBodyHelper(ModCountCheckerParamnewTail,filter);
      break;
    }
  }
  IncrementRootModCount
#ENDIF
  bubbleUpprefixCollapsebeginNode(numConsumed,beginNode,beginNodeCandidate);
  root.size-=numConsumed;
  beginNode.prev.joinnext(beginNodeCandidate);
}
#IF OfBoolean
private void rootCollapsebeginNode(modCountSigParamNode$<E>$ head,Node$<E>$ tail,$ArrayType$ removeThis)
{
  IncrementModCountMacro
  final int oldSize=this.size;
  int numConsumed=2;
  for(;;)
  {
    beginNode=beginNode.next;
    if(numConsumed==oldSize)
    {
      --numConsumed;
      break;
    }
    ++numConsumed;
    if(beginNode.val^removeThis)
    {
      numConsumed-=2-head.collapseBodyHelper(tail,!removeThis);
      break;
    }
  }
#ELSE
private void rootCollapsebeginNode(modCountSigParamNode$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
{
  final int oldSize=this.size;
  int numConsumed=2;
  final var root=this.root;
  for(;;)
  {
    beginNode=beginNode.next;
    if(numConsumed==oldSize)
    {
      CheckModCount
      --numConsumed;
      break;
    }
    ++numConsumed;
    if(!filter.test(beginNode.val))
    {
      numConsumed-=2-head.collapseBodyHelper(ModCountCheckerParamtail,filter);
      break;
    }
  }
  IncrementRootModCount
#ENDIF
  bubbleUprootCollapsebeginNode(numConsumed,beginNode);
  (($ClassPrefix$DblLnkSeq$<E>$)root).privatesetbeginNode(beginNode);
  root.size-=numConsumed;
}
#ENDDEF
#MACRODEF SubListRemoveValHelperMethods(override,modCountSigParam,CheckModCount,IncrementModCount,erasetaillines)
override
#IF OfRef
#MACRO SubListRemoveValHelper(,\,Predicate<Object> pred,!pred.test,modCountSigParam,CheckModCount,IncrementModCount,erasetaillines)
#ELSEIF OfDouble,OfFloat
#MACRO SubListRemoveValHelper(Bits,\,$queryParameterType$ bits,bits!=$convertToBits$,modCountSigParam,CheckModCount,IncrementModCount,erasetaillines)
override
#MACRO SubListRemoveValHelper(0,,0!=,modCountSigParam,CheckModCount,IncrementModCount,erasetaillines)
override
#MACRO SubListRemoveValHelper(NaN,,!$BoxedType$.isNaN,modCountSigParam,CheckModCount,IncrementModCount,erasetaillines)
#ELSEIF OfBoolean
#MACRO SubListRemoveValHelper(,\,$queryParameterType$ val,val^,modCountSigParam,CheckModCount,IncrementModCount,erasetaillines)
#ELSE
#MACRO SubListRemoveValHelper(,\,$queryParameterType$ val,val!=,modCountSigParam,CheckModCount,IncrementModCount,erasetaillines)
#ENDIF
#ENDDEF
#MACRODEF CheckedSubListRemoveVal(Suffix,sigParam,methodParam,nodeTest)
private boolean uncheckedremoveValSuffix(Node$<E>$ headsigParam)
{
  final int modCount=this.modCount;
  try
  {
    if(nodeTest(head.val))
    {
      return uncheckedremoveValSuffixHelper(modCount,headmethodParam);
    }
    removeFirstHelper(modCount,head);
    return true;
  }
  catch(final RuntimeException e)
  {
    throw CheckedCollection.checkModCount(modCount,root.modCount,e);
  }
}
#ENDDEF
#MACRODEF UncheckedSubListRemoveVal(Suffix,sigParam,methodParam,nodeTest)
private boolean uncheckedremoveValSuffix(Node$<E>$ headsigParam)
{
  if(nodeTest(head.val))
  {
    return uncheckedremoveValSuffixHelper(headmethodParam);
  }
  removeFirstHelper(head);
  return true;
}
#ENDDEF
#MACRODEF SubListRemoveValHelper(Suffix,sigParam,nodeTest,modCountSigParam,CheckModCount,IncrementModCount,erasetaillines)
boolean uncheckedremoveValSuffixHelper(modCountSigParamNode$<E>$ currsigParam)
{
  final var root=this.root;
  final var tail=this.tail;
  Node$<E>$ prev;
  do
  {
    if(curr==tail)
    {
      CheckModCount
      return false;
    }
  }
  while(nodeTest((curr=(prev=curr).next).val));
  CheckModCount
  IncrementModCount
  --root.size;
  if(curr==tail)
  {
    erasetaillines;
  }
  else
  {
    ((SubList$<E>$)this).bubbleUpdecrementSize();
    prev.joinnext(curr.next);
  }
  return true;
}
#ENDDEF
#MACRODEF SubListRemoveValMethods(MacroName)
#IF OfRef
#MACRO MacroName(,\,Predicate<Object> pred,\,pred,!pred.test)
#ELSEIF OfDouble,OfFloat
#MACRO MacroName(Bits,\,$queryParameterType$ bits,\,bits,bits!=$convertToBits$)
#MACRO MacroName(0,,,0!=)
#MACRO MacroName(NaN,,,!$BoxedType$.isNaN)
#ELSEIF OfBoolean
#MACRO MacroName(,\,$queryParameterType$ val,\,val,val^)
#ELSE
#MACRO MacroName(,\,$queryParameterType$ val,\,val,val!=)
#ENDIF
#ENDDEF
#MACRODEF RootCollapseEnd(visibility,beginNode,endNode,next)
#IF OfBoolean
visibility void collapsebeginNode(Node$<E>$ head,Node$<E>$ tail,$ArrayType$ retainThis)
{
  int numRemoved;
  for(numRemoved=1;(beginNode=beginNode.next)!=endNode;++numRemoved)
  {
    if(beginNode.val==retainThis)
    {
      numRemoved+=head.collapseBodyHelper(tail,retainThis);
#ELSE
visibility void collapsebeginNode(Node$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
{
  int numRemoved;
  for(numRemoved=1;(beginNode=beginNode.next)!=endNode;++numRemoved)
  {
    if(!filter.test(beginNode.val))
    {
      numRemoved+=head.collapseBodyHelper(tail,filter);
#ENDIF
      break;
    }
  }
  (($ClassPrefix$DblLnkSeq$<E>$)this).privatesetbeginNode(beginNode);
  this.size-=numRemoved;
}
#ENDDEF
#MACRODEF SubListIndexModify(HeadMacro,TailMacro,EmptyMacro,BodyMacro)
{
  if(index==0)
  {
    #MACRO HeadMacro()
  }
  else
  {
    if((size-=index)==0)
    {
      #MACRO TailMacro()
    }
    else
    {
      #MACRO BodyMacro()
    }
  }
}
else
{
  #MACRO EmptyMacro()
}
#ENDDEF
#MACRODEF RootPushHead()
Node$<E>$ newNode;
root.head=newNode=new Node$<E>$(val,this.head);
((SubList$<E>$)this).bubbleUppushhead(newNode);
#ENDDEF
#MACRODEF RootPushTail()
Node$<E>$ newNode;
root.tail=newNode=new Node$<E>$(this.tail,val);
((SubList$<E>$)this).bubbleUppushtail(newNode);
#ENDDEF
#MACRODEF RootPushInit()
Node$<E>$ newNode;
(($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(newNode=new Node$<E>$(val));
bubbleUpinit(newNode);
#ENDDEF
#MACRODEF PrefixPushTail()
Node$<E>$ oldtail;
((PrefixList$<E>$)this).bubbleUppushtail(oldtail=this.tail,new Node$<E>$(oldtail,val,oldtail.next));
#ENDDEF
#MACRODEF PrefixPushInit()
Node$<E>$ newNode;
root.head=newNode=new Node$<E>$(val,root.head);
bubbleUpinit(newNode);
#ENDDEF
#MACRODEF SuffixPushHead()
Node$<E>$ oldhead;
bubbleUppushhead(oldhead=this.head,new Node$<E>$(oldhead.prev,val,oldhead));
#ENDDEF
#MACRODEF SuffixPushInit()
Node$<E>$ newNode;
root.tail=newNode=new Node$<E>$(root.tail,val);
bubbleUpinit(newNode);
#ENDDEF
#MACRODEF BodyPushInit()
bubbleUpinit(new Node$<E>$(val));
#ENDDEF
#MACRODEF InsertNode(root,before,after,headDist,tailDist)
if(headDist<=tailDist)
{
  after=(before=root.head.iterateForward(headDist-1)).next;
}
else
{
  before=(after=root.tail.iterateReverse(tailDist-1)).prev;
}
#ENDDEF
#MACRODEF SubListInsertBody()
Node$<E>$ before,after;
#MACRO InsertNode(this,before,after,index,size);
new Node$<E>$(before,val,after);
((SubList$<E>$)this).bubbleUpincrementSize();
#ENDDEF
#MACRODEF SubListRemoveBody()
if(index<=size)
{
  Node$<E>$ before;
  (before=this.head.iterateForward(index-1)).joinnext((node=before.next).next);
}
else
{
  Node$<E>$ after;
  (node=(after=this.tail.iterateReverse(size-1)).prev).prev.joinnext(after);
}
((SubList$<E>$)this).bubbleUpdecrementSize();
#ENDDEF
#MACRODEF RootRemoveHead()
Node$<E>$ newHead;
(($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(newHead=(node=this.head).next);
((SubList$<E>$)this).bubbleUprootchophead(newHead);
#ENDDEF
#MACRODEF RootRemoveTail()
Node$<E>$ newTail;
(($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(newTail=(node=this.tail).prev);
((SubList$<E>$)this).bubbleUprootchoptail(newTail);
#ENDDEF
#MACRODEF RootRemoveClear()
node=this.head;
(($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
bubbleUpclearRoot();
#ENDDEF
#MACRODEF PrefixRemoveTail()
((SubList$<E>$)this).bubbleUpprefixchoptail(node=this.tail,node.prev);
#ENDDEF
#MACRODEF PrefixRemoveClear()
node=this.head;
(($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
((SubList$<E>$)this).bubbleUpclearPrefix(node=this.head,node.next,1);
#ENDDEF
#MACRODEF SuffixRemoveHead()
((SubList$<E>$)this).bubbleUpsuffixchophead(node=this.head,node.next);
#ENDDEF
#MACRODEF SuffixRemoveClear()
(($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
((SubList$<E>$)this).bubbleUpclearSuffix(node=this.head,node.prev,1);
#ENDDEF
#MACRODEF BodyRemoveClear()
((SubList$<E>$)this).bubbleUpclearBody(node=this.head,node,1);
#ENDDEF
#MACRODEF BubbleUpClearBody(incrementModCount)
private void bubbleUpclearBody(Node$<E>$ oldhead,Node$<E>$ oldtail,int numRemoved)
{
  Node$<E>$ prev,next;
  (prev=oldhead.prev).joinnext(next=tail.next);
  var curr=this;
  for(;;)
  {
    incrementModCount
    curr.size=0;
    (($ClassPrefix$DblLnkSeq$<E>$)curr).privateInit(null);
    if((curr=curr.parent)==null)
    {
      return;
    }
    if(curr.head!=oldhead)
    {
      while(curr.tail==oldtail)
      {
        incrementModCount
        curr.size-=numRemoved;
        curr.tail=prev;
        if((curr=curr.parent)==null)
        {
          return;
        }
      }
      break;
    }
    if(curr.tail!=oldtail)
    {
      do
      {
        incrementModCount
        curr.size-=numRemoved;
        curr.head=next;
        if((curr=curr.parent)==null)
        {
          return;
        }
      }
      while(curr.head==oldhead);
      break;
    }
  }
  curr.bubbleUpdecrementSize(numRemoved);
}
#ENDDEF
#MACRODEF BubbleUpMethods(incrementModCount)
#MACRO BubbleUpDoIfWhile(suffixchophead,Node$<E>$ oldHead\,Node$<E>$ newHead,decrementSize();oldHead.prev.joinnext(newHead),curr.head==oldHead,incrementModCount--curr.size;curr.head=newHead)
#MACRO BubbleUpDoIfWhile(prefixchoptail,Node$<E>$ oldTail\,Node$<E>$ newTail,decrementSize();newTail.joinnext(oldTail.next),curr.tail==oldTail,incrementModCount--curr.size;curr.tail=newTail)
#MACRO BubbleUpDoWhile(clearRoot,,incrementModCountcurr.size=0;(($ClassPrefix$DblLnkSeq$<E>$)curr).privateInit(null))
#MACRO BubbleUpDoWhile(incrementSize,,incrementModCount++curr.size)
#MACRO BubbleUpDoWhile(decrementSize,,incrementModCount--curr.size)
#MACRO BubbleUpDoWhile(decrementSize,int numRemoved,incrementModCountcurr.size-=numRemoved)
#MACRO BubbleUpDoWhile(rootchophead,Node$<E>$ newHead,incrementModCount--curr.size;curr.head=newHead)
#MACRO BubbleUpDoWhile(rootchoptail,Node$<E>$ newTail,incrementModCount--curr.size;curr.tail=newTail)
#MACRO BubbleUpDoWhile(rootchophead,int numRemoved\,Node$<E>$ newHead,incrementModCountcurr.size-=numRemoved;curr.head=newHead)
#MACRO BubbleUpDoWhile(rootchoptail,int numRemoved\,Node$<E>$ newTail,incrementModCountcurr.size-=numRemoved;curr.tail=newTail)
#MACRO BubbleUpDoIfWhile(prefixPushtail,Node$<E>$ oldTail\,Node$<E>$ newTail,incrementSize(),curr.tail==oldTail,incrementModCount++curr.size;curr.tail=newTail)
#MACRO BubbleUpDoIfWhile(suffixPushhead,Node$<E>$ oldHead\,Node$<E>$ newHead,incrementSize(),curr.head==oldHead,incrementModCount++curr.size;curr.head=newHead)
#MACRO BubbleUpDoIfWhile(clearPrefix,Node$<E>$ oldTail\,Node$<E>$ newHead\,int numRemoved,rootchophead(numRemoved\,newHead),curr.tail==oldTail,incrementModCountcurr.size=0;(($ClassPrefix$DblLnkSeq$<E>$)curr).privateInit(null))
#MACRO BubbleUpDoIfWhile(clearSuffix,Node$<E>$ oldHead\,Node$<E>$ newTail\,int numRemoved,rootchoptail(numRemoved\,newTail),curr.head==oldHead,incrementModCountcurr.size=0;(($ClassPrefix$DblLnkSeq$<E>$)curr).privateInit(null))
#MACRO BubbleUpClearBody(incrementModCount)
#MACRO BubbleUpWhileIf(prefixCollapsetail,int numRemoved\,Node$<E>$ oldTail\,Node$<E>$ newTail,decrementSize(numRemoved),curr.tail==oldTail,incrementModCountcurr.size-=numRemoved;curr.tail=newTail)
#MACRO BubbleUpWhileIf(suffixCollapsehead,int numRemoved\,Node$<E>$ oldHead\,Node$<E>$ newHead,decrementSize(numRemoved),curr.head==oldHead,incrementModCountcurr.size-=numRemoved;curr.head=newHead)
#MACRO BubbleUpDoWhile(rootCollapsehead,int numRemoved\,Node$<E>$ newHead,incrementModCountcurr.size-=numRemoved;curr.head=newHead)
#MACRO BubbleUpDoWhile(rootCollapsetail,int numRemoved\,Node$<E>$ newTail,incrementModCountcurr.size-=numRemoved;curr.tail=newTail)
#MACRO BubbleUpDoWhile(collapseHeadAndTail,Node$<E>$ newHead\,Node$<E>$ newTail\,int newSize,curr.privateCollapseHeadAndTail(newSize\,newHead\,newTail))
#MACRO BubbleUpDoWhile(init,Node$<E>$ newNode,incrementModCountcurr.size=1;(($ClassPrefix$DblLnkSeq$<E>$)curr).privateInit(newNode))
#ENDDEF
#MACRODEF BubbleUpInitBody(incrementModCount)
private void bubbleUpinit(Node$<E>$ newNode)
{
  SubList$<E>$ curr=this;
  Node$<E>$ before,after;
  for(;;)
  {
    incrementModCount
    curr.size=1;
    (($ClassPrefix$DblLnkSeq$<E>$)curr).privateInit(newNode);
    int currParentOffset=curr.getParentOffset();
    if((curr=curr.parent)==null)
    {
      int tailDist;
      if(currParentOffset<=(tailDist=root.size-currParentOffset))
      {
        after=(before=root.head.iterateForward(currParentOffset-1)).next;
      }
      else
      {
        before=(after=root.tail.iterateReverse(tailDist-1)).prev;
      }
      break;
    }
    int currSize;
    if((currSize=curr.size)!=0)
    {
      if(currParentOffset==0)
      {
        before=(after=curr.head).prev;
        curr.bubbleUpsuffixPushhead(after,newNode);
      }
      else
      {
        if((currSize-=currParentOffset)==0)
        {
          after=(before=curr.tail).next;
          curr.bubbleUpprefixPushtail(before,newNode);
        }
        else
        {
          #MACRO InsertNode(curr,before,after,currParentOffset,currSize)
          curr.bubbleUpincrementSize();
        }
      }
      break;
    }
  }
  before.joinnext(newNode);
  newNode.joinnext(after);
}
#ENDDEF
#MACRODEF BodyBubbleUpCollapseHeadAndTail(IncrementModCount)
private void bubbleUpcollapseHeadAndTail(Node$<E>$ oldHead,Node$<E>$ oldTail,Node$<E>$ newHead,Node$<E>$ newTail,int numRemoved)
{
  final int newSize=this.size-numRemoved;
  for(SubList$<E>$ curr=this;;)
  {
    curr.privateCollapseHeadAndTail(newSize,newHead,newTail);
    if((curr=curr.parent)==null)
    {
      break;
    }
    if(curr.head!=oldHead)
    {
      curr.bubbleUpprefixCollapsetail(numRemoved,oldTail,newTail);
      break;
    }
    if(curr.tail!=oldTail)
    {
      IncrementModCount
      curr.size-=numRemoved;
      curr.head=newHead;
      if((curr=curr.parent)!=null)
      {
        curr.bubbleUpsuffixCollapsehead(numRemoved,oldHead,newHead);
      }
      break;
    }
  }
  oldHead.prev.joinnext(newHead);
  newTail.joinnext(oldTail.next);
}
#ENDDEF
#MACRODEF BodyCollapseHeadAndTail(modCountSigParam,CheckModCount,IncrementModCount,modCountCheckerParam)
#IF OfBoolean
private void collapseHeadAndTail(modCountSigParamfinal Node$<E>$ head,final Node$<E>$ tail,final $TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ removeThis)
#ELSE
private void collapseHeadAndTail(modCountSigParamfinal Node$<E>$ head,final Node$<E>$ tail,final $TypeNameModifier$Predicate$<? super E>$ filter)
#ENDIF
{
  final int oldSize=this.size;
  int numConsumed=2;
  var headCandidate=head;
#IFNOT OfBoolean
  final var root=this.root;
#ENDIF
  for(;;)
  {
    if(numConsumed==oldSize)
    {
      CheckModCount
      ((SubList$<E>$)this).bubbleUpclearBody(head,tail,oldSize);
      break;
    }
    ++numConsumed;
#IF OfBoolean
    if((headCandidate=headCandidate.next).val^removeThis)
    {
      if(filter.test(!removeThis))
      {
        CheckModCount
        ((SubList$<E>$)this).bubbleUpclearBody(head,tail,oldSize);
        break;
      }
      CheckModCount
#ELSE
    if(!filter.test((headCandidate=headCandidate.next).val))
    {
#ENDIF
      var tailCandidate=tail;
      for(;;)
      {
        if(numConsumed==oldSize)
        {
#IFNOT OfBoolean
          CheckModCount
#ENDIF
          --numConsumed;
          break;
        }
        ++numConsumed;
#IF OfBoolean
        if((tailCandidate=tailCandidate.prev).val^removeThis)
        {
          numConsumed-=2-headCandidate.collapseBodyHelper(tailCandidate,!removeThis);
#ELSE
        if(filter.test((tailCandidate=tailCandidate.prev).val))
        {
          numConsumed-=2-headCandidate.collapseBodyHelper(modCountCheckerParamtailCandidate,filter);
#ENDIF
          break;
        }
      }
      bubbleUpcollapseHeadAndTail(head,tail,headCandidate,tailCandidate,numConsumed);
      break;
    }
  }
  IncrementModCount
  root.size-=numConsumed;
}
#ENDDEF
#MACRODEF BodyFindNewHead(modCountSigParam,modCountParam,CheckModCountMacro)
@Override
#IF OfBoolean
void findNewHead(modCountSigParamNode$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ removeThis)
{
  int numRemoved;
  final Node$<E>$ tail;
  if(curr!=(tail=this.tail))
  {
    if(tail.val^removeThis)
    {
      if(!filter.test(!removeThis))
      {
        ((SubList$<E>$)this).suffixCollapsehead(modCountParamcurr,tail,removeThis);
        return;
      }
      numRemoved=this.size;
    }
    else
    {
      collapseHeadAndTail(modCountParamcurr,tail,filter,removeThis);
      return;
    }
  }
  else
  {
    numRemoved=1;
  }
  CheckModCountMacro;
  root.size-=numRemoved;
  ((SubList$<E>$)this).bubbleUpclearBody(curr,tail,numRemoved);
#ELSE
void findNewHead(modCountSigParamNode$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter)
{
  final Node$<E>$ tail;
  if(curr!=(tail=this.tail))
  {
    if(!filter.test(tail.val))
    {
      ((SubList$<E>$)this).suffixCollapsehead(modCountParamcurr,tail,filter);
      return;
    }
    collapseHeadAndTail(modCountParamcurr,tail,filter);
    return;
  }
  CheckModCountMacro
  --root.size;
  ((SubList$<E>$)this).bubbleUpclearBody(curr,tail,1);
#ENDIF
}
#ENDDEF
#MACRODEF PrefixFindNewHead(modCountSigParam,modCountParam,CheckModCountMacro)
@Override
#IF OfBoolean
void findNewHead(modCountSigParamNode$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ removeThis)
{
  int numRemoved;
  final Node$<E>$ tail;
  if(curr!=(tail=this.tail))
  {
    if(tail.val^removeThis)
    {
      if(!filter.test(!removeThis))
      {
        ((SubList$<E>$)this).rootCollapsehead(modCountParamcurr,tail,removeThis);
        return;
      }
      else
      {
        numRemoved=this.size;
      }
    }
    else
    {
      collapseHeadAndTail(modCountParamcurr,tail,filter,removeThis);
      return;
    }
  }
  else
  {
    numRemoved=1;
  }
  CheckModCountMacro
  root.size-=numRemoved;
  ((SubList$<E>$)this).bubbleUpclearPrefix(curr,curr=tail.next,numRemoved);
#ELSE
void findNewHead(modCountSigParamNode$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter)
{
  final Node$<E>$ tail;
  if(curr!=(tail=this.tail))
  {
    if(!filter.test(tail.val))
    {
      ((SubList$<E>$)this).rootCollapsehead(modCountParamcurr,tail,filter);
      return;
    }
    collapseHeadAndTail(modCountParamcurr,tail,filter);
    return;
  }
  CheckModCountMacro
  --root.size;
  ((SubList$<E>$)this).bubbleUpclearPrefix(curr,curr=tail.next,1);
#ENDIF
  (($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(curr);
}
#ENDDEF
#MACRODEF SuffixFindNewHead(modCountSigParam,modCountParam,CheckModCountMacro)
@Override
#IF OfBoolean
void findNewHead(modCountSigParamNode$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ removeThis)
{
  int numRemoved;
  final Node$<E>$ tail;
  if(curr!=(tail=this.tail))
  {
    if(tail.val^removeThis)
    {
      if(!filter.test(!removeThis))
      {
        ((SubList$<E>$)this).suffixCollapsehead(modCountParamcurr,tail,removeThis);
        return;
      }
      numRemoved=size;
    }
    else
    {
      collapseHeadAndTail(modCountParamcurr,tail,filter,removeThis);
      return;
    }
  }
  else
  {
    numRemoved=1;
  }
  CheckModCountMacro
  root.size-=numRemoved;
  ((SubList$<E>$)this).bubbleUpclearSuffix(curr,curr=curr.prev,numRemoved);
#ELSE
void findNewHead(modCountSigParamNode$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter)
{
  final Node$<E>$ tail;
  if(curr!=(tail=this.tail))
  {
    if(!filter.test(tail.val))
    {
      ((SubList$<E>$)this).suffixCollapsehead(modCountParamcurr,tail,filter);
      return;
    }
    collapseHeadAndTail(modCountParamcurr,tail,filter);
    return;
  }
  CheckModCountMacro
  --root.size;
  ((SubList$<E>$)this).bubbleUpclearSuffix(curr,curr=curr.prev,1);
#ENDIF
  (($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(curr);
}
#ENDDEF
#MACRODEF PrefixSuffixCollapseHeadAndTail(modCountSigParam,BooleanRootDecl,CheckModCount,name,beginNode,endNode,next,prev,newHead,newTail,modCountCheckerParam,IncrementModCount,BooleanSetEnd)
private void bubbleUpcollapseHeadAndTail(Node$<E>$ oldendNode,Node$<E>$ newhead,Node$<E>$ newtail,int numRemoved)
{
  final int newSize=this.size-numRemoved;
  for(SubList$<E>$ curr=this;;)
  {
    curr.privateCollapseHeadAndTail(newSize,newhead,newtail);
    if((curr=curr.parent)==null)
    {
      break;
    }
    if(curr.endNode!=oldendNode)
    {
      curr.bubbleUprootCollapsebeginNode(numRemoved,newbeginNode);
      break;
    }
  }
  newendNode.joinnext(oldendNode.next);
}
#IF OfBoolean
private void collapseHeadAndTail(modCountSigParamNode$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ removeThis)
#ELSE
private void collapseHeadAndTail(modCountSigParamNode$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
#ENDIF
{
  final int oldSize=this.size;
  int numConsumed=2;
#IF OfBoolean
  BooleanRootDecl
#ELSE
  var root=this.root;
#ENDIF
  for(;;)
  {
    if(numConsumed==oldSize)
    {
      CheckModCount
      ((SubList$<E>$)this).bubbleUpclearname(endNode,beginNode=endNode.next,oldSize);
      break;
    }
    ++numConsumed;
#IF OfBoolean
    if((beginNode=beginNode.next).val^removeThis)
    {
      if(filter.test(!removeThis))
      {
        CheckModCount
        ((SubList$<E>$)this).bubbleUpclearname(endNode,beginNode=endNode.next,oldSize);
        break;
      }
      CheckModCount
#ELSE
    if(!filter.test((beginNode=beginNode.next).val))
    {
#ENDIF
      var endNodeCandidate=endNode;
      for(;;)
      {
        if(numConsumed==oldSize)
        {
          CheckModCount
          --numConsumed;
          break;
        }
        ++numConsumed;
#IF OfBoolean
        if((endNodeCandidate=endNodeCandidate.prev).val^removeThis)
        {
          numConsumed-=2-newHead.collapseBodyHelper(newTail,!removeThis);
#ELSE
        if(!filter.test((endNodeCandidate=endNodeCandidate.prev).val))
        {
          numConsumed-=2-newHead.collapseBodyHelper(modCountCheckerParamnewTail,filter);
#ENDIF
          break;
        }
        bubbleUpcollapseHeadAndTail(endNode,newHead,newTail,numConsumed);
        break;
      }
    }
    IncrementModCount
#IF OfBoolean
    BooleanSetEnd
#ELSE
    root.beginNode=beginNode;
#ENDIF
    beginNode.prev=null;
    root.size-=numConsumed;
  }
}
#ENDDEF
#MACRODEF RootFindNewHead(modCountSigParam,modCountParam,IncrementModCount,DeclRoot)
#IF OfBoolean
      void findNewHead(modCountSigParamNode$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ removeThis)
#ELSE
      void findNewHead(modCountSigParamNode$<E>$ curr,$TypeNameModifier$Predicate$<? super E>$ filter)
#ENDIF
      {
        final Node$<E>$ tail;
        if(curr!=(tail=this.tail))
        {
#IF OfBoolean
          if(tail.val^removeThis)
          {
            if(!filter.test(!removeThis))
            {
              rootCollapsehead(modCountParamcurr,tail,removeThis);
              return;
            }
          }
          collapseHeadAndTail(modCountParamcurr,tail,filter,removeThis);
#ELSE   
          if(!filter.test(tail.val))
          {
            rootCollapsehead(modCountParamcurr,tail,filter);
            return;
          }
          collapseHeadAndTail(modCountParamcurr,tail,filter);
#ENDIF
          return;
        }
        IncrementModCount
        DeclRoot.privateInit(null);
        root.size=0;
        bubbleUpclearRoot();
      }
#ENDDEF
#MACRODEF RootCollapseHeadAndTail(modCountSigParam,CheckModCount,modCountCheckerParam,IncrementModCount)
#IF OfBoolean
private void collapseHeadAndTail(modCountSigParamNode$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter,$ArrayType$ removeThis)
#ELSE
private void collapseHeadAndTail(modCountSigParamNode$<E>$ head,Node$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter)
#ENDIF
{
  final int oldSize=this.size;
  int numConsumed=2;
  final var root=this.root;
  for(;;)
  {
    if(numConsumed==oldSize)
    {
      CheckModCount
      bubbleUpclearRoot();
      (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
      break;
    }
    ++numConsumed;
#IF OfBoolean
    if((head=head.next).val^removeThis)
    {
      if(filter.test(!removeThis))
      {
        CheckModCount
        bubbleUpclearRoot();
        (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
        break;
      }
      CheckModCount
#ELSE
    if(!filter.test((head=head.next).val))
    {
#ENDIF
      for(;;)
      {
        if(numConsumed==oldSize)
        {
#IFNOT OfBoolean
          CheckModCount
#ENDIF
          --numConsumed;
          break;
        }
        ++numConsumed;
#IF OfBoolean
        if((tail=tail.prev).val^removeThis)
        {
          numConsumed-=2-head.collapseBodyHelper(tail,!removeThis);
#ELSE
        if(filter.test((tail=tail.prev).val))
        {
          numConsumed-=2-head.collapseBodyHelper(modCountCheckerParamtail,filter);
#ENDIF
          break;
        }
      }
      bubbleUpcollapseHeadAndTail(head,tail,numConsumed);
      (($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(head);
      (($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(tail);
      break;
    }
  }
  IncrementModCount
  root.size-=numConsumed;
}
#ENDDEF
#MACRODEF BodyClearOnlyNode()
Node$<E>$ node;
((SubList$<E>$)this).bubbleUpclearBody(node=this.head,node,1);
#ENDDEF
#MACRODEF SuffixChopHead()
((SubList$<E>$)this).bubbleUpsuffixchophead(curr,curr.next);
#ENDDEF
#MACRODEF SuffixClearOnlyNode()
((SubList$<E>$)this).bubbleUpclearSuffix(curr,curr=curr.prev,1);
(($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(curr);
#ENDDEF
#MACRODEF RootClearOnlyNode()
bubbleUpclearRoot();
(($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
#ENDDEF
#MACRODEF RootChopHead()
bubbleUprootchophead(curr=curr.next);
(($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(curr);
#ENDDEF
#MACRODEF SubListRemoveFirstHelper(override,modCountParam,DeclRoot,ClearOnlyNodeMacro,ChopHeadMacro)
override
void removeFirstHelper(modCountParamNode$<E>$ curr)
{
  DeclRoot
  if(curr==tail)
  {
    #MACRO ClearOnlyNodeMacro()
  }
  else
  {
    #MACRO ChopHeadMacro()
  }
  --root.size;
}
#ENDDEF
#MACRODEF CloneImpl(ClassName)
Node$<E>$ newHead,newTail;
final int size;
if((size=this.size)!=0)
{
  Node$<E>$ oldHead,oldTail;
  for(newHead=new Node$<E>$((oldHead=this.head).val),newTail=newHead,oldTail=this.tail;oldHead!=oldTail;new Node$<E>$(newTail,(oldHead=oldHead.next).val))
  {
  }
}
else
{
  newHead=null;
  newTail=null;
}
return new ClassName$<E>$(newHead,size,newTail);
#ENDDEF
#MACRODEF BodyUncheckedItrRemoveImpl()
if(lastRet==head)
{
  if(lastRet==tail)
  {
    ((SubList$<E>$)this).bubbleUpclearBody(lastRet,lastRet,1);
  }
  else
  {
    ((SubList$<E>$)this).bubbleUpsuffixchophead(lastRet,lastRet.next);
  }
}
else
{
  if(lastRet==tail)
  {
    ((SubList$<E>$)this).bubbleUpprefixchoptail(lastRet,lastRet.prev);
  }
  else
  {
    ((SubList$<E>$)this).bubbleUpdecrementSize();
    lastRet.prev.joinnext(lastRet.next);
  }
}
#ENDDEF
#MACRODEF SuffixUncheckedItrRemoveImpl()
if(lastRet==tail)
{
  if(lastRet==head)
  {
    ((SubList$<E>$)this).bubbleUpclearSuffix(lastRet,lastRet=lastRet.prev,1);
  }
  else
  {
    ((SubList$<E>$)this).bubbleUprootchoptail(lastRet=lastRet.prev);
  }
  (($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(lastRet);
}
else
{
  if(lastRet==head)
  {
    ((SubList$<E>$)this).bubbleUpsuffixchophead(lastRet,lastRet.next);
  }
  else
  {
    ((SubList$<E>$)this).bubbleUpdecrementSize();
    lastRet.prev.joinnext(lastRet.next);
  }
}
#ENDDEF
#MACRODEF PrefixUncheckedItrRemoveImpl()
if(lastRet==head)
{
  if(lastRet==tail)
  {
    ((SubList$<E>$)this).bubbleUpclearPrefix(lastRet,lastRet=lastRet.next,1);
  }
  else
  {
    ((SubList$<E>$)this).bubbleUprootchophead(lastRet=lastRet.next);
  }
  (($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(lastRet);
}
else
{
  if(lastRet==tail)
  {
    ((SubList$<E>$)this).bubbleUpprefixchoptail(lastRet,lastRet.prev);
  }
  else
  {
    ((SubList$<E>$)this).bubbleUpdecrementSize();
    lastRet.prev.joinnext(lastRet.next);
  }
}
#ENDDEF
#MACRODEF CheckedItrRemoveMethods(override,uncheckedMethodParams)
override
void ascItrRemove(AscendingItr$<E>$ itr)
{
  Node$<E>$ lastRet;
  if((lastRet=itr.lastRet)!=null)
  {
    int modCount;
    final Checked$<E>$ root;
    CheckedCollection.checkModCount(modCount=itr.modCount,(root=this.root).modCount);
    root.modCount=++modCount;
    uncheckedItrRemove(uncheckedMethodParams);
    itr.modCount=modCount;
    --root.size;
    return;
  }
  throw new IllegalStateException();
}
override
void bidirectItrRemove(BidirectionalItr$<E>$ itr)
{
  Node$<E>$ lastRet;
  if((lastRet=itr.lastRet)!=null)
  {
    int modCount;
    final Checked$<E>$ root;
    CheckedCollection.checkModCount(modCount=itr.modCount,(root=this.root).modCount);
    root.modCount=++modCount;
    uncheckedItrRemove(uncheckedMethodParams);
    if(lastRet!=itr.cursor)
    {
      --itr.nextIndex;
    }
    itr.modCount=modCount;
    --root.size;
    return;
  }
  throw new IllegalStateException();
}
#ENDDEF
#MACRODEF RootUncheckedItrRemoveImpl()
if(lastRet==tail)
{
  if(lastRet==head)
  {
    ((SubList$<E>$)this).bubbleUpclearRoot();
    (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(null);
  }
  else
  {
    ((SubList$<E>$)this).bubbleUprootchoptail(lastRet=lastRet.prev);
    (($ClassPrefix$DblLnkSeq$<E>$)root).privatesettail(lastRet);
  }
}
else
{
  if(lastRet==head)
  {
    ((SubList$<E>$)this).bubbleUprootchophead(lastRet=lastRet.next);
    (($ClassPrefix$DblLnkSeq$<E>$)root).privatesethead(lastRet);
  }
  else
  {
    ((SubList$<E>$)this).bubbleUpdecrementSize();
    lastRet.prev.joinnext(lastRet.next);
  }
}
#ENDDEF
#MACRODEF BodyInitHelperImpl()
final Node$<E>$ newNode;
(($ClassPrefix$DblLnkSeq$<E>$)this).privateInit(newNode=new Node$<E>$(val));
SubList$<E>$ parent,curr;
if((parent=(curr=this).parent)!=null)
{
  do
  {
    int parentSize;
    if((parentSize=parent.size)!=0)
    {
      Node$<E>$ before,after;
      int headDist,tailDist;
      if((headDist=curr.getParentOffset())==0)
      {
        parent.bubbleUpsuffixPushhead(newNode,after=parent.head);
        before=after.prev;
      }
      else if((tailDist=parentSize-headDist)==0)
      {
        parent.bubbleUpprefixPushtail(newNode,before=parent.tail);
        after=before.next;
      }
      else
      {
        #MACRO InsertNode(root,before,after,headDist,tailDist)
        parent.bubbleUpincrementSize();
      }
      before.joinnext(newNode);
      newNode.joinnext(after);
      return;
    }
    parent=(curr=parent).parent;
    curr.size=1;
    (($ClassPrefix$DblLnkSeq$<E>$)curr).privateInit(newNode);
  }
  while(parent!=null);
}
(($ClassPrefix$DblLnkSeq$<E>$)root).subSeqInsertHelper(newNode,curr.getParentOffset());
#ENDDEF
#MACRODEF PrependAppendHelperImpl(endNode,constructorParams,Name)
Node$<E>$ newNode,oldendNode;
endNode=newNode=new Node$<E>$(constructorParams);
SubList$<E>$ parent;
if((parent=this.parent)!=null)
{
  parent.bubbleUpNamePushendNode(newNode,oldendNode);
}
#ENDDEF
#MACRODEF PrefixSuffixInitHelperImpl(before,endNode,next)
final Node$<E>$ before,newNode=new Node$<E>$(val);
for(SubList$<E>$ curr=this;;curr.size=1)
{
  (($ClassPrefix$DblLnkSeq$<E>$)curr).privateInit(newNode);
  if((curr=curr.parent)==null)
  {
    before=root.endNode;
    break;
  }
  if(curr.size!=0)
  {
    before=curr.endNode;
    curr.bubbleUppushendNode(newNode);
    break;
  }
}
before.joinnext(newNode);
#ENDDEF
#MACRODEF RootAddHelperMethods(RootClass,incrementModCount)
void initHelper(RootClass$<E>$ root,$exposedType$ val)
{
  final var newNode=new Node$<E>$(val);
  for(var curr=this;;curr.size=1)
  {
    (($ClassPrefix$DblLnkSeq$<E>$)curr).privateInit(newNode);
    if((curr=curr.parent)==null)
    {
      (($ClassPrefix$DblLnkSeq$<E>$)root).privateInit(newNode);
      return;
    }
  }
}
void prependHelper($exposedType$ val)
{
  incrementModCount
  Node$<E>$ newNode;
  this.head=newNode=new Node$<E>$(val,this.head);
  SubList$<E>$ parent;
  if((parent=this.parent)!=null)
  {
    parent.bubbleUppushhead(newNode);
  }
}
void appendHelper($exposedType$ val)
{
  incrementModCount
  Node$<E>$ newNode;
  this.tail=newNode=new Node$<E>$(this.tail,val);
  SubList$<E>$ parent;
  if((parent=this.parent)!=null)
  {
    parent.bubbleUppushtail(newNode);
  }
}
private void insertHelper(Node$<E>$ before,$exposedType$ val,Node$<E>$ after)
{
  incrementModCount
  new Node$<E>$(before,val,after);
  SubList$<E>$ parent;
  if((parent=this.parent)!=null)
  {
    parent.bubbleUpincrementSize();
  }
}
#ENDDEF
#MACRODEF WhileLessThan(Val1,Val2)
while(
#IFSWITCH MethodName==sort
(Val1)<(Val2)
#ELSEIFSWITCH MethodName==reverseSort
(Val1)>(Val2)
#ELSE
sorter.$compareMethod$(($exposedType$)(Val1),($exposedType$)(Val2))<0
#ENDIF
)
#ENDDEF