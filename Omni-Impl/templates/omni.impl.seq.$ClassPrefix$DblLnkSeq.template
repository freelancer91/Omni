#TYPEDEF OfBoolean
#TYPEDEF OfByte
#TYPEDEF OfChar
#TYPEDEF OfShort
#TYPEDEF OfInt
#TYPEDEF OfLong
#TYPEDEF OfFloat
#TYPEDEF OfDouble
#TYPEDEF OfRef
package omni.impl.seq;
import omni.util.$ClassPrefix$SortUtil;
import omni.api.OmniList;
import omni.impl.$DNode$;
import java.util.function.Consumer;
#IF OfDouble,OfLong,OfInt
import java.util.function.$TypeNameModifier$Consumer;
import java.util.function.$TypeNameModifier$Predicate;
#ELSEIFNOT OfRef
import omni.function.$TypeNameModifier$Consumer;
import omni.function.$TypeNameModifier$Predicate;
#ENDIF
import java.util.function.UnaryOperator;
#IF OfDouble,OfLong,OfInt
import java.util.function.$UnaryOperator$;
#ELSEIFNOT OfBoolean,OfRef
import omni.function.$UnaryOperator$;
#ENDIF
import omni.util.OmniArray;
#IFNOT OfRef
import omni.util.TypeUtil;
import omni.impl.Abstract$ClassPrefix$Itr;
#ENDIF
#IF OfRef
import omni.util.OmniPred;
#ENDIF
import java.util.function.Predicate;
import java.util.function.IntFunction;
import java.util.Comparator;
#IF OfInt
import java.util.function.$Comparator$;
#ELSEIFNOT OfRef
import omni.function.$Comparator$;
#ENDIF
import omni.api.OmniIterator;
import omni.api.OmniListIterator;
import omni.api.OmniDeque;
import java.io.Externalizable;
import java.io.Serializable;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectOutput;
import java.io.ObjectInput;
import java.io.IOException;
import java.util.NoSuchElementException;
import java.util.ConcurrentModificationException;
import omni.impl.CheckedCollection;
#IFNOT OfRef,OfDouble,OfChar
import omni.util.ToStringUtil;
#ENDIF
public abstract class $ClassPrefix$DblLnkSeq$<E>$ extends 
#IF OfRef
AbstractSeq$<E>$
#ELSE
AbstractSeq<$BoxedType$>
#ENDIF
 implements
#IF OfRef
   OmniList.Of$ClassPrefix$$<E>$
#ELSE
   $ClassPrefix$SubListDefault$<E>$
#ENDIF
{
  private static final long serialVersionUID=1L;
  transient $DNode$$<E>$ head;
  transient $DNode$$<E>$ tail;
  private  $ClassPrefix$DblLnkSeq(){
  }
  private $ClassPrefix$DblLnkSeq($DNode$$<E>$ head,int size,$DNode$$<E>$ tail){
    super(size);
    this.head=head;
    this.tail=tail;
  }
  abstract void addLast($exposedType$ val);
  @Override public boolean add($exposedType$ val){
    addLast(val);
    return true;
  }
  private void iterateDescendingAndInsert(int dist,$DNode$$<E>$ after,$DNode$$<E>$ newNode){
    newNode.next=after=$DNode$.iterateDescending(after,dist-2);
    final $DNode$$<E>$ before;
    newNode.prev=before=after.prev;
    before.next=newNode;
    after.prev=newNode;
  }
  private void iterateAscendingAndInsert(int dist,$DNode$$<E>$ before,$DNode$$<E>$ newNode){
    newNode.prev=before=$DNode$.iterateAscending(before,dist-1);
    final $DNode$$<E>$ after;
    newNode.next=after=before.next;
    before.next=newNode;
    after.prev=newNode;
  }
  private void insertNode(int index,$DNode$$<E>$ newNode){
    int tailDist;
    if((tailDist=this.size-index)<=index){
      //the insertion point is closer to the tail
      var tail=this.tail;
      if(tailDist==1){
        //the insertion point IS the tail
        newNode.prev=tail;
        tail.next=newNode;
        this.tail=newNode;
      }else{
        //iterate from the root's tail
        iterateDescendingAndInsert(tailDist,tail,newNode);
      }
    }else{
      //the insertion point is closer to the head
      if(index==0){
        //the insertion point IS the head
        $DNode$$<E>$ head;
        (head=this.head).prev=newNode;
        newNode.next=head;
        this.head=newNode;
      }else{
        //iterate from the root's head 
        iterateAscendingAndInsert(index,this.head,newNode);
      }
    }
  }
#IFNOT OfBoolean
  private static $<E>$ int markSurvivors($DNode$$<E>$ curr,int numLeft,$TypeNameModifier$Predicate$<? super E>$ filter,long[] survivorSet){
    for(int numSurvivors=0,wordOffset=0;;){
      long word=0L,marker=1L;
      do{
        if(!filter.test(curr.val)){
          word|=marker;
          ++numSurvivors;
        }
        if(--numLeft==0)
        {
          survivorSet[wordOffset]=word;
          return numSurvivors;
        }
        curr=curr.next;
      }while((marker<<=1)!=0L);
      survivorSet[wordOffset++]=word;
    }
  }
  private static $<E>$ long markSurvivors($DNode$$<E>$ curr,int numLeft,$TypeNameModifier$Predicate$<? super E>$ filter){
    for(long word=0L,marker=1L;;marker<<=1,curr=curr.next){
      if(!filter.test(curr.val)){
        word|=marker;
      }
      if(--numLeft==0)
      {
        return word;
      }
    }
  }
#ENDIF
  private $DNode$$<E>$ getNode(int index,int size){
    if((size-=index)<=index){
      //the node is closer to the tail
      return $DNode$.iterateDescending(tail,size-1);
    }else{
      //the node is closer to the head
      return $DNode$.iterateAscending(head,index);
    }
  }
  private $DNode$$<E>$ getItrNode(int index,int size){
    if((size-=index)<=index){
      //the node is closer to the tail
      switch(size){
      case 0:
        return null;
      case 1:
        return tail;
      default:
        return $DNode$.uncheckedIterateDescending(tail,size-1);
      }
    }else{
      //the node is closer to the head
      return $DNode$.iterateAscending(head,index);
    }
  }
  @Override public $exposedType$ set(int index,$exposedType$ val){
    $DNode$$<E>$ tmp;
    final var ret=(tmp=getNode(index,size)).val;
    tmp.val=val;
    return ret;
  }
  @Override public void put(int index,$exposedType$ val){
    getNode(index,size).val=val;
  }
  @Override public $exposedType$ get$TypeNameModifier$(int index){
    return getNode(index,size).val;
  }
  @Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
    final $DNode$$<E>$ head;
    if((head=this.head)!=null){
      $DNode$.uncheckedForEachAscending(head,tail,action);
    }
  }
#IFNOT OfRef
  @Override public void forEach(Consumer<? super $BoxedType$> action){
    final $DNode$$<E>$ head;
    if((head=this.head)!=null){
      $DNode$.uncheckedForEachAscending(head,tail,action::accept);
    }
  }
#ENDIF
  @Override public <T> T[] toArray(T[] dst){
    final int size;
    if((size=this.size)!=0){
      $DNode$.uncheckedCopyInto(dst=OmniArray.uncheckedArrResize(size,dst),this.tail,size);
    }else if(dst.length!=0){
      dst[0]=null;
    }
    return dst;
  }
  @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
    final int size;
    final T[] dst=arrConstructor.apply(size=this.size);
    if(size!=0){
      $DNode$.uncheckedCopyInto(dst,this.tail,size);
    }
    return dst;
  }
  #MACRO ToArrayImpl<false>($ArrayType$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR,$TypeNameModifier$)
#IFNOT OfRef
  #MACRO ToArrayImpl<false>($BoxedType$,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR,)
  #IFNOT OfDouble
  #MACRO ToArrayImpl<false>(double,OmniArray.OfDouble.DEFAULT_ARR,Double)
    #IFNOT OfFloat
  #MACRO ToArrayImpl<false>(float,OmniArray.OfFloat.DEFAULT_ARR,Float)
      #IFNOT OfLong
  #MACRO ToArrayImpl<false>(long,OmniArray.OfLong.DEFAULT_ARR,Long)
        #IFNOT OfInt
  #MACRO ToArrayImpl<false>(int,OmniArray.OfInt.DEFAULT_ARR,Int)
          #IFNOT OfShort,OfChar
  #MACRO ToArrayImpl<false>(short,OmniArray.OfShort.DEFAULT_ARR,Short)
            #IFNOT OfByte
  #MACRO ToArrayImpl<false>(byte,OmniArray.OfByte.DEFAULT_ARR,Byte)
  #MACRO ToArrayImpl<false>(char,OmniArray.OfChar.DEFAULT_ARR,Char)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  @Override public void replaceAll($UnaryOperator$$<E>$ operator){
    final $DNode$$<E>$ head;
    if((head=this.head)!=null){
      $DNode$.uncheckedReplaceAll(head,tail,operator);
    }
  }
#IFNOT OfRef
  @Override public void replaceAll(UnaryOperator<$BoxedType$> operator){
    final $DNode$$<E>$ head;
    if((head=this.head)!=null){
      $DNode$.uncheckedReplaceAll(head,tail,operator::apply);
    }
  }
#ENDIF
  #MACRO ComparatorSortImpl<Stable,Root,false>($Comparator$$<? super E>$,sorter)
#IFNOT OfRef
  #MACRO ComparatorSortImpl<Stable,Root,false>(Comparator<? super $BoxedType$>,sorter::compare)
#ENDIF
  #MACRO NonComparatorSortImpl<Stable,Root,false,Ascending>()
  #MACRO NonComparatorSortImpl<Stable,Root,false,Descending>()
#IF OfRef
  #MACRO NonComparatorSortImpl<Unstable,Root,false,Ascending>()
  #MACRO NonComparatorSortImpl<Unstable,Root,false,Descending>()
#ENDIF
#IFNOT OfBoolean
  #MACRO ComparatorSortImpl<Unstable,Root,false>($Comparator$$<? super E>$,sorter)
#ENDIF
  @Override public String toString(){
    final $DNode$$<E>$ head;
    if((head=this.head)!=null){
#IF OfDouble,OfRef
      final StringBuilder builder;
      $DNode$.uncheckedToString(head,tail,builder=new StringBuilder("["));
      return builder.append(']').toString();
#ELSE
      int size;
  #IF OfChar
      final char[] buffer;
      $DNode$.uncheckedToString(head,tail,buffer=new char[size=this.size*3]);
      buffer[0]='[';
      buffer[size-1]=']';
      return new String(buffer,0,size);
  #ELSE
      final byte[] buffer;
    #IF OfBoolean
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/7)){(buffer=new byte[size*7])
    #ELSEIF OfByte
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/6)){(buffer=new byte[size*6])
    #ELSEIF OfShort
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE>>3)){(buffer=new byte[size<<3])
    #ELSEIF OfInt
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/13)){(buffer=new byte[size*13])
    #ELSEIF OfLong
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/22)){(buffer=new byte[size*22])
    #ELSEIF OfFloat
      if((size=this.size)<=(OmniArray.MAX_ARR_SIZE/17)){(buffer=new byte[size*17])
    #ENDIF
        [size=$DNode$.uncheckedToString(head,tail,buffer)]=(byte)']';
        buffer[0]=(byte)'[';
        return new String(buffer,0,size+1,ToStringUtil.IOS8859CharSet);
      }else{
        final ToStringUtil.OmniStringBuilderByte builder;
        $DNode$.uncheckedToString(head,tail,builder=new ToStringUtil.OmniStringBuilderByte(1,new byte[OmniArray.MAX_ARR_SIZE]));
        builder.uncheckedAppendChar((byte)']');
        (buffer=builder.buffer)[0]=(byte)'[';
        return new String(buffer,0,builder.size,ToStringUtil.IOS8859CharSet);
      }
  #ENDIF 
#ENDIF
    }
    return "[]";
  }
  @Override public int hashCode(){
    final $DNode$$<E>$ head;
    if((head=this.head)!=null){
      return $DNode$.uncheckedHashCode(head,tail);
    }
    return 1;
  }
  #MACRO QueryMethods<contains,Root,false>()
  #MACRO QueryMethods<indexOf,Root,false>()
  #MACRO QueryMethods<lastIndexOf,Root,false>()
#IF OfBoolean
  #MACRO CollapseBodyHelper(removeThis==,$ArrayType$ removeThis)
#ELSE
  #MACRO CollapseBodyHelper(filter.test,$TypeNameModifier$Predicate$<? super E>$ filter)
#ENDIF
#MACRODEF CollapseBodyHelper(TEST,PARAM)
private static $<E>$ int collapseBodyHelper($DNode$$<E>$ newHead,$DNode$$<E>$ newTail,PARAM){
  int numRemoved=0;
  outer:for($DNode$$<E>$ prev;(newHead=(prev=newHead).next)!=newTail;){
    if(TEST(newHead.val)){
      do{
        ++numRemoved;
        if((newHead=newHead.next)==newTail){
          newHead.prev=prev;
          prev.next=newHead;
          break outer;
        }
      }while(TEST(newHead.val));
      newHead.prev=prev;
      prev.next=newHead;
    }
  }
  return numRemoved;
}
#ENDDEF
  private static class UncheckedSubList$<E>$ extends $ClassPrefix$DblLnkSeq$<E>${
    private static final long serialVersionUID=1L;
    transient final UncheckedList$<E>$ root;
    transient final UncheckedSubList$<E>$ parent;
    transient final int parentOffset;
    private UncheckedSubList(UncheckedList$<E>$ root,int rootOffset,$DNode$$<E>$ head,int size,$DNode$$<E>$ tail){
      super(head,size,tail);
      this.root=root;
      this.parent=null;
      this.parentOffset=rootOffset;
    }
    private UncheckedSubList(UncheckedSubList$<E>$ parent,int parentOffset,$DNode$$<E>$ head,int size,$DNode$$<E>$ tail){
      super(head,size,tail);
      this.root=parent.root;
      this.parent=parent;
      this.parentOffset=parentOffset;
    }
    private UncheckedSubList(UncheckedList$<E>$ root,int rootOffset){
      super();
      this.root=root;
      this.parent=null;
      this.parentOffset=rootOffset;
    }
    private UncheckedSubList(UncheckedSubList$<E>$ parent,int parentOffset){
      super();
      this.root=parent.root;
      this.parent=parent;
      this.parentOffset=parentOffset;
    }
    private Object writeReplace(){
      return new UncheckedList$<E>$(this.head,this.size,this.tail);
    }
    #MACRO SubListAddMethods<Unchecked>()
    @Override public boolean equals(Object val){
      //TODO
      return false;
    }
    #MACRO SubListRemoveMethods<Unchecked>()
    @Override public Object clone(){
      final int size;
      if((size=this.size)!=0){
        $DNode$$<E>$ head,newTail;
        final var newHead=newTail=new $DNode$$<E>$((head=this.head).val);
        for(int i=1;i!=size;newTail=newTail.next=new $DNode$$<E>$(newTail,(head=head.next).val),++i){}
        return new UncheckedList$<E>$(newHead,size,newTail);
      }
      return new UncheckedList$<E>$();
    }
    private static class AscendingItr$<E>$
#IF OfRef
      implements OmniIterator.OfRef$<E>$
#ELSE
      extends Abstract$ClassPrefix$Itr$<E>$
#ENDIF
    {
      transient final UncheckedSubList$<E>$ parent;
      transient $DNode$$<E>$ curr;
      private AscendingItr(UncheckedSubList$<E>$ parent,$DNode$$<E>$ curr){
        this.parent=parent;
        this.curr=curr;
      }
      private AscendingItr(AscendingItr$<E>$ itr){
        this.parent=itr.parent;
        this.curr=itr.curr;
      }
      private AscendingItr(UncheckedSubList$<E>$ parent){
        this.parent=parent;
        this.curr=parent.head;
      }
      @Override public Object clone(){
        return new AscendingItr$<E>$(this);
      }
      @Override public boolean hasNext(){
        return curr!=null;
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        final $DNode$$<E>$ curr;
        this.curr=(curr=this.curr)==parent.tail?null:curr.next;
        return curr.val;
      }
      @Override public void remove(){
        UncheckedSubList$<E>$ parent;
        if(--(parent=this.parent).size==0){
          parent.removeLastNode(parent.tail);
        }else{
          $DNode$$<E>$ curr;
          if((curr=this.curr)==null){
            parent.peelTail(parent.tail);
          }else{
            $DNode$$<E>$ lastRet;
            if((lastRet=curr.prev)==parent.head){
              parent.peelHead(lastRet);
            }else{
              curr.prev=lastRet=lastRet.prev;
              lastRet.next=curr;
              parent.bubbleUpDecrementSize();
            }
          }
        }
        --parent.root.size;
      }
      @Override public void forEachRemaining($TypeNameModifier$Consumer$<? super E>$ action){
        final $DNode$$<E>$ curr;
        if((curr=this.curr)!=null){
          $DNode$.uncheckedForEachAscending(curr,parent.tail,action);
          this.curr=null;
        }
      }
#IFNOT OfRef
      @Override public void forEachRemaining(Consumer<? super $BoxedType$> action){
        final $DNode$$<E>$ curr;
        if((curr=this.curr)!=null){
          $DNode$.uncheckedForEachAscending(curr,parent.tail,action::accept);
          this.curr=null;
        }
      }
#ENDIF
    }
    private static class BidirectionalItr$<E>$ extends AscendingItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>${
      private transient int currIndex;
      private transient $DNode$$<E>$ lastRet;
      private BidirectionalItr(BidirectionalItr$<E>$ itr){
        super(itr);
        this.currIndex=itr.currIndex;
        this.lastRet=itr.lastRet;
      }
      private BidirectionalItr(UncheckedSubList$<E>$ parent){
        super(parent);
      }
      private BidirectionalItr(UncheckedSubList$<E>$ parent,$DNode$$<E>$ curr,int currIndex){
        super(parent,curr);
        this.currIndex=currIndex;
      }
      @Override public Object clone(){
        return new BidirectionalItr$<E>$(this);
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        final $DNode$$<E>$ curr;
        this.lastRet=curr=this.curr;
        this.curr=curr.next;
        ++this.currIndex;
        return curr.val;
      }
      @Override public $exposedType$ previous$TypeNameModifier$(){
        $DNode$$<E>$ curr;
        this.lastRet=curr=(curr=this.curr)==null?parent.tail:curr.prev;
        this.curr=curr;
        --this.currIndex;
        return curr.val;
      }
      @Override public boolean hasNext(){
        return currIndex<parent.size;
      }
      @Override public boolean hasPrevious(){
        return currIndex>0;
      }
      @Override public int nextIndex(){
        return this.currIndex;
      }
      @Override public int previousIndex(){
        return this.currIndex-1;
      }
      
      @Override public void set($exposedType$ val){
        lastRet.val=val;
      }
      @Override public void add($exposedType$ val){
        final UncheckedSubList$<E>$ currList;
        final UncheckedList$<E>$ root;
        this.lastRet=null;
        ++currIndex;
        if(++(root=(currList=this.parent).root).size!=1){
          if(++currList.size!=1){
            $DNode$$<E>$ after,before;
            if((after=this.curr)!=null){
              if((before=after.prev)!=null){
                before.next=before=new $DNode$$<E>$(before,val,after);
                if(after==currList.head){
                  currList.bubbleUpPrepend(after,before);
                }else{
                  currList.bubbleUpIncrementSize();
                }
              }else{
                currList.bubbleUpPrepend(before=new $DNode$$<E>$(val,after));
                root.head=before;
              }
              after.prev=before;
            }else{
              $DNode$$<E>$ newNode;
              if((after=(before=currList.tail).next)!=null){
                currList.bubbleUpAppend(before,newNode=new $DNode$$<E>$(before,val,after));
                after.prev=newNode;
              }else{
                currList.bubbleUpAppend(newNode=new $DNode$$<E>$(before,val));
                root.tail=newNode;
              }
              before.next=newNode;
            }
          }else{
            currList.bubbleUpInit(new $DNode$$<E>$(val));
          }
        }else{
          $DNode$$<E>$ newNode;
          currList.bubbleUpRootInit(newNode=new $DNode$$<E>$(val));
          currList.size=1;
          root.head=newNode;
          root.tail=newNode;
        }
      }
      @Override public void remove(){
        $DNode$$<E>$ lastRet,curr;
        if((curr=(lastRet=this.lastRet).next)==this.curr){
          --currIndex;
        }else{
          this.curr=curr;
        }
        UncheckedSubList$<E>$ parent;
        if(--(parent=this.parent).size==0){
          parent.removeLastNode(parent.tail);
        }else{
          if(lastRet==parent.tail){
            parent.peelTail(lastRet);
          }else{
            if(lastRet==parent.head){
              parent.peelHead(lastRet);
            }else{
              curr.prev=lastRet=lastRet.prev;
              lastRet.next=curr;
              parent.bubbleUpDecrementSize();
            }
          }
        }
        this.lastRet=null;
        --parent.root.size;
      }
      @Override public void forEachRemaining($TypeNameModifier$Consumer$<? super E>$ action){
        final int bound;
        final UncheckedSubList$<E>$ parent;
        if(this.currIndex<(bound=(parent=this.parent).size)){
          final $DNode$$<E>$ lastRet;
          $DNode$.uncheckedForEachAscending(this.curr,lastRet=parent.tail,action);
          this.lastRet=lastRet;
          this.curr=null;
          this.currIndex=bound;
        }
      }
#IFNOT OfRef
      @Override public void forEachRemaining(Consumer<? super $BoxedType$> action){
        final int bound;
        final UncheckedSubList$<E>$ parent;
        if(this.currIndex<(bound=(parent=this.parent).size)){
          final $DNode$$<E>$ lastRet;
          $DNode$.uncheckedForEachAscending(this.curr,lastRet=parent.tail,action::accept);
          this.lastRet=lastRet;
          this.curr=null;
          this.currIndex=bound;
        }
      }
#ENDIF
    }
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      return new AscendingItr$<E>$(this);
    }
    @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(){
      return new BidirectionalItr$<E>$(this);
    }
    @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index){
      return new BidirectionalItr$<E>$(this,(($ClassPrefix$DblLnkSeq$<E>$)this).getItrNode(index,this.size),index);
    }
    @Override public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex){
      final int subListSize;
      if((subListSize=toIndex-fromIndex)!=0){
        int tailDist;
        final $DNode$$<E>$ subListHead,subListTail;
        if((tailDist=this.size-toIndex)<=fromIndex){
          subListTail=$DNode$.iterateDescending(this.tail,tailDist);
          subListHead=subListSize<=fromIndex?$DNode$.iterateDescending(subListTail,subListSize-1):$DNode$.iterateAscending(this.head,fromIndex);
        }else{
          subListHead=$DNode$.iterateAscending(this.head,fromIndex);
          subListTail=subListSize<=tailDist?$DNode$.iterateAscending(subListHead,subListSize-1):$DNode$.iterateDescending(this.tail,tailDist);
        }
        return new UncheckedSubList$<E>$(this,fromIndex,subListHead,subListSize,subListTail);
      }
      return new UncheckedSubList$<E>$(this,fromIndex);
    }
    #MACRO QueryMethods<removeVal,SubList,false>()
#IF OfRef
    #MACRO UncheckedRemoveVal<SubList,false,NonNull>(nonNull.equals)
    #MACRO UncheckedRemoveVal<SubList,false,Null>(null==)
    #MACRO UncheckedRemoveVal<SubList,false,>(pred.test)
#ELSEIF OfFloat,OfDouble
    #MACRO UncheckedRemoveVal<SubList,false,Bits>(bits==$convertToBits$)
    #MACRO UncheckedRemoveVal<SubList,false,0>(0==)
    #MACRO UncheckedRemoveVal<SubList,false,NaN>($BoxedType$.isNaN)
#ELSE
    #MACRO UncheckedRemoveVal<SubList,false,>(val==)
#ENDIF
  }
  private static class CheckedSubList$<E>$ extends $ClassPrefix$DblLnkSeq$<E>${
    private static final long serialVersionUID=1L;
    transient final CheckedList$<E>$ root;
    transient final CheckedSubList$<E>$ parent;
    transient final int parentOffset;
    transient int modCount;
    private CheckedSubList(CheckedList$<E>$ root,int rootOffset,$DNode$$<E>$ head,int size,$DNode$$<E>$ tail){
      super(head,size,tail);
      this.root=root;
      this.parent=null;
      this.parentOffset=rootOffset;
      this.modCount=root.modCount;
    }
    private CheckedSubList(CheckedSubList$<E>$ parent,int parentOffset,$DNode$$<E>$ head,int size,$DNode$$<E>$ tail){
      super(head,size,tail);
      this.root=parent.root;
      this.parent=parent;
      this.parentOffset=parentOffset;
      this.modCount=parent.modCount;
    }
    private CheckedSubList(CheckedList$<E>$ root,int rootOffset){
      super();
      this.root=root;
      this.parent=null;
      this.parentOffset=rootOffset;
      this.modCount=root.modCount;
    }
    private CheckedSubList(CheckedSubList$<E>$ parent,int parentOffset){
      super();
      this.root=parent.root;
      this.parent=parent;
      this.parentOffset=parentOffset;
      this.modCount=parent.modCount;
    }
#IF OfRef
    #MACRO UncheckedRemoveVal<SubList,true,NonNull>(nonNull.equals)
    #MACRO UncheckedRemoveVal<SubList,true,Null>(null==)
    #MACRO UncheckedRemoveVal<SubList,true,>(pred.test)
#ELSEIF OfFloat,OfDouble
    #MACRO UncheckedRemoveVal<SubList,true,Bits>(bits==$convertToBits$)
    #MACRO UncheckedRemoveVal<SubList,true,0>(0==)
    #MACRO UncheckedRemoveVal<SubList,true,NaN>($BoxedType$.isNaN)
#ELSE
    #MACRO UncheckedRemoveVal<SubList,true,>(val==)
#ENDIF
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      CheckedCollection.checkModCount(modCount,root.modCount);
      return new BidirectionalItr$<E>$(this);
    }
    @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(){
      CheckedCollection.checkModCount(modCount,root.modCount);
      return new BidirectionalItr$<E>$(this);
    }
    @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index){
      CheckedCollection.checkModCount(modCount,root.modCount);
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkWriteHi(index,size=this.size);
      return new BidirectionalItr$<E>$(this,(($ClassPrefix$DblLnkSeq$<E>$)this).getItrNode(index,size),index);
    }
    private static class BidirectionalItr$<E>$
#IFNOT OfRef
      extends Abstract$ClassPrefix$Itr$<E>$
#ENDIF
      implements OmniListIterator.Of$ClassPrefix$$<E>${
      private transient final CheckedSubList$<E>$ parent;
      private transient int modCount;
      private transient $DNode$$<E>$ curr;
      private transient $DNode$$<E>$ lastRet;
      private transient int currIndex;
      private BidirectionalItr(BidirectionalItr$<E>$ itr){
        this.parent=itr.parent;
        this.modCount=itr.modCount;
        this.curr=itr.curr;
        this.lastRet=itr.lastRet;
        this.currIndex=itr.currIndex;
      }
      
      private BidirectionalItr(CheckedSubList$<E>$ parent){
        this.parent=parent;
        this.modCount=parent.modCount;
        this.curr=parent.head;
      }
      private BidirectionalItr(CheckedSubList$<E>$ parent,$DNode$$<E>$ curr,int currIndex){
        this.parent=parent;
        this.modCount=parent.modCount;
        this.curr=curr;
        this.currIndex=currIndex;
      }
      @Override public Object clone(){
        return new BidirectionalItr$<E>$(this);
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        final CheckedSubList$<E>$ parent;
        CheckedCollection.checkModCount(modCount,(parent=this.parent).root.modCount);
        final int currIndex;
        if((currIndex=this.currIndex)<parent.size){
          $DNode$$<E>$ curr;
          this.lastRet=curr=this.curr;
          this.curr=curr.next;
          this.currIndex=currIndex+1;
          return curr.val;
        }
        throw new NoSuchElementException();
      }
      @Override public $exposedType$ previous$TypeNameModifier$(){
        final CheckedSubList$<E>$ parent;
        CheckedCollection.checkModCount(modCount,(parent=this.parent).root.modCount);
        final int currIndex;
        if((currIndex=this.currIndex)!=0){
          $DNode$$<E>$ curr;
          this.lastRet=curr=(curr=this.curr)==null?parent.tail:curr.prev;
          this.curr=curr;
          this.currIndex=currIndex-1;
          return curr.val;
        }
        throw new NoSuchElementException();
      }
      @Override public boolean hasNext(){
        return currIndex<parent.size;
      }
      @Override public boolean hasPrevious(){
        return currIndex!=0;
      }
      @Override public int nextIndex(){
        return this.currIndex;
      }
      @Override public int previousIndex(){
        return this.currIndex-1;
      }
      @Override public void set($exposedType$ val){
        final $DNode$$<E>$ lastRet;
        if((lastRet=this.lastRet)!=null){
          CheckedCollection.checkModCount(modCount,parent.root.modCount);
          lastRet.val=val;
          return;
        }
        throw new IllegalStateException();
      }
      @Override public void forEachRemaining($TypeNameModifier$Consumer$<? super E>$ action){
        int size,numLeft;
        final CheckedSubList$<E>$ parent;
        if((numLeft=(size=(parent=this.parent).size)-this.currIndex)>0){
          final int modCount=this.modCount;
          try{
            $DNode$.uncheckedForEachAscending(this.curr,numLeft,action);
          }finally{
            CheckedCollection.checkModCount(modCount,parent.root.modCount);
          }
          this.lastRet=parent.tail;
          this.curr=null;
          this.currIndex=size;
        }
      }
#IFNOT OfRef
      @Override public void forEachRemaining(Consumer<? super $BoxedType$> action){
        final int size,numLeft;
        final CheckedSubList$<E>$ parent;
        if((numLeft=(size=(parent=this.parent).size)-this.currIndex)>0){
          final int modCount=this.modCount;
          try{
            $DNode$.uncheckedForEachAscending(this.curr,numLeft,action::accept);
          }finally{
            CheckedCollection.checkModCount(modCount,parent.root.modCount);
          }
          this.lastRet=parent.tail;
          this.curr=null;
          this.currIndex=size;
        }
      }
#ENDIF
      @Override public void remove(){
        $DNode$$<E>$ lastRet;
        if((lastRet=this.lastRet)!=null){
          CheckedSubList$<E>$ parent;
          CheckedList$<E>$ root;
          int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(root=(parent=this.parent).root).modCount);
          root.modCount=++modCount;
          this.modCount=modCount;
          parent.modCount=modCount;
          $DNode$$<E>$ curr;
          if((curr=lastRet.next)==this.curr){
            --currIndex;
          }else{
            this.curr=curr;
          }
          if(--(parent=this.parent).size==0){
            parent.removeLastNode(parent.tail);
          }else{
            if(lastRet==parent.tail){
              parent.peelTail(lastRet);
            }else{
              if(lastRet==parent.head){
                parent.peelHead(lastRet);
              }else{
                curr.prev=lastRet=lastRet.prev;
                lastRet.next=curr;
                parent.bubbleUpDecrementSize();
              }
            }
          }
          --root.size;
          this.lastRet=null;
          return;
        }
        throw new IllegalStateException();
      }
      @Override public void add($exposedType$ val){
        final CheckedSubList$<E>$ currList;
        final CheckedList$<E>$ root;
        int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,(root=(currList=this.parent).root).modCount);
        root.modCount=++modCount;
        this.modCount=modCount;
        currList.modCount=modCount;
        this.lastRet=null;
        ++currIndex;
        if(++root.size!=1){
          if(++currList.size!=1){
            $DNode$$<E>$ after,before;
            if((after=this.curr)!=null){
              if((before=after.prev)!=null){
                before.next=before=new $DNode$$<E>$(before,val,after);
                if(after==currList.head){
                  currList.bubbleUpPrepend(after,before);
                }else{
                  currList.bubbleUpIncrementSize();
                }
              }else{
                currList.bubbleUpPrepend(before=new $DNode$$<E>$(val,after));
                root.head=before;
              }
              after.prev=before;
            }else{
              $DNode$$<E>$ newNode;
              if((after=(before=currList.tail).next)!=null){
                currList.bubbleUpAppend(before,newNode=new $DNode$$<E>$(before,val,after));
                after.prev=newNode;
              }else{
                currList.bubbleUpAppend(newNode=new $DNode$$<E>$(before,val));
                root.tail=newNode;
              }
              before.next=newNode;
            }
          }else{
            currList.bubbleUpInit(new $DNode$$<E>$(val));
          }
        }else{
          $DNode$$<E>$ newNode;
          currList.bubbleUpRootInit(newNode=new $DNode$$<E>$(val));
          currList.size=1;
          root.head=newNode;
          root.tail=newNode;
        }
      }
    }
    @Override public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex){
      CheckedCollection.checkModCount(modCount,root.modCount);
      int tailDist;
      final int subListSize;
      if((subListSize=CheckedCollection.checkSubListRange(fromIndex,toIndex,tailDist=this.size))!=0){
        final $DNode$$<E>$ subListHead,subListTail;
        if((tailDist-=toIndex)<=fromIndex){
          subListTail=$DNode$.iterateDescending(this.tail,tailDist);
          subListHead=subListSize<=fromIndex?$DNode$.iterateDescending(subListTail,subListSize-1):$DNode$.iterateAscending(this.head,fromIndex);
        }else{
          subListHead=$DNode$.iterateAscending(this.head,fromIndex);
          subListTail=subListSize<=tailDist?$DNode$.iterateAscending(subListHead,subListSize-1):$DNode$.iterateDescending(this.tail,tailDist);
        }
        return new CheckedSubList$<E>$(this,fromIndex,subListHead,subListSize,subListTail);
      }
      return new CheckedSubList$<E>$(this,fromIndex);
    }
    @Override public Object clone(){
      CheckedCollection.checkModCount(modCount,root.modCount);
      final int size;
      if((size=this.size)!=0){
        $DNode$$<E>$ head,newTail;
        final var newHead=newTail=new $DNode$$<E>$((head=this.head).val);
        for(int i=1;i!=size;newTail=newTail.next=new $DNode$$<E>$(newTail,(head=head.next).val),++i){}
        return new CheckedList$<E>$(newHead,size,newTail);
      }
      return new CheckedList$<E>$();
    }
    #MACRO QueryMethods<removeVal,SubList,true>()
    #MACRO QueryMethods<indexOf,SubList,true>()
    #MACRO QueryMethods<lastIndexOf,SubList,true>()
    #MACRO QueryMethods<contains,SubList,true>()
    private static class SerializableSubList$<E>$ implements Serializable{
      private static final long serialVersionUID=1L;
      private transient $DNode$$<E>$ head;
      private transient $DNode$$<E>$ tail;
      private transient int size;
      private transient final CheckedList$<E>$.ModCountChecker modCountChecker;
      private SerializableSubList($DNode$$<E>$ head,int size,$DNode$$<E>$ tail,CheckedList$<E>$.ModCountChecker modCountChecker){
        this.head=head;
        this.tail=tail;
        this.size=size;
        this.modCountChecker=modCountChecker;
      }
      private Object readResolve(){
        return new CheckedList$<E>$(head,size,tail);
      }
#IF OfRef
      @SuppressWarnings("unchecked")
#ENDIF
      private void readObject(ObjectInputStream ois) throws IOException
#IF OfRef
        ,ClassNotFoundException
#ENDIF
      {
        int size;
        this.size=size=ois.readInt();
        if(size!=0){
          $DNode$$<E>$ curr;
#IF OfBoolean
          int word,marker;
          for(this.head=curr=new $DNode$(((marker=1)&(word=ois.readUnsignedByte()))!=0);--size!=0;curr=curr.next=new $DNode$$<E>$(curr,(word&marker)!=0)){
            if((marker<<=1)==(1<<8)){
              word=ois.readUnsignedByte();
              marker=1;
            }
          }
#ELSEIF OfRef
          for(this.head=curr=new $DNode$$<E>$(($exposedType$)ois.readObject());--size!=0;curr=curr.next=new $DNode$$<E>$(curr,($exposedType$)ois.readObject())){}
#ELSE
          for(this.head=curr=new $DNode$$<E>$(($exposedType$)ois.read$TypeNameModifier$());--size!=0;curr=curr.next=new $DNode$$<E>$(curr,($exposedType$)ois.read$TypeNameModifier$())){}
#ENDIF
          this.tail=curr;
        }
      }
      private void writeObject(ObjectOutputStream oos) throws IOException{
        try{
          int size;
          oos.writeInt(size=this.size);
          if(size!=0){
            var curr=this.head;
#IF OfBoolean
            for(int word=TypeUtil.castToByte(curr.val),marker=1;;){
              if(--size==0){
                oos.writeByte(word);
                return;
              }else if((marker<<=1)==(1<<8)){
                oos.writeByte(word);
                word=0;
                marker=1;
              }
              if((curr=curr.next).val){
                word|=marker;
              }
            }
#ELSE
            for(;;curr=curr.next){
  #IF OfRef
              oos.writeObject(curr.val);
  #ELSE
              oos.write$TypeNameModifier$(curr.val);
  #ENDIF
              if(--size==0){
                break;
              }
            }
#ENDIF
          }
        }finally{
          modCountChecker.checkModCount();
        }
      }
    }
    private Object writeReplace(){
      return new SerializableSubList$<E>$(this.head,this.size,this.tail,root.new ModCountChecker(this.modCount));
    }   
    #MACRO SubListRemoveMethods<Checked>()
    #MACRO SubListAddMethods<Checked>()
    @Override public $exposedType$ set(int index,$exposedType$ val){
      CheckedCollection.checkModCount(modCount,root.modCount);
      CheckedCollection.checkLo(index);
      final int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      final $DNode$$<E>$ node;
      final var ret=(node=(($ClassPrefix$DblLnkSeq$<E>$)this).getNode(index,size)).val;
      node.val=val;
      return ret;
    }
    @Override public void put(int index,$exposedType$ val){
      CheckedCollection.checkModCount(modCount,root.modCount);
      CheckedCollection.checkLo(index);
      final int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      (($ClassPrefix$DblLnkSeq$<E>$)this).getNode(index,size).val=val;
    }
    @Override public $exposedType$ get$TypeNameModifier$(int index){
      CheckedCollection.checkModCount(modCount,root.modCount);
      CheckedCollection.checkLo(index);
      final int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      return (($ClassPrefix$DblLnkSeq$<E>$)this).getNode(index,size).val;
    }
    @Override public int size(){
      CheckedCollection.checkModCount(modCount,root.modCount);
      return this.size;
    }
    @Override public boolean isEmpty(){
      CheckedCollection.checkModCount(modCount,root.modCount);
      return this.size==0;
    }
    @Override public void replaceAll($UnaryOperator$$<E>$ operator){
      final $DNode$$<E>$ head;
      if((head=this.head)==null){
        CheckedCollection.checkModCount(modCount,root.modCount);
        return;
      }
      final CheckedList$<E>$ root;
      int modCount=this.modCount;
      try{
        $DNode$.uncheckedReplaceAll(head,this.size,operator);
      }finally{
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        root.modCount=++modCount;
        var curr=this;
        do{
          curr.modCount=modCount;
        }while((curr=curr.parent)!=null);
      }
    }
    @Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
      final int modCount=this.modCount;
      try{
        final $DNode$$<E>$ head;
        if((head=this.head)!=null){
          $DNode$.uncheckedForEachAscending(head,this.size,action);
        }
      }finally{
        CheckedCollection.checkModCount(modCount,root.modCount);
      }
    }
    #MACRO ComparatorSortImpl<Stable,SubList,true>($Comparator$$<? super E>$,sorter)
    #MACRO NonComparatorSortImpl<Stable,SubList,true,Ascending>()
    #MACRO NonComparatorSortImpl<Stable,SubList,true,Descending>()
#IF OfRef
    #MACRO NonComparatorSortImpl<Unstable,SubList,true,Ascending>()
    #MACRO NonComparatorSortImpl<Unstable,SubList,true,Descending>()
#ELSE
    @Override public void replaceAll(UnaryOperator<$BoxedType$> operator){
      final $DNode$$<E>$ head;
      if((head=this.head)==null){
        CheckedCollection.checkModCount(modCount,root.modCount);
        return;
      }
      final CheckedList$<E>$ root;
      int modCount=this.modCount;
      try{
        $DNode$.uncheckedReplaceAll(head,this.size,operator::apply);
      }finally{
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        root.modCount=++modCount;
        var curr=this;
        do{
          curr.modCount=modCount;
        }while((curr=curr.parent)!=null);
      }
    }
    @Override public void forEach(Consumer<? super $BoxedType$> action){
      final int modCount=this.modCount;
      try{
        final $DNode$$<E>$ head;
        if((head=this.head)!=null){
          $DNode$.uncheckedForEachAscending(head,this.size,action::accept);
        }
      }finally{
        CheckedCollection.checkModCount(modCount,root.modCount);
      }
    }
    #MACRO ComparatorSortImpl<Stable,SubList,true>(Comparator<? super $BoxedType$>,sorter::compare)
#ENDIF
#IFNOT OfBoolean
    #MACRO ComparatorSortImpl<Unstable,SubList,true>($Comparator$$<? super E>$,sorter)
#ENDIF
    @Override public <T> T[] toArray(T[] dst){
      CheckedCollection.checkModCount(modCount,root.modCount);
      return super.toArray(dst);
    }
    @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
      return super.toArray(arrSize->
      {
        final int modCount=this.modCount;
        try{
          return arrConstructor.apply(arrSize);
        }finally{
          CheckedCollection.checkModCount(modCount,root.modCount);
        }
      });
    }
    #MACRO ToArrayImpl<true>($ArrayType$,OmniArray.Of$ClassPrefix$.DEFAULT_ARR,$TypeNameModifier$)
  #IFNOT OfRef
    #MACRO ToArrayImpl<true>($BoxedType$,OmniArray.Of$ClassPrefix$.DEFAULT_BOXED_ARR,)
    #IFNOT OfDouble
    #MACRO ToArrayImpl<true>(double,OmniArray.OfDouble.DEFAULT_ARR,Double)
      #IFNOT OfFloat
    #MACRO ToArrayImpl<true>(float,OmniArray.OfFloat.DEFAULT_ARR,Float)
        #IFNOT OfLong
    #MACRO ToArrayImpl<true>(long,OmniArray.OfLong.DEFAULT_ARR,Long)
          #IFNOT OfInt
    #MACRO ToArrayImpl<true>(int,OmniArray.OfInt.DEFAULT_ARR,Int)
            #IFNOT OfShort,OfChar
    #MACRO ToArrayImpl<true>(short,OmniArray.OfShort.DEFAULT_ARR,Short)
              #IFNOT OfByte
    #MACRO ToArrayImpl<true>(byte,OmniArray.OfByte.DEFAULT_ARR,Byte)
    #MACRO ToArrayImpl<true>(char,OmniArray.OfChar.DEFAULT_ARR,Char)
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
    @Override public String toString(){
#IF OfRef
      final int modCount=this.modCount;
      try{
        final $DNode$$<E>$ head;
        if((head=this.head)!=null){
           final StringBuilder builder;
           RefDblLnkNode.uncheckedToString(head,size,builder=new StringBuilder("["));
           return builder.append(']').toString();
        }
        return "[]";
      }finally{
        CheckedCollection.checkModCount(modCount,root.modCount);
      }
#ELSE
      CheckedCollection.checkModCount(modCount,root.modCount);
      return super.toString();
#ENDIF
    }
    @Override public int hashCode(){
#IF OfRef
      final int modCount=this.modCount;
      try{
        final $DNode$$<E>$ head;
        if((head=this.head)!=null){
           return RefDblLnkNode.uncheckedHashCode(head,size);
        }
        return 1;
      }finally{
        CheckedCollection.checkModCount(modCount,root.modCount);
      }
#ELSE
      CheckedCollection.checkModCount(modCount,root.modCount);
      return super.hashCode();
#ENDIF
    }
    @Override public boolean equals(Object val){
      //TODO
      return false;
    } 
  }
  public static class CheckedList$<E>$ extends UncheckedList$<E>${
    transient int modCount;
    public CheckedList(){
    }
    CheckedList($DNode$$<E>$ head,int size,$DNode$$<E>$ tail){
      super(head,size,tail);
    }
    private class ModCountChecker extends CheckedCollection.AbstractModCountChecker
    {
      ModCountChecker(int modCount){
        super(modCount);
      }
      @Override protected int getActualModCount(){
        return CheckedList.this.modCount;
      }
    }
    @Override public void clear(){
      if(size!=0){
        ++this.modCount;
        this.size=0;
        this.head=null;
        this.tail=null;
      }
    }
    #MACRO RootRemoveMethods<Checked>()
    #MACRO RootAddMethods<Checked>()
    @Override public $exposedType$ set(int index,$exposedType$ val){
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      $DNode$$<E>$ tmp;
      final var ret=(tmp=(($ClassPrefix$DblLnkSeq$<E>$)this).getNode(index,size)).val;
      tmp.val=val;
      return ret;
    }
    @Override public void put(int index,$exposedType$ val){
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      (($ClassPrefix$DblLnkSeq$<E>$)this).getNode(index,size).val=val;
    }
    @Override public $exposedType$ get$TypeNameModifier$(int index){
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkReadHi(index,size=this.size);
      return (($ClassPrefix$DblLnkSeq$<E>$)this).getNode(index,size).val;
    }
    @Override public $exposedType$ getLast$TypeNameModifier$(){
      final $DNode$$<E>$ tail;
      if((tail=this.tail)!=null){
         return tail.val;
      }
      throw new NoSuchElementException();
    }
    @Override public $exposedType$ $elementMethod$(){
      final $DNode$$<E>$ head;
      if((head=this.head)!=null){
         return head.val;
      }
      throw new NoSuchElementException();
    }
    @Override public <T> T[] toArray(IntFunction<T[]> arrConstructor){
      return super.toArray(arrSize->{
        final int modCount=this.modCount;
        try{
          return arrConstructor.apply(arrSize);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      });
    }
    @Override public void forEach($TypeNameModifier$Consumer$<? super E>$ action){
      final $DNode$$<E>$ head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          $DNode$.uncheckedForEachAscending(head,this.size,action);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
    }
    @Override public void replaceAll($UnaryOperator$$<E>$ operator){
      final $DNode$$<E>$ head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          $DNode$.uncheckedReplaceAll(head,this.size,operator);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
        }
      }
    }
    #MACRO ComparatorSortImpl<Stable,Root,true>($Comparator$$<? super E>$,sorter)
    #MACRO NonComparatorSortImpl<Stable,Root,true,Ascending>()
    #MACRO NonComparatorSortImpl<Stable,Root,true,Descending>()
#IF OfRef
    @Override public String toString(){
      final RefDblLnkNode<E> head;
      if((head=this.head)!=null){
        final StringBuilder builder=new StringBuilder("[");
        final int modCount=this.modCount;
        try{
          RefDblLnkNode.uncheckedToString(head,size,builder);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
        return builder.append(']').toString();
      }
      return "[]";
    }
    @Override public int hashCode(){
      final RefDblLnkNode<E> head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          return RefDblLnkNode.uncheckedHashCode(head,size);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
      return 1;
    }
    #MACRO NonComparatorSortImpl<Unstable,Root,true,Ascending>()
    #MACRO NonComparatorSortImpl<Unstable,Root,true,Descending>()
#ELSE
    @Override public void forEach(Consumer<? super $BoxedType$> action){
      final $DNode$$<E>$ head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          $DNode$.uncheckedForEachAscending(head,this.size,action::accept);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
      }
    }
    @Override public void replaceAll(UnaryOperator<$BoxedType$> operator){
      final $DNode$$<E>$ head;
      if((head=this.head)!=null){
        final int modCount=this.modCount;
        try{
          $DNode$.uncheckedReplaceAll(head,this.size,operator::apply);
        }finally{
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
        }
      }
    }
    #MACRO ComparatorSortImpl<Stable,Root,true>(Comparator<? super $BoxedType$>,sorter::compare)
#ENDIF
#IF OfBoolean
    private int removeIfHelper($DNode$$<E>$ prev,int numLeft,boolean retainThis){
      int numSurvivors=1;
      outer:for($DNode$$<E>$ next;--numLeft!=0;prev=next,++numSurvivors){
        if((next=prev.next).val^retainThis){
          do{
            if(--numLeft==0){
              prev.next=null;
              this.tail=prev;
              break outer;
            }
          }while((next=next.next).val^retainThis);
          prev.next=next;
          next.prev=prev;
        }
      }
      return numSurvivors;
    }
    private int removeIfHelper($DNode$$<E>$ prev,$DNode$$<E>$ head,int numLeft,boolean retainThis){
      int numSurvivors=0;
      outer:for(;;){
        if(--numLeft==0){
          prev.next=null;
          this.tail=prev;
          break;
        }
        if((head=head.next).val==retainThis){
          prev.next=head;
          head.prev=prev;
          do{
            ++numSurvivors;
            if(--numLeft==0){
              break outer;
            }
          }
          while((head=(prev=head).next).val==retainThis);
        }
      }
      return numSurvivors;
    }
#ELSE
    #MACRO ComparatorSortImpl<Unstable,Root,true>($Comparator$$<? super E>$,sorter)
    private void pullSurvivorsDown($DNode$$<E>$ prev,long[] survivorSet,int numSurvivors,int numRemoved){
      int wordOffset;
      for(long word=survivorSet[wordOffset=0],marker=1L;;){
        var curr=prev.next;
        if((marker&word)==0){
          do{
            if(--numRemoved==0){
              if(curr==tail){
                prev.next=null;
                this.tail=prev;
              }else{
                prev.next=curr=curr.next;
                curr.prev=prev;
              }
              return;
            }else if((marker<<=1)==0){
              word=survivorSet[++wordOffset];
              marker=1L;
            }
            curr=curr.next;
          }while((marker&word)==0);
          prev.next=curr;
          curr.prev=prev;
        }
        if(--numSurvivors==0){
          this.tail=curr;
          curr.next=null;
          return;
        }
        if((marker<<=1)==0){
           word=survivorSet[++wordOffset];
           marker=1L;
        }
        prev=curr;
      }
    }
    private void pullSurvivorsDown($DNode$$<E>$ prev,long word,int numSurvivors,int numRemoved){
      for(long marker=1L;;marker<<=1){
        var curr=prev.next;
        if((marker&word)==0){
          do{
            if(--numRemoved==0){
              if(curr==tail){
                prev.next=null;
                this.tail=prev;
              }else{
                prev.next=curr=curr.next;
                curr.prev=prev;
              }
              return;
            }
            curr=curr.next;
          }while(((marker<<=1)&word)==0);
          prev.next=curr;
          curr.prev=prev;
        }
        if(--numSurvivors==0){
          this.tail=curr;
          curr.next=null;
          return;
        }
        prev=curr;
      }
    }
    private int removeIfHelper($DNode$$<E>$ prev,$TypeNameModifier$Predicate$<? super E>$ filter,int numLeft,int modCount){
      if(numLeft!=0){
        int numSurvivors;
        if(numLeft>64){
          final long[] survivorSet;
          numSurvivors=markSurvivors(prev.next,numLeft,filter,survivorSet=new long[(numLeft-1>>6)+1]);
          CheckedCollection.checkModCount(modCount,this.modCount);
          if((numLeft-=numSurvivors)!=0){
            pullSurvivorsDown(prev,survivorSet,numSurvivors,numLeft);
          }
        }else{
          final long survivorWord=markSurvivors(prev.next,numLeft,filter);
          CheckedCollection.checkModCount(modCount,this.modCount);
          if((numLeft-=(numSurvivors=Long.bitCount(survivorWord)))!=0){
            pullSurvivorsDown(prev,survivorWord,numSurvivors,numLeft);
          }
        }
        return numSurvivors;
      }
      CheckedCollection.checkModCount(modCount,this.modCount);
      return 0;
    }
#ENDIF
    @Override boolean uncheckedRemoveIf($DNode$$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter){
      final int modCount=this.modCount;
      try{
        int numLeft=this.size;
#IF OfBoolean
        boolean firstVal;
        if(filter.test(firstVal=head.val)){
          while(--numLeft!=0){
            if((head=head.next).val^firstVal){
              if(filter.test(firstVal=!firstVal)){
                break;
              }
              CheckedCollection.checkModCount(modCount,this.modCount);
              this.modCount=modCount+1;
              head.prev=null;
              this.head=head;
              this.size=removeIfHelper(head,numLeft,firstVal);
              return true;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
          this.head=null;
          this.tail=null;
          this.size=0;
          return true;
        }else{
          for(int numSurvivors=1;--numLeft!=0;++numSurvivors){
            $DNode$$<E>$ prev;
            if((head=(prev=head).next).val^firstVal){
              if(filter.test(!firstVal)){
                CheckedCollection.checkModCount(modCount,this.modCount);
                this.modCount=modCount+1;
                this.size=numSurvivors+removeIfHelper(prev,head,numLeft,firstVal);
                return true;
              }
              break;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
        }
#ELSE
        if(filter.test(head.val)){
          while(--numLeft!=0){
            if(!filter.test((head=head.next).val)){
              this.size=1+removeIfHelper(head,filter,--numLeft,modCount);
              this.modCount=modCount+1;
              this.head=head;
              head.prev=null;
              return true;
            }
          }
          CheckedCollection.checkModCount(modCount,this.modCount);
          this.modCount=modCount+1;
          this.head=null;
          this.tail=null;
          this.size=0;
          return true;
        }else{
          int numSurvivors;
          if(--numLeft!=(numSurvivors=removeIfHelper(head,filter,numLeft,modCount))){
            this.modCount=modCount+1;
            this.size=1+numSurvivors;
            return true;
          }
        }
#ENDIF
      }catch(ConcurrentModificationException e){
        throw e;
      }catch(RuntimeException e){
        throw CheckedCollection.checkModCount(modCount,this.modCount,e);
      }
      return false;
    }
    @Override public void writeExternal(ObjectOutput out) throws IOException{
      final int modCount=this.modCount;
      try{
        int size;
        out.writeInt(size=this.size);
        if(size!=0){
          var curr=this.head;
  #IF OfBoolean
          for(int word=TypeUtil.castToByte(curr.val),marker=1;;){
            if(--size==0){
              out.writeByte(word);
              return;
            }else if((marker<<=1)==(1<<8)){
              out.writeByte(word);
              word=0;
              marker=1;
            }
            if((curr=curr.next).val){
              word|=marker;
            }
          }
  #ELSE
          for(;;curr=curr.next){
    #IF OfRef
            out.writeObject(curr.val);
    #ELSE
            out.write$TypeNameModifier$(curr.val);
    #ENDIF
            if(--size==0){
              break;
            }
          }
        
  #ENDIF
        }
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
    }
    @Override public Object clone(){
      final int size;
      if((size=this.size)!=0){
        $DNode$$<E>$ head,newTail;
        final var newHead=newTail=new $DNode$$<E>$((head=this.head).val);
        for(int i=1;i!=size;newTail=newTail.next=new $DNode$$<E>$(newTail,(head=head.next).val),++i){}
        return new CheckedList$<E>$(newHead,size,newTail);
      }
      return new CheckedList$<E>$();
    }
    @Override public boolean equals(Object val){
      //TODO
      return false;
    }
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ descendingIterator(){
      return new DescendingItr$<E>$(this);
    }
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      return new BidirectionalItr$<E>$(this);
    }
    @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(){
      return new BidirectionalItr$<E>$(this);
    }
    @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index){
      CheckedCollection.checkLo(index);
      int size;
      CheckedCollection.checkWriteHi(index,size=this.size);
      return new BidirectionalItr$<E>$(this,(($ClassPrefix$DblLnkSeq$<E>$)this).getItrNode(index,size),index);
    }
    @Override public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex){
      int tailDist;
      final int subListSize;
      if((subListSize=CheckedCollection.checkSubListRange(fromIndex,toIndex,tailDist=this.size))!=0){
        final $DNode$$<E>$ subListHead,subListTail;
        if((tailDist-=toIndex)<=fromIndex){
          subListTail=$DNode$.iterateDescending(this.tail,tailDist);
          subListHead=subListSize<=fromIndex?$DNode$.iterateDescending(subListTail,subListSize-1):$DNode$.iterateAscending(this.head,fromIndex);
        }else{
          subListHead=$DNode$.iterateAscending(this.head,fromIndex);
          subListTail=subListSize<=tailDist?$DNode$.iterateAscending(subListHead,subListSize-1):$DNode$.iterateDescending(this.tail,tailDist);
        }
        return new CheckedSubList$<E>$(this,fromIndex,subListHead,subListSize,subListTail);
      }
      return new CheckedSubList$<E>$(this,fromIndex);
    } 
#IF OfRef
    @Override public int search(Object val){
      final $DNode$$<E>$ head;
      if((head=this.head)!=null){
        if(val!=null){
          final int modCount=this.modCount;
          try{
            return $DNode$.uncheckedsearchNonNull(head,this.size,val);
          }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return $DNode$.uncheckedsearchNull(head);
      }
      return -1;
    }
    @Override public boolean contains(Object val){
      final $DNode$$<E>$ head;
      if((head=this.head)!=null){
        if(val!=null){
          final int modCount=this.modCount;
          try{
            return $DNode$.uncheckedcontainsNonNull(head,this.size,val);
          }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return $DNode$.uncheckedcontainsNull(head,tail);
      }
      return false;
    }
    @Override public int indexOf(Object val){
      final $DNode$$<E>$ head;
      if((head=this.head)!=null){
        if(val!=null){
          final int modCount=this.modCount;
          try{
            return $DNode$.uncheckedindexOfNonNull(head,this.size,val);
          }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return $DNode$.uncheckedindexOfNull(head,tail);
      }
      return -1;
    }
    @Override public int lastIndexOf(Object val){
      final $DNode$$<E>$ tail;
      if((tail=this.tail)!=null){
        if(val!=null){
          final int modCount=this.modCount;
          try{
            return $DNode$.uncheckedlastIndexOfNonNull(this.size,tail,val);
          }finally{
            CheckedCollection.checkModCount(modCount,this.modCount);
          }
        }
        return $DNode$.uncheckedlastIndexOfNull(this.size,tail);
      }
      return -1;
    }
#ENDIF
#IF OfRef
    #MACRO UncheckedRemoveLastOccurrence<true,NonNull>(nonNull.equals)
    #MACRO UncheckedRemoveLastOccurrence<true,Null>(null==)
    #MACRO UncheckedRemoveLastOccurrence<true,>(pred.test)
    #MACRO UncheckedRemoveVal<Root,true,NonNull>(nonNull.equals)
    #MACRO UncheckedRemoveVal<Root,true,Null>(null==)
    #MACRO UncheckedRemoveVal<Root,true,>(pred.test)
#ELSEIF OfFloat,OfDouble
    #MACRO UncheckedRemoveLastOccurrence<true,Bits>(bits==$convertToBits$)
    #MACRO UncheckedRemoveLastOccurrence<true,0>(0==)
    #MACRO UncheckedRemoveLastOccurrence<true,NaN>($BoxedType$.isNaN)
    #MACRO UncheckedRemoveVal<Root,true,Bits>(bits==$convertToBits$)
    #MACRO UncheckedRemoveVal<Root,true,0>(0==)
    #MACRO UncheckedRemoveVal<Root,true,NaN>($BoxedType$.isNaN)
#ELSE
    #MACRO UncheckedRemoveLastOccurrence<true,>(val==)
    #MACRO UncheckedRemoveVal<Root,true,>(val==)
#ENDIF
    #MACRO OutputMethods<true>(PollImpl)
    private static class DescendingItr$<E>$
#IF OfRef
      implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
      extends Abstract$ClassPrefix$Itr$<E>$
#ENDIF
    {
      transient final CheckedList$<E>$ parent;
      transient int modCount;
      transient $DNode$$<E>$ curr;
      transient $DNode$$<E>$ lastRet;
      transient int currIndex;
      private DescendingItr(DescendingItr$<E>$ itr){
        this.parent=itr.parent;
        this.modCount=itr.modCount;
        this.curr=itr.curr;
        this.lastRet=itr.lastRet;
        this.currIndex=itr.currIndex;
      }
      private DescendingItr(CheckedList$<E>$ parent){
        this.parent=parent;
        this.modCount=parent.modCount;
        this.currIndex=parent.size;
        this.curr=parent.tail;
      }
      private DescendingItr(CheckedList$<E>$ parent,$DNode$$<E>$ curr,int currIndex){
        this.parent=parent;
        this.modCount=parent.modCount;
        this.curr=curr;
        this.currIndex=currIndex;
      }
      @Override public Object clone(){
        return new DescendingItr$<E>$(this);
      }
      @Override public boolean hasNext(){
        return this.curr!=null;
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        CheckedCollection.checkModCount(modCount,parent.modCount);
        final $DNode$$<E>$ curr;
        if((curr=this.curr)!=null){
          this.lastRet=curr;
          this.curr=curr.prev;
          --currIndex;
          return curr.val;
        }
        throw new NoSuchElementException();
      }
      @Override public void remove(){
        $DNode$$<E>$ lastRet;
        if((lastRet=this.lastRet)!=null){
          final CheckedList$<E>$ parent;
          int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(parent=this.parent).modCount);
          parent.modCount=++modCount;
          this.modCount=modCount;
          if(--parent.size==0){
            parent.head=null;
            parent.tail=null;
          }else{
            if(lastRet==parent.tail){
              parent.tail=lastRet=lastRet.prev;
              lastRet.next=null;
            }else if(lastRet==parent.head){
              parent.head=lastRet=lastRet.next;
              lastRet.prev=null;
            }else{
              $DNode$.eraseNode(lastRet);
            }
          }
          this.lastRet=null;
          return;
        }
        throw new IllegalStateException();
      }
      private void uncheckedForEachRemaining(int currIndex,$TypeNameModifier$Consumer$<? super E>$ action){
        final int modCount=this.modCount;
        final CheckedList$<E>$ parent;
        try{
          $DNode$.uncheckedForEachDescending(this.curr,currIndex,action);
        }finally{
          CheckedCollection.checkModCount(modCount,(parent=this.parent).modCount);
        }
        this.curr=null;
        this.lastRet=parent.head;
        this.currIndex=0;
      }
      @Override public void forEachRemaining($TypeNameModifier$Consumer$<? super E>$ action){
        final int currIndex;
        if((currIndex=this.currIndex)>0){
          uncheckedForEachRemaining(currIndex,action);
        }
      }
#IFNOT OfRef
      @Override public void forEachRemaining(Consumer<? super $BoxedType$> action){
        final int currIndex;
        if((currIndex=this.currIndex)>0){
          uncheckedForEachRemaining(currIndex,action::accept);
        }
      }
#ENDIF  
    }
    private static class BidirectionalItr$<E>$ extends DescendingItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>${
      private BidirectionalItr(BidirectionalItr$<E>$ itr){
        super(itr);
      }
      private BidirectionalItr(CheckedList$<E>$ parent){
        super(parent,parent.head,0);
      }
      private BidirectionalItr(CheckedList$<E>$ parent,$DNode$$<E>$ curr,int currIndex){
        super(parent,curr,currIndex);
      }
      @Override public Object clone(){
        return new BidirectionalItr$<E>$(this);
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        CheckedCollection.checkModCount(modCount,parent.modCount);
        final $DNode$$<E>$ curr;
        if((curr=this.curr)!=null){
          this.lastRet=curr;
          this.curr=curr.next;
          ++this.currIndex;
          return curr.val;
        }
        throw new NoSuchElementException();
      }
      @Override public $exposedType$ previous$TypeNameModifier$(){
        final CheckedList$<E>$ parent;
        CheckedCollection.checkModCount(modCount,(parent=this.parent).modCount);
        final int currIndex;
        if((currIndex=this.currIndex)!=0){
          $DNode$$<E>$ curr;
          this.lastRet=curr=(curr=this.curr)==null?parent.tail:curr.prev;
          this.curr=curr;
          this.currIndex=currIndex-1;
          return curr.val;
        }
        throw new NoSuchElementException();
      }
      @Override public boolean hasPrevious(){
        return this.currIndex!=0;
      }
      @Override public int nextIndex(){
        return this.currIndex;
      }
      @Override public int previousIndex(){
        return this.currIndex-1;
      }
      @Override public void set($exposedType$ val){
        final $DNode$$<E>$ lastRet;
        if((lastRet=this.lastRet)!=null){
          CheckedCollection.checkModCount(modCount,parent.modCount);
          lastRet.val=val;
          return;
        }
        throw new IllegalStateException();
      }
      @Override public void add($exposedType$ val){
        final CheckedList$<E>$ parent;
        int modCount;
        CheckedCollection.checkModCount(modCount=this.modCount,(parent=this.parent).modCount);
        parent.modCount=++modCount;
        this.modCount=modCount;
        $DNode$$<E>$ newNode;
        final int currIndex;
        if((currIndex=++this.currIndex)==++parent.size){
          if(currIndex==1){
            parent.head=newNode=new $DNode$$<E>$(val);
          }else{
            (newNode=parent.tail).next=newNode=new $DNode$$<E>$(newNode,val);
          }
          parent.tail=newNode;
        }else{
          if(currIndex==1){
            (newNode=parent.head).prev=newNode=new $DNode$$<E>$(val,newNode);
            parent.head=newNode;
          }else{
            final $DNode$$<E>$ tmp;
            (newNode=curr).prev=newNode=new $DNode$$<E>$(tmp=newNode.prev,val,newNode);
            tmp.next=newNode;
          }
        }
        this.lastRet=null;
      }
      @Override public void remove(){
        $DNode$$<E>$ lastRet;
        if((lastRet=this.lastRet)!=null){
          final CheckedList$<E>$ parent;
          int modCount;
          CheckedCollection.checkModCount(modCount=this.modCount,(parent=this.parent).modCount);
          parent.modCount=++modCount;
          this.modCount=modCount;
          $DNode$$<E>$ curr;
          if((curr=lastRet.next)==this.curr){
            --currIndex;
          }else{
            this.curr=curr;
          }
          if(--parent.size==0){
            parent.head=null;
            parent.tail=null;
          }else{
            if(lastRet==parent.tail){
              parent.tail=lastRet=lastRet.prev;
              lastRet.next=null;
            }else if(lastRet==parent.head){
              parent.head=curr;
              curr.prev=null;
            }else{
              curr.prev=lastRet=lastRet.prev;
              lastRet.next=curr;
            }
          }
          this.lastRet=null;
          return;
        }
        throw new IllegalStateException();
      }
      @Override public void forEachRemaining($TypeNameModifier$Consumer$<? super E>$ action){
        final int size,numLeft;
        final CheckedList$<E>$ parent;
        if((numLeft=(size=(parent=this.parent).size)-this.currIndex)!=0){
          final int modCount=this.modCount;
          try{
            $DNode$.uncheckedForEachAscending(this.curr,numLeft,action);
          }finally{
            CheckedCollection.checkModCount(modCount,parent.modCount);
          }
          this.curr=null;
          this.lastRet=parent.tail;
          this.currIndex=size;
        }
      }
#IFNOT OfRef
      @Override public void forEachRemaining(Consumer<? super $BoxedType$> action){
        final int size,numLeft;
        final CheckedList$<E>$ parent;
        if((numLeft=(size=(parent=this.parent).size)-this.currIndex)!=0){
          final int modCount=this.modCount;
          try{
            $DNode$.uncheckedForEachAscending(this.curr,numLeft,action::accept);
          }finally{
            CheckedCollection.checkModCount(modCount,parent.modCount);
          }
          this.curr=null;
          this.lastRet=parent.tail;
          this.currIndex=size;
        }
      }
#ENDIF  
    }
  }
  public static class UncheckedList$<E>$ extends $ClassPrefix$DblLnkSeq$<E>$ implements OmniDeque.Of$ClassPrefix$$<E>$,Externalizable{
    private static final long serialVersionUID=1L;
    public UncheckedList(){
    }
    UncheckedList($DNode$$<E>$ head,int size,$DNode$$<E>$ tail){
      super(head,size,tail);
    }
    @Override public void clear(){
      this.head=null;
      this.size=0;
      this.tail=null;
    }
    #MACRO RootRemoveMethods<Unchecked>()
    #MACRO RootAddMethods<Unchecked>()
    @Override public void writeExternal(ObjectOutput out) throws IOException{
      int size;
      out.writeInt(size=this.size);
      if(size!=0){
        var curr=this.head;
#IF OfBoolean
        for(int word=TypeUtil.castToByte(curr.val),marker=1;;){
          if((curr=curr.next)==null){
            out.writeByte(word);
            return;
          }else if((marker<<=1)==(1<<8)){
            out.writeByte(word);
            word=0;
            marker=1;
          }
          if(curr.val){
            word|=marker;
          }
        }
#ELSE
        do{
  #IF OfRef
          out.writeObject(curr.val);
  #ELSE
          out.write$TypeNameModifier$(curr.val);
  #ENDIF
        }
        while((curr=curr.next)!=null);
#ENDIF
      }
    }
#IF OfRef
    @SuppressWarnings("unchecked")
#ENDIF
    @Override public void readExternal(ObjectInput in) throws IOException
#IF OfRef
      ,ClassNotFoundException
#ENDIF
    {
      int size;
      this.size=size=in.readInt();
      if(size!=0){
        $DNode$$<E>$ curr;
#IF OfBoolean
        int word,marker;
        for(this.head=curr=new $DNode$(((marker=1)&(word=in.readUnsignedByte()))!=0);--size!=0;curr=curr.next=new $DNode$$<E>$(curr,(word&marker)!=0)){
          if((marker<<=1)==(1<<8)){
            word=in.readUnsignedByte();
            marker=1;
          }
        }
#ELSEIF OfRef
        for(this.head=curr=new $DNode$$<E>$(($exposedType$)in.readObject());--size!=0;curr=curr.next=new $DNode$$<E>$(curr,($exposedType$)in.readObject())){}
#ELSE
        for(this.head=curr=new $DNode$$<E>$(($exposedType$)in.read$TypeNameModifier$());--size!=0;curr=curr.next=new $DNode$$<E>$(curr,($exposedType$)in.read$TypeNameModifier$())){}
#ENDIF
        this.tail=curr;
      }
    }
    @Override public Object clone(){
      final int size;
      if((size=this.size)!=0){
        $DNode$$<E>$ head,newTail;
        final var newHead=newTail=new $DNode$$<E>$((head=this.head).val);
        for(int i=1;i!=size;newTail=newTail.next=new $DNode$$<E>$(newTail,(head=head.next).val),++i){}
        return new UncheckedList$<E>$(newHead,size,newTail);
      }
      return new UncheckedList$<E>$();
    }
    @Override public boolean equals(Object val){
      //TODO
      return false;
    }
    #MACRO QueryMethods<removeVal,Root,false>()
#IF OfRef
    #MACRO UncheckedRemoveVal<Root,false,NonNull>(nonNull.equals)
    #MACRO UncheckedRemoveVal<Root,false,Null>(null==)
    #MACRO UncheckedRemoveVal<Root,false,>(pred.test)
#ELSEIF OfFloat,OfDouble
    #MACRO UncheckedRemoveVal<Root,false,Bits>(bits==$convertToBits$)
    #MACRO UncheckedRemoveVal<Root,false,0>(0==)
    #MACRO UncheckedRemoveVal<Root,false,NaN>($BoxedType$.isNaN)
#ELSE
    #MACRO UncheckedRemoveVal<Root,false,>(val==)
#ENDIF
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ descendingIterator(){
      return new DescendingItr$<E>$(this);
    }
    @Override public OmniIterator.Of$ClassPrefix$$<E>$ iterator(){
      return new AscendingItr$<E>$(this);
    }
    @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(){
      return new BidirectionalItr$<E>$(this);
    }
    @Override public OmniListIterator.Of$ClassPrefix$$<E>$ listIterator(int index){
      return new BidirectionalItr$<E>$(this,(($ClassPrefix$DblLnkSeq$<E>$)this).getItrNode(index,this.size),index);
    }
    @Override public OmniList.Of$ClassPrefix$$<E>$ subList(int fromIndex,int toIndex){
      final int subListSize;
      if((subListSize=toIndex-fromIndex)!=0){
        final int tailDist;
        final $DNode$$<E>$ subListHead,subListTail;
        if((tailDist=this.size-toIndex)<=fromIndex){
          subListTail=$DNode$.iterateDescending(this.tail,tailDist);
          subListHead=subListSize<=fromIndex?$DNode$.iterateDescending(subListTail,subListSize-1):$DNode$.iterateAscending(this.head,fromIndex);
        }else{
          subListHead=$DNode$.iterateAscending(this.head,fromIndex);
          subListTail=subListSize<=tailDist?$DNode$.iterateAscending(subListHead,subListSize-1):$DNode$.iterateDescending(this.tail,tailDist);
        }
        return new UncheckedSubList$<E>$(this,fromIndex,subListHead,subListSize,subListTail);
      }
      return new UncheckedSubList$<E>$(this,fromIndex);
    }
    @Override public $exposedType$ getLast$TypeNameModifier$(){
      return tail.val;
    }
    @Override public boolean offerFirst($exposedType$ val){
      push(($exposedType$)val);
      return true;
    }
    @Override public boolean offerLast($exposedType$ val){
      addLast(($exposedType$)val);
      return true;
    }
#IF OfBoolean,OfRef
    @Override public void addFirst($exposedType$ val){
      push(($exposedType$)val);
    }
#ENDIF
#IF OfRef
    @Override public $exposedType$ removeFirst$TypeNameModifier$(){
      return pop$TypeNameModifier$();
    }
#ENDIF
    @Override public boolean removeFirstOccurrence(Object val){
      return remove(val);
    }
    @Override public $exposedType$ $elementMethod$(){
      return head.val;
    }
    @Override public boolean offer($exposedType$ val){
      addLast(($exposedType$)val);
      return true;
    }
    #MACRO QueryMethods<search,Root,false>()
    #MACRO QueryMethods<removeLastOccurrence,Root,false>()
#IF OfRef
    #MACRO UncheckedRemoveLastOccurrence<false,NonNull>(nonNull.equals)
    #MACRO UncheckedRemoveLastOccurrence<false,Null>(null==)
    #MACRO UncheckedRemoveLastOccurrence<false,>(pred.test)
#ELSEIF OfFloat,OfDouble
    #MACRO UncheckedRemoveLastOccurrence<false,Bits>(bits==$convertToBits$)
    #MACRO UncheckedRemoveLastOccurrence<false,0>(0==)
    #MACRO UncheckedRemoveLastOccurrence<false,NaN>($BoxedType$.isNaN)
#ELSE
    #MACRO UncheckedRemoveLastOccurrence<false,>(val==)
#ENDIF
#IF OfRef
    @Override public $exposedType$ remove$TypeNameModifier$(){
      return pop$TypeNameModifier$();
    }
    @Override public $exposedType$ pollFirst$TypeNameModifier$(){
      return poll$TypeNameModifier$();
    }
    @Override public $exposedType$ peekFirst$TypeNameModifier$(){
      return peek$TypeNameModifier$();
    }
    @Override public $exposedType$ getFirst$TypeNameModifier$(){
      return $elementMethod$();
    }
#ELSE
    @Override public $BoxedType$ peekFirst(){
      return peek();
    }
    @Override public $BoxedType$ pollFirst(){
      return poll();
    }
    @Override public $BoxedType$ pop(){
      return pop$TypeNameModifier$();
    }
    @Override public $BoxedType$ remove(){
      return pop$TypeNameModifier$();
    }
    @Override public boolean offer($BoxedType$ val){
      addLast(($exposedType$)val);
      return true;
    }
    @Override public $BoxedType$ element(){
      return $elementMethod$();
    }
    @Override public $BoxedType$ removeFirst(){
      return pop$TypeNameModifier$();
    }
    @Override public $BoxedType$ removeLast(){
      return removeLast$TypeNameModifier$();
    }
    @Override public boolean offerFirst($BoxedType$ val){
      push(($exposedType$)val);
      return true;
    }
    @Override public boolean offerLast($BoxedType$ val){
      addLast(($exposedType$)val);
      return true;
    }
    @Override public void push($BoxedType$ val){
      push(($exposedType$)val);
    }
    @Override public void addFirst($BoxedType$ val){
      push(($exposedType$)val);
    }
    @Override public void addLast($BoxedType$ val){
      addLast(($exposedType$)val);
    }
    @Override public $BoxedType$ getFirst(){
      return $elementMethod$();
    }
    @Override public $BoxedType$ getLast(){
      return getLast$TypeNameModifier$();
    }
#ENDIF
    #MACRO OutputMethods<false>(PollImpl)
    #MACRO OutputMethods<false>(PeekImpl)
    @Override public boolean removeIf($TypeNameModifier$Predicate$<? super E>$ filter){
      final $DNode$$<E>$ head;
      return (head=this.head)!=null && uncheckedRemoveIf(head,filter);
    }
#IFNOT OfRef
    @Override public boolean removeIf(Predicate<? super $BoxedType$> filter){
      final $DNode$$<E>$ head;
      return (head=this.head)!=null && uncheckedRemoveIf(head,filter::test);
    }
#ENDIF
#IF OfBoolean
    private int removeIfHelper($DNode$$<E>$ prev,$DNode$$<E>$ tail,boolean retainThis){
      int numSurvivors=1;
      outer:for($DNode$$<E>$ next;prev!=tail;++numSurvivors,prev=next){
        if((next=prev.next).val^retainThis){
          do{
            if(next==tail){
              this.tail=prev;
              prev.next=null;
              break outer;
            }
          }
          while((next=next.next).val^retainThis);
          prev.next=next;
          next.prev=prev;
        }
      }
      return numSurvivors;
    }
    private int removeIfHelper($DNode$$<E>$ prev,$DNode$$<E>$ curr,$DNode$$<E>$ tail,boolean retainThis){
      int numSurvivors=0;
      while(curr!=tail) {
        if((curr=curr.next).val==retainThis){
          prev.next=curr;
          curr.prev=prev;
          do{
            ++numSurvivors;
            if(curr==tail){
              return numSurvivors;
            }
          }while((curr=(prev=curr).next).val==retainThis);
        }
      }
      prev.next=null;
      this.tail=prev;
      return numSurvivors;
    }
#ELSE
    private int removeIfHelper($DNode$$<E>$ prev,$DNode$$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter){
      int numSurvivors=1;
      outer:for($DNode$$<E>$ next;prev!=tail;++numSurvivors,prev=next){
        if(filter.test((next=prev.next).val)){
          do{
            if(next==tail){
              this.tail=prev;
              prev.next=null;
              break outer;
            }
          }
          while(filter.test((next=next.next).val));
          prev.next=next;
          next.prev=prev;
        }
      }
      return numSurvivors;
    }
    private int removeIfHelper($DNode$$<E>$ prev,$DNode$$<E>$ curr,$DNode$$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter){
      int numSurvivors=0;
      while(curr!=tail) {
        if(!filter.test((curr=curr.next).val)){
          prev.next=curr;
          curr.prev=prev;
          do{
            ++numSurvivors;
            if(curr==tail){
              return numSurvivors;
            }
          }while(!filter.test((curr=(prev=curr).next).val));
        }
      }
      prev.next=null;
      this.tail=prev;
      return numSurvivors;
    }
#ENDIF
    boolean uncheckedRemoveIf($DNode$$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter){
#IF OfBoolean
      boolean firstVal;
      if(filter.test(firstVal=head.val)){
        for(var tail=this.tail;head!=tail;){
          if((head=head.next).val^firstVal){
            if(filter.test(firstVal=!firstVal)){
              break;
            }
            head.prev=null;
            this.head=head;
            this.size=removeIfHelper(head,tail,firstVal);
            return true;
          }
        }
        this.head=null;
        this.tail=null;
        this.size=0;
        return true;
      }else{
        int numSurvivors=1;
        for(final var tail=this.tail;head!=tail;++numSurvivors){
          final $DNode$$<E>$ prev;
          if((head=(prev=head).next).val^firstVal){
            if(filter.test(!firstVal)){
              this.size=numSurvivors+removeIfHelper(prev,head,tail,firstVal);
              return true;
            }
            break;
          }
        }
        return false;
      }
#ELSE
      if(filter.test(head.val)){
        for(var tail=this.tail;head!=tail;){
          if(!filter.test((head=head.next).val)){
            this.size=removeIfHelper(head,tail,filter);
            head.prev=null;
            this.head=head;
            return true;  
          }
        }
        this.head=null;
        this.tail=null;
        this.size=0;
        return true;
      }else{
        int numSurvivors=1;
        for(final var tail=this.tail;head!=tail;++numSurvivors){
          final $DNode$$<E>$ prev;
          if(filter.test((head=(prev=head).next).val)){
            this.size=numSurvivors+removeIfHelper(prev,head,tail,filter);
            return true;
          }
        }
        return false;
      }
#ENDIF
    }
    private static class DescendingItr$<E>$ extends AscendingItr$<E>${
      private DescendingItr(DescendingItr$<E>$ itr){
        super(itr);
      }
      private DescendingItr(UncheckedList$<E>$ parent){
        super(parent,parent.tail);
      }
      private DescendingItr(UncheckedList$<E>$ parent,$DNode$$<E>$ curr){
        super(parent,curr);
      }
      @Override public Object clone(){
        return new DescendingItr$<E>$(this);
      }
      @Override public void remove(){
        final UncheckedList$<E>$ parent;
        if(--(parent=this.parent).size==0){
          parent.head=null;
          parent.tail=null;
        }else{
          $DNode$$<E>$ curr;
          if((curr=this.curr)==null){
            (curr=parent.head.next).prev=null;
            parent.head=curr;
          }else{
            $DNode$$<E>$ lastRet;
            if((lastRet=curr.next)==parent.tail){
              parent.tail=curr;
              curr.next=null;
            }else{
              curr.next=lastRet=lastRet.next;
              lastRet.prev=curr;
            }
          }
        }
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        final $DNode$$<E>$ curr;
        this.curr=(curr=this.curr).prev;
        return curr.val;
      }
      @Override void uncheckedForEachRemaining($DNode$$<E>$ curr,$TypeNameModifier$Consumer$<? super E>$ action){
        $DNode$.uncheckedForEachDescending(curr,action);
      }
    }
    private static class AscendingItr$<E>$
#IF OfRef
      implements OmniIterator.Of$ClassPrefix$$<E>$
#ELSE
      extends Abstract$ClassPrefix$Itr$<E>$
#ENDIF
    {
      transient final UncheckedList$<E>$ parent;
      transient $DNode$$<E>$ curr;
      private AscendingItr(AscendingItr$<E>$ itr){
        this.parent=itr.parent;
        this.curr=itr.curr;
      }
      private AscendingItr(UncheckedList$<E>$ parent,$DNode$$<E>$ curr){
        this.parent=parent;
        this.curr=curr;
      }
      private AscendingItr(UncheckedList$<E>$ parent){
        this.parent=parent;
        this.curr=parent.head;
      }
      @Override public Object clone(){
        return new AscendingItr$<E>$(this);
      }
      @Override public boolean hasNext(){
        return curr!=null;
      }
      @Override public void remove(){
        final UncheckedList$<E>$ parent;
        if(--(parent=this.parent).size==0){
          parent.head=null;
          parent.tail=null;
        }else{
          $DNode$$<E>$ curr;
          if((curr=this.curr)==null){
            (curr=parent.tail.prev).next=null;
            parent.tail=curr;
          }else{
            $DNode$$<E>$ lastRet;
            if((lastRet=curr.prev)==parent.head){
              parent.head=curr;
              curr.prev=null;
            }else{
              curr.prev=lastRet=lastRet.prev;
              lastRet.next=curr;
            }
          }
        }
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        final $DNode$$<E>$ curr;
        this.curr=(curr=this.curr).next;
        return curr.val;
      }
      void uncheckedForEachRemaining($DNode$$<E>$ curr,$TypeNameModifier$Consumer$<? super E>$ action){
        $DNode$.uncheckedForEachAscending(curr,action);
        this.curr=null;
      }
      @Override public void forEachRemaining($TypeNameModifier$Consumer$<? super E>$ action){
        final $DNode$$<E>$ curr;
        if((curr=this.curr)!=null){
          uncheckedForEachRemaining(curr,action);
          this.curr=null;
        }
      }
#IFNOT OfRef
      @Override public void forEachRemaining(Consumer<? super $BoxedType$> action){
        final $DNode$$<E>$ curr;
        if((curr=this.curr)!=null){
          uncheckedForEachRemaining(curr,action::accept);
          this.curr=null;
        }
      }
#ENDIF
    }
    private static class BidirectionalItr$<E>$ extends AscendingItr$<E>$ implements OmniListIterator.Of$ClassPrefix$$<E>${
      private transient int currIndex;
      private transient $DNode$$<E>$ lastRet;
      private BidirectionalItr(BidirectionalItr$<E>$ itr){
        super(itr);
        this.currIndex=itr.currIndex;
        this.lastRet=itr.lastRet;
      }
      private BidirectionalItr(UncheckedList$<E>$ parent){
        super(parent);
      }
      private BidirectionalItr(UncheckedList$<E>$ parent,$DNode$$<E>$ curr,int currIndex){
        super(parent,curr);
        this.currIndex=currIndex;
      }
      @Override public Object clone(){
        return new BidirectionalItr$<E>$(this);
      }
      @Override public $exposedType$ next$TypeNameModifier$(){
        final $DNode$$<E>$ curr;
        this.lastRet=curr=this.curr;
        this.curr=curr.next;
        ++this.currIndex;
        return curr.val;
      }
      @Override public $exposedType$ previous$TypeNameModifier$(){
        $DNode$$<E>$ curr;
        this.lastRet=curr=(curr=this.curr)==null?parent.tail:curr.prev;
        this.curr=curr;
        --this.currIndex;
        return curr.val;
      }
      @Override public boolean hasPrevious(){
        return currIndex>0;
      }
      @Override public int nextIndex(){
        return currIndex;
      }
      @Override public int previousIndex(){
        return currIndex-1;
      }
      @Override public void add($exposedType$ val){
        final UncheckedList$<E>$ parent;
        $DNode$$<E>$ newNode;
        final int currIndex;
        if((currIndex=++this.currIndex)==++(parent=this.parent).size){
          if(currIndex==1){
            parent.head=newNode=new $DNode$$<E>$(val);
          }else{
            (newNode=parent.tail).next=newNode=new $DNode$$<E>$(newNode,val);
          }
          parent.tail=newNode;
        }else{
          if(currIndex==1){
            (newNode=parent.head).prev=newNode=new $DNode$$<E>$(val,newNode);
            parent.head=newNode;
          }else{
            final $DNode$$<E>$ tmp;
            (newNode=curr).prev=newNode=new $DNode$$<E>$(tmp=newNode.prev,val,newNode);
            tmp.next=newNode;
          }
        }
        this.lastRet=null;
      }
      @Override public void set($exposedType$ val){
        lastRet.val=val;
      }
      @Override public void remove(){
        $DNode$$<E>$ lastRet,curr;
        if((curr=(lastRet=this.lastRet).next)==this.curr){
          --currIndex;
        }else{
          this.curr=curr;
        }
        final UncheckedList$<E>$ parent;
        if(--(parent=this.parent).size==0){
          parent.head=null;
          parent.tail=null;
        }else{
          if(lastRet==parent.tail){
            parent.tail=lastRet=lastRet.prev;
            lastRet.next=null;
          }else if(lastRet==parent.head){
            parent.head=curr;
            curr.prev=null;
          }else{
            curr.prev=lastRet=lastRet.prev;
            lastRet.next=curr;
          }
        }
        this.lastRet=null;
      }
      @Override void uncheckedForEachRemaining($DNode$$<E>$ curr,$TypeNameModifier$Consumer$<? super E>$ action){
        $DNode$.uncheckedForEachAscending(curr,action);
        final UncheckedList$<E>$ parent;
        this.lastRet=(parent=this.parent).tail;
        this.currIndex=parent.size;
      }
    }
  }
}
#MACRODEF ToArrayImpl<CHECKED>(RETTYPE,DEFAULTARR,CLASSPREFIX)
@Override public RETTYPE[] toCLASSPREFIXArray(){
#IFSWITCH CHECKED==true
  CheckedCollection.checkModCount(modCount,root.modCount);
  return super.toCLASSPREFIXArray();
#ELSE
  int size;
  if((size=this.size)!=0){
    final RETTYPE[] dst;
    $DNode$.uncheckedCopyInto(dst=new RETTYPE[size],tail,size);
    return dst;
  }
  return DEFAULTARR;
#ENDIF
}
#ENDDEF
#MACRODEF QueryMethods<METHODNAME,STRUCTNAME,CHECKED>()
#IFSWITCH STRUCTNAME==Root
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
  #IF OfByte
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
  #ENDIF
  #IF OfInt,OfLong
    #IFSWITCH METHODNAME==contains,removeVal
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
    #ENDIF
  #ENDIF
  #IF OfRef
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
  #ENDIF
  #IF OfChar,OfShort
    #IFSWITCH METHODNAME==contains,removeVal
#MACRO QueryMethod<byte>( )
    #ENDIF
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
  #ENDIF
  #IF OfFloat
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )  
  #ENDIF
  #IF OfRef
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
  #ENDIF
#ELSE
  #IFSWITCH METHODNAME==removeVal
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
  #IF OfByte,OfInt,OfLong
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
  #ENDIF
  #IF OfChar,OfRef,OfShort
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
  #ENDIF
  #IF OfFloat
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )  
  #ENDIF
  #IF OfRef
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
  #ENDIF
  #ELSE
    #IFSWITCH CHECKED==true
#MACRO QueryMethod<boolean>( )
#MACRO QueryMethod<int>( )
#MACRO QueryMethod<long>( )
#MACRO QueryMethod<float>( )
#MACRO QueryMethod<double>( )
#MACRO QueryMethod<Object>( )
  #IF OfInt,OfLong
    #IFSWITCH METHODNAME==contains
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
    #ENDIF
  #ENDIF
  #IF OfByte
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
  #ENDIF
  #IF OfRef
#MACRO QueryMethod<byte>( )
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
  #ENDIF
  #IF OfChar,OfShort
    #IFSWITCH METHODNAME==contains
#MACRO QueryMethod<byte>( )
    #ENDIF
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )
  #ENDIF
  #IF OfFloat
#MACRO QueryMethod<char>( )
#MACRO QueryMethod<short>( )  
  #ENDIF
  #IF OfRef
#MACRO QueryMethod<Boolean>((boolean))
#MACRO QueryMethod<Byte>((byte))
#MACRO QueryMethod<Character>((char))
#MACRO QueryMethod<Short>((short))
#MACRO QueryMethod<Integer>((int))
#MACRO QueryMethod<Long>((long))
#MACRO QueryMethod<Float>((float))
#MACRO QueryMethod<Double>((double))
  #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
  
#ENDDEF

#MACRODEF SizeCheck()
#IFSWITCH METHODNAME==contains,indexOf,search,removeVal
final $DNode$$<E>$ head;
if((head=this.head)!=null)
#ELSEIFSWITCH METHODNAME==lastIndexOf,removeLastOccurrence
final $DNode$$<E>$ tail;
if((tail=this.tail)!=null)
#ELSE
ERROR unknown method name METHODNAME in SizeCheck()
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryBits(VAL)
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQueryBits(VAL) is only valid for Float and Double
#ENDIF
#IFSWITCH METHODNAME==contains,indexOf
return $DNode$.uncheckedMETHODNAMEBits(head,tail,VAL);
#ELSEIFSWITCH METHODNAME==search
return $DNode$.uncheckedMETHODNAMEBits(head,VAL);
#ELSEIFSWITCH METHODNAME==lastIndexOf
return $DNode$.uncheckedMETHODNAMEBits(size,tail,VAL);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAMEBits(head,VAL);
#ELSEIFSWITCH METHODNAME==removeLastOccurrence
return uncheckedMETHODNAMEBits(tail,VAL);
#ELSE
ERROR unknown method name METHODNAME in ReturnUncheckedQueryBits(VAL)
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQuery0()
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQuery0() is only valid for Float and Double
#ENDIF
#IFSWITCH METHODNAME==contains,indexOf
return $DNode$.uncheckedMETHODNAME0(head,tail);
#ELSEIFSWITCH METHODNAME==search
return $DNode$.uncheckedMETHODNAME0(head);
#ELSEIFSWITCH METHODNAME==lastIndexOf
return $DNode$.uncheckedMETHODNAME0(size,tail);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAME0(head);
#ELSEIFSWITCH METHODNAME==removeLastOccurrence
return uncheckedMETHODNAME0(tail);
#ELSE
ERROR unknown method name METHODNAME in  ReturnUncheckedQuery0()
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryNaN()
#IFNOT OfDouble,OfFloat
ERROR ReturnUncheckedQueryNaN() is only valid for Float and Double
#ENDIF
#IFSWITCH METHODNAME==contains,indexOf
return $DNode$.uncheckedMETHODNAMENaN(head,tail);
#ELSEIFSWITCH METHODNAME==search
return $DNode$.uncheckedMETHODNAMENaN(head);
#ELSEIFSWITCH METHODNAME==lastIndexOf
return $DNode$.uncheckedMETHODNAMENaN(size,tail);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAMENaN(head);
#ELSEIFSWITCH METHODNAME==removeLastOccurrence
return uncheckedMETHODNAMENaN(tail);
#ELSE
ERROR unknown method name METHODNAME in ReturnUncheckedQueryNaN()
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQuery(VAL)
#IF OfFloat,OfDouble
ERROR ReturnUncheckedQuery(VAL) is not valid for $ClassPrefix$
#ENDIF
#IFSWITCH METHODNAME==contains,indexOf
return $DNode$.uncheckedMETHODNAME(head,tail,VAL);
#ELSEIFSWITCH METHODNAME==search
return $DNode$.uncheckedMETHODNAME(head,VAL);
#ELSEIFSWITCH METHODNAME==lastIndexOf
return $DNode$.uncheckedMETHODNAME(size,tail,VAL);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAME(head,VAL);
#ELSEIFSWITCH METHODNAME==removeLastOccurrence
return uncheckedMETHODNAME(tail,VAL);
#ELSE
ERROR unknown method name METHODNAME in ReturnUncheckedQuery(VAL)
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryNonNull(VAL)
#IFNOT OfRef
ERROR ReturnUncheckedQueryNonNull(VAL) is not valid for $ClassPrefix$
#ENDIF
#IFSWITCH METHODNAME==contains,indexOf
  #IFSWITCH CHECKED==true
return $DNode$.uncheckedMETHODNAMENonNull(head,this.size,VAL);
  #ELSE
return $DNode$.uncheckedMETHODNAMENonNull(head,tail,VAL);
  #ENDIF
#ELSEIFSWITCH METHODNAME==search
return $DNode$.uncheckedMETHODNAMENonNull(head,VAL);
#ELSEIFSWITCH METHODNAME==lastIndexOf
return $DNode$.uncheckedMETHODNAMENonNull(size,tail,VAL);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAMENonNull(head,VAL);
#ELSEIFSWITCH METHODNAME==removeLastOccurrence
return uncheckedMETHODNAMENonNull(tail,VAL);
#ELSE
ERROR unknown method name METHODNAME in ReturnUncheckedQueryNonNull(VAL)
#ENDIF
#ENDDEF
#MACRODEF ReturnUncheckedQueryNull()
#IFNOT OfRef
ERROR ReturnUncheckedQueryNull() is not valid for $ClassPrefix$
#ENDIF
#IFSWITCH METHODNAME==contains,indexOf
return $DNode$.uncheckedMETHODNAMENull(head,tail);
#ELSEIFSWITCH METHODNAME==search
return $DNode$.uncheckedMETHODNAMENull(head);
#ELSEIFSWITCH METHODNAME==lastIndexOf
return $DNode$.uncheckedMETHODNAMENull(size,tail);
#ELSEIFSWITCH METHODNAME==removeVal
return uncheckedMETHODNAMENull(head);
#ELSEIFSWITCH METHODNAME==removeLastOccurrence
return uncheckedMETHODNAMENull(tail);
#ELSE
ERROR unknown method name METHODNAME in ReturnUncheckedQueryNull()
#ENDIF
#ENDDEF
#MACRODEF CheckedSubListQueryModCountDecl()
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH CHECKED==true
    #IFNOTSWITCH METHODNAME==removeVal
      #IF OfRef
        #IFSWITCH INPUTTYPE==Object
final int modCount=this.modCount;
try
        #ELSE
CheckedCollection.checkModCount(modCount,root.modCount);
        #ENDIF
      #ELSE
CheckedCollection.checkModCount(modCount,root.modCount);
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF CheckedSubListQueryFinallyModCount()
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH CHECKED==true
    #IFNOTSWITCH METHODNAME==removeVal
      #IF OfRef
        #IFSWITCH INPUTTYPE==Object
finally{
  CheckedCollection.checkModCount(modCount,root.modCount);
}
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF CheckedSubListRemoveValModCountCheck()
#IFSWITCH STRUCTNAME==SubList
  #IFSWITCH CHECKED==true
    #IFSWITCH METHODNAME==removeVal
CheckedCollection.checkModCount(modCount,root.modCount);
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF QueryMethod<INPUTTYPE>(CAST)
#IFSWITCH METHODNAME==removeVal
  #IFSWITCH INPUTTYPE==Object
@Override public boolean remove(INPUTTYPE val){
  #ELSE
@Override public boolean METHODNAME(INPUTTYPE val){
  #ENDIF
#ELSEIFSWITCH METHODNAME==contains,removeLastOccurrence
@Override public boolean METHODNAME(INPUTTYPE val){
#ELSEIFSWITCH METHODNAME==search,indexOf,lastIndexOf
@Override public int METHODNAME(INPUTTYPE val){
#ELSE
ERROR unknown method name METHODNAME in QueryMethod<INPUTTYPE>(CAST)
#ENDIF
#IFSWITCH INPUTTYPE==byte,short
  #IF OfChar
  if(val>=0)
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==char
  #IF OfByte,OfShort
  if(val<=$BoxedType$.MAX_VALUE)
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==int
  #IF OfByte,OfChar,OfShort
  if(val==($ArrayType$)val)
  #ENDIF
#ENDIF
  {
    #MACRO CheckedSubListQueryModCountDecl()
    {
      #MACRO SizeCheck()
      {
#IFSWITCH INPUTTYPE==boolean
  #IF OfDouble,OfFloat
        if(val){
          #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
        }
        #MACRO ReturnUncheckedQuery0()
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastBoolean$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==byte,char,short
  #IF OfDouble,OfFloat
        if(val!=0){
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
        #MACRO ReturnUncheckedQuery0()
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==int
  #IF OfBoolean
        returnFalse:for(;;){
          final $ArrayType$ v;
          switch(val){
          default:
            break returnFalse;
          case 0:
            v=false;
            break;
          case 1:
            v=true;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat,OfDouble
    #IF OfDouble
    #ENDIF
        if(val!=0){
    #IF OfFloat
          if(TypeUtil.checkCastTo$ClassPrefix$(val))
    #ENDIF
          {
            #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
          }
        }else{
          #MACRO ReturnUncheckedQuery0()
        }
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==long
  #IF OfBoolean
        returnFalse:for(;;){
          final $ArrayType$ v;
          if(val==0L){
            v=false;
          }else if(val==1L){
            v=true;
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat,OfDouble
        if(val!=0){
          if(TypeUtil.checkCastTo$ClassPrefix$(val)){
            #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
          }
        }else{
          #MACRO ReturnUncheckedQuery0()
        }
  #ELSEIF OfByte,OfChar,OfShort,OfInt
        final $ArrayType$ v;
        if((v=($ArrayType$)val)==val){
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSE
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==float
  #IF OfBoolean
        returnFalse:for(;;){
          final $ArrayType$ v;
          switch(Float.floatToRawIntBits(val)){
            default:
              break returnFalse;
            case 0:
            case Integer.MIN_VALUE:
              v=false;
              break;
            case TypeUtil.FLT_TRUE_BITS:
              v=true;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat,OfDouble
        if(val==val){
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
        #MACRO ReturnUncheckedQueryNaN()
  #ELSEIF OfRef
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ELSE
        final $ArrayType$ v;
    #IF OfLong
        if(TypeUtil.floatEquals(val,v=($ArrayType$)val))
    #ELSEIF OfInt
        if((double)val==(double)(v=($ArrayType$)val))
    #ELSE
        if(val==(v=($ArrayType$)val))
    #ENDIF
        {
          #MACRO ReturnUncheckedQuery(v)
        }
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==double
  #IF OfBoolean
        returnFalse:for(;;){
          final $ArrayType$ v;
          long bits;
          if(((bits=Double.doubleToRawLongBits(val))&(Long.MAX_VALUE))==0){
            v=false;
          }else if(bits==TypeUtil.DBL_TRUE_BITS){
            v=true;
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(v)
        }
  #ELSEIF OfFloat
        final $ArrayType$ v;
        if(val==(v=($ArrayType$)val)){
          #MACRO ReturnUncheckedQueryBits($convertToBits$(v))
        }else if(v!=v){
          #MACRO ReturnUncheckedQueryNaN()
        }
  #ELSEIF OfDouble
        if(val==val){
          #MACRO ReturnUncheckedQueryBits($convertToBits$(val))
        }
        #MACRO ReturnUncheckedQueryNaN()
  #ELSEIF OfRef
        #MACRO ReturnUncheckedQuery($queryCastPrimitive$(val))
  #ELSE
        final $ArrayType$ v;
    #IF OfLong
        if(TypeUtil.doubleEquals(val,v=($ArrayType$)val))
    #ELSE
        if(val==(v=($ArrayType$)val))
    #ENDIF
        {
          #MACRO ReturnUncheckedQuery(v)
        }
  #ENDIF
#ELSEIFSWITCH INPUTTYPE==Object
  #IF OfRef
        if(val!=null){
          #MACRO ReturnUncheckedQueryNonNull(val)
        }
        #MACRO ReturnUncheckedQueryNull()
  #ELSE
        //todo: a pattern-matching switch statement would be great here
        returnFalse:for(;;){
    #IF OfBoolean
          final boolean b;
          if(val instanceof Boolean){
            b=(boolean)val;
          }else if(val instanceof Integer||val instanceof Byte||val instanceof Short){
            switch(((Number)val).intValue()){
              default:
                break returnFalse;
              case 0:
                b=false;
                break;
              case 1:
                b=true;
            }
          }else if(val instanceof Float){
            switch(Float.floatToRawIntBits((float)val)){
              default:
                break returnFalse;
              case 0:
              case Integer.MIN_VALUE:
                b=false;
                break;
              case TypeUtil.FLT_TRUE_BITS:
                b=true;
            }
          }else if(val instanceof Double){
            final long bits;
            if(((bits=Double.doubleToRawLongBits((double)val))&(Long.MAX_VALUE))==0){
              b=false;
            }else if(bits==TypeUtil.DBL_TRUE_BITS){
              b=true;
            }else{
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long v;
            if((v=(long)val)==0L){
              b=false;
            }else if(v==1L){
              b=true;
            }else{
             break returnFalse;
            }
          }else if(val instanceof Character){
            switch(((Character)val).charValue()){
              default:
                break returnFalse;
              case 0:
                b=false;
                break;
              case 1:
                b=true;
            }
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(b)
    #ELSEIF OfByte
          final int i;
          if(val instanceof Byte){
            i=(byte)val;
          }else if(val instanceof Integer||val instanceof Short){
            if((i=((Number)val).intValue())!=(byte)i){
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(byte)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)!=(i=(byte)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(byte)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            if((i=(char)val)>Byte.MAX_VALUE){
              break returnFalse;
            }
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfChar
          final int i;
          if(val instanceof Character){
            i=(char)val;
          }else if(val instanceof Integer){
            if((i=(int)val)!=(char)i){
              break returnFalse;
            }
          }else if(val instanceof Byte||val instanceof Short){
            if((i=((Number)val).shortValue())<0){
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(char)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)!=(i=(char)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(char)d)){
              break returnFalse;
            }
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfShort
          final int i;
          if(val instanceof Short||val instanceof Byte){
            i=((Number)val).shortValue();
          }else if(val instanceof Integer){
            if((i=(int)val)!=(short)i){
              break returnFalse;
            }
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(short)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)!=(i=(short)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(short)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            if((i=(char)val)>Short.MAX_VALUE){
              break returnFalse;
            }
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfInt
          final int i;
          if(val instanceof Integer||val instanceof Byte||val instanceof Short){
            i=((Number)val).intValue();
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=(i=(int)l)){
              break returnFalse;
            }
          }else if(val instanceof Float){
            final float f;
            if((double)(f=(float)val)!=(double)(i=(int)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if((d=(double)val)!=(i=(int)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            i=(char)val;
          }else if(val instanceof Boolean){
            i=TypeUtil.castToByte((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(i);
    #ELSEIF OfLong
          final long l;
          if(val instanceof Long||val instanceof Integer||val instanceof Byte||val instanceof Short){
            l=((Number)val).longValue();
          }else if(val instanceof Float){
            final float f;
            if(!TypeUtil.floatEquals(f=(float)val,l=(long)f)){
              break returnFalse;
            }
          }else if(val instanceof Double){
            final double d;
            if(!TypeUtil.doubleEquals(d=(double)val,l=(long)d)){
              break returnFalse;
            }
          }else if(val instanceof Character){
            l=(char)val;
          }else if(val instanceof Boolean){
            l=TypeUtil.castToLong((boolean)val);
          }else{
            break returnFalse;
          }
          #MACRO ReturnUncheckedQuery(l);
    #ELSEIF OfFloat
          if(val instanceof Float){
            final float f;
            if((f=(float)val)==f){
               #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
            }
            #MACRO ReturnUncheckedQueryNaN()
          }else if(val instanceof Double){
            final double d;
            final float f;
            if((d=(double)val)==(f=(float)d)){
              #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
            }else if(f!=f){
              #MACRO ReturnUncheckedQueryNaN()
            }else{
              break returnFalse;
            }
          }else if(val instanceof Integer){
            final int i;
            if((i=(int)val)!=0){
              if(!TypeUtil.checkCastToFloat(i)){
                break returnFalse;
              }
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=0){
              if(!TypeUtil.checkCastToFloat(l)){
                break returnFalse;
              }
              #MACRO ReturnUncheckedQueryBits($convertToBits$(l))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Short||val instanceof Byte){
            final int i;
            if((i=((Number)val).shortValue())!=0){
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Character){
            final int i;
            if((i=(char)val)!=0){
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Boolean){
            if((boolean)val){
              #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
            }
            #MACRO ReturnUncheckedQuery0()
          }else{
            break returnFalse;
          }
    #ELSE
          if(val instanceof Double){
            final double d;
            if((d=(double)val)==d){
               #MACRO ReturnUncheckedQueryBits($convertToBits$(d))
            }
            #MACRO ReturnUncheckedQueryNaN()
          }else if(val instanceof Float){
            final float f;
            if((f=(float)val)==f){
               #MACRO ReturnUncheckedQueryBits($convertToBits$(f))
            }
            #MACRO ReturnUncheckedQueryNaN()
          }else if(val instanceof Integer|| val instanceof Short||val instanceof Byte){
            final int i;
            if((i=((Number)val).intValue())!=0){
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Long){
            final long l;
            if((l=(long)val)!=0){
              if(!TypeUtil.checkCastToDouble(l)){
                break returnFalse;
              }
              #MACRO ReturnUncheckedQueryBits($convertToBits$(l))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Character){
            final int i;
            if((i=(char)val)!=0){
              #MACRO ReturnUncheckedQueryBits($convertToBits$(i))
            }
            #MACRO ReturnUncheckedQuery0()
          }else if(val instanceof Boolean){
            if((boolean)val){
              #MACRO ReturnUncheckedQueryBits($TRUE_BITS$)
            }
            #MACRO ReturnUncheckedQuery0()
          }else{
            break returnFalse;
          }
    #ENDIF
        }
  #ENDIF
#ELSE
        if(val!=null){
          #MACRO ReturnUncheckedQuery($queryCastRef$(CAST(val)))
        }
        #MACRO ReturnUncheckedQueryNull()
#ENDIF
      } //end size check
    } //end checked sublist try modcount
    #MACRO CheckedSubListQueryFinallyModCount()
  }//end val check
#IFSWITCH METHODNAME==search,indexOf,lastIndexOf
  return -1;
#ELSE
  #MACRO CheckedSubListRemoveValModCountCheck()
  return false;
#ENDIF
}
#ENDDEF
#MACRODEF UncheckedQueryParam()
#IFSWITCH SUFFIX==NonNull
,Object nonNull
#ELSEIFSWITCH SUFFIX==Bits
,$queryParameterType$ bits
#ELSEIFSWITCH SUFFIX==Null,0,NaN
#ELSE
  #IF OfRef
,$TypeNameModifier$Predicate$<? super E>$ pred
  #ELSE
,$queryParameterType$ val
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF UncheckedRemoveVal<STRUCTNAME,CHECKED,SUFFIX>(POSTEST)
boolean uncheckedremoveValSUFFIX($DNode$$<E>$ head
#MACRO UncheckedQueryParam()
){
#IFSWITCH STRUCTNAME==Root
  #IFSWITCH CHECKED==true
    #IFSWITCH SUFFIX==NonNull
  int modCount=this.modCount;
  int size=this.size;
  try{
    if(POSTEST(head.val)){
      CheckedCollection.checkModCount(modCount,this.modCount);
      this.modCount=modCount+1;
      if(--size==0){
        this.head=null;
        this.tail=null;
      }else{
        this.head=head=head.next;
        head.prev=null;
      }
      this.size=size;
      return true;
    }
    int numLeft=--size;
    for(;numLeft!=0;--numLeft){
      $DNode$$<E>$ prev;
      if(POSTEST((head=(prev=head).next).val)){
        CheckedCollection.checkModCount(modCount,this.modCount);
        this.modCount=modCount+1;
        if(numLeft==1){
          this.tail=prev;
          prev.next=null;
        }else{
          (head=head.next).prev=prev;
          prev.next=head;
        }
        this.size=size;
        return true;
      }
    }
  }catch(ConcurrentModificationException e){
    throw e;
  }catch(RuntimeException e){
    throw CheckedCollection.checkModCount(modCount,this.modCount,e);
  }
  CheckedCollection.checkModCount(modCount,this.modCount);
    #ELSE
  {
    if(POSTEST(head.val)){
      ++this.modCount;
      if(--size==0){
        this.head=null;
        this.tail=null;
      }else{
        this.head=head=head.next;
        head.prev=null;
      }
      return true;
    }
    for($DNode$$<E>$ prev;(head=(prev=head).next)!=null;){
      if(POSTEST(head.val)){
        ++this.modCount;
        if((head=head.next)==null){
          this.tail=prev;
          prev.next=null;
        }else{
          head.prev=prev;
          prev.next=head;
        }
        --size;
        return true;
      }
    }
  }
    #ENDIF
  #ELSE
  {
    if(POSTEST(head.val)){
      if(--size==0){
        this.head=null;
        this.tail=null;
      }else{
        this.head=head=head.next;
        head.prev=null;
      }
      return true;
    }
    for($DNode$$<E>$ prev;(head=(prev=head).next)!=null;){
      if(POSTEST(head.val)){
        if((head=head.next)==null){
          this.tail=prev;
          prev.next=null;
        }else{
          head.prev=prev;
          prev.next=head;
        }
        --size;
        return true;
      }
    }
  }
  #ENDIF
#ELSE
  #IFSWITCH CHECKED==true
    #IFSWITCH SUFFIX==NonNull
  int modCount=this.modCount;
  final var root=this.root;
  int size=this.size;
  try
    #ELSE
  int modCount;
  final CheckedList$<E>$ root;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
    #ENDIF
  {
    if(POSTEST(head.val)){
    #IFSWITCH SUFFIX==NonNull
      CheckedCollection.checkModCount(modCount,root.modCount);
    #ENDIF
      root.modCount=++modCount;
      this.modCount=modCount;
      --root.size;
      if(--this.size==0){
        removeLastNode(head);
      }else{
        peelHead(head);
      }
      return true;
    }
    #IFSWITCH SUFFIX==NonNull
    for(int numLeft=--size;numLeft!=0;--numLeft){
      $DNode$$<E>$ prev;
      if(POSTEST((head=(prev=head).next).val)){
        CheckedCollection.checkModCount(modCount,root.modCount);
        root.modCount=++modCount;
        this.modCount=modCount;
        --root.size;
        this.size=size;
        if(numLeft==1){
          peelTail(prev,head);
        }else{
          prev.next=head=head.next;
          head.prev=prev;
          bubbleUpDecrementSize();
        }
        return true;
      }
    }
    #ELSE
    for(final var tail=this.tail;head!=tail;){
      $DNode$$<E>$ prev;
      if(POSTEST((head=(prev=head).next).val)){
        root.modCount=++modCount;
        this.modCount=modCount;
        --root.size;
        --this.size;
        if(head==tail){
          peelTail(prev,head);
        }else{
          prev.next=head=head.next;
          head.prev=prev;
          bubbleUpDecrementSize();
        }
        return true;
      }
    }
    #ENDIF
  }
    #IFSWITCH SUFFIX==NonNull
  catch(ConcurrentModificationException e){
    throw e;
  }catch(RuntimeException e){
    throw CheckedCollection.checkModCount(modCount,root.modCount,e);
  }
  CheckedCollection.checkModCount(modCount,root.modCount);
    #ENDIF
  #ELSE
  if(POSTEST(head.val)){
    --root.size;
    if(--this.size==0){
      removeLastNode(head);
    }else{
      peelHead(head);
    }
    return true;
  }else{
    for(final var tail=this.tail;tail!=head;){
      $DNode$$<E>$ prev;
      if(POSTEST((head=(prev=head).next).val)){
        --root.size;
        --this.size;
        if(head==tail){
          peelTail(prev,head);
        }else{
          prev.next=head=head.next;
          head.prev=prev;
          bubbleUpDecrementSize();
        }
        return true;
      }
    }
  }
  #ENDIF
#ENDIF
  return false;
}
#ENDDEF
#MACRODEF UncheckedRemoveLastOccurrence<CHECKED,SUFFIX>(POSTEST)
boolean uncheckedremoveLastOccurrenceSUFFIX($DNode$$<E>$ tail
#MACRO UncheckedQueryParam()
){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
  int modCount=this.modCount;
  int size=this.size;
  try
  #ENDIF
#ENDIF
  {
    if(POSTEST(tail.val)){
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
      CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
      this.modCount=modCount+1;
#ENDIF
      if((tail=tail.prev)==null){
        this.head=null;
        this.tail=null;
      }else{
        this.tail=tail;
        tail.next=null;
      }
#IFSWITCH SUFFIX==NonNull
      this.size=size-1;
#ELSE
      --this.size;
#ENDIF
      return true;
    }
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
    int numLeft=--size;
    for(;numLeft!=0;--numLeft){
      $DNode$$<E>$ next;
      if(POSTEST((tail=(next=tail).prev).val)){
        CheckedCollection.checkModCount(modCount,this.modCount);
        this.modCount=modCount+1;
        if(numLeft==1)
        {
          this.head=next;
          next.prev=null;
        }else{
          (tail=tail.prev).next=next;
          next.prev=tail;
        }
        this.size=size;
        return true;
      }
    }
  #ELSE
    for($DNode$$<E>$ next;(tail=(next=tail).prev)!=null;){
      if(POSTEST(tail.val)){
        this.modCount=modCount+1;
        if((tail=tail.prev)==null){
          this.head=next;
          next.prev=null;
        }else{
          tail.next=next;
          next.prev=tail;
        }
        --this.size;
        return true;
      }
    }
  #ENDIF
#ELSE
    for($DNode$$<E>$ next;(tail=(next=tail).prev)!=null;){
      if(POSTEST(tail.val)){
        if((tail=tail.prev)==null){
          this.head=next;
          next.prev=null;
        }else{
          tail.next=next;
          next.prev=tail;
        }
        --this.size;
        return true;
      }
    }
#ENDIF
  }
#IFSWITCH CHECKED==true
  #IFSWITCH SUFFIX==NonNull
  catch(ConcurrentModificationException e){
    throw e;
  }catch(RuntimeException e){
    throw CheckedCollection.checkModCount(modCount,this.modCount,e);
  }
  CheckedCollection.checkModCount(modCount,this.modCount);
  #ENDIF
#ENDIF
  return false;
}
#ENDDEF
#MACRODEF OutputMethods<CHECKED>(MACRONAME)
#MACRO MACRONAME($TypeNameModifier$,$exposedType$,$defaultVal$,)
#IFNOT OfRef
#MACRO MACRONAME(,$BoxedType$,null,)
  #IFNOT OfDouble
#MACRO MACRONAME(Double,double,Double.NaN,$castToDouble$)
    #IFNOT OfFloat
#MACRO MACRONAME(Float,float,Float.NaN,$castToFloat$)
      #IFNOT OfLong
#MACRO MACRONAME(Long,long,Long.MIN_VALUE,$castToLong$)
        #IFNOT OfInt
#MACRO MACRONAME(Int,int,Integer.MIN_VALUE,$castToInt$)
          #IFNOT OfShort,OfChar
#MACRO MACRONAME(Short,short,Short.MIN_VALUE,$castToShort$)
            #IFNOT OfByte
#MACRO MACRONAME(Byte,byte,Byte.MIN_VALUE,$castToByte$)
#MACRO MACRONAME(Char,char,Character.MIN_VALUE,$castToChar$)
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDIF
#ENDDEF
#MACRODEF PollImpl(CLASSPREFIX,RETTYPE,DEFAULTVAL,CAST)
@Override public RETTYPE pollCLASSPREFIX(){
  $DNode$$<E>$ head;
  if((head=this.head)!=null){
#IFSWITCH CHECKED==true
    ++this.modCount;
#ENDIF
    final var ret=CAST(head.val);
    if(--this.size==0){
      this.head=null;
      this.tail=null;
    }else{
      (head=head.next).prev=null;
      this.head=head;
    }
    return ret;
  }
  return DEFAULTVAL;
}
@Override public RETTYPE pollLastCLASSPREFIX(){
  $DNode$$<E>$ tail;
  if((tail=this.tail)!=null){
#IFSWITCH CHECKED==true
    ++this.modCount;
#ENDIF
    final var ret=CAST(tail.val);
    if(--this.size==0){
      this.head=null;
      this.tail=null;
    }else{
      (tail=tail.prev).next=null;
      this.tail=tail;
    }
    return ret;
  }
  return DEFAULTVAL;
}
#ENDDEF
#MACRODEF PeekImpl(CLASSPREFIX,RETTYPE,DEFAULTVAL,CAST)
@Override public RETTYPE peekCLASSPREFIX(){
  final $DNode$$<E>$ head;
  if((head=this.head)!=null){
    return CAST(head.val);
  }
  return DEFAULTVAL;
}
@Override public RETTYPE peekLastCLASSPREFIX(){
  final $DNode$$<E>$ tail;
  if((tail=this.tail)!=null){
    return CAST(tail.val);
  }
  return DEFAULTVAL;
}
#ENDDEF

#MACRODEF NonComparatorSortImpl<STABLE,STRUCTNAME,CHECKED,DIRECTION>()
#IFSWITCH STABLE==Stable
@Override public void stableDIRECTIONSort()
#ELSE
@Override public void unstableDIRECTIONSort()
#ENDIF
{
  //todo: see about making an in-place sort implementation rather than copying to an array
#IFSWITCH CHECKED==true
  #IFSWITCH STRUCTNAME==SubList
    #IF OfRef
  final int size;
  if((size=this.size)>1){
    final $ArrayType$[] tmp;
    final $DNode$$<E>$ tail;
    $DNode$.uncheckedCopyInto(tmp=new $ArrayType$[size],tail=this.tail,size);
    final CheckedList$<E>$ root;
    int modCount=this.modCount;
    try{
      $ClassPrefix$SortUtil.uncheckedSTABLEDIRECTIONSort(tmp,0,size);
    }catch(ArrayIndexOutOfBoundsException e){
      throw new IllegalArgumentException("Comparison method violates its general contract!",e);
    }finally{
      CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
    }
    root.modCount=++modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,curr=curr.parent){}
    this.modCount=modCount;
    $DNode$.uncheckedCopyFrom(tmp,size,tail);
  }else{
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
    #ELSE
  int modCount;
  final CheckedList$<E>$ root;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
  final int size;
  if((size=this.size)>1){
    final $ArrayType$[] tmp;
    final $DNode$$<E>$ tail;
    $DNode$.uncheckedCopyInto(tmp=new $ArrayType$[size],tail=this.tail,size);
    root.modCount=++modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,curr=curr.parent){}
    this.modCount=modCount;
    $ClassPrefix$SortUtil.uncheckedDIRECTIONSort(tmp,0,size);
    $DNode$.uncheckedCopyFrom(tmp,size,tail);
  }
    #ENDIF
  #ELSE
  final int size;
  if((size=this.size)>1){
    final $ArrayType$[] tmp;
    final $DNode$$<E>$ tail;
    $DNode$.uncheckedCopyInto(tmp=new $ArrayType$[size],tail=this.tail,size);
    #IF OfRef
    int modCount=this.modCount;
    try{
      $ClassPrefix$SortUtil.uncheckedSTABLEDIRECTIONSort(tmp,0,size);
    }catch(ArrayIndexOutOfBoundsException e){
      throw new IllegalArgumentException("Comparison method violates its general contract!",e);
    }finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
    #ELSE
    $ClassPrefix$SortUtil.uncheckedDIRECTIONSort(tmp,0,size);
    #ENDIF
    this.modCount=modCount+1;
    $DNode$.uncheckedCopyFrom(tmp,size,tail);
  }
  #ENDIF
#ELSE
  final int size;
  if((size=this.size)>1){
    final $ArrayType$[] tmp;
    final $DNode$$<E>$ tail;
    $DNode$.uncheckedCopyInto(tmp=new $ArrayType$[size],tail=this.tail,size);
  #IF OfRef
    $ClassPrefix$SortUtil.uncheckedSTABLEDIRECTIONSort(tmp,0,size);
  #ELSE
    $ClassPrefix$SortUtil.uncheckedDIRECTIONSort(tmp,0,size);
  #ENDIF
    $DNode$.uncheckedCopyFrom(tmp,size,tail);
  }
#ENDIF
}
#ENDDEF
#MACRODEF ComparatorSortImpl<STABLE,STRUCTNAME,CHECKED>(COMPARATOR,COMPARE)
#IFSWITCH STABLE==Stable
@Override public void sort(COMPARATOR sorter){
#ELSE
@Override public void unstableSort(COMPARATOR sorter){
#ENDIF
  //todo: see about making an in-place sort implementation rather than copying to an array
#IFSWITCH CHECKED==true
  #IFSWITCH STRUCTNAME==SubList
  final int size;
  if((size=this.size)>1){
    int modCount=this.modCount;
    final CheckedList$<E>$ root;
    final $ArrayType$[] tmp;
    final $DNode$$<E>$ tail;
    #IF OfRef
    $DNode$.uncheckedCopyInto(tmp=new $ArrayType$[size],tail=this.tail,size);
    try{
      if(sorter==null){
        $ClassPrefix$SortUtil.uncheckedSTABLEAscendingSort(tmp,0,size);
      }else{
        $ClassPrefix$SortUtil.uncheckedSTABLESort(tmp,0,size,COMPARE);
      }
    }catch(ArrayIndexOutOfBoundsException e){
      throw new IllegalArgumentException("Comparison method violates its general contract!",e);
    }finally{
      CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
    }
    #ELSE
    if(sorter==null){
      CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
      $DNode$.uncheckedCopyInto(tmp=new $ArrayType$[size],tail=this.tail,size);
      $ClassPrefix$SortUtil.uncheckedAscendingSort(tmp,0,size);
    }else{
      $DNode$.uncheckedCopyInto(tmp=new $ArrayType$[size],tail=this.tail,size);
      try{
      #IF OfBoolean
        $ClassPrefix$SortUtil.uncheckedSort(tmp,0,size,COMPARE);
      #ELSE
        $ClassPrefix$SortUtil.uncheckedSTABLESort(tmp,0,size,COMPARE);
      #ENDIF
      }catch(ArrayIndexOutOfBoundsException e){
        throw new IllegalArgumentException("Comparison method violates its general contract!",e);
      }finally{
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
      }
    }
    #ENDIF
    root.modCount=++modCount;
    for(var curr=parent;curr!=null;curr.modCount=modCount,curr=curr.parent){}
    this.modCount=modCount;
    $DNode$.uncheckedCopyFrom(tmp,size,tail);
  }else{
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
  #ELSE
  final int size;
  if((size=this.size)>1){
    final $ArrayType$[] tmp;
    final $DNode$$<E>$ tail;
    $DNode$.uncheckedCopyInto(tmp=new $ArrayType$[size],tail=this.tail,size);
    #IF OfRef
    int modCount=this.modCount;
    try{
      if(sorter==null){
        $ClassPrefix$SortUtil.uncheckedSTABLEAscendingSort(tmp,0,size);
      }else{
        $ClassPrefix$SortUtil.uncheckedSTABLESort(tmp,0,size,COMPARE);
      }
    }catch(ArrayIndexOutOfBoundsException e){
      throw new IllegalArgumentException("Comparison method violates its general contract!",e);
    }finally{
      CheckedCollection.checkModCount(modCount,this.modCount);
    }
    this.modCount=modCount+1;
    #ELSE   
    if(sorter==null){
      $ClassPrefix$SortUtil.uncheckedAscendingSort(tmp,0,size);
      ++this.modCount;
    }else{
      int modCount=this.modCount;
      try{
      #IF OfBoolean
        $ClassPrefix$SortUtil.uncheckedSort(tmp,0,size,COMPARE);
      #ELSE
        $ClassPrefix$SortUtil.uncheckedSTABLESort(tmp,0,size,COMPARE);
      #ENDIF
      }catch(ArrayIndexOutOfBoundsException e){
        throw new IllegalArgumentException("Comparison method violates its general contract!",e);
      }finally{
        CheckedCollection.checkModCount(modCount,this.modCount);
      }
      this.modCount=modCount+1;
    }
    #ENDIF
    $DNode$.uncheckedCopyFrom(tmp,size,tail);
  }
  #ENDIF
#ELSE
  final int size;
  if((size=this.size)>1){
    final $ArrayType$[] tmp;
    final $DNode$$<E>$ tail;
    $DNode$.uncheckedCopyInto(tmp=new $ArrayType$[size],tail=this.tail,size);
    if(sorter==null){
  #IF OfRef
      $ClassPrefix$SortUtil.uncheckedSTABLEAscendingSort(tmp,0,size);
  #ELSE
      $ClassPrefix$SortUtil.uncheckedAscendingSort(tmp,0,size);
  #ENDIF
    }else{
  #IF OfBoolean
      $ClassPrefix$SortUtil.uncheckedSort(tmp,0,size,COMPARE);
  #ELSE
      $ClassPrefix$SortUtil.uncheckedSTABLESort(tmp,0,size,COMPARE);
  #ENDIF
    }
    $DNode$.uncheckedCopyFrom(tmp,size,tail);
  }
#ENDIF
}
#ENDDEF
#MACRODEF SubListAddMethods<CHECKED>()
private void bubbleUpIncrementSize(){
  for(var curr=parent;curr!=null;++curr.size,curr=curr.parent){
#IFSWITCH CHECKED==Checked
    ++curr.modCount;
#ENDIF
  }
}
private void bubbleUpAppend($DNode$$<E>$ oldTail,$DNode$$<E>$ newTail){
  oldTail.next=newTail;
  this.tail=newTail;
  for(var currList=parent;currList!=null;currList.tail=newTail,currList=currList.parent){
#IFSWITCH CHECKED==Checked
    ++currList.modCount;
#ENDIF
    ++currList.size;
    if(currList.tail!=oldTail){
      currList.bubbleUpIncrementSize();
      return;
    }
  }
}
private void bubbleUpAppend($DNode$$<E>$ newTail){
  this.tail=newTail;
  for(var currList=parent;currList!=null;++currList.size,currList.tail=newTail,currList=currList.parent){
#IFSWITCH CHECKED==Checked
    ++currList.modCount;
#ENDIF  
  }
}
private void bubbleUpPrepend($DNode$$<E>$ oldHead,$DNode$$<E>$ newHead){
  this.head=newHead;
  for(var currList=parent;currList!=null;currList.head=newHead,currList=currList.parent){
#IFSWITCH CHECKED==Checked
    ++currList.modCount;
#ENDIF
    ++currList.size;
    if(currList.head!=oldHead){
      currList.bubbleUpIncrementSize();
      return;
    }
  }
}
private void bubbleUpPrepend($DNode$$<E>$ newHead){
  this.head=newHead;
  for(var currList=parent;currList!=null;++currList.size,currList.head=newHead,currList=currList.parent){
#IFSWITCH CHECKED==Checked
    ++currList.modCount;
#ENDIF  
  }
}
private void bubbleUpRootInit($DNode$$<E>$ newNode){
  this.head=newNode;
  this.tail=newNode;
  for(var parent=this.parent;parent!=null;parent=parent.parent){
#IFSWITCH CHECKED==Checked
    ++parent.modCount;
#ENDIF
    parent.size=1;
    parent.head=newNode;
    parent.tail=newNode;
  }
}
private void bubbleUpInitHelper(int index,int size,$DNode$$<E>$ newNode){
  $DNode$$<E>$ after,before;   
  if((size-=index)<=index){
    before=this.tail;
    if(size==1){
      if((after=before.next)==null){
        this.bubbleUpAppend(newNode);
        root.tail=newNode;
      }else{
        this.bubbleUpAppend(before,newNode);
        after.prev=newNode;
      }
    }else{
      this.bubbleUpIncrementSize();
      before=(after=$DNode$.iterateDescending(before,size-2)).prev;
      after.prev=newNode;
    }
    before.next=newNode;        
  }else{
    after=this.head;
    if(index==0){
      if((before=after.prev)==null){
        this.bubbleUpPrepend(newNode);
        root.head=newNode;
      }else{
        this.bubbleUpPrepend(after,newNode);
        before.next=newNode;
      }
    }else{
      this.bubbleUpIncrementSize();
      after=(before=$DNode$.iterateAscending(after,index-1)).next;
      before.next=newNode;
    }
    after.prev=newNode;
  }
  newNode.next=after;
  newNode.prev=before;
}
private void bubbleUpInit($DNode$$<E>$ newNode){
  this.head=newNode;
  this.tail=newNode;
  CHECKEDSubList$<E>$ curr;
  for(var currParent=(curr=this).parent;currParent!=null;currParent=(curr=currParent).parent){
#IFSWITCH CHECKED==Checked
    ++currParent.modCount;
#ENDIF
    int parentSize;
    if((parentSize=++currParent.size)!=1){
      currParent.bubbleUpInitHelper(curr.parentOffset,parentSize,newNode);
      return;
    }
    currParent.head=newNode;
    currParent.tail=newNode;
  }
  (($ClassPrefix$DblLnkSeq$<E>$)root).insertNode(curr.parentOffset,newNode);
}
@Override public void add(int index,$exposedType$ val){
  final CHECKEDList$<E>$ root;
#IFSWITCH CHECKED==Checked
  int modCount;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
  CheckedCollection.checkLo(index);
  int currSize;
  CheckedCollection.checkWriteHi(index,currSize=this.size);
  root.modCount=++modCount;
  this.modCount=modCount;
  final var newNode=new $DNode$$<E>$(val);
  if(++root.size!=1){
    this.size=++currSize;
    if(currSize!=1){    
#ELSE
  final var newNode=new $DNode$$<E>$(val);
  if(++(root=this.root).size!=1){
    final int currSize;
    if((currSize=++this.size)!=1){
#ENDIF
      bubbleUpInitHelper(index,currSize,newNode);
    }else{
      bubbleUpInit(newNode);
    }
  }else{
    bubbleUpRootInit(newNode);
    this.size=1;
    root.head=newNode;
    root.tail=newNode;
  }
}
@Override void addLast($exposedType$ val){
  final CHECKEDList$<E>$ root;
#IFSWITCH CHECKED==Checked
  int modCount;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
  root.modCount=++modCount;
  this.modCount=modCount;
  if(++root.size!=1){
#ELSE
  if(++(root=this.root).size!=1){
#ENDIF
    if(++this.size!=1){
      $DNode$$<E>$ currTail,after;
      if((after=(currTail=this.tail).next)==null){
        currTail.next=currTail=new $DNode$$<E>$(currTail,val);
        bubbleUpAppend(currTail);
        root.tail=currTail;
      }else{
        bubbleUpAppend(currTail,currTail=new $DNode$$<E>$(currTail,val,after));
        after.prev=currTail;
      }
    }else{
      bubbleUpInit(new $DNode$$<E>$(val));
    }
  }else{
    $DNode$$<E>$ newNode;
    bubbleUpRootInit(newNode=new $DNode$$<E>$(val));
    this.size=1;
    root.head=newNode;
    root.tail=newNode;
  }
}
#ENDDEF
#MACRODEF RootRemoveMethods<CHECKED>()
@Override public $exposedType$ removeLast$TypeNameModifier$(){
  $DNode$$<E>$ tail;
#IFSWITCH CHECKED==Checked
  if((tail=this.tail)!=null){
    ++this.modCount;
    final var ret=tail.val;
#ELSE
  final var ret=(tail=this.tail).val;{
#ENDIF
  if(--size==0){
      this.head=null;
      this.tail=null;
    }else{
      (tail=tail.prev).next=null;
      this.tail=tail;
    }
    return ret;
  }
#IFSWITCH CHECKED==Checked
  throw new NoSuchElementException();
#ENDIF
}
@Override public $exposedType$ pop$TypeNameModifier$(){
  $DNode$$<E>$ head;
#IFSWITCH CHECKED==Checked
  if((head=this.head)!=null){
    ++this.modCount;
    final var ret=head.val;
#ELSE
  final var ret=(head=this.head).val;{
#ENDIF
  if(--size==0){
      this.head=null;
      this.tail=null;
    }else{
      (head=head.next).prev=null;
      this.head=head;
    }
    return ret;
  }
#IFSWITCH CHECKED==Checked
  throw new NoSuchElementException();
#ENDIF
}
@Override public $exposedType$ $removeAtIndexMethod$(int index){
  final $exposedType$ ret;
#IFSWITCH CHECKED==Checked
  CheckedCollection.checkLo(index);
  int size;
  CheckedCollection.checkReadHi(index,size=this.size);
  ++this.modCount;
  this.size=--size;
  if((size-=index)<=index){
#ELSE
  int size;
  if((size=--this.size-index)<=index){
#ENDIF
    //the node to remove is closer to the tail
    var tail=this.tail;
    if(size==0){
      //the node to the remove IS the tail
      ret=tail.val;
      if(index==0){
        //the node is the last node
        this.head=null;
        this.tail=null;
      }else{
        //peel off the tail
        this.tail=tail=tail.prev;
        tail.next=null;
      }
    }else{
      //iterate from the tail
      $DNode$$<E>$ before;
      ret=(before=(tail=$DNode$.iterateDescending(tail,size-1)).prev).val;
      (before=before.prev).next=tail;
      tail.prev=before;
    }
  }else{
    //the node to remove is close to the head
    var head=this.head;
    if(index==0){
      //peel off the head
      ret=head.val;
      this.head=head=head.next;
      head.prev=null;
    }else{
      //iterate from the head
      $DNode$$<E>$ after;
      ret=(after=(head=$DNode$.iterateAscending(head,index-1)).next).val;
      (after=after.next).prev=head;
      head.next=after;
    }
  }
  return ret;
}
#ENDDEF
#MACRODEF RootAddMethods<CHECKED>()
@Override public void add(int index,$exposedType$ val){
  int size;
#IFSWITCH CHECKED==Checked
  CheckedCollection.checkLo(index);
  CheckedCollection.checkWriteHi(index,size=this.size);
  ++this.modCount;
  this.size=++size;
  if((size-=index)<=index){
#ELSE
  if((size=++this.size-index)<=index){
#ENDIF
    //the insertion point is closer to the tail
    var tail=this.tail;
    if(size==1){
      //the insertion point IS the tail
      tail.next=tail=new $DNode$$<E>$(tail,val);
      this.tail=tail;
    }else{
      //iterate from the tail and insert
      $DNode$$<E>$ before;
      (before=(tail=$DNode$.iterateDescending(tail,size-2)).prev).next=before=new $DNode$$<E>$(before,val,tail);
      tail.prev=before;
    }
  }else{
    //the insertion point is closer to the head
    $DNode$$<E>$ head;
    if((head=this.head)==null){
      //initialize the list
      this.head=head=new $DNode$$<E>$(val);
      this.tail=head;
    }else if(index==0){
      //the insertion point IS the head
      head.prev=head=new $DNode$$<E>$(val,head);
      this.head=head;
    }else{
      //iterate from the head and insert
      $DNode$$<E>$ after;
      (after=(head=$DNode$.iterateAscending(head,index-1)).next).prev=after=new $DNode$$<E>$(head,val,after);
      head.next=after;
    }
  }
}
#IFSWITCH CHECKED==Checked
@Override public void addLast($exposedType$ val){
  ++this.modCount;
  super.addLast(val);
}
@Override public void push($exposedType$ val){
  ++this.modCount;
  super.push(val);
}
#ELSE
@Override public void addLast($exposedType$ val){
  $DNode$$<E>$ tail;
  if((tail=this.tail)==null){
    this.head=tail=new $DNode$$<E>$(val);
  }else{
    tail.next=tail=new $DNode$$<E>$(tail,val);
  }
  this.tail=tail;
  ++this.size;
}
@Override public void push($exposedType$ val){
  $DNode$$<E>$ head;
  if((head=this.head)==null){
    tail=head=new $DNode$$<E>$(val);
  }else{
    head.prev=head=new $DNode$$<E>$(val,head);
  }
  this.head=head;
  ++this.size;
}
#ENDIF
#ENDDEF
#MACRODEF SubListRemoveMethods<CHECKED>()
#IFNOT OfBoolean
  #IFSWITCH CHECKED==Checked
private static $<E>$ $DNode$$<E>$ pullSurvivorsDown($DNode$$<E>$ prev,long[] survivorSet,int numSurvivors,int numRemoved){
  int wordOffset;
  for(long word=survivorSet[wordOffset=0],marker=1L;;){
    var curr=prev.next;
    if((marker&word)==0){
      do{
        if(--numRemoved==0){
          prev.next=curr=curr.next;
          curr.prev=prev;
          return null;
        }else if((marker<<=1)==0){
          word=survivorSet[++wordOffset];
          marker=1L;
        }
        curr=curr.next;
      }while((marker&word)==0);
      prev.next=curr;
      curr.prev=prev;
    }
    if(--numSurvivors==0){
      return curr;
    }
    if((marker<<=1)==0){
       word=survivorSet[++wordOffset];
       marker=1L;
    }
    prev=curr;
  }
}
private static $<E>$ $DNode$$<E>$ pullSurvivorsDown($DNode$$<E>$ prev,long word,int numSurvivors,int numRemoved){
  for(long marker=1L;;marker<<=1){
    var curr=prev.next;
    if((marker&word)==0){
      do{
        if(--numRemoved==0){
          prev.next=curr=curr.next;
          curr.prev=prev;
          return null;
        }
        curr=curr.next;
      }while(((marker<<=1)&word)==0);
      prev.next=curr;
      curr.prev=prev;
    }
    if(--numSurvivors==0){
      return curr;
    }
    prev=curr;
  }
}
  #ENDIF
#ENDIF
private void bubbleUpPeelHead($DNode$$<E>$ newHead,$DNode$$<E>$ oldHead){
  newHead.prev=null;
  for(var curr=parent;curr!=null;curr=curr.parent){
    if(curr.tail!=oldHead){
      curr.bubbleUpPeelHead(newHead);
      break;
    }
#IFSWITCH CHECKED==Checked
    ++curr.modCount;
#ENDIF
    curr.size=0;
    curr.head=null;
    curr.tail=null;
  }
}
private void bubbleUpPeelHead($DNode$$<E>$ newHead){
  var curr=this;
  do{
#IFSWITCH CHECKED==Checked
    ++curr.modCount;
#ENDIF
    curr.head=newHead;
    --curr.size; 
  }while((curr=curr.parent)!=null);
}
private void bubbleUpPeelTail($DNode$$<E>$ newTail,$DNode$$<E>$ oldTail){
  newTail.next=null;
  for(var curr=parent;curr!=null;curr=curr.parent){
    if(curr.head!=oldTail){
      curr.bubbleUpPeelTail(newTail);
      break;
    }
#IFSWITCH CHECKED==Checked
    ++curr.modCount;
#ENDIF
    curr.size=0;
    curr.head=null;
    curr.tail=null;
  }
}
private void bubbleUpPeelTail($DNode$$<E>$ newTail){
  var curr=this;
  do{
#IFSWITCH CHECKED==Checked
    ++curr.modCount;
#ENDIF
    curr.tail=newTail;
    --curr.size;
  }while((curr=curr.parent)!=null);
}
private void uncheckedBubbleUpDecrementSize(){
  var curr=this;
  do{
#IFSWITCH CHECKED==Checked
    ++curr.modCount;
#ENDIF
    --curr.size;    
  }while((curr=curr.parent)!=null);
}
private void bubbleUpDecrementSize(){
   CHECKEDSubList$<E>$ parent;
   if((parent=this.parent)!=null){
     parent.uncheckedBubbleUpDecrementSize();
   }
}
private void peelTail($DNode$$<E>$ newTail,$DNode$$<E>$ oldTail){
  this.tail=newTail;
  $DNode$$<E>$ after;
  if((after=oldTail.next)==null){
    final CHECKEDSubList$<E>$ parent;
    if((parent=this.parent)!=null){
      parent.bubbleUpPeelTail(newTail);
    }
    root.tail=newTail;
  }else{
    after.prev=newTail;
    for(var curr=parent;curr!=null;curr=curr.parent){
      if(curr.tail!=oldTail){
        curr.uncheckedBubbleUpDecrementSize();
        break;
      }
#IFSWITCH CHECKED==Checked
      ++curr.modCount;
#ENDIF
      --curr.size;
      curr.tail=newTail;
    }
  }
  newTail.next=after;
}
private void peelTail($DNode$$<E>$ tail){
  $DNode$$<E>$ after,before;
  (before=tail.prev).next=(after=tail.next);
  this.tail=before;
  if(after==null){
    for(var curr=this.parent;curr!=null;curr=curr.parent){
#IFSWITCH CHECKED==Checked
      ++curr.modCount;
#ENDIF
      --curr.size;
      curr.tail=before;
    }
    root.tail=before;
  }else{
    after.prev=before;
    for(var curr=this.parent;curr!=null;curr=curr.parent){
      if(curr.tail!=tail){
        curr.uncheckedBubbleUpDecrementSize();
        break;
      }
#IFSWITCH CHECKED==Checked
      ++curr.modCount;
#ENDIF
      --curr.size;
      curr.tail=before;
    }
  }
}
private void removeLastNode($DNode$$<E>$ lastNode){
  $DNode$$<E>$ after,before=lastNode.prev;
  if((after=lastNode.next)==null){
    CHECKEDList$<E>$ root;
    (root=this.root).tail=before;
    if(before==null){
      for(var curr=parent;curr!=null;
#IFSWITCH CHECKED==Checked
      ++curr.modCount,
#ENDIF
      curr.head=null,curr.tail=null,curr.size=0,curr=curr.parent){}
      root.head=null;
    }else{
      bubbleUpPeelTail(before,lastNode);
    }
  }else{
    if(before==null){
      bubbleUpPeelHead(after,lastNode);
      root.head=after;
    }else{
      after.prev=before;
      before.next=after;
      for(var curr=parent;curr!=null;curr=curr.parent){
        if(curr.head!=lastNode){
          do{
            if(curr.tail!=lastNode){
              curr.uncheckedBubbleUpDecrementSize();
              break;
            }
#IFSWITCH CHECKED==Checked
            ++curr.modCount;
#ENDIF
            --curr.size;
            curr.tail=before;
          }while((curr=curr.parent)!=null);
          break;
        }
        if(curr.tail!=lastNode){
          for(;;){
#IFSWITCH CHECKED==Checked
            ++curr.modCount;
#ENDIF
            --curr.size;
            curr.head=after;
            if((curr=curr.parent)==null){
              break;
            }
            if(curr.head!=lastNode){
              curr.uncheckedBubbleUpDecrementSize();
              break;
            }
          }
          break;
        }
#IFSWITCH CHECKED==Checked
        ++curr.modCount;
#ENDIF
        curr.head=null;
        curr.tail=null;
        curr.size=0;
      }
    }
  }
  this.head=null;
  this.tail=null;
}
private void peelHead($DNode$$<E>$ head){
  $DNode$$<E>$ after,before;
  (after=head.next).prev=(before=head.prev);
  this.head=after;
  if(before==null){
    for(var curr=this.parent;curr!=null;curr=curr.parent){
#IFSWITCH CHECKED==Checked
      ++curr.modCount;
#ENDIF
      --curr.size;
      curr.head=after;
    }
    root.head=after;
  }else{
    before.next=after;
    for(var curr=this.parent;curr!=null;curr=curr.parent){
      if(curr.head!=head){
        curr.uncheckedBubbleUpDecrementSize();
        break;
      }
#IFSWITCH CHECKED==Checked
      ++curr.modCount;
#ENDIF
      --curr.size;
      curr.head=after;
    }
  }
}
@Override public $exposedType$ $removeAtIndexMethod$(int index){
  final $exposedType$ ret;
  int size;
#IFSWITCH CHECKED==Checked
  final CHECKEDList$<E>$ root;
  int modCount;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
  CheckedCollection.checkLo(index);
  CheckedCollection.checkReadHi(index,size=this.size);
  root.modCount=++modCount;
  this.modCount=modCount;
  this.size=--size;
  if((size-=index)<=index){
#ELSE
  if((size=(--this.size)-index)<=index){
#ENDIF
    var tail=this.tail;
    if(size==0){
      ret=tail.val;
      if(index==0){
        removeLastNode(tail);
      }else{
        peelTail(tail);
      }
    }else{
      $DNode$$<E>$ before;
      ret=(before=( tail=$DNode$.iterateDescending(tail,size-1)).prev).val;
      (before=before.prev).next=tail;
      tail.prev=before;
      bubbleUpDecrementSize();
    }
  }else{
    var head=this.head;
    if(index==0){
      ret=head.val;
      peelHead(head);
    }else{
      $DNode$$<E>$ after;
      ret=(after=(head=$DNode$.iterateAscending(head,index-1)).next).val;
      (after=after.next).prev=head;
      head.next=after;
      bubbleUpDecrementSize();
    }
  }
  --root.size;
  return ret;
}
@Override public boolean removeIf($TypeNameModifier$Predicate$<? super E>$ filter){
  final $DNode$$<E>$ head;
#IFSWITCH CHECKED==Checked
  if((head=this.head)!=null){
    return uncheckedRemoveIf(head,filter);
  }else{
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
  return false;
#ELSE
  return (head=this.head)!=null && uncheckedRemoveIf(head,filter);
#ENDIF
}
#IFNOT OfRef
@Override public boolean removeIf(Predicate<? super $BoxedType$> filter){
  final $DNode$$<E>$ head;
  #IFSWITCH CHECKED==Checked
  if((head=this.head)!=null){
    return uncheckedRemoveIf(head,filter::test);
  }else{
    CheckedCollection.checkModCount(modCount,root.modCount);
  }
  return false;
  #ELSE
  return (head=this.head)!=null && uncheckedRemoveIf(head,filter::test);
  #ENDIF
}
#ENDIF
#MACRO CollapseEnd<head>(tail,next,prev)
#MACRO CollapseEnd<tail>(head,prev,next)
private void bubbleUpCollapseHeadAndTail($DNode$$<E>$ oldHead,$DNode$$<E>$ newHead,int numRemoved,$DNode$$<E>$ newTail,$DNode$$<E>$ oldTail){
  this.head=newHead;
  this.tail=newTail;
  final $DNode$$<E>$ after,before=oldHead.prev;
  if((after=oldTail.next)==null){
    if(before==null){
      for(var parent=this.parent;parent!=null;
#IFSWITCH CHECKED==Checked
      ++parent.modCount,
#ENDIF
      parent.size-=numRemoved,parent.head=newHead,parent.tail=newTail,parent=parent.parent){}
      CHECKEDList$<E>$ root;
      (root=this.root).head=newHead;
      root.tail=newTail;
    }else{
      before.next=newHead;
      for(var parent=this.parent;parent!=null;
#IFSWITCH CHECKED==Checked
        ++parent.modCount,
#ENDIF
        parent.size-=numRemoved,parent.head=newHead,parent.tail=newTail,parent=parent.parent){
        if(parent.head!=oldHead){
          do{
#IFSWITCH CHECKED==Checked
            ++parent.modCount;
#ENDIF
            parent.size-=numRemoved;
            parent.tail=newTail;
          }while((parent=parent.parent)!=null);
          break;
        }
      }
      root.tail=newTail;
    }
  }else{
    after.prev=newTail;
    if(before==null){
      for(var parent=this.parent;parent!=null;
#IFSWITCH CHECKED==Checked
        ++parent.modCount,
#ENDIF
        parent.size-=numRemoved,parent.head=newHead,parent.tail=newTail,parent=parent.parent){
        if(parent.tail!=oldTail){
          do{
#IFSWITCH CHECKED==Checked
            ++parent.modCount;
#ENDIF
            parent.size-=numRemoved;
            parent.head=newHead;
          }while((parent=parent.parent)!=null);
          break;
        }
      }
      root.head=newHead;
    }else{
      before.next=newHead;
      for(var parent=this.parent;parent!=null;
#IFSWITCH CHECKED==Checked
        ++parent.modCount,
#ENDIF
        parent.size-=numRemoved,parent.head=newHead,parent.tail=newTail,parent=parent.parent){
        if(parent.head!=oldHead){
          do{
            if(parent.tail!=oldTail){
#IFSWITCH CHECKED==Checked
              ++parent.modCount;
#ENDIF
              parent.size-=numRemoved;
              parent.bubbleUpDecrementSize(numRemoved);
              break;
            }
#IFSWITCH CHECKED==Checked
            ++parent.modCount;
#ENDIF
            parent.size-=numRemoved;
            parent.tail=newTail;
          }while((parent=parent.parent)!=null);
          break;
        }
        if(parent.tail!=oldTail){
          for(;;){
#IFSWITCH CHECKED==Checked
            ++parent.modCount;
#ENDIF
            parent.size-=numRemoved;
            parent.head=newHead;
            if((parent=parent.parent)==null){
              break;
            }
            if(parent.head!=oldHead){
#IFSWITCH CHECKED==Checked
              ++parent.modCount;
#ENDIF
              parent.size-=numRemoved;
              parent.bubbleUpDecrementSize(numRemoved);
              break;
            }
          }
          break;
        }
      }
    }
  }
  newHead.prev=before;
  newTail.next=after;
}
private boolean uncheckedRemoveIf($DNode$$<E>$ head,$TypeNameModifier$Predicate$<? super E>$ filter){
  $DNode$$<E>$ tail;
#IFSWITCH CHECKED==Checked
  int modCount=this.modCount;
  int size=this.size;
  try
#ENDIF
  {
#IF OfBoolean
    boolean firstVal;
    if(filter.test(firstVal=(tail=this.tail).val)){
#ELSE
    if(filter.test((tail=this.tail).val)){
#ENDIF
  #IFSWITCH CHECKED==Checked
      if(size==1){
        final CHECKEDList$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        root.modCount=++modCount;
        this.modCount=modCount;
  #ELSE
      if(tail==head){
  #ENDIF
        --root.size;
        this.size=size-1;
        //only one node was in the list; remove it
        removeLastNode(head);
      }else{
#IF OfBoolean
        if(head.val^firstVal){
          if(filter.test(firstVal=!firstVal)){
            final CHECKEDList$<E>$ root;
  #IFSWITCH CHECKED==Checked
            CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
            root.modCount=++modCount;
            this.modCount=modCount;
            root.size-=size;
  #ELSE
            int size;
            (root=this.root).size-=(size=this.size);
  #ENDIF
            //all nodes should be removed from the list
            clearAllHelper(size,head,tail,root);
          }else{
  #IFSWITCH CHECKED==Checked
            final CHECKEDList$<E>$ root;
            CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
            root.modCount=++modCount;
            this.modCount=modCount;
  #ENDIF
            final int numRemoved;
            root.size-=(numRemoved=collapsetail(tail,head,firstVal));
            this.size=size-numRemoved;
          }
        }else{
          collapseHeadAndTail(head,tail,firstVal,filter
  #IFSWITCH CHECKED==Checked
            ,size,modCount
  #ENDIF
          );
        }
      }
      return true;
    }else{
  #IFSWITCH CHECKED==Checked
      if(size!=1){
  #ELSE
      if(tail!=head){
  #ENDIF
        if(head.val^firstVal){
          if(filter.test(!firstVal)){
  #IFSWITCH CHECKED==Checked
            final CHECKEDList$<E>$ root;
            CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
            root.modCount=++modCount;
            this.modCount=modCount;
  #ENDIF
            final int numRemoved;
            root.size-=(numRemoved=collapsehead(head,tail,firstVal));
            this.size=size-numRemoved;
            return true;
          }
        }else{
          return collapseBody(head,tail,firstVal,filter
  #IFSWITCH CHECKED==Checked
            ,size,modCount
  #ENDIF
          );
        }
      }
    }
#ELSE
        if(filter.test(head.val)){
          collapseHeadAndTail(head,tail,filter
  #IFSWITCH CHECKED==Checked
            ,size,modCount
  #ENDIF
          );
        }else{
          collapsetail(tail,head,filter
  #IFSWITCH CHECKED==Checked
            ,size,modCount
  #ENDIF
          );
        }
      }
      return true;
    }else{
  #IFSWITCH CHECKED==Checked
      if(size!=1){
  #ELSE
      if(tail!=head){
  #ENDIF
        if(filter.test(head.val)){
          collapsehead(head,tail,filter
  #IFSWITCH CHECKED==Checked
            ,size,modCount
  #ENDIF
          );
          return true;
        }else{
          return collapseBody(head,tail,filter
  #IFSWITCH CHECKED==Checked
            ,size,modCount
  #ENDIF
          );
        }
      }
    }
#ENDIF
  }
#IFSWITCH CHECKED==Checked
  catch(ConcurrentModificationException e){
    throw e;
  }catch(RuntimeException e){
    throw CheckedCollection.checkModCount(modCount,root.modCount,e);
  }
  CheckedCollection.checkModCount(modCount,root.modCount);
#ENDIF
  return false;
}
@Override public void clear(){
#IFSWITCH CHECKED==Checked
  final CHECKEDList$<E>$ root;
  int modCount;
  CheckedCollection.checkModCount(modCount=this.modCount,(root=this.root).modCount);
#ENDIF
  int size;
  if((size=this.size)!=0){
#IFSWITCH CHECKED==Checked
    root.modCount=++modCount;
    this.modCount=modCount;
    root.size-=size;
#ELSE
    final UncheckedList$<E>$ root;
    (root=this.root).size-=size;
#ENDIF
    clearAllHelper(size,this.head,this.tail,root);
  }
}
private void clearAllHelper(int size,$DNode$$<E>$ head,$DNode$$<E>$ tail,CHECKEDList$<E>$ root){
  $DNode$$<E>$ before,after=tail.next;
  if((before=head.prev)==null){
    //this sublist is not preceded by nodes
    if(after==null){
      bubbleUpClearAll();
      root.tail=null;
    }else{
      bubbleUpClearHead(tail,after,size);
      after.prev=null;
    }
    root.head=after;
  }else{
    before.next=after;
    if(after==null){
      bubbleUpClearTail(head,before,size);
      root.tail=before;
    }else{
      bubbleUpClearBody(before,head,size,tail,after);
      after.prev=before;
    }
  }
  this.head=null;
  this.tail=null;
  this.size=0;
}
private void bubbleUpClearAll(){
  for(var curr=parent;curr!=null;
#IFSWITCH CHECKED==Checked
  ++curr.modCount,
#ENDIF
  curr.head=null,curr.tail=null,curr.size=0,curr=curr.parent){}
}
private void bubbleUpDecrementSize(int numRemoved){
  for(var curr=parent;curr!=null;curr.size-=numRemoved,curr=curr.parent){
#IFSWITCH CHECKED==Checked
    ++curr.modCount;
#ENDIF
  }
}
private void bubbleUpClearBody($DNode$$<E>$ before,$DNode$$<E>$ head,int numRemoved,$DNode$$<E>$ tail,$DNode$$<E>$ after){
  for(var curr=parent;curr!=null;
#IFSWITCH CHECKED==Checked
  ++curr.modCount,
#ENDIF
  curr.head=null,curr.tail=null,curr.size=0,curr=curr.parent){
    if(curr.head!=head){
      while(curr.tail==tail){
#IFSWITCH CHECKED==Checked
        ++curr.modCount;
#ENDIF
        curr.tail=before;
        curr.size-=numRemoved;
        if((curr=curr.parent)==null){
          return;
        }
      }
#IFSWITCH CHECKED==Checked
      ++curr.modCount;
#ENDIF
      curr.size-=numRemoved;
      curr.bubbleUpDecrementSize(numRemoved);
      return;
    }else if(curr.tail!=tail){
      do{
#IFSWITCH CHECKED==Checked
        ++curr.modCount;
#ENDIF
        curr.head=after;
        curr.size-=numRemoved;
        if((curr=curr.parent)==null){
          return;
        }
      }while(curr.head==head);
#IFSWITCH CHECKED==Checked
      ++curr.modCount;
#ENDIF
      curr.size-=numRemoved;
      curr.bubbleUpDecrementSize(numRemoved);
      return;
    }
  }
}
private void bubbleUpClearHead($DNode$$<E>$ tail, $DNode$$<E>$ after,int numRemoved){
  for(var curr=parent;curr!=null;
#IFSWITCH CHECKED==Checked
  ++curr.modCount,
#ENDIF
  curr.head=null,curr.tail=null,curr.size=0,curr=curr.parent){
    if(curr.tail!=tail){
      do{
#IFSWITCH CHECKED==Checked
        ++curr.modCount;
#ENDIF
        curr.head=after;
        curr.size-=numRemoved;
      }while((curr=curr.parent)!=null);
      break;
    }
  }
}
private void bubbleUpClearTail($DNode$$<E>$ head, $DNode$$<E>$ before,int numRemoved){
  for(var curr=parent;curr!=null;
#IFSWITCH CHECKED==Checked
  ++curr.modCount,
#ENDIF
  curr.head=null,curr.tail=null,curr.size=0,curr=curr.parent){
    if(curr.head!=head){
      do{
#IFSWITCH CHECKED==Checked
        ++curr.modCount;
#ENDIF
        curr.tail=before;
        curr.size-=numRemoved;
      }while((curr=curr.parent)!=null);
      break;
    }
  }
}
#IF OfBoolean
private void collapseHeadAndTail($DNode$$<E>$ head,$DNode$$<E>$ tail,$ArrayType$ removeThis,$TypeNameModifier$Predicate$<? super E>$ filter
  #IFSWITCH CHECKED==Checked
  ,int size,int modCount
  #ENDIF
){
  #IFSWITCH CHECKED==Checked
  int numLeft;
  if((numLeft=size-2)!=0)
  #ENDIF
  {
    int numRemoved=2;
    for(var newHead=head.next;;++numRemoved,newHead=newHead.next){
  #IFNOTSWITCH CHECKED==Checked
      if(newHead==tail){
        break;
      }
  #ENDIF
      if(newHead.val^removeThis){
        if(filter.test(!removeThis)){
          break;   
        }
  #IFSWITCH CHECKED==Checked
        CHECKEDList$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        root.modCount=++modCount;
        this.modCount=modCount;
  #ENDIF
        $DNode$$<E>$ newTail;
        for(newTail=tail.prev;newTail!=newHead;++numRemoved,newTail=newTail.prev){
          if(newTail.val^removeThis){
            numRemoved+=collapseBodyHelper(newHead,newTail,removeThis);
            break;
          }
        }
        bubbleUpCollapseHeadAndTail(head,newHead,numRemoved,newTail,tail);
        this.size=size-numRemoved;
        root.size-=numRemoved;
        return;
      }
  #IFSWITCH CHECKED==Checked
      if(--numLeft==0){
        break;
      }
  #ENDIF
    }
  }
  final CHECKEDList$<E>$ root;
  #IFSWITCH CHECKED==Checked
  CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
  root.modCount=++modCount;
  this.modCount=modCount;
  root.size-=size;
  #ELSE
  final int size;
  (root=this.root).size-=(size=this.size);
  #ENDIF
  clearAllHelper(size,head,tail,root);
}
private boolean collapseBody($DNode$$<E>$ head,$DNode$$<E>$ tail,$ArrayType$ retainThis,$TypeNameModifier$Predicate$<? super E>$ filter
  #IFSWITCH CHECKED==Checked
  ,int size,int modCount
  #ENDIF
){
  #IFSWITCH CHECKED==Checked
  for(int numLeft=size-2;numLeft!=0;--numLeft){
    $DNode$$<E>$ prev;
    if((head=(prev=head).next).val^retainThis){
      if(filter.test(!retainThis)){
        final CHECKEDList$<E>$ root;
        CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
        root.modCount=++modCount;
        this.modCount=modCount;
  #ELSE
  for($DNode$$<E>$ prev;(head=(prev=head).next)!=tail;){
    if(head.val^retainThis){
      if(filter.test(!retainThis)){
  #ENDIF
        int numRemoved=1;
        while((head=head.next)!=tail){
          if(head.val==retainThis){
            numRemoved+=collapseBodyHelper(head,tail,!retainThis);
            break;
          }
          ++numRemoved;
        }
        prev.next=head;
        head.prev=prev;
        for(var parent=this.parent;parent!=null;
  #IFSWITCH CHECKED==Checked
          parent.modCount=modCount,
  #ENDIF
          parent.size-=numRemoved,parent=parent.parent){}
        root.size-=numRemoved;
        this.size=size-numRemoved;
        return true;
      }
      break;
    }
  }
#IFSWITCH CHECKED==Checked
  CheckedCollection.checkModCount(modCount,root.modCount);
#ENDIF
  return false;
}
#ELSE
  #IFSWITCH CHECKED==Checked
private static $<E>$ int collapseBodyHelper($DNode$$<E>$ newHead,$DNode$$<E>$ newTail,int numLeft,$TypeNameModifier$Predicate$<? super E>$ filter,CHECKEDList$<E>$.ModCountChecker modCountChecker)
{
  if(numLeft!=0){
    int numSurvivors;
    if(numLeft>64){
      long[] survivorSet;
      numSurvivors=markSurvivors(newHead.next,numLeft,filter,survivorSet=new long[(numLeft-1>>6)+1]);
      modCountChecker.checkModCount();
      if((numLeft-=numSurvivors)!=0){
        if((newHead=pullSurvivorsDown(newHead,survivorSet,numSurvivors,numLeft))!=null){
          newHead.next=newTail;
          newTail.prev=newHead;
        }
      }
    }else{
      final long survivorWord=markSurvivors(newHead.next,numLeft,filter);
      modCountChecker.checkModCount();
      if((numLeft-=(numSurvivors=Long.bitCount(survivorWord)))!=0){
        if((newHead=pullSurvivorsDown(newHead,survivorWord,numSurvivors,numLeft))!=null){
          newHead.next=newTail;
          newTail.prev=newHead;
        }
      }
    }
  }else{
    modCountChecker.checkModCount();
  }
  return numLeft;
}
  #ENDIF

private void collapseHeadAndTail($DNode$$<E>$ head,$DNode$$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter
  #IFSWITCH CHECKED==Checked
  ,int size,int modCount
  #ENDIF
){
  #IFSWITCH CHECKED==Checked
  int numRemoved;
  if((numRemoved=2)!=size){
    for(var newHead=head.next;;newHead=newHead.next){
      if(!filter.test(newHead.val)){
        var newTail=tail.prev;
        final CHECKEDList$<E>$ root=this.root;
        for(--size;;++numRemoved,newTail=newTail.prev){
          if(numRemoved==size){
             CheckedCollection.checkModCount(modCount,root.modCount);
             break;
          }
          if(!filter.test(newTail.val)){
            numRemoved+=collapseBodyHelper(newHead,newTail,size-1-numRemoved,filter,root.new ModCountChecker(modCount));
            break;
          }
        }
        root.modCount=++modCount;
        this.modCount=modCount;
        root.size-=numRemoved;
        this.size=size+1-numRemoved;
        bubbleUpCollapseHeadAndTail(head,newHead,numRemoved,newTail,tail);
        return;
      }
      if(++numRemoved==size){
        break;
      }
    }
  }
  CHECKEDList$<E>$ root;
  CheckedCollection.checkModCount(modCount,(root=this.root).modCount);
  root.modCount=++modCount;
  this.modCount=modCount;
  root.size-=size;
  #ELSE
  $DNode$$<E>$ newHead;
  if((newHead=head.next)!=tail){
    for(int numRemoved=2;;++numRemoved){
      if(!filter.test(newHead.val)){
        $DNode$$<E>$ prev;
        outer: for(var curr=(prev=newHead).next;curr!=tail;curr=(prev=curr).next){
          if(filter.test(curr.val)){
            do{
              ++numRemoved;
              if((curr=curr.next)==tail){
                break outer;
              }
            }while(filter.test(curr.val));
            prev.next=curr;
            curr.prev=prev;
          }
        }
        this.size-=numRemoved;
        root.size-=numRemoved; 
        bubbleUpCollapseHeadAndTail(head,newHead,numRemoved,prev,tail);
        return;
      }else if((newHead=newHead.next)==tail){
        break;
      }
    }
  }
  CHECKEDList$<E>$ root;
  int size;
  (root=this.root).size-=(size=this.size);
  #ENDIF
  clearAllHelper(size,head,tail,root);
}
private boolean collapseBody($DNode$$<E>$ head,$DNode$$<E>$ tail,$TypeNameModifier$Predicate$<? super E>$ filter
  #IFSWITCH CHECKED==Checked
  ,int size,int modCount
  #ENDIF
){
#IFSWITCH CHECKED==Checked
  for(int numLeft=size-2;numLeft!=0;--numLeft){
    $DNode$$<E>$ prev;
    if(filter.test((head=(prev=head).next).val)){
      int numRemoved=1;
      var root=this.root;
      for(;;++numRemoved){
        head=head.next;
        if(--numLeft==0){
          CheckedCollection.checkModCount(modCount,root.modCount);
          break;
        }else if(!filter.test(head.val)){
          numRemoved+=collapseBodyHelper(head,tail,--numLeft,filter,root.new ModCountChecker(modCount));
          break;
        }
      }
      root.modCount=++modCount;
      this.modCount=modCount;
#ELSE
  for($DNode$$<E>$ prev;(head=(prev=head).next)!=tail;){
    if(filter.test(head.val)){
      int numRemoved=1;
      for(;(head=head.next)!=tail;++numRemoved){
        if(!filter.test(head.val)){
          numRemoved+=collapseBodyHelper(head,tail,filter);
          break;
        }
      }
#ENDIF
      head.prev=prev;
      prev.next=head;
      root.size-=numRemoved;
      this.size=size-numRemoved;
      bubbleUpDecrementSize(numRemoved);
      return true;
    }
  }
#IFSWITCH CHECKED==Checked
  CheckedCollection.checkModCount(modCount,root.modCount);
#ENDIF
  return false;
}
#ENDIF
#ENDDEF
#MACRODEF CollapseEnd<HEAD>(TAIL,NEXT,PREV)
#IF OfBoolean
private int collapseHEAD($DNode$$<E>$ oldHEAD,$DNode$$<E>$ TAIL,$ArrayType$ retainThis){
  int numRemoved=1;
  $DNode$$<E>$ newHEAD;
  outer:for(newHEAD=oldHEAD.NEXT;newHEAD!=TAIL;++numRemoved,newHEAD=newHEAD.NEXT){
    if(newHEAD.val==retainThis){
      $DNode$$<E>$ PREV,curr;
      for(curr=(PREV=newHEAD).NEXT;curr!=TAIL;curr=(PREV=curr).NEXT){
        if(curr.val^retainThis){
          do{
            ++numRemoved;
            if((curr=curr.NEXT)==TAIL){
              curr.PREV=PREV;
              PREV.NEXT=curr;
              break outer;
            }
          }while(curr.val^retainThis);
          curr.PREV=PREV;
          PREV.NEXT=curr;
        }
      }
      break;
    }
  }
  this.HEAD=newHEAD;
  $DNode$$<E>$ tmp;
  if((tmp=oldHEAD.PREV)==null){
    for(var parent=this.parent;parent!=null;
#IFSWITCH CHECKED==Checked
      ++parent.modCount,
#ENDIF
      parent.HEAD=newHEAD,parent.size-=numRemoved,parent=parent.parent){}
    root.HEAD=newHEAD;
  }else{
    for(var parent=this.parent;parent!=null;
#IFSWITCH CHECKED==Checked
      ++parent.modCount,
#ENDIF
      parent.HEAD=newHEAD,parent.size-=numRemoved,parent=parent.parent){
      if(parent.HEAD!=oldHEAD){
        parent.size-=numRemoved;
#IFSWITCH CHECKED==Checked
        ++parent.modCount;
#ENDIF
        parent.bubbleUpDecrementSize(numRemoved);
        break;
      }
    }
    tmp.NEXT=newHEAD;
  }
  newHEAD.PREV=tmp;
  return numRemoved;
}
#ELSE
private void collapseHEAD($DNode$$<E>$ oldHEAD,$DNode$$<E>$ TAIL,$TypeNameModifier$Predicate$<? super E>$ filter
  #IFSWITCH CHECKED==Checked
  ,int size,int modCount
  #ENDIF
){
  #IFSWITCH CHECKED==Checked
  int numRemoved;
  int numLeft=size-(numRemoved=1)-1;
  final CHECKEDList$<E>$ root=this.root;
  #ELSE
  int numRemoved=1;
  #ENDIF
  $DNode$$<E>$ newHEAD;
  #IFNOTSWITCH CHECKED==Checked
  outer:
  #ENDIF
  for(newHEAD=oldHEAD.NEXT;;
  #IFSWITCH CHECKED==Checked
  --numLeft,
  #ENDIF
  ++numRemoved,newHEAD=newHEAD.NEXT){ 
  #IFSWITCH CHECKED==Checked
    if(numLeft==0){
      CheckedCollection.checkModCount(modCount,root.modCount);
  #ELSE
    if(newHEAD==TAIL){
  #ENDIF
      break;
    }
    if(!filter.test(newHEAD.val)){
  #IFSWITCH CHECKED==Checked
    #IFSWITCH HEAD==head
      numRemoved+=collapseBodyHelper(newhead,TAIL,--numLeft,filter,root.new ModCountChecker(modCount));
    #ELSE
      numRemoved+=collapseBodyHelper(head,newtail,--numLeft,filter,root.new ModCountChecker(modCount));
    #ENDIF
      break;
    }
  }
  #ELSE
      $DNode$$<E>$ PREV,curr;
      for(curr=(PREV=newHEAD).NEXT;curr!=TAIL;curr=(PREV=curr).NEXT){
        if(filter.test(curr.val)){
          do{
            ++numRemoved;
            if((curr=curr.NEXT)==TAIL){
              curr.PREV=PREV;
              PREV.NEXT=curr;
              break outer;
            }
          }while(filter.test(curr.val));
          curr.PREV=PREV;
          PREV.NEXT=curr;
        }
      }
      break;
    }
  }
  CHECKEDList$<E>$ root;
  (root=this.root).size-=numRemoved;
  #ENDIF
  #IFSWITCH CHECKED==Checked
  root.modCount=++modCount;
  this.modCount=modCount;
  root.size-=numRemoved;
  #ENDIF
  this.size-=numRemoved;
  this.HEAD=newHEAD;
  $DNode$$<E>$ tmp;
  if((tmp=oldHEAD.PREV)==null){
    for(var parent=this.parent;parent!=null;parent.HEAD=newHEAD,parent.size-=numRemoved,parent=parent.parent){
#IFSWITCH CHECKED==Checked
        ++parent.modCount;
#ENDIF
    }
    root.HEAD=newHEAD;
  }else{
    for(var parent=this.parent;parent!=null;parent.HEAD=newHEAD,parent.size-=numRemoved,parent=parent.parent){
      if(parent.HEAD!=oldHEAD){
#IFSWITCH CHECKED==Checked
        ++parent.modCount;
#ENDIF
        parent.size-=numRemoved;
        parent.bubbleUpDecrementSize(numRemoved);
        break;
      }
#IFSWITCH CHECKED==Checked
      ++parent.modCount;
#ENDIF
    }
    tmp.NEXT=newHEAD;
  }
  newHEAD.PREV=tmp;
}
#ENDIF
#ENDDEF